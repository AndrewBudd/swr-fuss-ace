act_comm.c:*--------------------------------------------------------------------------*
act_comm.c:* -------------------------------------------------------------------------*
act_comm.c:*--------------------------------------------------------------------------*
act_comm.c:* ------------------------------------------------------------------------ *
act_comm.c:* ------------------------------------------------------------------------ *
act_comm.c:   for( vic = room->first_person; vic; vic = vic->next_in_room )
act_comm.c:      if( !IS_NPC( vic ) && IS_SET( vic->act, PLR_SOUND ) )
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( IS_SET( ch->act, PLR_SILENCE ) || IS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
act_comm.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:      if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:   for( obj = victim->last_carrying; obj; obj = obj->prev_content )
act_comm.c:      if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:   if( !IS_NPC( victim ) && ( victim->switched ) && ( get_trust( ch ) > LEVEL_AVATAR ) )
act_comm.c:   else if( !IS_NPC( victim ) && ( !victim->desc ) )
act_comm.c:      send_to_char( "That player is link-dead.\r\n", ch );
act_comm.c:   if( IS_SET( victim->deaf, CHANNEL_TELLS ) && ( !IS_IMMORTAL( ch ) || ( get_trust( ch ) < get_trust( victim ) ) ) )
act_comm.c:   if( !IS_NPC( victim ) && ( IS_SET( victim->act, PLR_SILENCE ) ) )
act_comm.c:       || ( !IS_NPC( victim ) && IS_SET( victim->in_room->room_flags, ROOM_SILENCE ) ) )
act_comm.c:   if( victim->desc  /* make sure desc exists first  -Thoric */
act_comm.c:       && victim->desc->connected == CON_EDITING && get_trust( ch ) < LEVEL_GOD )
act_comm.c:   ch_printf( ch, "&WYou beep %s: %s\r\n\a", victim->name, argument );
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_WHITE, "$n beeps: '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:/* Text scrambler -- Altrag */
act_comm.c:         conversion = -conversion + position - modifier + argument[position] - 'A';
act_comm.c:         conversion = number_range( conversion - 5, conversion + 5 );
act_comm.c:            conversion -= 26;
act_comm.c:         conversion = -conversion + position - modifier + argument[position] - 'a';
act_comm.c:         conversion = number_range( conversion - 5, conversion + 5 );
act_comm.c:            conversion -= 26;
act_comm.c:         conversion = -conversion + position - modifier + argument[position] - '0';
act_comm.c:         conversion = number_range( conversion - 2, conversion + 2 );
act_comm.c:            conversion -= 10;
act_comm.c:/* I'll rewrite this later if its still needed.. -- Altrag */
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata )
act_comm.c:   drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:                  txt1--;
act_comm.c:               *txt++ = '-';
act_comm.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:            if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:   else if( channel == CHANNEL_OOC && !IS_SET( ch->in_room->room_flags, ROOM_HOTEL ) )
act_comm.c:      if( ch->pcdata->clan->mainclan )
act_comm.c:         clan = ch->pcdata->clan->mainclan;
act_comm.c:         clan = ch->pcdata->clan;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if( ch->master )
act_comm.c:         send_to_char( "I don't think so...\r\n", ch->master );
act_comm.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   REMOVE_BIT( ch->deaf, channel );
act_comm.c:         ch_printf( ch, "(NEWBIE) %s: %s\r\n", ch->name, argument );
act_comm.c:         position = ch->position;
act_comm.c:         ch->position = POS_STANDING;
act_comm.c:         ch->position = position;
act_comm.c:            sprintf( buf, "&Y( IMM - $n ) >&W $t" );
act_comm.c:         position = ch->position;
act_comm.c:         ch->position = POS_STANDING;
act_comm.c:         ch->position = position;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      sprintf( buf2, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument, verb );
act_comm.c:   for( d = first_descriptor; d; d = d->next )
act_comm.c:      och = d->original ? d->original : d->character;
act_comm.c:      vch = d->character;
act_comm.c:      if( d->connected == CON_PLAYING && vch != ch && !IS_SET( och->deaf, channel ) )
act_comm.c:               for( obj = och->last_carrying; obj; obj = obj->prev_content )
act_comm.c:                  if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:         if( IS_SET( vch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:            if( ch->in_room != och->in_room )
act_comm.c:            if( !vch->pcdata->clan )
act_comm.c:            if( vch->pcdata->clan != clan && vch->pcdata->clan->mainclan != clan )
act_comm.c:            SHIP_DATA *ship = ship_from_cockpit( ch->in_room->vnum );
act_comm.c:            if( !vch->in_room )
act_comm.c:               if( vch->in_room->vnum > ship->lastroom || vch->in_room->vnum < ship->firstroom )
act_comm.c:            target = ship_from_cockpit( vch->in_room->vnum );
act_comm.c:               if( target->starsystem != ship->starsystem )
act_comm.c:         position = vch->position;
act_comm.c:            vch->position = POS_STANDING;
act_comm.c:         if( !knows_language( vch, ch->speaking, ch ) &&
act_comm.c:             ( !IS_NPC( ch ) || ch->speaking != 0 ) &&
act_comm.c:            sbuf = scramble( argument, ch->speaking );
act_comm.c:         vch->position = position;
act_comm.c:   for( d = first_descriptor; d; d = d->next )
act_comm.c:      och = d->original ? d->original : d->character;
act_comm.c:      vch = d->character;
act_comm.c:      if( d->connected == CON_PLAYING && !IS_SET( och->deaf, channel ) && get_trust( vch ) >= level )
act_comm.c:   if( ch->gold < 1 )
act_comm.c:   ch->gold -= 1;
act_comm.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
act_comm.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
act_comm.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
act_comm.c:   if( ch->top_level > 5 )
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:   sprintf(colorized,"%s%s%s", color_str(ch->textcolor , ch ) , argument, color_str( AT_SAY , ch ) );
act_comm.c:   actflags = ch->act;
act_comm.c:      REMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( colorized, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      sprintf( buf, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:   if( IS_SET( ch->deaf, CHANNEL_TELLS ) && !IS_IMMORTAL( ch ) )
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( IS_SET( ch->act, PLR_SILENCE ) || IS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
act_comm.c:   if( victim->in_room != ch->in_room && !IS_IMMORTAL( ch ) )
act_comm.c:      for( obj = ch->last_carrying; obj; obj = obj->prev_content )
act_comm.c:         if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
act_comm.c:         if( obj->pIndexData->item_type == ITEM_COMLINK )
act_comm.c:   if( !IS_NPC( victim ) && ( victim->switched )
act_comm.c:       && !IS_SET( victim->switched->act, ACT_POLYMORPHED ) && !IS_AFFECTED( victim->switched, AFF_POSSESS ) )
act_comm.c:   else if( !IS_NPC( victim ) && ( victim->switched )
act_comm.c:            && ( IS_SET( victim->switched->act, ACT_POLYMORPHED ) || IS_AFFECTED( victim->switched, AFF_POSSESS ) ) )
act_comm.c:      switched_victim = victim->switched;
act_comm.c:   else if( !IS_NPC( victim ) && ( !victim->desc ) )
act_comm.c:      send_to_char( "That player is link-dead.\r\n", ch );
act_comm.c:   if( !IS_NPC( victim ) && ( IS_SET( victim->act, PLR_AFK ) ) )
act_comm.c:   if( IS_SET( victim->deaf, CHANNEL_TELLS ) && ( !IS_IMMORTAL( ch ) || ( get_trust( ch ) < get_trust( victim ) ) ) )
act_comm.c:   if( !IS_NPC( victim ) && ( IS_SET( victim->act, PLR_SILENCE ) ) )
act_comm.c:       || ( !IS_NPC( victim ) && IS_SET( victim->in_room->room_flags, ROOM_SILENCE ) ) )
act_comm.c:   if( victim->desc  /* make sure desc exists first  -Thoric */
act_comm.c:       && victim->desc->connected == CON_EDITING && get_trust( ch ) < LEVEL_GOD )
act_comm.c:   position = victim->position;
act_comm.c:   victim->position = POS_STANDING;
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   victim->position = position;
act_comm.c:   victim->reply = ch;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   if( ( victim = ch->reply ) == NULL )
act_comm.c:   if( !IS_NPC( victim ) && ( victim->switched ) && can_see( ch, victim ) && ( get_trust( ch ) > LEVEL_AVATAR ) )
act_comm.c:   else if( !IS_NPC( victim ) && ( !victim->desc ) )
act_comm.c:      send_to_char( "That player is link-dead.\r\n", ch );
act_comm.c:   if( !IS_NPC( victim ) && ( IS_SET( victim->act, PLR_AFK ) ) )
act_comm.c:   if( IS_SET( victim->deaf, CHANNEL_TELLS ) && ( !IS_IMMORTAL( ch ) || ( get_trust( ch ) < get_trust( victim ) ) ) )
act_comm.c:       || ( !IS_NPC( victim ) && IS_SET( victim->in_room->room_flags, ROOM_SILENCE ) ) )
act_comm.c:   position = victim->position;
act_comm.c:   victim->position = POS_STANDING;
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   victim->position = position;
act_comm.c:   victim->reply = ch;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:               IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:   actflags = ch->act;
act_comm.c:      REMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   if( isalpha( plast[-1] ) )
act_comm.c:   ch->act = actflags;
act_comm.c:   if( IS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      sprintf( buf, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_POLYMORPHED ) )
act_comm.c:   if( ch->position == POS_FIGHTING )
act_comm.c:   if( ch->position < POS_STUNNED )
act_comm.c:   if( auction->item != NULL && ( ( ch == auction->buyer ) || ( ch == auction->seller ) ) )
act_comm.c:   if( !IS_IMMORTAL( ch ) && ch->in_room && !IS_SET( ch->in_room->room_flags, ROOM_HOTEL ) && !NOT_AUTHED( ch ) )
act_comm.c:   sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      SET_BIT( ch->act, PLR_ANSI );
act_comm.c:      SET_BIT( ch->act, PLR_ANSI );
act_comm.c:      REMOVE_BIT( ch->act, PLR_ANSI );
act_comm.c:      SET_BIT( ch->act, PLR_SOUND );
act_comm.c:      REMOVE_BIT( ch->act, PLR_SOUND );
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_POLYMORPHED ) )
act_comm.c:   if( !IS_SET( ch->affected_by, race_table[ch->race].affected ) )
act_comm.c:      SET_BIT( ch->affected_by, race_table[ch->race].affected );
act_comm.c:   if( !IS_SET( ch->resistant, race_table[ch->race].resist ) )
act_comm.c:      SET_BIT( ch->resistant, race_table[ch->race].resist );
act_comm.c:   if( !IS_SET( ch->susceptible, race_table[ch->race].suscept ) )
act_comm.c:      SET_BIT( ch->susceptible, race_table[ch->race].suscept );
act_comm.c: * (Which exists in many maze areas)			-Thoric
act_comm.c:   for( tmp = victim; tmp; tmp = tmp->master )
act_comm.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master )
act_comm.c:      act( AT_PLAIN, "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:      if( !ch->master )
act_comm.c:   if( ch->master )
act_comm.c:   if( ch->master )
act_comm.c:      bug( "Add_follower: non-null master.", 0 );
act_comm.c:   ch->master = master;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( !ch->master )
act_comm.c:      REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:   if( can_see( ch->master, ch ) )
act_comm.c:      act( AT_ACTION, "$n stops following you.", ch, NULL, ch->master, TO_VICT );
act_comm.c:   act( AT_ACTION, "You stop following $N.", ch, NULL, ch->master, TO_CHAR );
act_comm.c:   ch->master = NULL;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( ch->master )
act_comm.c:   ch->leader = NULL;
act_comm.c:   for( fch = first_char; fch; fch = fch->next )
act_comm.c:      if( fch->master == ch )
act_comm.c:      if( fch->leader == ch )
act_comm.c:         fch->leader = fch;
act_comm.c:      if( !IS_AFFECTED( victim, AFF_CHARM ) || victim->master != ch )
act_comm.c:   for( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:      och_next = och->next_in_room;
act_comm.c:      if( IS_AFFECTED( och, AFF_CHARM ) && och->master == ch && ( fAll || och == victim ) && !IS_IMMORTAL( och ) )
act_comm.c:      sprintf( log_buf, "%s: order %s.", ch->name, argbuf );
act_comm.c:      log_string_plus( log_buf, LOG_NORMAL, ch->top_level );
act_comm.c:      leader = ch->leader ? ch->leader : ch;
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:                          "[%2d %s] %-16s %4s/%4s hp %4s/%4s mv %5s xp\r\n",
act_comm.c:                          gch->top_level,
act_comm.c:                          IS_NPC( gch ) ? "Mob" : race_table[gch->race].race_name,
act_comm.c:                          "[%2d %s] %-16s %4d/%4d hp %4d/%4d mv\r\n",
act_comm.c:                          gch->top_level,
act_comm.c:                          IS_NPC( gch ) ? "Mob" : race_table[gch->race].race_name,
act_comm.c:                          capitalize( PERS( gch, ch ) ), gch->hit, gch->max_hit, gch->move, gch->max_move );
act_comm.c:      if( ch->leader || ch->master )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:            gch->leader = NULL;
act_comm.c:            gch->master = NULL;
act_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:         if( ch != rch && !IS_NPC( rch ) && rch->master == ch && !ch->master && !ch->leader && !is_same_group( rch, ch ) )
act_comm.c:            rch->leader = ch;
act_comm.c:   if( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:   if( victim->master != ch && ch != victim )
act_comm.c:      victim->leader = NULL;
act_comm.c:   victim->leader = ch;
act_comm.c:   if( ch->gold < amount )
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:   if( ( IS_SET( ch->act, PLR_AUTOGOLD ) ) && ( members < 2 ) )
act_comm.c:   ch->gold -= amount;
act_comm.c:   ch->gold += share + extra;
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:         gch->gold += share;
act_comm.c:   if( IS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:/*    sprintf( buf, "%s tells the group '%s'.\r\n", ch->name, argument );*/
act_comm.c:   for( gch = first_char; gch; gch = gch->next )
act_comm.c:          * still garble though. -- Altrag 
act_comm.c:         if( knows_language( gch, ch->speaking, gch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:            ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'.\r\n", ch->name, scramble( argument, ch->speaking ) );
act_comm.c:   if( ach->leader )
act_comm.c:      ach = ach->leader;
act_comm.c:   if( bch->leader )
act_comm.c:      bch = bch->leader;
act_comm.c:   for( d = first_descriptor; d; d = d->next )
act_comm.c:      original = d->original ? d->original : d->character;  /* if switched */
act_comm.c:      if( ( d->connected == CON_PLAYING ) && !IS_SET( original->deaf, CHANNEL_AUCTION )
act_comm.c:          && !IS_SET( original->in_room->room_flags, ROOM_SILENCE ) && !NOT_AUTHED( original ) )
act_comm.c: * Language support functions. -- Altrag
act_comm.c:   if( IS_NPC( ch ) && !ch->speaks )   /* No langs = knows all for npcs */
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->speaks, ( language & ~LANG_CLAN ) ) )
act_comm.c:       * Clan = common for mobs.. snicker.. -- Altrag 
act_comm.c:      if( ch->pcdata->clan == cch->pcdata->clan && ch->pcdata->clan != NULL )
act_comm.c:      if( IS_SET( race_table[ch->race].language, language ) )
act_comm.c:         if( IS_SET( language, lang_array[lang] ) && IS_SET( ch->speaks, lang_array[lang] ) )
act_comm.c:            if( ( sn = skill_lookup( lang_names[lang] ) ) != -1 && ch->pcdata->learned[sn] >= 60 )
act_comm.c:   if( race_table[ch->race].language & language )
act_comm.c:   if( ch->speaks & language )
act_comm.c:            if( ch->pcdata->learned[sn] >= 99 )
act_comm.c:   "trandoshan", "chadra-fan", "quarren", "duinuogwuin", "",
act_comm.c:   "trandoshan", "chadra-fan", "quarren", "duinuogwuin", "",
act_comm.c:      ch->speaking = ~LANG_CLAN;
act_comm.c:   if( !str_prefix( arg, "common" ) && ch->race == RACE_WOOKIEE )
act_comm.c:   if( !str_prefix( arg, "twilek" ) && ch->race != RACE_TWI_LEK )
act_comm.c:            if( lang_array[langs] == LANG_CLAN && ( IS_NPC( ch ) || !ch->pcdata->clan ) )
act_comm.c:            ch->speaking = lang_array[langs];
act_comm.c:      if( race_table[ch->race].language & lang_array[lang] || ch->pcdata->learned[sn] >= 99 )
act_comm.c:      for( sch = ch->in_room->first_person; sch; sch = sch->next_in_room )
act_comm.c:         if( IS_NPC( sch ) && IS_SET( sch->act, ACT_SCHOLAR ) &&
act_comm.c:             knows_language( sch, ch->speaking, ch ) &&
act_comm.c:             knows_language( sch, lang_array[lang], sch ) && ( !sch->speaking || knows_language( ch, sch->speaking, sch ) ) )
act_comm.c:      if( ch->gold < 25 )
act_comm.c:      ch->gold -= 25;
act_comm.c:       * Max 12% (5 + 4 + 3) at 24+ int and 21+ wis. -- Altrag 
act_comm.c:      ch->pcdata->learned[sn] += prct;
act_comm.c:      ch->pcdata->learned[sn] = UMIN( ch->pcdata->learned[sn], 99 );
act_comm.c:      SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:      if( ch->pcdata->learned[sn] == prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 99 )
act_comm.c:      if( ch->speaking & lang_array[lang] || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:         ch_printf( ch, "(%3d) ", ch->pcdata->learned[sn] );
act_info.c:*--------------------------------------------------------------------------*
act_info.c:* -------------------------------------------------------------------------*
act_info.c:*--------------------------------------------------------------------------*
act_info.c:* ------------------------------------------------------------------------ *
act_info.c:* ------------------------------------------------------------------------ *
act_info.c: * Keep players from defeating examine progs -Druid
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECTTRAPS ) || IS_SET( ch->act, PLR_HOLYLIGHT ) ) && is_trapped( obj ) )
act_info.c:      if( obj->short_descr )
act_info.c:         strcat( buf, obj->short_descr );
act_info.c:      if( obj->description )
act_info.c:         strcat( buf, obj->description );
act_info.c: * Some increasingly freaky halucinated objects		-Thoric
act_info.c:      switch ( number_range( 6 - URANGE( 1, sms / 2, 5 ), sms ) )
act_info.c:   switch ( number_range( 6 - URANGE( 1, sms / 2, 5 ), sms ) )
act_info.c:   if( !ch->desc )
act_info.c:    * if there's no list... then don't do all this crap!  -Thoric
act_info.c:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   for( obj = list; obj; obj = obj->next_content )
act_info.c:   ms = ( ch->mental_state ? ch->mental_state : 1 )
act_info.c:      * ( IS_NPC( ch ) ? 1 : ( ch->pcdata->condition[COND_DRUNK] ? ( ch->pcdata->condition[COND_DRUNK] / 12 ) : 1 ) );
act_info.c:      offcount = URANGE( -( count ), ( count * ms ) / 100, count * 2 );
act_info.c:         offcount -= number_range( 0, offcount );
act_info.c:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   for( obj = list; obj; obj = obj->next_content )
act_info.c:         --tmp;
act_info.c:      if( obj->wear_loc == WEAR_NONE
act_info.c:          && can_see_obj( ch, obj ) && ( obj->item_type != ITEM_TRAP || IS_AFFECTED( ch, AFF_DETECTTRAPS ) ) )
act_info.c:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c:            for( iShow = nShow - 1; iShow >= 0; iShow-- )
act_info.c:                  prgnShow[iShow] += obj->count;
act_info.c:         pitShow[nShow] = obj->item_type;
act_info.c:            prgnShow[nShow] = obj->count;
act_info.c:    * Output the formatted list.      -Color support by Thoric
act_info.c:/*	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:      if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c: * Show fancy descriptions for certain spell affects		-Thoric
act_info.c:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c:   if( !IS_NPC( victim ) && !victim->desc && victim->switched && IS_AFFECTED( victim->switched, AFF_POSSESS ) )
act_info.c:   if( !IS_NPC( victim ) && !victim->desc )
act_info.c:      if( !victim->switched )
act_info.c:      else if( !IS_AFFECTED( victim->switched, AFF_POSSESS ) )
act_info.c:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_AFK ) )
act_info.c:   if( ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) )
act_info.c:       || ( IS_NPC( victim ) && IS_SET( victim->act, ACT_MOBINVIS ) ) )
act_info.c:         sprintf( buf1, "(Invis %d) ", victim->pcdata->wizinvis );
act_info.c:         sprintf( buf1, "(Mobinvis %d) ", victim->mobinvis );
act_info.c:   if( ( victim->mana > 10 ) && ( IS_AFFECTED( ch, AFF_DETECT_MAGIC ) || IS_IMMORTAL( ch ) ) )
act_info.c:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_LITTERBUG ) )
act_info.c:   if( IS_NPC( victim ) && IS_IMMORTAL( ch ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
act_info.c:   if( victim->desc && victim->desc->connected == CON_EDITING )
act_info.c:   if( victim->position == victim->defposition && victim->long_descr[0] != '\0' )
act_info.c:      strcat( buf, victim->long_descr );
act_info.c:    * *    removed to prevent prepending of name to title     -Kuran  
act_info.c:    * *    But added back bellow so that you can see mobs too :P   -Durga 
act_info.c:   if( !IS_NPC( victim ) && !IS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      strcat( buf, victim->pcdata->title );
act_info.c:   switch ( victim->position )
act_info.c:         if( ch->position == POS_SITTING || ch->position == POS_RESTING )
act_info.c:         if( ch->position == POS_RESTING )
act_info.c:         else if( ch->position == POS_MOUNTED )
act_info.c:         if( ch->position == POS_SITTING )
act_info.c:         else if( ch->position == POS_RESTING )
act_info.c:            if( ( victim->in_room->sector_type == SECT_UNDERWATER )
act_info.c:         else if( victim->in_room->sector_type == SECT_UNDERWATER )
act_info.c:            if( ( victim->in_room->sector_type == SECT_OCEANFLOOR )
act_info.c:         else if( victim->in_room->sector_type == SECT_OCEANFLOOR )
act_info.c:         if( !victim->mount )
act_info.c:         else if( victim->mount == ch )
act_info.c:         else if( victim->in_room == victim->mount->in_room )
act_info.c:            strcat( buf, PERS( victim->mount, ch ) );
act_info.c:         if( !victim->fighting )
act_info.c:         else if( victim->in_room == victim->fighting->who->in_room )
act_info.c:            strcat( buf, PERS( victim->fighting->who, ch ) );
act_info.c:   if( victim->description[0] != '\0' )
act_info.c:      send_to_char( victim->description, ch );
act_info.c:   if( IS_IMMORTAL( victim ) && ( victim->top_level > ch->top_level ) )
act_info.c:   if( number_percent(  ) < ch->pcdata->learned[gsn_peek] )
act_info.c:      show_list_to_char( victim->first_carrying, ch, TRUE, TRUE );
act_info.c:   else if( ch->pcdata->learned[gsn_peek] )
act_info.c:   for( rch = list; rch; rch = rch->next_in_room )
act_info.c:      else if( rch->race == RACE_DEFEL )
act_info.c:      else if( room_is_dark( ch->in_room ) && IS_AFFECTED( ch, AFF_INFRARED ) )
act_info.c:      ch_printf( ch, "&C%-35s     ", rship->name );
act_info.c:      if( ( nship = rship->next_in_room ) != NULL )
act_info.c:         ch_printf( ch, "%-35s", nship->name );
act_info.c:         nship = nship->next_in_room;
act_info.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c: * Returns classical DIKU door direction based on text in arg	-Thoric
act_info.c:      door = -1;
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:       && !IS_SET( ch->act, PLR_HOLYLIGHT ) && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && room_is_dark( ch->in_room ) )
act_info.c:         show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      send_to_char( ch->in_room->name, ch );
act_info.c:      if( !ch->desc->original )
act_info.c:            if( IS_SET( ch->act, PLR_ROOMVNUM ) )
act_info.c:                ch_printf( ch, "%d", ch->in_room->vnum );
act_info.c:            if( IS_SET( ch->pcdata->flags, PCFLAG_ROOM ) )
act_info.c:                send_to_char( flag_string( ch->in_room->room_flags, r_flags ), ch );
act_info.c:      if( arg1[0] == '\0' || ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c:         send_to_char( ch->in_room->description, ch );
act_info.c:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOEXIT ) )
act_info.c:      show_ships_to_char( ch->in_room->first_ship, ch );
act_info.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) != NULL )
act_info.c:            if( ship->starsystem )
act_info.c:               if( ship->starsystem->star1 && str_cmp( ship->starsystem->star1, "" ) )
act_info.c:                  ch_printf( ch, "%s\r\n", ship->starsystem->star1 );
act_info.c:               if( ship->starsystem->star2 && str_cmp( ship->starsystem->star2, "" ) )
act_info.c:                  ch_printf( ch, "%s\r\n", ship->starsystem->star2 );
act_info.c:               if( ship->starsystem->planet1 && str_cmp( ship->starsystem->planet1, "" ) )
act_info.c:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet1 );
act_info.c:               if( ship->starsystem->planet2 && str_cmp( ship->starsystem->planet2, "" ) )
act_info.c:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet2 );
act_info.c:               if( ship->starsystem->planet3 && str_cmp( ship->starsystem->planet3, "" ) )
act_info.c:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet3 );
act_info.c:               for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
act_info.c:                     ch_printf( ch, "%s\r\n", target->name );
act_info.c:               for( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
act_info.c:                             missile->missiletype == CONCUSSION_MISSILE ? "A Concusion Missile" :
act_info.c:                             ( missile->missiletype == PROTON_TORPEDO ? "A Torpedo" :
act_info.c:                               ( missile->missiletype == HEAVY_ROCKET ? "A Heavy Rocket" : "A Heavy Bomb" ) ) );
act_info.c:            else if( ship->location == ship->lastdoc )
act_info.c:               if( ( to_room = get_room_index( ship->location ) ) != NULL )
act_info.c:                  original = ch->in_room;
act_info.c:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:      count = obj->count;
act_info.c:      obj->count = 1;
act_info.c:      obj->count = count;
act_info.c:         show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c:      switch ( obj->item_type )
act_info.c:            if( obj->value[1] <= 0 )
act_info.c:                       obj->value[1] < obj->value[0] / 4
act_info.c:                       obj->value[1] < 3 * obj->value[0] / 4 ? "about" : "more than", liq_table[obj->value[2]].liq_color );
act_info.c:            for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:               if( pexit->vdir == DIR_PORTAL && IS_SET( pexit->exit_info, EX_PORTAL ) )
act_info.c:                  if( room_is_private( ch, pexit->to_room ) && get_trust( ch ) < sysdata.level_override_private )
act_info.c:                  original = ch->in_room;
act_info.c:                  char_to_room( ch, pexit->to_room );
act_info.c:            if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_info.c:            count = obj->count;
act_info.c:            obj->count = 1;
act_info.c:            obj->count = count;
act_info.c:            show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c:   if( ( pdesc = get_extra_descr( arg1, ch->in_room->first_extradesc ) ) != NULL )
act_info.c:      if( pexit->keyword )
act_info.c:         if( IS_SET( pexit->exit_info, EX_CLOSED ) && !IS_SET( pexit->exit_info, EX_WINDOW ) )
act_info.c:            if( IS_SET( pexit->exit_info, EX_SECRET ) && door != -1 )
act_info.c:               act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
act_info.c:         if( IS_SET( pexit->exit_info, EX_BASHED ) )
act_info.c:            act( AT_RED, "The $d has been bashed from its hinges!", ch, NULL, pexit->keyword, TO_CHAR );
act_info.c:      if( pexit->description && pexit->description[0] != '\0' )
act_info.c:         send_to_char( pexit->description, ch );
act_info.c:       * Ability to look into the next room        -Thoric
act_info.c:      if( pexit->to_room
act_info.c:               || IS_SET( pexit->exit_info, EX_xLOOK ) || get_trust( ch ) >= LEVEL_IMMORTAL ) )
act_info.c:         if( !IS_SET( pexit->exit_info, EX_xLOOK ) && get_trust( ch ) < LEVEL_IMMORTAL )
act_info.c:               int percent = ch->pcdata->learned[skill_lookup( "scry" )];
act_info.c:         if( room_is_private( ch, pexit->to_room ) && get_trust( ch ) < sysdata.level_override_private )
act_info.c:         original = ch->in_room;
act_info.c://         if( pexit->distance > 1 )
act_info.c://            if( ( to_room = generate_exit( ch->in_room, &pexit ) ) != NULL )
act_info.c://               char_to_room( ch, pexit->to_room );
act_info.c:            char_to_room( ch, pexit->to_room );
act_info.c:   else if( door != -1 )
act_info.c:    * finally fixed the annoying look 2.obj desc bug -Thoric 
act_info.c:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c:   if( victim->max_hit > 0 )
act_info.c:      percent = ( int )( ( 100.0 * ( double )( victim->hit ) ) / ( double )( victim->max_hit ) );
act_info.c:      percent = -1;
act_info.c:   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_DROID ) )
act_info.c:-- Narn, winter '96
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:      save_act = ch->act;
act_info.c:      SET_BIT( ch->act, PLR_BRIEF );
act_info.c:      ch->act = save_act;
act_info.c:         if( board->num_posts )
act_info.c:            ch_printf( ch, "There are about %d notes posted here.  Type 'note list' to list them.\r\n", board->num_posts );
act_info.c:      switch ( obj->item_type )
act_info.c:            if( obj->value[1] == 0 )
act_info.c:               obj->value[1] = obj->value[0];
act_info.c:            if( obj->value[1] == 0 )
act_info.c:               obj->value[1] = 1;
act_info.c:            dam = ( short )( ( obj->value[0] * 10 ) / obj->value[1] );
act_info.c:            dam = INIT_WEAPON_CONDITION - obj->value[0];
act_info.c:            if( obj->value[3] == WEAPON_BLASTER )
act_info.c:               if( obj->blaster_setting == BLASTER_FULL )
act_info.c:               else if( obj->blaster_setting == BLASTER_HIGH )
act_info.c:               else if( obj->blaster_setting == BLASTER_NORMAL )
act_info.c:               else if( obj->blaster_setting == BLASTER_HALF )
act_info.c:               else if( obj->blaster_setting == BLASTER_LOW )
act_info.c:               else if( obj->blaster_setting == BLASTER_STUN )
act_info.c:               ch_printf( ch, "It has from %d to %d shots remaining.\r\n", obj->value[4] / 5, obj->value[4] );
act_info.c:            else if( ( obj->value[3] == WEAPON_LIGHTSABER ||
act_info.c:                       obj->value[3] == WEAPON_VIBRO_BLADE || obj->value[3] == WEAPON_FORCE_PIKE ) )
act_info.c:               ch_printf( ch, "It has %d/%d units of charge remaining.\r\n", obj->value[4], obj->value[5] );
act_info.c:            if( obj->timer > 0 && obj->value[1] > 0 )
act_info.c:               dam = ( obj->timer * 10 ) / obj->value[1];
act_info.c:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c:            short timerfrac = obj->timer;
act_info.c:            if( obj->item_type == ITEM_CORPSE_PC )
act_info.c:               timerfrac = ( int )obj->timer / 8 + 1;
act_info.c:            short timerfrac = obj->timer;
act_info.c:       && !IS_SET( ch->act, PLR_HOLYLIGHT )
act_info.c:       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_INFRARED ) && room_is_dark( ch->in_room ) )
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:      if( pexit->to_room && !IS_SET( pexit->exit_info, EX_HIDDEN ) )
act_info.c:            if( IS_SET( pexit->exit_info, EX_CLOSED ) )
act_info.c:               sprintf( buf + strlen( buf ), "%-5s - (closed)\r\n", capitalize( dir_name[pexit->vdir] ) );
act_info.c:            else if( IS_SET( pexit->exit_info, EX_WINDOW ) )
act_info.c:               sprintf( buf + strlen( buf ), "%-5s - (window)\r\n", capitalize( dir_name[pexit->vdir] ) );
act_info.c:            else if( IS_SET( pexit->exit_info, EX_xAUTO ) )
act_info.c:               sprintf( buf + strlen( buf ), "%-5s - %s\r\n",
act_info.c:                        capitalize( pexit->keyword ),
act_info.c:                        room_is_dark( pexit->to_room ) ? "Too dark to tell" : pexit->to_room->name );
act_info.c:               sprintf( buf + strlen( buf ), "%-5s - %s\r\n",
act_info.c:                        capitalize( dir_name[pexit->vdir] ),
act_info.c:                        room_is_dark( pexit->to_room ) ? "Too dark to tell" : pexit->to_room->name );
act_info.c:            sprintf( buf + strlen( buf ), " %s", capitalize( dir_name[pexit->vdir] ) );
act_info.c: * ie: online help editing				-Thoric
act_info.c:      lev = -2;
act_info.c:   for( pHelp = first_help; pHelp; pHelp = pHelp->next )
act_info.c:      if( pHelp->level > get_trust( ch ) )
act_info.c:      if( lev != -2 && pHelp->level != lev )
act_info.c:      if( is_name( argall, pHelp->keyword ) )
act_info.c:   if( pHelp->level >= 0 && str_cmp( argument, "imotd" ) )
act_info.c:      send_to_pager( pHelp->keyword, ch );
act_info.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SOUND ) )
act_info.c:   if( pHelp->text[0] == '.' )
act_info.c:      send_to_pager_color( pHelp->text + 1, ch );
act_info.c:      send_to_pager_color( pHelp->text, ch );
act_info.c: * Help editor							-Thoric
act_info.c:   if( !ch->desc )
act_info.c:   switch ( ch->substate )
act_info.c:	if( ( pHelp = ( HELP_DATA* ) ch->dest_buf ) == NULL )
act_info.c:            bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
act_info.c:         STRFREE( pHelp->text );
act_info.c:         pHelp->text = copy_buffer( ch );
act_info.c:      for( tHelp = first_help; tHelp; tHelp = tHelp->next )
act_info.c:         if( !str_cmp( argument, tHelp->keyword ) )
act_info.c:         pHelp->keyword = STRALLOC( strupper( argument ) );
act_info.c:         pHelp->text = STRALLOC( "" );
act_info.c:         pHelp->level = lev;
act_info.c:   ch->substate = SUB_HELP_EDIT;
act_info.c:   ch->dest_buf = pHelp;
act_info.c:   start_editing( ch, pHelp->text );
act_info.c: * Stupid leading space muncher fix				-Thoric
act_info.c:      for( pHelp = first_help; pHelp; pHelp = pHelp->next )
act_info.c:         fprintf( fpout, "%d %s~\n%s~\n\n", pHelp->level, pHelp->keyword, help_fix( pHelp->text ) );
act_info.c:      STRFREE( pHelp->text );
act_info.c:      STRFREE( pHelp->keyword );
act_info.c:      if( lev < -1 || lev > get_trust(ch) )
act_info.c:      pHelp->level = lev;
act_info.c:      STRFREE( pHelp->keyword );
act_info.c:      pHelp->keyword = STRALLOC( strupper( arg2 ) );
act_info.c: * Show help topics in a level range				-Thoric
act_info.c:   minlimit = maxlimit >= LEVEL_GREATER ? -1 : 0;
act_info.c:   for( cnt = 0, help = first_help; help; help = help->next )
act_info.c:      if( help->level >= min && help->level <= max )
act_info.c:         pager_printf( ch, "  %3d %s\r\n", help->level, help->keyword );
act_info.c: * New do_who with WHO REQUEST, clan, race and homepage support.  -Thoric
act_info.c:   for( d = last_descriptor; d; d = d->prev )
act_info.c:      if( ( d->connected != CON_PLAYING && d->connected != CON_EDITING )
act_info.c:          || ( !can_see( ch, d->character ) && IS_IMMORTAL( d->character ) ) || d->original )
act_info.c:      wch = d->original ? d->original : d->character;
act_info.c:      if( wch->top_level < iLevelLower
act_info.c:          || wch->top_level > iLevelUpper
act_info.c:          || ( fImmortalOnly && wch->top_level < LEVEL_IMMORTAL )
act_info.c:          || ( fRaceRestrict && !rgfRace[wch->race] ) || ( fClanMatch && ( pClan != wch->pcdata->clan ) ) /* SB */  )
act_info.c:      if( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
act_info.c:         sprintf( char_name, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:      sprintf( race_text, "(%s) ", race_table[wch->race].race_name );
act_info.c:      switch ( wch->top_level )
act_info.c:         case MAX_LEVEL - 0:
act_info.c:         case MAX_LEVEL - 1:
act_info.c:         case MAX_LEVEL - 2:
act_info.c:         case MAX_LEVEL - 3:
act_info.c:         case MAX_LEVEL - 4:
act_info.c:      if( !nifty_is_name( wch->name, wch->pcdata->title ) && ch->top_level > wch->top_level )
act_info.c:         sprintf( extra_title, " [%s]", wch->name );
act_info.c:      else if( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c:         race = wch->pcdata->rank;
act_info.c:      if( wch->pcdata->clan )
act_info.c:         CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:         if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:         if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:         if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:         strcat( clan_name, pclan->name );
act_info.c:      if( IS_SET( wch->act, PLR_WIZINVIS ) )
act_info.c:         sprintf( invis_str, "(%d) ", wch->pcdata->wizinvis );
act_info.c:               IS_SET( wch->act, PLR_AFK ) ? "[AFK] " : "",
act_info.c:               wch->pcdata->title,
act_info.c:               extra_title, clan_name, IS_SET( wch->act, PLR_KILLER ) ? "&R [Wanted for Murder]&W" : "&W" );
act_info.c:      cur_who->text = str_dup( buf );
act_info.c:         cur_who->type = WT_IMM;
act_info.c:         cur_who->type = WT_NEWBIE;
act_info.c:         cur_who->type = WT_MORTAL;
act_info.c:      switch ( cur_who->type )
act_info.c:            cur_who->next = first_mortal;
act_info.c:            cur_who->next = first_imm;
act_info.c:            cur_who->next = first_newbie;
act_info.c:         fprintf( whoout, "\r\n----------------------------------[ New Citizens ]----------------------------\r\n\r\n" );
act_info.c:         send_to_pager( "\r\n&G----------------------------------[ New Citizens ]----------------------------&W\r\n\r\n",
act_info.c:         fprintf( whoout, "%s", cur_who->text );
act_info.c:         send_to_pager( cur_who->text, ch );
act_info.c:      next_who = cur_who->next;
act_info.c:      DISPOSE( cur_who->text );
act_info.c:         fprintf( whoout, "\r\n--------------------------------[ Galactic Citizens ]-------------------------\r\n\r\n" );
act_info.c:         send_to_pager( "\r\n&G--------------------------------[ Galactic Citizens ]-------------------------&W\r\n\r\n",
act_info.c:         fprintf( whoout, "%s", cur_who->text );
act_info.c:         send_to_pager( cur_who->text, ch );
act_info.c:      next_who = cur_who->next;
act_info.c:      DISPOSE( cur_who->text );
act_info.c:         fprintf( whoout, "\r\n-------------------------------[ Omnipresent Beings ]-------------------------\r\n\r\n" );
act_info.c:         send_to_pager( "\r\n&G-------------------------------[ Omnipresent Beings ]--------------------------&W\r\n\r\n",
act_info.c:         fprintf( whoout, "%s", cur_who->text );
act_info.c:         send_to_pager( cur_who->text, ch );
act_info.c:      next_who = cur_who->next;
act_info.c:      DISPOSE( cur_who->text );
act_info.c:      for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:         if( obj2->wear_loc != WEAR_NONE
act_info.c:             && obj1->item_type == obj2->item_type && ( obj1->wear_flags & obj2->wear_flags & ~ITEM_TAKE ) != 0 )
act_info.c:   else if( obj1->item_type != obj2->item_type )
act_info.c:      switch ( obj1->item_type )
act_info.c:            value1 = obj1->value[0];
act_info.c:            value2 = obj2->value[0];
act_info.c:            value1 = obj1->value[1] + obj1->value[2];
act_info.c:            value2 = obj2->value[1] + obj2->value[2];
act_info.c:         pager_printf( ch, "Players near you in %s:\r\n", ch->in_room->area->name );
act_info.c:      for( d = first_descriptor; d; d = d->next )
act_info.c:         if( ( d->connected == CON_PLAYING || d->connected == CON_EDITING )
act_info.c:             && ( victim = d->character ) != NULL
act_info.c:             && victim->in_room
act_info.c:             && ( victim->in_room->area == ch->in_room->area || get_trust( ch ) >= LEVEL_IMMORTAL )
act_info.c:            pager_printf( ch, "%-28s %s\r\n", victim->name, victim->in_room->name );
act_info.c:      for( victim = first_char; victim; victim = victim->next )
act_info.c:         if( victim->in_room
act_info.c:             && victim->in_room->area == ch->in_room->area
act_info.c:             && !IS_AFFECTED( victim, AFF_SNEAK ) && can_see( ch, victim ) && is_name( arg, victim->name ) )
act_info.c:            pager_printf( ch, "%-28s %s\r\n", PERS( victim, ch ), victim->in_room->name );
act_info.c:   diff = ( victim->top_level - ch->top_level ) * 10;
act_info.c:   diff += ( int )( victim->max_hit - ch->max_hit ) / 10;
act_info.c:   if( diff <= -200 )
act_info.c:   else if( diff <= -150 )
act_info.c:   else if( diff <= -100 )
act_info.c:   else if( diff <= -50 )
act_info.c:      msg = "$N is built like an AT-AT!";
act_info.c: * (Uses an is_name check). -- Altrag
act_info.c:         if( !skill_table[sn]->name )
act_info.c:         if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c:         if( strcmp( skill_table[sn]->name, "reserved" ) == 0 && ( IS_IMMORTAL( ch ) ) )
act_info.c:            send_to_pager( "--------------------------------[Spells]---------------------------------\r\n", ch );
act_info.c:         if( skill_table[sn]->type != lasttype )
act_info.c:                          "--------------------------------%ss---------------------------------\r\n",
act_info.c:                          skill_tname[skill_table[sn]->type] );
act_info.c:         lasttype = skill_table[sn]->type;
act_info.c:         if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c:         if( ch->pcdata->learned[sn] <= 0 && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c:         if( ch->pcdata->learned[sn] == 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c:         pager_printf( ch, "%18s %3d%%  ", skill_table[sn]->name, ch->pcdata->learned[sn] );
act_info.c:      for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:         if( IS_NPC( mob ) && IS_SET( mob->act, ACT_PRACTICE ) )
act_info.c:      if( sn == -1 )
act_info.c:      if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c:      if( can_prac && !IS_NPC( ch ) && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c:      if( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) )
act_info.c:      if( skill_table[sn]->teachers && skill_table[sn]->teachers[0] != '\0' )
act_info.c:         sprintf( buf, "%d", mob->pIndexData->vnum );
act_info.c:         if( !is_name( buf, skill_table[sn]->teachers ) )
act_info.c:      if( ch->gold < skill_table[sn]->min_level * 10 )
act_info.c:                  skill_table[sn]->min_level * 10 );
act_info.c:      if( ch->pcdata->learned[sn] >= adept )
act_info.c:         sprintf( buf, "$n tells you, 'I've taught you everything I can about %s.'", skill_table[sn]->name );
act_info.c:         ch->gold -= skill_table[sn]->min_level * 10;
act_info.c:         ch->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c:         act( AT_ACTION, "You practice $T.", ch, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c:         act( AT_ACTION, "$n practices $T.", ch, NULL, skill_table[sn]->name, TO_ROOM );
act_info.c:         if( ch->pcdata->learned[sn] >= adept )
act_info.c:            ch->pcdata->learned[sn] = adept;
act_info.c:      if( sn == -1 )
act_info.c:      if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c:      if( victim->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c:      if( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) )
act_info.c:      if( victim->pcdata->learned[sn] >= adept )
act_info.c:      if( ch->pcdata->learned[sn] < 100 )
act_info.c:         victim->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c:         sprintf( buf, "You teach %s $T.", victim->name );
act_info.c:         act( AT_ACTION, buf, ch, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c:         sprintf( buf, "%s teaches you $T.", ch->name );
act_info.c:         act( AT_ACTION, buf, victim, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c:      wimpy = ( int )ch->max_hit / 5;
act_info.c:   if( wimpy > ch->max_hit )
act_info.c:   ch->wimpy = wimpy;
act_info.c:   if( strcmp( sha256_crypt( arg1 ), ch->pcdata->pwd ) )
act_info.c:   DISPOSE( ch->pcdata->pwd );
act_info.c:   ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:      for( social = social_index[iHash]; social; social = social->next )
act_info.c:         pager_printf( ch, "%-12s", social->name );
act_info.c:         for( command = command_hash[hash]; command; command = command->next )
act_info.c:            if( command->level < LEVEL_HERO
act_info.c:                && command->level <= get_trust( ch ) && ( command->name[0] != 'm' && command->name[1] != 'p' ) )
act_info.c:               pager_printf( ch, "%-12s", command->name );
act_info.c:         for( command = command_hash[hash]; command; command = command->next )
act_info.c:            if( command->level < LEVEL_HERO
act_info.c:                && command->level <= get_trust( ch )
act_info.c:                && !str_prefix( argument, command->name ) && ( command->name[0] != 'm' && command->name[1] != 'p' ) )
act_info.c:               pager_printf( ch, "%-12s", command->name );
act_info.c:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_AUCTION ) ? " +AUCTION" : " -auction", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_CHAT ) ? " +CHAT" : " -chat", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_OOC ) ? " +OOC" : " -ooc", ch );
act_info.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_CLAN ) ? " +CLAN" : " -clan", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_QUEST ) ? " +QUEST" : " -quest", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_TELLS ) ? " +TELLS" : " -tells", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_WARTALK ) ? " +WARTALK" : " -wartalk", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_AVTALK ) ? " +AVATAR" : " -avatar", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_IMMTALK ) ? " +IMMTALK" : " -immtalk", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_PRAY ) ? " +PRAY" : " -pray", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_MUSIC ) ? " +MUSIC" : " -music", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_ASK ) ? " +ASK" : " -ask", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_SHOUT ) ? " +SHOUT" : " -shout", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_YELL ) ? " +YELL" : " -yell", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_MONITOR ) ? " +MONITOR" : " -monitor", ch );
act_info.c:      send_to_char( !IS_SET( ch->deaf, CHANNEL_NEWBIE ) ? " +NEWBIE" : " -newbie", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_LOG ) ? " +LOG" : " -log", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_BUILD ) ? " +BUILD" : " -build", ch );
act_info.c:         send_to_char( !IS_SET( ch->deaf, CHANNEL_COMM ) ? " +COMM" : " -comm", ch );
act_info.c:      else if( arg[0] == '-' )
act_info.c:         send_to_char( "Channels -channel or +channel?\r\n", ch );
act_info.c:      else if( !str_cmp( arg + 1, "clan" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:       && ch->pcdata->clan->clan_type != CLAN_GUILD )
act_info.c:      else if( !str_cmp( arg + 1, "guild" )  && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:       && ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:      else if( !str_cmp( arg + 1, "newbie" ) && ( IS_IMMORTAL( ch ) || ch->top_level < 3 ) )
act_info.c:      else if( !str_cmp( arg + 1, "order" )  && !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_IMMTALK); 
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:          * if (ch->pcdata->clan)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:          * if (ch->pcdata->guild)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:         if( ch->top_level >= LEVEL_IMMORTAL )
act_info.c:            REMOVE_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:         if( ch->top_level >= sysdata.log_level )
act_info.c:            REMOVE_BIT( ch->deaf, CHANNEL_COMM );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_IMMTALK); 
act_info.c:         SET_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:         if( ch->top_level >= LEVEL_IMMORTAL )
act_info.c:            SET_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:         if( ch->top_level >= sysdata.log_level )
act_info.c:            SET_BIT( ch->deaf, CHANNEL_COMM );
act_info.c:         REMOVE_BIT( ch->deaf, bit );
act_info.c:         SET_BIT( ch->deaf, bit );
act_info.c: * display WIZLIST file						-Thoric
act_info.c:      send_to_char( IS_SET( ch->act, PLR_FLEE )
act_info.c:                    : "[-flee     ] You fight back if you get attacked.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NORECALL )
act_info.c:                    ? "[+NORECALL ] You fight to the death, link-dead or not.\r\n"
act_info.c:                    : "[-norecall ] You try to recall if fighting link-dead.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_AUTOEXIT )
act_info.c:                    : "[-autoexit ] You don't automatically see exits.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_AUTOLOOT )
act_info.c:                    : "[-autoloot ] You don't automatically loot corpses.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_AUTOSAC )
act_info.c:                    : "[-autosac  ] You don't automatically sacrifice corpses.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_AUTOGOLD )
act_info.c:                    : "[-autocred ] You don't automatically split credits from kills in groups.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_GAG )
act_info.c:                    : "[-gag      ] You see full battle text.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON )
act_info.c:                    ? "[+PAGER    ] Long output is page-paused.\r\n"
act_info.c:                    : "[-pager    ] Long output scrolls to the end.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_BLANK )
act_info.c:                    : "[-blank    ] You have no blank line before your prompt.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_BRIEF )
act_info.c:                    ? "[+BRIEF    ] You see brief descriptions.\r\n" : "[-brief    ] You see long descriptions.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_COMBINE )
act_info.c:                    : "[-combine  ] You see object lists in single format.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO )
act_info.c:                    : "[-nointro  ] You see the ascii intro screen on login.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_PROMPT )
act_info.c:                    ? "[+PROMPT   ] You have a prompt.\r\n" : "[-prompt   ] You don't have a prompt.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_TELNET_GA )
act_info.c:                    : "[-telnetga ] You don't receive a telnet GA sequence.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_ANSI )
act_info.c:                    : "[-ansi     ] You don't receive receive ANSI colors.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_SOUND )
act_info.c:                    ? "[+SOUND     ] You have MSP support.\r\n" : "[-sound     ] You don't have MSP support.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_SHOVEDRAG )
act_info.c:                    : "[-shovedrag] You'd rather not be shoved or dragged around.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON )
act_info.c:                    : "[-nosummon ] You allow other players to summon you.\r\n", ch );
act_info.c:         send_to_char( IS_SET( ch->act, PLR_ROOMVNUM )
act_info.c:                       : "[-vnum     ] You do not see the VNUM of a room.\r\n", ch );
act_info.c:         send_to_char( IS_SET( ch->act, PLR_AUTOMAP ) /* maps */
act_info.c:                       : "[-map      ] You do not see the MAP of a room.\r\n", ch );
act_info.c:         send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_ROOM )
act_info.c:                       ? "[+ROOMFLAGS] You will see room flags.\r\n" : "[-roomflags] You will not see room flags.\r\n", ch );
act_info.c:      send_to_char( IS_SET( ch->act, PLR_SILENCE ) ? "[+SILENCE  ] You are silenced.\r\n" : "", ch );
act_info.c:      send_to_char( !IS_SET( ch->act, PLR_NO_EMOTE ) ? "" : "[-emote    ] You can't emote.\r\n", ch );
act_info.c:      send_to_char( !IS_SET( ch->act, PLR_NO_TELL ) ? "" : "[-tell     ] You can't use 'tell'.\r\n", ch );
act_info.c:      send_to_char( !IS_SET( ch->act, PLR_LITTERBUG )
act_info.c:                    ? "" : "[-litter  ] A convicted litterbug. You cannot drop anything.\r\n", ch );
act_info.c:      else if( arg[0] == '-' )
act_info.c:         send_to_char( "Config -option or +option?\r\n", ch );
act_info.c:            SET_BIT( ch->act, bit );
act_info.c:            REMOVE_BIT( ch->act, bit );
act_info.c:            SET_BIT( ch->pcdata->flags, bit );
act_info.c:            REMOVE_BIT( ch->pcdata->flags, bit );
act_info.c:	pArea2 = pArea2->next;
act_info.c:	ch_printf( ch, "%-39s%-39s\r\n",
act_info.c:	    pArea1->name, pArea2 ? pArea2->name : "" );
act_info.c:	pArea1 = pArea1->next;
act_info.c:	    pArea2 = pArea2->next;
act_info.c:   send_to_pager( "-------------+--------------------------------------+-------------+-----------\r\n", ch );
act_info.c:   for( pArea = first_area; pArea; pArea = pArea->next )
act_info.c:      pager_printf( ch, "%-12s | %-36s | %4d - %-4d | %3d - %-3d \r\n",
act_info.c:                    pArea->author, pArea->name, pArea->low_soft_range,
act_info.c:                    pArea->hi_soft_range, pArea->low_hard_range, pArea->hi_hard_range );
act_info.c:   if( IS_SET( ch->act, PLR_AFK ) )
act_info.c:      REMOVE_BIT( ch->act, PLR_AFK );
act_info.c:      SET_BIT( ch->act, PLR_AFK );
act_info.c:   send_to_pager( "------------------\r\n", ch );
act_info.c:   for( ability = -1; ability < MAX_ABILITY; ability++ )
act_info.c:            if( !skill_table[sn]->name )
act_info.c:            if( skill_table[sn]->guild != ability )
act_info.c:            if( ch->pcdata->learned[sn] == 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c:            if( i == skill_table[sn]->min_level )
act_info.c:               pager_printf( ch, "(%3d) %-18.18s  ", i, skill_table[sn]->name );
act_info.c:              victim->name,
act_info.c:              victim->sex == SEX_MALE ? "male" :
act_info.c:              victim->sex == SEX_FEMALE ? "female" : "neutral", victim->top_level, npc_race[victim->race] );
act_info.c:      ch_printf( ch, " in room %d.\r\n", victim->in_room->vnum );
act_info.c:   if( victim->pcdata->clan )
act_info.c:      if( victim->pcdata->clan->clan_type == CLAN_CRIME )
act_info.c:      else if( victim->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:      send_to_char( victim->pcdata->clan->name, ch );
act_info.c:   if( victim->pcdata->homepage && victim->pcdata->homepage[0] != '\0' )
act_info.c:      ch_printf( ch, "%s's homepage can be found at %s.\r\n", victim->name, victim->pcdata->homepage );
act_info.c:   if( victim->pcdata->bio && victim->pcdata->bio[0] != '\0' )
act_info.c:      ch_printf( ch, "%s's personal bio:\r\n%s", victim->name, victim->pcdata->bio );
act_info.c:      send_to_char( "----------------------------------------------------\r\n", ch );
act_info.c:      if( victim->pcdata->authed_by && victim->pcdata->authed_by[0] != '\0' )
act_info.c:         ch_printf( ch, "%s was authorized by %s.\r\n", victim->name, victim->pcdata->authed_by );
act_info.c:                 victim->name, victim->pcdata->mkills, victim->pcdata->mdeaths );
act_info.c:      if( victim->pcdata->pkills || victim->pcdata->pdeaths )
act_info.c:                    victim->name, victim->pcdata->pkills, victim->pcdata->pdeaths );
act_info.c:      if( victim->pcdata->illegal_pk )
act_info.c:         ch_printf( ch, "%s has committed %d illegal player kills.\r\n", victim->name, victim->pcdata->illegal_pk );
act_info.c:                 victim->name, ( victim->pcdata->release_date == 0 ) ? "not " : "" );
act_info.c:      if( victim->pcdata->release_date != 0 )
act_info.c:                    victim->sex == SEX_MALE ? "He" :
act_info.c:                    victim->sex == SEX_FEMALE ? "She" : "It",
act_info.c:                    victim->pcdata->helled_by, ctime( &victim->pcdata->release_date ) );
act_info.c:      if( IS_SET( victim->act, PLR_SILENCE ) || IS_SET( victim->act, PLR_NO_EMOTE ) || IS_SET( victim->act, PLR_NO_TELL ) )
act_info.c:         if( IS_SET( victim->act, PLR_SILENCE ) )
act_info.c:         if( IS_SET( victim->act, PLR_NO_EMOTE ) )
act_info.c:         if( IS_SET( victim->act, PLR_NO_TELL ) )
act_info.c:      if( victim->desc && victim->desc->host[0] != '\0' )   /* added by Gorog */
act_info.c:         sprintf( buf2, "%s's IP info: %s ", victim->name, victim->desc->hostip );
act_info.c:            strcat( buf2, victim->desc->host );
act_info.c:      if( get_trust( ch ) >= LEVEL_GOD && get_trust( ch ) >= get_trust( victim ) && victim->pcdata )
act_info.c:         sprintf( buf2, "Email: %s\r\n", victim->pcdata->email );
act_info.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
act_info.c:         do_config( ch, "-pager" );
act_info.c:   ch->pcdata->pagerlen = atoi( arg );
act_info.c:   if( ch->pcdata->pagerlen < 5 )
act_info.c:      ch->pcdata->pagerlen = 5;
act_info.c:   ch_printf( ch, "Page pausing set to %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c~:*--------------------------------------------------------------------------*
act_info.c~:* -------------------------------------------------------------------------*
act_info.c~:*--------------------------------------------------------------------------*
act_info.c~:* ------------------------------------------------------------------------ *
act_info.c~:* ------------------------------------------------------------------------ *
act_info.c~: * Keep players from defeating examine progs -Druid
act_info.c~:   if( ( IS_AFFECTED( ch, AFF_DETECTTRAPS ) || IS_SET( ch->act, PLR_HOLYLIGHT ) ) && is_trapped( obj ) )
act_info.c~:      if( obj->short_descr )
act_info.c~:         strcat( buf, obj->short_descr );
act_info.c~:      if( obj->description )
act_info.c~:         strcat( buf, obj->description );
act_info.c~: * Some increasingly freaky halucinated objects		-Thoric
act_info.c~:      switch ( number_range( 6 - URANGE( 1, sms / 2, 5 ), sms ) )
act_info.c~:   switch ( number_range( 6 - URANGE( 1, sms / 2, 5 ), sms ) )
act_info.c~:   if( !ch->desc )
act_info.c~:    * if there's no list... then don't do all this crap!  -Thoric
act_info.c~:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c~:   for( obj = list; obj; obj = obj->next_content )
act_info.c~:   ms = ( ch->mental_state ? ch->mental_state : 1 )
act_info.c~:      * ( IS_NPC( ch ) ? 1 : ( ch->pcdata->condition[COND_DRUNK] ? ( ch->pcdata->condition[COND_DRUNK] / 12 ) : 1 ) );
act_info.c~:      offcount = URANGE( -( count ), ( count * ms ) / 100, count * 2 );
act_info.c~:         offcount -= number_range( 0, offcount );
act_info.c~:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c~:   for( obj = list; obj; obj = obj->next_content )
act_info.c~:         --tmp;
act_info.c~:      if( obj->wear_loc == WEAR_NONE
act_info.c~:          && can_see_obj( ch, obj ) && ( obj->item_type != ITEM_TRAP || IS_AFFECTED( ch, AFF_DETECTTRAPS ) ) )
act_info.c~:         if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c~:            for( iShow = nShow - 1; iShow >= 0; iShow-- )
act_info.c~:                  prgnShow[iShow] += obj->count;
act_info.c~:         pitShow[nShow] = obj->item_type;
act_info.c~:            prgnShow[nShow] = obj->count;
act_info.c~:    * Output the formatted list.      -Color support by Thoric
act_info.c~:/*	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) ) */
act_info.c~:      if( IS_NPC( ch ) || IS_SET( ch->act, PLR_COMBINE ) )
act_info.c~: * Show fancy descriptions for certain spell affects		-Thoric
act_info.c~:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                    IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:                 IS_NPC( victim ) ? capitalize( victim->short_descr ) : ( victim->name ) );
act_info.c~:   if( !IS_NPC( victim ) && !victim->desc && victim->switched && IS_AFFECTED( victim->switched, AFF_POSSESS ) )
act_info.c~:   if( !IS_NPC( victim ) && !victim->desc )
act_info.c~:      if( !victim->switched )
act_info.c~:      else if( !IS_AFFECTED( victim->switched, AFF_POSSESS ) )
act_info.c~:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_AFK ) )
act_info.c~:   if( ( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) )
act_info.c~:       || ( IS_NPC( victim ) && IS_SET( victim->act, ACT_MOBINVIS ) ) )
act_info.c~:         sprintf( buf1, "(Invis %d) ", victim->pcdata->wizinvis );
act_info.c~:         sprintf( buf1, "(Mobinvis %d) ", victim->mobinvis );
act_info.c~:   if( ( victim->mana > 10 ) && ( IS_AFFECTED( ch, AFF_DETECT_MAGIC ) || IS_IMMORTAL( ch ) ) )
act_info.c~:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_LITTERBUG ) )
act_info.c~:   if( IS_NPC( victim ) && IS_IMMORTAL( ch ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
act_info.c~:   if( victim->desc && victim->desc->connected == CON_EDITING )
act_info.c~:   if( victim->position == victim->defposition && victim->long_descr[0] != '\0' )
act_info.c~:      strcat( buf, victim->long_descr );
act_info.c~:    * *    removed to prevent prepending of name to title     -Kuran  
act_info.c~:    * *    But added back bellow so that you can see mobs too :P   -Durga 
act_info.c~:   if( !IS_NPC( victim ) && !IS_SET( ch->act, PLR_BRIEF ) )
act_info.c~:      strcat( buf, victim->pcdata->title );
act_info.c~:   switch ( victim->position )
act_info.c~:         if( ch->position == POS_SITTING || ch->position == POS_RESTING )
act_info.c~:         if( ch->position == POS_RESTING )
act_info.c~:         else if( ch->position == POS_MOUNTED )
act_info.c~:         if( ch->position == POS_SITTING )
act_info.c~:         else if( ch->position == POS_RESTING )
act_info.c~:            if( ( victim->in_room->sector_type == SECT_UNDERWATER )
act_info.c~:         else if( victim->in_room->sector_type == SECT_UNDERWATER )
act_info.c~:            if( ( victim->in_room->sector_type == SECT_OCEANFLOOR )
act_info.c~:         else if( victim->in_room->sector_type == SECT_OCEANFLOOR )
act_info.c~:         if( !victim->mount )
act_info.c~:         else if( victim->mount == ch )
act_info.c~:         else if( victim->in_room == victim->mount->in_room )
act_info.c~:            strcat( buf, PERS( victim->mount, ch ) );
act_info.c~:         if( !victim->fighting )
act_info.c~:         else if( victim->in_room == victim->fighting->who->in_room )
act_info.c~:            strcat( buf, PERS( victim->fighting->who, ch ) );
act_info.c~:   if( victim->description[0] != '\0' )
act_info.c~:      send_to_char( victim->description, ch );
act_info.c~:   if( IS_IMMORTAL( victim ) && ( victim->top_level > ch->top_level ) )
act_info.c~:   if( number_percent(  ) < ch->pcdata->learned[gsn_peek] )
act_info.c~:      show_list_to_char( victim->first_carrying, ch, TRUE, TRUE );
act_info.c~:   else if( ch->pcdata->learned[gsn_peek] )
act_info.c~:   for( rch = list; rch; rch = rch->next_in_room )
act_info.c~:      else if( rch->race == RACE_DEFEL )
act_info.c~:      else if( room_is_dark( ch->in_room ) && IS_AFFECTED( ch, AFF_INFRARED ) )
act_info.c~:      ch_printf( ch, "&C%-35s     ", rship->name );
act_info.c~:      if( ( nship = rship->next_in_room ) != NULL )
act_info.c~:         ch_printf( ch, "%-35s", nship->name );
act_info.c~:         nship = nship->next_in_room;
act_info.c~:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c~: * Returns classical DIKU door direction based on text in arg	-Thoric
act_info.c~:      door = -1;
act_info.c~:   if( !ch->desc )
act_info.c~:   if( ch->position < POS_SLEEPING )
act_info.c~:   if( ch->position == POS_SLEEPING )
act_info.c~:       && !IS_SET( ch->act, PLR_HOLYLIGHT ) && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && room_is_dark( ch->in_room ) )
act_info.c~:         show_char_to_char( ch->in_room->first_person, ch );
act_info.c~:      send_to_char( ch->in_room->name, ch );
act_info.c~:      if( !ch->desc->original )
act_info.c~:            if( IS_SET( ch->act, PLR_ROOMVNUM ) )
act_info.c~:                ch_printf( ch, "%d", ch->in_room->vnum );
act_info.c~:            if( IS_SET( ch->pcdata->flags, PCFLAG_ROOM ) )
act_info.c~:                send_to_char( flag_string( ch->in_room->room_flags, r_flags ), ch );
act_info.c~:      if( arg1[0] == '\0' || ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c~:         send_to_char( ch->in_room->description, ch );
act_info.c~:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOEXIT ) )
act_info.c~:      show_ships_to_char( ch->in_room->first_ship, ch );
act_info.c~:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c~:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c~:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) != NULL )
act_info.c~:            if( ship->starsystem )
act_info.c~:               if( ship->starsystem->star1 && str_cmp( ship->starsystem->star1, "" ) )
act_info.c~:                  ch_printf( ch, "%s\r\n", ship->starsystem->star1 );
act_info.c~:               if( ship->starsystem->star2 && str_cmp( ship->starsystem->star2, "" ) )
act_info.c~:                  ch_printf( ch, "%s\r\n", ship->starsystem->star2 );
act_info.c~:               if( ship->starsystem->planet1 && str_cmp( ship->starsystem->planet1, "" ) )
act_info.c~:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet1 );
act_info.c~:               if( ship->starsystem->planet2 && str_cmp( ship->starsystem->planet2, "" ) )
act_info.c~:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet2 );
act_info.c~:               if( ship->starsystem->planet3 && str_cmp( ship->starsystem->planet3, "" ) )
act_info.c~:                  ch_printf( ch, "%s\r\n", ship->starsystem->planet3 );
act_info.c~:               for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
act_info.c~:                     ch_printf( ch, "%s\r\n", target->name );
act_info.c~:               for( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
act_info.c~:                             missile->missiletype == CONCUSSION_MISSILE ? "A Concusion Missile" :
act_info.c~:                             ( missile->missiletype == PROTON_TORPEDO ? "A Torpedo" :
act_info.c~:                               ( missile->missiletype == HEAVY_ROCKET ? "A Heavy Rocket" : "A Heavy Bomb" ) ) );
act_info.c~:            else if( ship->location == ship->lastdoc )
act_info.c~:               if( ( to_room = get_room_index( ship->location ) ) != NULL )
act_info.c~:                  original = ch->in_room;
act_info.c~:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c~:      count = obj->count;
act_info.c~:      obj->count = 1;
act_info.c~:      obj->count = count;
act_info.c~:         show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c~:      switch ( obj->item_type )
act_info.c~:            if( obj->value[1] <= 0 )
act_info.c~:                       obj->value[1] < obj->value[0] / 4
act_info.c~:                       obj->value[1] < 3 * obj->value[0] / 4 ? "about" : "more than", liq_table[obj->value[2]].liq_color );
act_info.c~:            for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c~:               if( pexit->vdir == DIR_PORTAL && IS_SET( pexit->exit_info, EX_PORTAL ) )
act_info.c~:                  if( room_is_private( ch, pexit->to_room ) && get_trust( ch ) < sysdata.level_override_private )
act_info.c~:                  original = ch->in_room;
act_info.c~:                  char_to_room( ch, pexit->to_room );
act_info.c~:            if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_info.c~:            count = obj->count;
act_info.c~:            obj->count = 1;
act_info.c~:            obj->count = count;
act_info.c~:            show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c~:   if( ( pdesc = get_extra_descr( arg1, ch->in_room->first_extradesc ) ) != NULL )
act_info.c~:      if( pexit->keyword )
act_info.c~:         if( IS_SET( pexit->exit_info, EX_CLOSED ) && !IS_SET( pexit->exit_info, EX_WINDOW ) )
act_info.c~:            if( IS_SET( pexit->exit_info, EX_SECRET ) && door != -1 )
act_info.c~:               act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
act_info.c~:         if( IS_SET( pexit->exit_info, EX_BASHED ) )
act_info.c~:            act( AT_RED, "The $d has been bashed from its hinges!", ch, NULL, pexit->keyword, TO_CHAR );
act_info.c~:      if( pexit->description && pexit->description[0] != '\0' )
act_info.c~:         send_to_char( pexit->description, ch );
act_info.c~:       * Ability to look into the next room        -Thoric
act_info.c~:      if( pexit->to_room
act_info.c~:               || IS_SET( pexit->exit_info, EX_xLOOK ) || get_trust( ch ) >= LEVEL_IMMORTAL ) )
act_info.c~:         if( !IS_SET( pexit->exit_info, EX_xLOOK ) && get_trust( ch ) < LEVEL_IMMORTAL )
act_info.c~:               int percent = ch->pcdata->learned[skill_lookup( "scry" )];
act_info.c~:         if( room_is_private( ch, pexit->to_room ) && get_trust( ch ) < sysdata.level_override_private )
act_info.c~:         original = ch->in_room;
act_info.c~:         if( pexit->distance > 1 )
act_info.c~:            if( ( to_room = generate_exit( ch->in_room, &pexit ) ) != NULL )
act_info.c~:               char_to_room( ch, pexit->to_room );
act_info.c~:            char_to_room( ch, pexit->to_room );
act_info.c~:   else if( door != -1 )
act_info.c~:    * finally fixed the annoying look 2.obj desc bug -Thoric 
act_info.c~:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c~:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c~:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c~:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c~:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c~:            if( ( cnt += obj->count ) < number )
act_info.c~:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c~:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c~:   if( victim->max_hit > 0 )
act_info.c~:      percent = ( int )( ( 100.0 * ( double )( victim->hit ) ) / ( double )( victim->max_hit ) );
act_info.c~:      percent = -1;
act_info.c~:   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_DROID ) )
act_info.c~:-- Narn, winter '96
act_info.c~:   if( !ch->desc )
act_info.c~:   if( ch->position < POS_SLEEPING )
act_info.c~:   if( ch->position == POS_SLEEPING )
act_info.c~:      save_act = ch->act;
act_info.c~:      SET_BIT( ch->act, PLR_BRIEF );
act_info.c~:      ch->act = save_act;
act_info.c~:         if( board->num_posts )
act_info.c~:            ch_printf( ch, "There are about %d notes posted here.  Type 'note list' to list them.\r\n", board->num_posts );
act_info.c~:      switch ( obj->item_type )
act_info.c~:            if( obj->value[1] == 0 )
act_info.c~:               obj->value[1] = obj->value[0];
act_info.c~:            if( obj->value[1] == 0 )
act_info.c~:               obj->value[1] = 1;
act_info.c~:            dam = ( short )( ( obj->value[0] * 10 ) / obj->value[1] );
act_info.c~:            dam = INIT_WEAPON_CONDITION - obj->value[0];
act_info.c~:            if( obj->value[3] == WEAPON_BLASTER )
act_info.c~:               if( obj->blaster_setting == BLASTER_FULL )
act_info.c~:               else if( obj->blaster_setting == BLASTER_HIGH )
act_info.c~:               else if( obj->blaster_setting == BLASTER_NORMAL )
act_info.c~:               else if( obj->blaster_setting == BLASTER_HALF )
act_info.c~:               else if( obj->blaster_setting == BLASTER_LOW )
act_info.c~:               else if( obj->blaster_setting == BLASTER_STUN )
act_info.c~:               ch_printf( ch, "It has from %d to %d shots remaining.\r\n", obj->value[4] / 5, obj->value[4] );
act_info.c~:            else if( ( obj->value[3] == WEAPON_LIGHTSABER ||
act_info.c~:                       obj->value[3] == WEAPON_VIBRO_BLADE || obj->value[3] == WEAPON_FORCE_PIKE ) )
act_info.c~:               ch_printf( ch, "It has %d/%d units of charge remaining.\r\n", obj->value[4], obj->value[5] );
act_info.c~:            if( obj->timer > 0 && obj->value[1] > 0 )
act_info.c~:               dam = ( obj->timer * 10 ) / obj->value[1];
act_info.c~:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c~:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c~:            short timerfrac = obj->timer;
act_info.c~:            if( obj->item_type == ITEM_CORPSE_PC )
act_info.c~:               timerfrac = ( int )obj->timer / 8 + 1;
act_info.c~:            short timerfrac = obj->timer;
act_info.c~:       && !IS_SET( ch->act, PLR_HOLYLIGHT )
act_info.c~:       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_INFRARED ) && room_is_dark( ch->in_room ) )
act_info.c~:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c~:      if( pexit->to_room && !IS_SET( pexit->exit_info, EX_HIDDEN ) )
act_info.c~:            if( IS_SET( pexit->exit_info, EX_CLOSED ) )
act_info.c~:               sprintf( buf + strlen( buf ), "%-5s - (closed)\r\n", capitalize( dir_name[pexit->vdir] ) );
act_info.c~:            else if( IS_SET( pexit->exit_info, EX_WINDOW ) )
act_info.c~:               sprintf( buf + strlen( buf ), "%-5s - (window)\r\n", capitalize( dir_name[pexit->vdir] ) );
act_info.c~:            else if( IS_SET( pexit->exit_info, EX_xAUTO ) )
act_info.c~:               sprintf( buf + strlen( buf ), "%-5s - %s\r\n",
act_info.c~:                        capitalize( pexit->keyword ),
act_info.c~:                        room_is_dark( pexit->to_room ) ? "Too dark to tell" : pexit->to_room->name );
act_info.c~:               sprintf( buf + strlen( buf ), "%-5s - %s\r\n",
act_info.c~:                        capitalize( dir_name[pexit->vdir] ),
act_info.c~:                        room_is_dark( pexit->to_room ) ? "Too dark to tell" : pexit->to_room->name );
act_info.c~:            sprintf( buf + strlen( buf ), " %s", capitalize( dir_name[pexit->vdir] ) );
act_info.c~: * ie: online help editing				-Thoric
act_info.c~:      lev = -2;
act_info.c~:   for( pHelp = first_help; pHelp; pHelp = pHelp->next )
act_info.c~:      if( pHelp->level > get_trust( ch ) )
act_info.c~:      if( lev != -2 && pHelp->level != lev )
act_info.c~:      if( is_name( argall, pHelp->keyword ) )
act_info.c~:   if( pHelp->level >= 0 && str_cmp( argument, "imotd" ) )
act_info.c~:      send_to_pager( pHelp->keyword, ch );
act_info.c~:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SOUND ) )
act_info.c~:   if( pHelp->text[0] == '.' )
act_info.c~:      send_to_pager_color( pHelp->text + 1, ch );
act_info.c~:      send_to_pager_color( pHelp->text, ch );
act_info.c~: * Help editor							-Thoric
act_info.c~:   if( !ch->desc )
act_info.c~:   switch ( ch->substate )
act_info.c~:	if( ( pHelp = ( HELP_DATA* ) ch->dest_buf ) == NULL )
act_info.c~:            bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
act_info.c~:         STRFREE( pHelp->text );
act_info.c~:         pHelp->text = copy_buffer( ch );
act_info.c~:      for( tHelp = first_help; tHelp; tHelp = tHelp->next )
act_info.c~:         if( !str_cmp( argument, tHelp->keyword ) )
act_info.c~:         pHelp->keyword = STRALLOC( strupper( argument ) );
act_info.c~:         pHelp->text = STRALLOC( "" );
act_info.c~:         pHelp->level = lev;
act_info.c~:   ch->substate = SUB_HELP_EDIT;
act_info.c~:   ch->dest_buf = pHelp;
act_info.c~:   start_editing( ch, pHelp->text );
act_info.c~: * Stupid leading space muncher fix				-Thoric
act_info.c~:      for( pHelp = first_help; pHelp; pHelp = pHelp->next )
act_info.c~:         fprintf( fpout, "%d %s~\n%s~\n\n", pHelp->level, pHelp->keyword, help_fix( pHelp->text ) );
act_info.c~:      STRFREE( pHelp->text );
act_info.c~:      STRFREE( pHelp->keyword );
act_info.c~:      if( lev < -1 || lev > get_trust(ch) )
act_info.c~:      pHelp->level = lev;
act_info.c~:      STRFREE( pHelp->keyword );
act_info.c~:      pHelp->keyword = STRALLOC( strupper( arg2 ) );
act_info.c~: * Show help topics in a level range				-Thoric
act_info.c~:   minlimit = maxlimit >= LEVEL_GREATER ? -1 : 0;
act_info.c~:   for( cnt = 0, help = first_help; help; help = help->next )
act_info.c~:      if( help->level >= min && help->level <= max )
act_info.c~:         pager_printf( ch, "  %3d %s\r\n", help->level, help->keyword );
act_info.c~: * New do_who with WHO REQUEST, clan, race and homepage support.  -Thoric
act_info.c~:   for( d = last_descriptor; d; d = d->prev )
act_info.c~:      if( ( d->connected != CON_PLAYING && d->connected != CON_EDITING )
act_info.c~:          || ( !can_see( ch, d->character ) && IS_IMMORTAL( d->character ) ) || d->original )
act_info.c~:      wch = d->original ? d->original : d->character;
act_info.c~:      if( wch->top_level < iLevelLower
act_info.c~:          || wch->top_level > iLevelUpper
act_info.c~:          || ( fImmortalOnly && wch->top_level < LEVEL_IMMORTAL )
act_info.c~:          || ( fRaceRestrict && !rgfRace[wch->race] ) || ( fClanMatch && ( pClan != wch->pcdata->clan ) ) /* SB */  )
act_info.c~:      if( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
act_info.c~:         sprintf( char_name, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c~:      sprintf( race_text, "(%s) ", race_table[wch->race].race_name );
act_info.c~:      switch ( wch->top_level )
act_info.c~:         case MAX_LEVEL - 0:
act_info.c~:         case MAX_LEVEL - 1:
act_info.c~:         case MAX_LEVEL - 2:
act_info.c~:         case MAX_LEVEL - 3:
act_info.c~:         case MAX_LEVEL - 4:
act_info.c~:      if( !nifty_is_name( wch->name, wch->pcdata->title ) && ch->top_level > wch->top_level )
act_info.c~:         sprintf( extra_title, " [%s]", wch->name );
act_info.c~:      else if( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c~:         race = wch->pcdata->rank;
act_info.c~:      if( wch->pcdata->clan )
act_info.c~:         CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c~:         if( !str_cmp( wch->name, pclan->leader ) )
act_info.c~:         if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c~:         if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c~:         strcat( clan_name, pclan->name );
act_info.c~:      if( IS_SET( wch->act, PLR_WIZINVIS ) )
act_info.c~:         sprintf( invis_str, "(%d) ", wch->pcdata->wizinvis );
act_info.c~:               IS_SET( wch->act, PLR_AFK ) ? "[AFK] " : "",
act_info.c~:               wch->pcdata->title,
act_info.c~:               extra_title, clan_name, IS_SET( wch->act, PLR_KILLER ) ? "&R [Wanted for Murder]&W" : "&W" );
act_info.c~:      cur_who->text = str_dup( buf );
act_info.c~:         cur_who->type = WT_IMM;
act_info.c~:         cur_who->type = WT_NEWBIE;
act_info.c~:         cur_who->type = WT_MORTAL;
act_info.c~:      switch ( cur_who->type )
act_info.c~:            cur_who->next = first_mortal;
act_info.c~:            cur_who->next = first_imm;
act_info.c~:            cur_who->next = first_newbie;
act_info.c~:         fprintf( whoout, "\r\n----------------------------------[ New Citizens ]----------------------------\r\n\r\n" );
act_info.c~:         send_to_pager( "\r\n&G----------------------------------[ New Citizens ]----------------------------&W\r\n\r\n",
act_info.c~:         fprintf( whoout, "%s", cur_who->text );
act_info.c~:         send_to_pager( cur_who->text, ch );
act_info.c~:      next_who = cur_who->next;
act_info.c~:      DISPOSE( cur_who->text );
act_info.c~:         fprintf( whoout, "\r\n--------------------------------[ Galactic Citizens ]-------------------------\r\n\r\n" );
act_info.c~:         send_to_pager( "\r\n&G--------------------------------[ Galactic Citizens ]-------------------------&W\r\n\r\n",
act_info.c~:         fprintf( whoout, "%s", cur_who->text );
act_info.c~:         send_to_pager( cur_who->text, ch );
act_info.c~:      next_who = cur_who->next;
act_info.c~:      DISPOSE( cur_who->text );
act_info.c~:         fprintf( whoout, "\r\n-------------------------------[ Omnipresent Beings ]-------------------------\r\n\r\n" );
act_info.c~:         send_to_pager( "\r\n&G-------------------------------[ Omnipresent Beings ]--------------------------&W\r\n\r\n",
act_info.c~:         fprintf( whoout, "%s", cur_who->text );
act_info.c~:         send_to_pager( cur_who->text, ch );
act_info.c~:      next_who = cur_who->next;
act_info.c~:      DISPOSE( cur_who->text );
act_info.c~:      for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c~:         if( obj2->wear_loc != WEAR_NONE
act_info.c~:             && obj1->item_type == obj2->item_type && ( obj1->wear_flags & obj2->wear_flags & ~ITEM_TAKE ) != 0 )
act_info.c~:   else if( obj1->item_type != obj2->item_type )
act_info.c~:      switch ( obj1->item_type )
act_info.c~:            value1 = obj1->value[0];
act_info.c~:            value2 = obj2->value[0];
act_info.c~:            value1 = obj1->value[1] + obj1->value[2];
act_info.c~:            value2 = obj2->value[1] + obj2->value[2];
act_info.c~:         pager_printf( ch, "Players near you in %s:\r\n", ch->in_room->area->name );
act_info.c~:      for( d = first_descriptor; d; d = d->next )
act_info.c~:         if( ( d->connected == CON_PLAYING || d->connected == CON_EDITING )
act_info.c~:             && ( victim = d->character ) != NULL
act_info.c~:             && victim->in_room
act_info.c~:             && ( victim->in_room->area == ch->in_room->area || get_trust( ch ) >= LEVEL_IMMORTAL )
act_info.c~:            pager_printf( ch, "%-28s %s\r\n", victim->name, victim->in_room->name );
act_info.c~:      for( victim = first_char; victim; victim = victim->next )
act_info.c~:         if( victim->in_room
act_info.c~:             && victim->in_room->area == ch->in_room->area
act_info.c~:             && !IS_AFFECTED( victim, AFF_SNEAK ) && can_see( ch, victim ) && is_name( arg, victim->name ) )
act_info.c~:            pager_printf( ch, "%-28s %s\r\n", PERS( victim, ch ), victim->in_room->name );
act_info.c~:   diff = ( victim->top_level - ch->top_level ) * 10;
act_info.c~:   diff += ( int )( victim->max_hit - ch->max_hit ) / 10;
act_info.c~:   if( diff <= -200 )
act_info.c~:   else if( diff <= -150 )
act_info.c~:   else if( diff <= -100 )
act_info.c~:   else if( diff <= -50 )
act_info.c~:      msg = "$N is built like an AT-AT!";
act_info.c~: * (Uses an is_name check). -- Altrag
act_info.c~:         if( !skill_table[sn]->name )
act_info.c~:         if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c~:         if( strcmp( skill_table[sn]->name, "reserved" ) == 0 && ( IS_IMMORTAL( ch ) ) )
act_info.c~:            send_to_pager( "--------------------------------[Spells]---------------------------------\r\n", ch );
act_info.c~:         if( skill_table[sn]->type != lasttype )
act_info.c~:                          "--------------------------------%ss---------------------------------\r\n",
act_info.c~:                          skill_tname[skill_table[sn]->type] );
act_info.c~:         lasttype = skill_table[sn]->type;
act_info.c~:         if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c~:         if( ch->pcdata->learned[sn] <= 0 && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c~:         if( ch->pcdata->learned[sn] == 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c~:         pager_printf( ch, "%18s %3d%%  ", skill_table[sn]->name, ch->pcdata->learned[sn] );
act_info.c~:      for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c~:         if( IS_NPC( mob ) && IS_SET( mob->act, ACT_PRACTICE ) )
act_info.c~:      if( sn == -1 )
act_info.c~:      if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c~:      if( can_prac && !IS_NPC( ch ) && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c~:      if( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) )
act_info.c~:      if( skill_table[sn]->teachers && skill_table[sn]->teachers[0] != '\0' )
act_info.c~:         sprintf( buf, "%d", mob->pIndexData->vnum );
act_info.c~:         if( !is_name( buf, skill_table[sn]->teachers ) )
act_info.c~:      if( ch->gold < skill_table[sn]->min_level * 10 )
act_info.c~:                  skill_table[sn]->min_level * 10 );
act_info.c~:      if( ch->pcdata->learned[sn] >= adept )
act_info.c~:         sprintf( buf, "$n tells you, 'I've taught you everything I can about %s.'", skill_table[sn]->name );
act_info.c~:         ch->gold -= skill_table[sn]->min_level * 10;
act_info.c~:         ch->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c~:         act( AT_ACTION, "You practice $T.", ch, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c~:         act( AT_ACTION, "$n practices $T.", ch, NULL, skill_table[sn]->name, TO_ROOM );
act_info.c~:         if( ch->pcdata->learned[sn] >= adept )
act_info.c~:            ch->pcdata->learned[sn] = adept;
act_info.c~:      if( sn == -1 )
act_info.c~:      if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
act_info.c~:      if( victim->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
act_info.c~:      if( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) )
act_info.c~:      if( victim->pcdata->learned[sn] >= adept )
act_info.c~:      if( ch->pcdata->learned[sn] < 100 )
act_info.c~:         victim->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c~:         sprintf( buf, "You teach %s $T.", victim->name );
act_info.c~:         act( AT_ACTION, buf, ch, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c~:         sprintf( buf, "%s teaches you $T.", ch->name );
act_info.c~:         act( AT_ACTION, buf, victim, NULL, skill_table[sn]->name, TO_CHAR );
act_info.c~:      wimpy = ( int )ch->max_hit / 5;
act_info.c~:   if( wimpy > ch->max_hit )
act_info.c~:   ch->wimpy = wimpy;
act_info.c~:   if( strcmp( sha256_crypt( arg1 ), ch->pcdata->pwd ) )
act_info.c~:   DISPOSE( ch->pcdata->pwd );
act_info.c~:   ch->pcdata->pwd = str_dup( pwdnew );
act_info.c~:      for( social = social_index[iHash]; social; social = social->next )
act_info.c~:         pager_printf( ch, "%-12s", social->name );
act_info.c~:         for( command = command_hash[hash]; command; command = command->next )
act_info.c~:            if( command->level < LEVEL_HERO
act_info.c~:                && command->level <= get_trust( ch ) && ( command->name[0] != 'm' && command->name[1] != 'p' ) )
act_info.c~:               pager_printf( ch, "%-12s", command->name );
act_info.c~:         for( command = command_hash[hash]; command; command = command->next )
act_info.c~:            if( command->level < LEVEL_HERO
act_info.c~:                && command->level <= get_trust( ch )
act_info.c~:                && !str_prefix( argument, command->name ) && ( command->name[0] != 'm' && command->name[1] != 'p' ) )
act_info.c~:               pager_printf( ch, "%-12s", command->name );
act_info.c~:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_AUCTION ) ? " +AUCTION" : " -auction", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_CHAT ) ? " +CHAT" : " -chat", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_OOC ) ? " +OOC" : " -ooc", ch );
act_info.c~:      if( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_CLAN ) ? " +CLAN" : " -clan", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_QUEST ) ? " +QUEST" : " -quest", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_TELLS ) ? " +TELLS" : " -tells", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_WARTALK ) ? " +WARTALK" : " -wartalk", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_AVTALK ) ? " +AVATAR" : " -avatar", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_IMMTALK ) ? " +IMMTALK" : " -immtalk", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_PRAY ) ? " +PRAY" : " -pray", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_MUSIC ) ? " +MUSIC" : " -music", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_ASK ) ? " +ASK" : " -ask", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_SHOUT ) ? " +SHOUT" : " -shout", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_YELL ) ? " +YELL" : " -yell", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_MONITOR ) ? " +MONITOR" : " -monitor", ch );
act_info.c~:      send_to_char( !IS_SET( ch->deaf, CHANNEL_NEWBIE ) ? " +NEWBIE" : " -newbie", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_LOG ) ? " +LOG" : " -log", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_BUILD ) ? " +BUILD" : " -build", ch );
act_info.c~:         send_to_char( !IS_SET( ch->deaf, CHANNEL_COMM ) ? " +COMM" : " -comm", ch );
act_info.c~:      else if( arg[0] == '-' )
act_info.c~:         send_to_char( "Channels -channel or +channel?\r\n", ch );
act_info.c~:      else if( !str_cmp( arg + 1, "clan" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c~:       && ch->pcdata->clan->clan_type != CLAN_GUILD )
act_info.c~:      else if( !str_cmp( arg + 1, "guild" )  && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c~:       && ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c~:      else if( !str_cmp( arg + 1, "newbie" ) && ( IS_IMMORTAL( ch ) || ch->top_level < 3 ) )
act_info.c~:      else if( !str_cmp( arg + 1, "order" )  && !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c~:          * REMOVE_BIT (ch->deaf, CHANNEL_IMMTALK); 
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_ASK );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c~:         REMOVE_BIT( ch->deaf, CHANNEL_YELL );
act_info.c~:          * if (ch->pcdata->clan)
act_info.c~:          * REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c~:          * if (ch->pcdata->guild)
act_info.c~:          * REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c~:         if( ch->top_level >= LEVEL_IMMORTAL )
act_info.c~:            REMOVE_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c~:         if( ch->top_level >= sysdata.log_level )
act_info.c~:            REMOVE_BIT( ch->deaf, CHANNEL_COMM );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c~:          * SET_BIT (ch->deaf, CHANNEL_IMMTALK); 
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_ASK );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c~:         SET_BIT( ch->deaf, CHANNEL_YELL );
act_info.c~:         if( ch->top_level >= LEVEL_IMMORTAL )
act_info.c~:            SET_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c~:         if( ch->top_level >= sysdata.log_level )
act_info.c~:            SET_BIT( ch->deaf, CHANNEL_COMM );
act_info.c~:         REMOVE_BIT( ch->deaf, bit );
act_info.c~:         SET_BIT( ch->deaf, bit );
act_info.c~: * display WIZLIST file						-Thoric
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_FLEE )
act_info.c~:                    : "[-flee     ] You fight back if you get attacked.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NORECALL )
act_info.c~:                    ? "[+NORECALL ] You fight to the death, link-dead or not.\r\n"
act_info.c~:                    : "[-norecall ] You try to recall if fighting link-dead.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_AUTOEXIT )
act_info.c~:                    : "[-autoexit ] You don't automatically see exits.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_AUTOLOOT )
act_info.c~:                    : "[-autoloot ] You don't automatically loot corpses.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_AUTOSAC )
act_info.c~:                    : "[-autosac  ] You don't automatically sacrifice corpses.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_AUTOGOLD )
act_info.c~:                    : "[-autocred ] You don't automatically split credits from kills in groups.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_GAG )
act_info.c~:                    : "[-gag      ] You see full battle text.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON )
act_info.c~:                    ? "[+PAGER    ] Long output is page-paused.\r\n"
act_info.c~:                    : "[-pager    ] Long output scrolls to the end.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_BLANK )
act_info.c~:                    : "[-blank    ] You have no blank line before your prompt.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_BRIEF )
act_info.c~:                    ? "[+BRIEF    ] You see brief descriptions.\r\n" : "[-brief    ] You see long descriptions.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_COMBINE )
act_info.c~:                    : "[-combine  ] You see object lists in single format.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO )
act_info.c~:                    : "[-nointro  ] You see the ascii intro screen on login.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_PROMPT )
act_info.c~:                    ? "[+PROMPT   ] You have a prompt.\r\n" : "[-prompt   ] You don't have a prompt.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_TELNET_GA )
act_info.c~:                    : "[-telnetga ] You don't receive a telnet GA sequence.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_ANSI )
act_info.c~:                    : "[-ansi     ] You don't receive receive ANSI colors.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_SOUND )
act_info.c~:                    ? "[+SOUND     ] You have MSP support.\r\n" : "[-sound     ] You don't have MSP support.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_SHOVEDRAG )
act_info.c~:                    : "[-shovedrag] You'd rather not be shoved or dragged around.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON )
act_info.c~:                    : "[-nosummon ] You allow other players to summon you.\r\n", ch );
act_info.c~:         send_to_char( IS_SET( ch->act, PLR_ROOMVNUM )
act_info.c~:                       : "[-vnum     ] You do not see the VNUM of a room.\r\n", ch );
act_info.c~:         send_to_char( IS_SET( ch->act, PLR_AUTOMAP ) /* maps */
act_info.c~:                       : "[-map      ] You do not see the MAP of a room.\r\n", ch );
act_info.c~:         send_to_char( IS_SET( ch->pcdata->flags, PCFLAG_ROOM )
act_info.c~:                       ? "[+ROOMFLAGS] You will see room flags.\r\n" : "[-roomflags] You will not see room flags.\r\n", ch );
act_info.c~:      send_to_char( IS_SET( ch->act, PLR_SILENCE ) ? "[+SILENCE  ] You are silenced.\r\n" : "", ch );
act_info.c~:      send_to_char( !IS_SET( ch->act, PLR_NO_EMOTE ) ? "" : "[-emote    ] You can't emote.\r\n", ch );
act_info.c~:      send_to_char( !IS_SET( ch->act, PLR_NO_TELL ) ? "" : "[-tell     ] You can't use 'tell'.\r\n", ch );
act_info.c~:      send_to_char( !IS_SET( ch->act, PLR_LITTERBUG )
act_info.c~:                    ? "" : "[-litter  ] A convicted litterbug. You cannot drop anything.\r\n", ch );
act_info.c~:      else if( arg[0] == '-' )
act_info.c~:         send_to_char( "Config -option or +option?\r\n", ch );
act_info.c~:            SET_BIT( ch->act, bit );
act_info.c~:            REMOVE_BIT( ch->act, bit );
act_info.c~:            SET_BIT( ch->pcdata->flags, bit );
act_info.c~:            REMOVE_BIT( ch->pcdata->flags, bit );
act_info.c~:	pArea2 = pArea2->next;
act_info.c~:	ch_printf( ch, "%-39s%-39s\r\n",
act_info.c~:	    pArea1->name, pArea2 ? pArea2->name : "" );
act_info.c~:	pArea1 = pArea1->next;
act_info.c~:	    pArea2 = pArea2->next;
act_info.c~:   send_to_pager( "-------------+--------------------------------------+-------------+-----------\r\n", ch );
act_info.c~:   for( pArea = first_area; pArea; pArea = pArea->next )
act_info.c~:      pager_printf( ch, "%-12s | %-36s | %4d - %-4d | %3d - %-3d \r\n",
act_info.c~:                    pArea->author, pArea->name, pArea->low_soft_range,
act_info.c~:                    pArea->hi_soft_range, pArea->low_hard_range, pArea->hi_hard_range );
act_info.c~:   if( IS_SET( ch->act, PLR_AFK ) )
act_info.c~:      REMOVE_BIT( ch->act, PLR_AFK );
act_info.c~:      SET_BIT( ch->act, PLR_AFK );
act_info.c~:   send_to_pager( "------------------\r\n", ch );
act_info.c~:   for( ability = -1; ability < MAX_ABILITY; ability++ )
act_info.c~:            if( !skill_table[sn]->name )
act_info.c~:            if( skill_table[sn]->guild != ability )
act_info.c~:            if( ch->pcdata->learned[sn] == 0 && SPELL_FLAG( skill_table[sn], SF_SECRETSKILL ) )
act_info.c~:            if( i == skill_table[sn]->min_level )
act_info.c~:               pager_printf( ch, "(%3d) %-18.18s  ", i, skill_table[sn]->name );
act_info.c~:              victim->name,
act_info.c~:              victim->sex == SEX_MALE ? "male" :
act_info.c~:              victim->sex == SEX_FEMALE ? "female" : "neutral", victim->top_level, npc_race[victim->race] );
act_info.c~:      ch_printf( ch, " in room %d.\r\n", victim->in_room->vnum );
act_info.c~:   if( victim->pcdata->clan )
act_info.c~:      if( victim->pcdata->clan->clan_type == CLAN_CRIME )
act_info.c~:      else if( victim->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c~:      send_to_char( victim->pcdata->clan->name, ch );
act_info.c~:   if( victim->pcdata->homepage && victim->pcdata->homepage[0] != '\0' )
act_info.c~:      ch_printf( ch, "%s's homepage can be found at %s.\r\n", victim->name, victim->pcdata->homepage );
act_info.c~:   if( victim->pcdata->bio && victim->pcdata->bio[0] != '\0' )
act_info.c~:      ch_printf( ch, "%s's personal bio:\r\n%s", victim->name, victim->pcdata->bio );
act_info.c~:      send_to_char( "----------------------------------------------------\r\n", ch );
act_info.c~:      if( victim->pcdata->authed_by && victim->pcdata->authed_by[0] != '\0' )
act_info.c~:         ch_printf( ch, "%s was authorized by %s.\r\n", victim->name, victim->pcdata->authed_by );
act_info.c~:                 victim->name, victim->pcdata->mkills, victim->pcdata->mdeaths );
act_info.c~:      if( victim->pcdata->pkills || victim->pcdata->pdeaths )
act_info.c~:                    victim->name, victim->pcdata->pkills, victim->pcdata->pdeaths );
act_info.c~:      if( victim->pcdata->illegal_pk )
act_info.c~:         ch_printf( ch, "%s has committed %d illegal player kills.\r\n", victim->name, victim->pcdata->illegal_pk );
act_info.c~:                 victim->name, ( victim->pcdata->release_date == 0 ) ? "not " : "" );
act_info.c~:      if( victim->pcdata->release_date != 0 )
act_info.c~:                    victim->sex == SEX_MALE ? "He" :
act_info.c~:                    victim->sex == SEX_FEMALE ? "She" : "It",
act_info.c~:                    victim->pcdata->helled_by, ctime( &victim->pcdata->release_date ) );
act_info.c~:      if( IS_SET( victim->act, PLR_SILENCE ) || IS_SET( victim->act, PLR_NO_EMOTE ) || IS_SET( victim->act, PLR_NO_TELL ) )
act_info.c~:         if( IS_SET( victim->act, PLR_SILENCE ) )
act_info.c~:         if( IS_SET( victim->act, PLR_NO_EMOTE ) )
act_info.c~:         if( IS_SET( victim->act, PLR_NO_TELL ) )
act_info.c~:      if( victim->desc && victim->desc->host[0] != '\0' )   /* added by Gorog */
act_info.c~:         sprintf( buf2, "%s's IP info: %s ", victim->name, victim->desc->hostip );
act_info.c~:            strcat( buf2, victim->desc->host );
act_info.c~:      if( get_trust( ch ) >= LEVEL_GOD && get_trust( ch ) >= get_trust( victim ) && victim->pcdata )
act_info.c~:         sprintf( buf2, "Email: %s\r\n", victim->pcdata->email );
act_info.c~:      if( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
act_info.c~:         do_config( ch, "-pager" );
act_info.c~:   ch->pcdata->pagerlen = atoi( arg );
act_info.c~:   if( ch->pcdata->pagerlen < 5 )
act_info.c~:      ch->pcdata->pagerlen = 5;
act_info.c~:   ch_printf( ch, "Page pausing set to %d lines.\r\n", ch->pcdata->pagerlen );
act_move.c:*--------------------------------------------------------------------------*
act_move.c:* -------------------------------------------------------------------------*
act_move.c:*--------------------------------------------------------------------------*
act_move.c:* ------------------------------------------------------------------------ *
act_move.c:* ------------------------------------------------------------------------ *
act_move.c:   if( ch->plr_home )
act_move.c:      return ch->plr_home->vnum;
act_move.c:   if( ch->race == RACE_HUMAN )
act_move.c:   if( ch->race == RACE_WOOKIEE )
act_move.c:   if( ch->race == RACE_RODIAN )
act_move.c:   if( ch->race == RACE_MON_CALAMARI )
act_move.c:   if( ch->race == RACE_TWI_LEK )
act_move.c:   if( ch->race == RACE_HUTT )
act_move.c:   if( ch->race == RACE_GAMORREAN )
act_move.c:   if( ch->race == RACE_JAWA )
act_move.c:   if( ch->race == RACE_ADARIAN )
act_move.c:   if( ch->race == RACE_EWOK )
act_move.c:   if( ch->race == RACE_VERPINE )
act_move.c:   if( ch->race == RACE_DEFEL )
act_move.c:   if( ch->race == RACE_TRANDOSHAN )
act_move.c:   if( ch->race == RACE_CHADRA_FAN )
act_move.c:   if( ch->race == RACE_QUARREN )
act_move.c:   if( ch->race == RACE_DUINUOGWUIN )
act_move.c:   if( ch->race == RACE_NOGHRI )
act_move.c:            if( line[ln - 1] == '.' )
act_move.c:   int sector = room->sector_type;
act_move.c:   if( room->name )
act_move.c:      STRFREE( room->name );
act_move.c:   if( room->description )
act_move.c:      STRFREE( room->description );
act_move.c:   room->name = STRALLOC( sect_names[sector][0] );
act_move.c:      previous[iRand] = -1;
act_move.c:      while( previous[iRand] == -1 )
act_move.c:         x = number_range( 0, sent_total[sector] - 1 );
act_move.c:         if( len > 5 && buf[len - 1] == '.' )
act_move.c:   room->description = STRALLOC( buf2 );
act_move.c: * Remove any unused virtual rooms				-Thoric
act_move.c:      while( vroom_hash[hash] && !vroom_hash[hash]->first_person && !vroom_hash[hash]->first_content )
act_move.c:         vroom_hash[hash] = room->next;
act_move.c:         --top_vroom;
act_move.c:         room_next = room->next;
act_move.c:         if( !room->first_person && !room->first_content )
act_move.c:               prev->next = room_next;
act_move.c:            --top_vroom;
act_move.c: * Function to get the equivelant exit of DIR 0-MAXDIR out of linked list.
act_move.c: * Made to allow old-style diku-merc exit functions to work.	-Thoric
act_move.c:   for( xit = room->first_exit; xit; xit = xit->next )
act_move.c:      if( xit->vdir == dir )
act_move.c:   for( xit = room->first_exit; xit; xit = xit->next )
act_move.c:      if( xit->vdir == dir && xit->vnum == vnum )
act_move.c: * Function to get the nth exit of a room			-Thoric
act_move.c:   for( cnt = 0, xit = room->first_exit; xit; xit = xit->next )
act_move.c: * Modify movement due to encumbrance				-Thoric
act_move.c:  cur = ch->carry_weight;
act_move.c: * Check to see if a character can fall down, checks for looping   -Thoric
act_move.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:       && ( !IS_AFFECTED( ch, AFF_FLYING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:         bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:      move_char( ch, get_exit( ch->in_room, DIR_DOWN ), ++fall );
act_move.c: * create a 'virtual' room					-Thoric
act_move.c:   int distance = -1;
act_move.c:   int vdir = orig_exit->vdir;
act_move.c:   if( in_room->vnum > 32767 && in_room->vnum < 65534)   
act_move.c:      serial = in_room->vnum;
act_move.c:      roomnum = in_room->tele_vnum;
act_move.c:      if( ( serial & 65535 ) == orig_exit->vnum )
act_move.c:         --roomnum;
act_move.c:         distance = orig_exit->distance - 1;
act_move.c:      int r1 = in_room->vnum;
act_move.c:      int r2 = orig_exit->vnum;
act_move.c:      distance = orig_exit->distance - 1;
act_move.c:   for( room = vroom_hash[hash]; room; room = room->next )
act_move.c:      if( room->vnum == serial && room->tele_vnum == roomnum )
act_move.c:      room->area = in_room->area;
act_move.c:      room->vnum = serial;
act_move.c:      room->tele_vnum = roomnum;
act_move.c:      room->sector_type = in_room->sector_type;
act_move.c:      room->room_flags = in_room->room_flags;
act_move.c:      room->next = vroom_hash[hash];
act_move.c:      xit = make_exit( room, orig_exit->to_room, vdir );
act_move.c:      xit->keyword = STRALLOC( "" );
act_move.c:      xit->description = STRALLOC( "" );
act_move.c:      xit->key = -1;
act_move.c:      xit->distance = distance;
act_move.c:      bxit->keyword = STRALLOC( "" );
act_move.c:      bxit->description = STRALLOC( "" );
act_move.c:      bxit->key = -1;
act_move.c:      if( ( serial & 65535 ) != orig_exit->vnum )
act_move.c:         bxit->distance = roomnum;
act_move.c:         int fulldist = tmp->distance;
act_move.c:         bxit->distance = fulldist - distance;
act_move.c:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:      bug( "%s: %s to door %d", __FUNCTION__, ch->name, pexit->vdir );
act_move.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOUNTED ) )
act_move.c:   in_room = ch->in_room;
act_move.c:   if( !pexit || ( to_room = pexit->to_room ) == NULL )
act_move.c:   door = pexit->vdir;
act_move.c:   distance = pexit->distance;
act_move.c:    * unless it's a door with a window in it      -Thoric
act_move.c:   if( IS_SET( pexit->exit_info, EX_WINDOW ) && !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:   if( IS_SET( pexit->exit_info, EX_PORTAL ) && IS_NPC( ch ) )
act_move.c:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) )
act_move.c:   if( IS_SET( to_room->room_flags, ROOM_NO_MOB ) && IS_NPC( ch ) )
act_move.c:   if( IS_SET( pexit->exit_info, EX_CLOSED )
act_move.c:       && ( !IS_AFFECTED( ch, AFF_PASS_DOOR ) || IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_SECRET ) && !IS_SET( pexit->exit_info, EX_DIG ) )
act_move.c:            act( AT_PLAIN, "$n runs into the $d in $s drunken state.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:            act( AT_PLAIN, "You run into the $d in your drunken state.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c:            act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c:    * Crazy virtual room idea, created upon demand.     -Thoric
act_move.c:   if( !fall && IS_AFFECTED( ch, AFF_CHARM ) && ch->master && in_room == ch->master->in_room )
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->top_level < to_room->area->low_hard_range )
act_move.c:         switch ( to_room->area->low_hard_range - ch->top_level )
act_move.c:      else if( ch->top_level > to_room->area->hi_hard_range )
act_move.c:      if( in_room->sector_type == SECT_AIR || to_room->sector_type == SECT_AIR || IS_SET( pexit->exit_info, EX_FLY ) )
act_move.c:         if( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !ch->mount && !IS_AFFECTED( ch, AFF_FLYING ) )
act_move.c:      if( in_room->sector_type == SECT_WATER_NOSWIM || to_room->sector_type == SECT_WATER_NOSWIM )
act_move.c:         if( ch->mount )
act_move.c:            if( IS_AFFECTED( ch->mount, AFF_FLYING ) || IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:               if( obj->item_type == ITEM_BOAT )
act_move.c:      if( IS_SET( pexit->exit_info, EX_CLIMB ) )
act_move.c:         if( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !found && !ch->mount )
act_move.c:            if( ( !IS_NPC( ch ) && number_percent(  ) > ch->pcdata->learned[gsn_climb] ) || drunk || ch->mental_state < -90 )
act_move.c:               if( pexit->vdir == DIR_DOWN )
act_move.c:               retcode = damage( ch, ch, ( pexit->vdir == DIR_UP ? 10 : 5 ), TYPE_UNDEFINED );
act_move.c:            WAIT_STATE( ch, skill_table[gsn_climb]->beats );
act_move.c:      if( ch->mount )
act_move.c:         switch ( ch->mount->position )
act_move.c:         if( !IS_AFFECTED( ch->mount, AFF_FLYING ) && !IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            move = movement_loss[UMIN( SECT_MAX - 1, in_room->sector_type )];
act_move.c:         if( ch->mount->move < move )
act_move.c:            move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, in_room->sector_type )] );
act_move.c:         if( ch->move < move )
act_move.c:      if( ch->mount )
act_move.c:         ch->mount->move -= move;
act_move.c:         ch->move -= move;
act_move.c:   if( to_room->tunnel > 0 )
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:      for( ctmp = to_room->first_person; ctmp; ctmp = ctmp->next_in_room )
act_move.c:         if( ++count >= to_room->tunnel )
act_move.c:            if( ch->mount && count == to_room->tunnel )
act_move.c:    * check for traps on exit - later 
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:         if( ch->mount )
act_move.c:            if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:            else if( ch->position == POS_SHOVE )
act_move.c:            else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:   if( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:       * Mount bug fix test. -Orion
act_move.c:      if( char_died( ch->mount ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, to_room );
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:      else if( ch->mount )
act_move.c:         if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:         else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         else if( ch->position == POS_SHOVE )
act_move.c:         else if( ch->position == POS_DRAG )
act_move.c:            dtxt = "the south-west";
act_move.c:            dtxt = "the south-east";
act_move.c:            dtxt = "the north-west";
act_move.c:            dtxt = "the north-east";
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->top_level < to_room->area->low_soft_range )
act_move.c:      else if( ch->top_level > to_room->area->hi_soft_range )
act_move.c:      SET_BIT( ch->act, PLR_BRIEF );
act_move.c:    * the right number of them.  -- Narn
act_move.c:      for( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:      for( fch = from_room->first_person; fch && ( count < chars ); fch = nextinroom )
act_move.c:         nextinroom = fch->next_in_room;
act_move.c:             && fch->master == ch && fch->position == POS_STANDING )
act_move.c:   if( ch->in_room->first_content )
act_move.c:      if( !IS_AFFECTED( ch, AFF_FLOATING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_EAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_WEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_UP ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_DOWN ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), 0 );
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:         if( ( quiet || IS_SET( pexit->exit_info, EX_ISDOOR ) ) && pexit->keyword && nifty_is_name( arg, pexit->keyword ) )
act_move.c:   if( ( pexit = get_exit( ch->in_room, door ) ) == NULL )
act_move.c:   if( IS_SET( pexit->exit_info, EX_SECRET ) )
act_move.c:   if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:   TOGGLE_BIT( pexit->exit_info, flag );
act_move.c:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c:      TOGGLE_BIT( pexit_rev->exit_info, flag );
act_move.c:   SET_BIT( pexit->exit_info, flag );
act_move.c:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c:      SET_BIT( pexit_rev->exit_info, flag );
act_move.c:   REMOVE_BIT( pexit->exit_info, flag );
act_move.c:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c:      REMOVE_BIT( pexit_rev->exit_info, flag );
act_move.c:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c:      if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c:         act( AT_ACTION, "$n opens the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:         act( AT_ACTION, "You open the $d.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:               act( AT_ACTION, "The $d opens.", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c:            sound_to_room( pexit->to_room, "!!SOUND(door)" );
act_move.c:         if( ( door = pexit->vdir ) >= 0 && door < 10 )
act_move.c:         sound_to_room( ch->in_room, "!!SOUND(door)" );
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:         ch_printf( ch, "%s isn't a container.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:         ch_printf( ch, "%s is already open.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:         ch_printf( ch, "%s is locked.\r\n", capitalize( obj->short_descr ) );
act_move.c:      REMOVE_BIT( obj->value[1], CONT_CLOSED );
act_move.c:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c:      act( AT_ACTION, "$n closes the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:      act( AT_ACTION, "You close the $d.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:         SET_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c:         for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:            act( AT_ACTION, "The $d closes.", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c:      if( ( door = pexit->vdir ) >= 0 && door < 10 )
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:         ch_printf( ch, "%s isn't a container.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:         ch_printf( ch, "%s is already closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      SET_BIT( obj->value[1], CONT_CLOSED );
act_move.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:      if( obj->pIndexData->vnum == key || obj->value[0] == key )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c:      if( pexit->key < 0 )
act_move.c:      if( !has_key( ch, pexit->key ) )
act_move.c:      if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c:         act( AT_ACTION, "$n locks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:      if( obj->value[2] < 0 )
act_move.c:      if( !has_key( ch, obj->value[2] ) )
act_move.c:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:      SET_BIT( obj->value[1], CONT_LOCKED );
act_move.c:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c:      if( pexit->key < 0 )
act_move.c:      if( !has_key( ch, pexit->key ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c:         act( AT_ACTION, "$n unlocks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:      if( obj->value[2] < 0 )
act_move.c:      if( !has_key( ch, obj->value[2] ) )
act_move.c:      if( !IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:      REMOVE_BIT( obj->value[1], CONT_LOCKED );
act_move.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_bashdoor] <= 0 )
act_move.c:   if( ch->fighting )
act_move.c:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c:      WAIT_STATE( ch, skill_table[gsn_bashdoor]->beats );
act_move.c:      if( IS_SET( pexit->exit_info, EX_SECRET ) )
act_move.c:         keyword = pexit->keyword;
act_move.c:         schance = ch->pcdata->learned[gsn_bashdoor] / 2;
act_move.c:      if( !IS_SET( pexit->exit_info, EX_BASHPROOF )
act_move.c:          && ch->move >= 15 && number_percent(  ) < ( schance + 4 * ( get_curr_str( ch ) - 19 ) ) )
act_move.c:         REMOVE_BIT( pexit->exit_info, EX_CLOSED );
act_move.c:         if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c:            REMOVE_BIT( pexit->exit_info, EX_LOCKED );
act_move.c:         SET_BIT( pexit->exit_info, EX_BASHED );
act_move.c:         if( ( to_room = pexit->to_room ) != NULL
act_move.c:             && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            REMOVE_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c:            if( IS_SET( pexit_rev->exit_info, EX_LOCKED ) )
act_move.c:               REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
act_move.c:            SET_BIT( pexit_rev->exit_info, EX_BASHED );
act_move.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:               act( AT_SKILL, "The $d crashes open!", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:      damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         send_to_char( "You are already sitting - on your mount.\r\n", ch );
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:   switch ( ch->position )
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 10 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 5 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && number_percent(  ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:   if( IS_AFFECTED( victim, AFF_SLEEP ) || victim->position < POS_SLEEPING )
act_move.c:   victim->position = POS_STANDING;
act_move.c:   for( nch = ch->in_room->first_person; nch; nch = nch_next )
act_move.c:      nch_next = nch->next_in_room;
act_move.c: * "Climb" in a certain direction.				-Thoric
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:         if( IS_SET( pexit->exit_info, EX_xCLIMB ) )
act_move.c:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xCLIMB ) )
act_move.c: * "enter" something (moves through an exit)			-Thoric
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:         if( IS_SET( pexit->exit_info, EX_xENTER ) )
act_move.c:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xENTER ) )
act_move.c: * Leave through an exit.					-Thoric
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:         if( IS_SET( pexit->exit_info, EX_xLEAVE ) )
act_move.c:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xLEAVE ) )
act_move.c~:*--------------------------------------------------------------------------*
act_move.c~:* -------------------------------------------------------------------------*
act_move.c~:*--------------------------------------------------------------------------*
act_move.c~:* ------------------------------------------------------------------------ *
act_move.c~:* ------------------------------------------------------------------------ *
act_move.c~:   if( ch->plr_home )
act_move.c~:      return ch->plr_home->vnum;
act_move.c~:   if( ch->race == RACE_HUMAN )
act_move.c~:   if( ch->race == RACE_WOOKIEE )
act_move.c~:   if( ch->race == RACE_RODIAN )
act_move.c~:   if( ch->race == RACE_MON_CALAMARI )
act_move.c~:   if( ch->race == RACE_TWI_LEK )
act_move.c~:   if( ch->race == RACE_HUTT )
act_move.c~:   if( ch->race == RACE_GAMORREAN )
act_move.c~:   if( ch->race == RACE_JAWA )
act_move.c~:   if( ch->race == RACE_ADARIAN )
act_move.c~:   if( ch->race == RACE_EWOK )
act_move.c~:   if( ch->race == RACE_VERPINE )
act_move.c~:   if( ch->race == RACE_DEFEL )
act_move.c~:   if( ch->race == RACE_TRANDOSHAN )
act_move.c~:   if( ch->race == RACE_CHADRA_FAN )
act_move.c~:   if( ch->race == RACE_QUARREN )
act_move.c~:   if( ch->race == RACE_DUINUOGWUIN )
act_move.c~:   if( ch->race == RACE_NOGHRI )
act_move.c~:            if( line[ln - 1] == '.' )
act_move.c~:   int sector = room->sector_type;
act_move.c~:   if( room->name )
act_move.c~:      STRFREE( room->name );
act_move.c~:   if( room->description )
act_move.c~:      STRFREE( room->description );
act_move.c~:   room->name = STRALLOC( sect_names[sector][0] );
act_move.c~:      previous[iRand] = -1;
act_move.c~:      while( previous[iRand] == -1 )
act_move.c~:         x = number_range( 0, sent_total[sector] - 1 );
act_move.c~:         if( len > 5 && buf[len - 1] == '.' )
act_move.c~:   room->description = STRALLOC( buf2 );
act_move.c~: * Remove any unused virtual rooms				-Thoric
act_move.c~:      while( vroom_hash[hash] && !vroom_hash[hash]->first_person && !vroom_hash[hash]->first_content )
act_move.c~:         vroom_hash[hash] = room->next;
act_move.c~:         --top_vroom;
act_move.c~:         room_next = room->next;
act_move.c~:         if( !room->first_person && !room->first_content )
act_move.c~:               prev->next = room_next;
act_move.c~:            --top_vroom;
act_move.c~: * Function to get the equivelant exit of DIR 0-MAXDIR out of linked list.
act_move.c~: * Made to allow old-style diku-merc exit functions to work.	-Thoric
act_move.c~:   for( xit = room->first_exit; xit; xit = xit->next )
act_move.c~:      if( xit->vdir == dir )
act_move.c~:   for( xit = room->first_exit; xit; xit = xit->next )
act_move.c~:      if( xit->vdir == dir && xit->vnum == vnum )
act_move.c~: * Function to get the nth exit of a room			-Thoric
act_move.c~:   for( cnt = 0, xit = room->first_exit; xit; xit = xit->next )
act_move.c~: * Modify movement due to encumbrance				-Thoric
act_move.c~:  cur = ch->carry_weight;
act_move.c~: * Check to see if a character can fall down, checks for looping   -Thoric
act_move.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c~:       && ( !IS_AFFECTED( ch, AFF_FLYING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c~:         bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c~:      move_char( ch, get_exit( ch->in_room, DIR_DOWN ), ++fall );
act_move.c~: * create a 'virtual' room					-Thoric
act_move.c~:   int distance = -1;
act_move.c~:   int vdir = orig_exit->vdir;
act_move.c~:   if( in_room->vnum > 32767 && in_room->vnum < 65534)   
act_move.c~:      serial = in_room->vnum;
act_move.c~:      roomnum = in_room->tele_vnum;
act_move.c~:      if( ( serial & 65535 ) == orig_exit->vnum )
act_move.c~:         --roomnum;
act_move.c~:         distance = orig_exit->distance - 1;
act_move.c~:      int r1 = in_room->vnum;
act_move.c~:      int r2 = orig_exit->vnum;
act_move.c~:      distance = orig_exit->distance - 1;
act_move.c~:   for( room = vroom_hash[hash]; room; room = room->next )
act_move.c~:      if( room->vnum == serial && room->tele_vnum == roomnum )
act_move.c~:      room->area = in_room->area;
act_move.c~:      room->vnum = serial;
act_move.c~:      room->tele_vnum = roomnum;
act_move.c~:      room->sector_type = in_room->sector_type;
act_move.c~:      room->room_flags = in_room->room_flags;
act_move.c~:      room->next = vroom_hash[hash];
act_move.c~:      xit = make_exit( room, orig_exit->to_room, vdir );
act_move.c~:      xit->keyword = STRALLOC( "" );
act_move.c~:      xit->description = STRALLOC( "" );
act_move.c~:      xit->key = -1;
act_move.c~:      xit->distance = distance;
act_move.c~:      bxit->keyword = STRALLOC( "" );
act_move.c~:      bxit->description = STRALLOC( "" );
act_move.c~:      bxit->key = -1;
act_move.c~:      if( ( serial & 65535 ) != orig_exit->vnum )
act_move.c~:         bxit->distance = roomnum;
act_move.c~:         int fulldist = tmp->distance;
act_move.c~:         bxit->distance = fulldist - distance;
act_move.c~:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
act_move.c~:      pexit = get_exit( ch->in_room, door );
act_move.c~:      bug( "%s: %s to door %d", __FUNCTION__, ch->name, pexit->vdir );
act_move.c~:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOUNTED ) )
act_move.c~:   in_room = ch->in_room;
act_move.c~:   if( !pexit || ( to_room = pexit->to_room ) == NULL )
act_move.c~:   door = pexit->vdir;
act_move.c~:   distance = pexit->distance;
act_move.c~:    * unless it's a door with a window in it      -Thoric
act_move.c~:   if( IS_SET( pexit->exit_info, EX_WINDOW ) && !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:   if( IS_SET( pexit->exit_info, EX_PORTAL ) && IS_NPC( ch ) )
act_move.c~:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) )
act_move.c~:   if( IS_SET( to_room->room_flags, ROOM_NO_MOB ) && IS_NPC( ch ) )
act_move.c~:   if( IS_SET( pexit->exit_info, EX_CLOSED )
act_move.c~:       && ( !IS_AFFECTED( ch, AFF_PASS_DOOR ) || IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_SECRET ) && !IS_SET( pexit->exit_info, EX_DIG ) )
act_move.c~:            act( AT_PLAIN, "$n runs into the $d in $s drunken state.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c~:            act( AT_PLAIN, "You run into the $d in your drunken state.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c~:            act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c~:    * Crazy virtual room idea, created upon demand.     -Thoric
act_move.c~:   if( !fall && IS_AFFECTED( ch, AFF_CHARM ) && ch->master && in_room == ch->master->in_room )
act_move.c~:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c~:      if( ch->top_level < to_room->area->low_hard_range )
act_move.c~:         switch ( to_room->area->low_hard_range - ch->top_level )
act_move.c~:      else if( ch->top_level > to_room->area->hi_hard_range )
act_move.c~:      if( in_room->sector_type == SECT_AIR || to_room->sector_type == SECT_AIR || IS_SET( pexit->exit_info, EX_FLY ) )
act_move.c~:         if( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c~:         if( !ch->mount && !IS_AFFECTED( ch, AFF_FLYING ) )
act_move.c~:      if( in_room->sector_type == SECT_WATER_NOSWIM || to_room->sector_type == SECT_WATER_NOSWIM )
act_move.c~:         if( ch->mount )
act_move.c~:            if( IS_AFFECTED( ch->mount, AFF_FLYING ) || IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c~:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c~:               if( obj->item_type == ITEM_BOAT )
act_move.c~:      if( IS_SET( pexit->exit_info, EX_CLIMB ) )
act_move.c~:         if( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c~:         if( !found && !ch->mount )
act_move.c~:            if( ( !IS_NPC( ch ) && number_percent(  ) > ch->pcdata->learned[gsn_climb] ) || drunk || ch->mental_state < -90 )
act_move.c~:               if( pexit->vdir == DIR_DOWN )
act_move.c~:               retcode = damage( ch, ch, ( pexit->vdir == DIR_UP ? 10 : 5 ), TYPE_UNDEFINED );
act_move.c~:            WAIT_STATE( ch, skill_table[gsn_climb]->beats );
act_move.c~:      if( ch->mount )
act_move.c~:         switch ( ch->mount->position )
act_move.c~:         if( !IS_AFFECTED( ch->mount, AFF_FLYING ) && !IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c~:            move = movement_loss[UMIN( SECT_MAX - 1, in_room->sector_type )];
act_move.c~:         if( ch->mount->move < move )
act_move.c~:            move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, in_room->sector_type )] );
act_move.c~:         if( ch->move < move )
act_move.c~:      if( ch->mount )
act_move.c~:         ch->mount->move -= move;
act_move.c~:         ch->move -= move;
act_move.c~:   if( to_room->tunnel > 0 )
act_move.c~:      int count = ch->mount ? 1 : 0;
act_move.c~:      for( ctmp = to_room->first_person; ctmp; ctmp = ctmp->next_in_room )
act_move.c~:         if( ++count >= to_room->tunnel )
act_move.c~:            if( ch->mount && count == to_room->tunnel )
act_move.c~:    * check for traps on exit - later 
act_move.c~:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c~:         if( ch->mount )
act_move.c~:            if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c~:            else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c~:            else if( ch->position == POS_SHOVE )
act_move.c~:            else if( ch->position == POS_DRAG )
act_move.c~:      if( ch->mount )
act_move.c~:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c~:   if( ch->mount )
act_move.c~:      rprog_leave_trigger( ch->mount );
act_move.c~:       * Mount bug fix test. -Orion
act_move.c~:      if( char_died( ch->mount ) )
act_move.c~:      if( ch->mount )
act_move.c~:         char_from_room( ch->mount );
act_move.c~:         char_to_room( ch->mount, to_room );
act_move.c~:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c~:      else if( ch->mount )
act_move.c~:         if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c~:         else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c~:         else if( ch->position == POS_SHOVE )
act_move.c~:         else if( ch->position == POS_DRAG )
act_move.c~:            dtxt = "the south-west";
act_move.c~:            dtxt = "the south-east";
act_move.c~:            dtxt = "the north-west";
act_move.c~:            dtxt = "the north-east";
act_move.c~:      if( ch->mount )
act_move.c~:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c~:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c~:      if( ch->top_level < to_room->area->low_soft_range )
act_move.c~:      else if( ch->top_level > to_room->area->hi_soft_range )
act_move.c~:      SET_BIT( ch->act, PLR_BRIEF );
act_move.c~:    * the right number of them.  -- Narn
act_move.c~:      for( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c~:      for( fch = from_room->first_person; fch && ( count < chars ); fch = nextinroom )
act_move.c~:         nextinroom = fch->next_in_room;
act_move.c~:             && fch->master == ch && fch->position == POS_STANDING )
act_move.c~:   if( ch->in_room->first_content )
act_move.c~:      if( !IS_AFFECTED( ch, AFF_FLOATING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_NORTH ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_EAST ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_WEST ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_UP ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_DOWN ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), 0 );
act_move.c~:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), 0 );
act_move.c~:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c~:         if( ( quiet || IS_SET( pexit->exit_info, EX_ISDOOR ) ) && pexit->keyword && nifty_is_name( arg, pexit->keyword ) )
act_move.c~:   if( ( pexit = get_exit( ch->in_room, door ) ) == NULL )
act_move.c~:   if( IS_SET( pexit->exit_info, EX_SECRET ) )
act_move.c~:   if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:   TOGGLE_BIT( pexit->exit_info, flag );
act_move.c~:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c~:      TOGGLE_BIT( pexit_rev->exit_info, flag );
act_move.c~:   SET_BIT( pexit->exit_info, flag );
act_move.c~:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c~:      SET_BIT( pexit_rev->exit_info, flag );
act_move.c~:   REMOVE_BIT( pexit->exit_info, flag );
act_move.c~:   if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev != pexit )
act_move.c~:      REMOVE_BIT( pexit_rev->exit_info, flag );
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c~:      if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c~:         act( AT_ACTION, "$n opens the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c~:         act( AT_ACTION, "You open the $d.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c~:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c~:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c~:               act( AT_ACTION, "The $d opens.", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c~:            sound_to_room( pexit->to_room, "!!SOUND(door)" );
act_move.c~:         if( ( door = pexit->vdir ) >= 0 && door < 10 )
act_move.c~:         sound_to_room( ch->in_room, "!!SOUND(door)" );
act_move.c~:      if( obj->item_type != ITEM_CONTAINER )
act_move.c~:         ch_printf( ch, "%s isn't a container.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c~:         ch_printf( ch, "%s is already open.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c~:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c~:         ch_printf( ch, "%s is locked.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      REMOVE_BIT( obj->value[1], CONT_CLOSED );
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c~:      act( AT_ACTION, "$n closes the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c~:      act( AT_ACTION, "You close the $d.", ch, NULL, pexit->keyword, TO_CHAR );
act_move.c~:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c~:         SET_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c~:         for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c~:            act( AT_ACTION, "The $d closes.", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c~:      if( ( door = pexit->vdir ) >= 0 && door < 10 )
act_move.c~:      if( obj->item_type != ITEM_CONTAINER )
act_move.c~:         ch_printf( ch, "%s isn't a container.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c~:         ch_printf( ch, "%s is already closed.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c~:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c~:      SET_BIT( obj->value[1], CONT_CLOSED );
act_move.c~:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c~:      if( obj->pIndexData->vnum == key || obj->value[0] == key )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c~:      if( pexit->key < 0 )
act_move.c~:      if( !has_key( ch, pexit->key ) )
act_move.c~:      if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c~:         act( AT_ACTION, "$n locks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c~:      if( obj->item_type != ITEM_CONTAINER )
act_move.c~:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c~:      if( obj->value[2] < 0 )
act_move.c~:      if( !has_key( ch, obj->value[2] ) )
act_move.c~:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c~:      SET_BIT( obj->value[1], CONT_LOCKED );
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c~:      if( pexit->key < 0 )
act_move.c~:      if( !has_key( ch, pexit->key ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_SECRET ) || ( pexit->keyword && nifty_is_name( arg, pexit->keyword ) ) )
act_move.c~:         act( AT_ACTION, "$n unlocks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
act_move.c~:      if( obj->item_type != ITEM_CONTAINER )
act_move.c~:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c~:      if( obj->value[2] < 0 )
act_move.c~:      if( !has_key( ch, obj->value[2] ) )
act_move.c~:      if( !IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c~:      REMOVE_BIT( obj->value[1], CONT_LOCKED );
act_move.c~:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_bashdoor] <= 0 )
act_move.c~:   if( ch->fighting )
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
act_move.c~:      WAIT_STATE( ch, skill_table[gsn_bashdoor]->beats );
act_move.c~:      if( IS_SET( pexit->exit_info, EX_SECRET ) )
act_move.c~:         keyword = pexit->keyword;
act_move.c~:         schance = ch->pcdata->learned[gsn_bashdoor] / 2;
act_move.c~:      if( !IS_SET( pexit->exit_info, EX_BASHPROOF )
act_move.c~:          && ch->move >= 15 && number_percent(  ) < ( schance + 4 * ( get_curr_str( ch ) - 19 ) ) )
act_move.c~:         REMOVE_BIT( pexit->exit_info, EX_CLOSED );
act_move.c~:         if( IS_SET( pexit->exit_info, EX_LOCKED ) )
act_move.c~:            REMOVE_BIT( pexit->exit_info, EX_LOCKED );
act_move.c~:         SET_BIT( pexit->exit_info, EX_BASHED );
act_move.c~:         if( ( to_room = pexit->to_room ) != NULL
act_move.c~:             && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c~:            REMOVE_BIT( pexit_rev->exit_info, EX_CLOSED );
act_move.c~:            if( IS_SET( pexit_rev->exit_info, EX_LOCKED ) )
act_move.c~:               REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
act_move.c~:            SET_BIT( pexit_rev->exit_info, EX_BASHED );
act_move.c~:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c~:               act( AT_SKILL, "The $d crashes open!", rch, NULL, pexit_rev->keyword, TO_CHAR );
act_move.c~:         damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c~:         damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c~:      damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c~:   switch ( ch->position )
act_move.c~:         ch->position = POS_STANDING;
act_move.c~:         ch->position = POS_STANDING;
act_move.c~:         ch->position = POS_STANDING;
act_move.c~:   switch ( ch->position )
act_move.c~:         ch->position = POS_SITTING;
act_move.c~:         ch->position = POS_SITTING;
act_move.c~:         ch->position = POS_SITTING;
act_move.c~:         send_to_char( "You are already sitting - on your mount.\r\n", ch );
act_move.c~:   switch ( ch->position )
act_move.c~:         ch->position = POS_RESTING;
act_move.c~:         ch->position = POS_RESTING;
act_move.c~:         ch->position = POS_RESTING;
act_move.c~:   switch ( ch->position )
act_move.c~:         if( ch->mental_state > 30 && ( number_percent(  ) + 10 ) < ch->mental_state )
act_move.c~:         ch->position = POS_SLEEPING;
act_move.c~:         if( ch->mental_state > 30 && ( number_percent(  ) + 5 ) < ch->mental_state )
act_move.c~:         ch->position = POS_SLEEPING;
act_move.c~:         if( ch->mental_state > 30 && number_percent(  ) < ch->mental_state )
act_move.c~:         ch->position = POS_SLEEPING;
act_move.c~:   if( IS_AFFECTED( victim, AFF_SLEEP ) || victim->position < POS_SLEEPING )
act_move.c~:   victim->position = POS_STANDING;
act_move.c~:   for( nch = ch->in_room->first_person; nch; nch = nch_next )
act_move.c~:      nch_next = nch->next_in_room;
act_move.c~: * "Climb" in a certain direction.				-Thoric
act_move.c~:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c~:         if( IS_SET( pexit->exit_info, EX_xCLIMB ) )
act_move.c~:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xCLIMB ) )
act_move.c~: * "enter" something (moves through an exit)			-Thoric
act_move.c~:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c~:         if( IS_SET( pexit->exit_info, EX_xENTER ) )
act_move.c~:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xENTER ) )
act_move.c~: * Leave through an exit.					-Thoric
act_move.c~:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c~:         if( IS_SET( pexit->exit_info, EX_xLEAVE ) )
act_move.c~:   if( ( pexit = find_door( ch, argument, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xLEAVE ) )
act_obj.c:*--------------------------------------------------------------------------*
act_obj.c:* -------------------------------------------------------------------------*
act_obj.c:*--------------------------------------------------------------------------*
act_obj.c:* ------------------------------------------------------------------------ *
act_obj.c:* ------------------------------------------------------------------------ *
act_obj.c: * how resistant an object is to damage				-Thoric
act_obj.c:   resist += ( obj->level / 10 );
act_obj.c:   if( obj->item_type == ITEM_ARMOR || obj->item_type == ITEM_WEAPON )
act_obj.c:      resist += ( obj->value[0] );
act_obj.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) && ( ch->top_level < sysdata.level_getobjnotake ) )
act_obj.c:   if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:      act( AT_PLAIN, "$d: you can't carry that many items.", ch, NULL, obj->name, TO_CHAR );
act_obj.c:      weight = obj->weight;
act_obj.c:   if( obj->item_type != ITEM_MONEY )
act_obj.c:      if( obj->in_obj )
act_obj.c:         OBJ_DATA *tobj = obj->in_obj;
act_obj.c:         if( tobj->item_type == ITEM_CONTAINER && IS_OBJ_STAT( tobj, ITEM_MAGIC ) )
act_obj.c:         while( tobj->in_obj )
act_obj.c:            tobj = tobj->in_obj;
act_obj.c:            if( tobj->item_type == ITEM_CONTAINER && IS_OBJ_STAT( tobj, ITEM_MAGIC ) )
act_obj.c:         if( !tobj->carried_by || tobj->carried_by != ch || checkweight )
act_obj.c:            if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:               act( AT_PLAIN, "$d: you can't carry that much weight.", ch, NULL, obj->name, TO_CHAR );
act_obj.c:      else if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:         act( AT_PLAIN, "$d: you can't carry that much weight.", ch, NULL, obj->name, TO_CHAR );
act_obj.c:   if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && ( !container || container->carried_by == NULL ) )
act_obj.c:      for( clan = first_clan; clan; clan = clan->next )
act_obj.c:         if( clan->storeroom == ch->in_room->vnum )
act_obj.c:   if( obj->item_type != ITEM_CONTAINER )
act_obj.c:   if( obj->item_type == ITEM_MONEY )
act_obj.c:      ch->gold += obj->value[0] * obj->count;
act_obj.c:      if( ( ch->carry_number + number ) > can_carry_n( ch ) )
act_obj.c:         obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:         if( IS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:         for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:            obj_next = obj->next_content;
act_obj.c:            if( ( fAll || nifty_is_name( chk, obj->name ) ) && can_see_obj( ch, obj ) )
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:                  split_obj( obj, number - cnt );
act_obj.c:               cnt += obj->count;
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:      switch ( container->item_type )
act_obj.c:            if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:      if( !IS_OBJ_STAT( container, ITEM_COVERING ) && IS_SET( container->value[1], CONT_CLOSED ) )
act_obj.c:         act( AT_PLAIN, "The $d is closed.", ch, NULL, container->name, TO_CHAR );
act_obj.c:         obj = get_obj_list( ch, arg1, container->first_content );
act_obj.c:               "I see nothing like that beneath the $T." : "I see nothing like that in the $T.", ch, NULL, container->short_descr, TO_CHAR );
act_obj.c:         for( obj = container->first_content; obj; obj = obj_next )
act_obj.c:            obj_next = obj->next_content;
act_obj.c:            if( ( fAll || nifty_is_name( chk, obj->name ) ) && can_see_obj( ch, obj ) )
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:                  split_obj( obj, number - cnt );
act_obj.c:               cnt += obj->count;
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:                  if( container->item_type == ITEM_CORPSE_PC )
act_obj.c:                     write_corpses( NULL, container->short_descr + 14 );
act_obj.c:                    "I see nothing beneath the $T." : "I see nothing in the $T.", ch, NULL, container->short_descr, TO_CHAR );
act_obj.c:                    "I see nothing like that in the $T.", ch, NULL, container->short_descr, TO_CHAR );
act_obj.c:   if( !container->carried_by && IS_SET( sysdata.save_flags, SV_PUT ) )
act_obj.c:      if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:      if( container->item_type != ITEM_CONTAINER )
act_obj.c:      if( IS_SET( container->value[1], CONT_CLOSED ) )
act_obj.c:         act( AT_PLAIN, "The $d is closed.", ch, NULL, container->name, TO_CHAR );
act_obj.c:            && ( get_obj_weight( obj ) / obj->count )
act_obj.c:            > ( ( get_obj_weight( container ) / container->count ) - container->weight ) ) )
act_obj.c:      if( ( get_obj_weight( obj ) / obj->count ) + ( get_obj_weight( container ) / container->count ) > container->value[0] )
act_obj.c:      count = obj->count;
act_obj.c:      obj->count = 1;
act_obj.c:      obj->count = count;
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:         for( clan = first_clan; clan; clan = clan->next )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( ( fAll || nifty_is_name( chk, obj->name ) )
act_obj.c:             && obj->wear_loc == WEAR_NONE
act_obj.c:             && can_drop_obj( ch, obj ) && get_obj_weight( obj ) + get_obj_weight( container ) <= container->value[0] )
act_obj.c:            if( number && ( cnt + obj->count ) > number )
act_obj.c:               split_obj( obj, number - cnt );
act_obj.c:            cnt += obj->count;
act_obj.c:       * Don't bother to save anything if nothing was dropped   -Thoric
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:         for( clan = first_clan; clan; clan = clan->next )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NODROP ) || ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_LITTERBUG ) ) )
act_obj.c:         if( ch->gold < number )
act_obj.c:         ch->gold -= number;
act_obj.c:         for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:            obj_next = obj->next_content;
act_obj.c:            switch ( obj->pIndexData->vnum )
act_obj.c:                  number += obj->value[0];
act_obj.c:         obj_to_room( create_money( number ), ch->in_room );
act_obj.c:      obj = obj_to_room( obj, ch->in_room );
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         for( clan = first_clan; clan; clan = clan->next )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( ( fAll || nifty_is_name( chk, obj->name ) )
act_obj.c:             && can_see_obj( ch, obj ) && obj->wear_loc == WEAR_NONE && can_drop_obj( ch, obj ) )
act_obj.c:            if( obj->pIndexData->progtypes & DROP_PROG && obj->count > 1 )
act_obj.c:                  obj_next = ch->first_carrying;
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:                  split_obj( obj, number - cnt );
act_obj.c:               cnt += obj->count;
act_obj.c:            obj = obj_to_room( obj, ch->in_room );
act_obj.c:      if( IS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         for( clan = first_clan; clan; clan = clan->next )
act_obj.c:            if( clan->storeroom == ch->in_room->vnum )
act_obj.c:      if( ch->gold < amount )
act_obj.c:      ch->gold -= amount;
act_obj.c:      victim->gold += amount;
act_obj.c:   if( obj->wear_loc != WEAR_NONE )
act_obj.c:   if( victim->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( victim ) )
act_obj.c:   if( victim->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( victim ) )
act_obj.c: * Damage an object.						-Thoric
act_obj.c:   ch = obj->carried_by;
act_obj.c:   else if( obj->in_room && ( ch = obj->in_room->first_person ) != NULL )
act_obj.c:   switch ( obj->item_type )
act_obj.c:         if( --obj->value[3] <= 0 )
act_obj.c:         if( ch && obj->value[0] >= 1 )
act_obj.c:            ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:         if( --obj->value[0] <= 0 )
act_obj.c:         else if( ch && obj->value[0] >= 1 )
act_obj.c:            ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:         if( --obj->value[0] <= 0 )
act_obj.c:      save_char_obj( ch ); /* Stop scrap duping - Samson 1-2-00 */
act_obj.c:   if( !fReplace && ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:      act( AT_PLAIN, "$d: you can't carry that many items.", ch, NULL, obj->name, TO_CHAR );
act_obj.c:      tmpobj->wear_loc = WEAR_WIELD;
act_obj.c: * See if char could be capable of dual-wielding		-Thoric
act_obj.c:   if( IS_NPC( ch ) || ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:   short objlayers = obj->pIndexData->layers;
act_obj.c:   for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:      if( otmp->wear_loc == wear_loc )
act_obj.c:         if( !otmp->pIndexData->layers )
act_obj.c:            bitlayers |= otmp->pIndexData->layers;
act_obj.c: * Restructured a bit to allow for specifying body location	-Thoric
act_obj.c:   if( wear_bit > -1 )
act_obj.c:      for( bit = -1, tmp = 1; tmp < 31; tmp++ )
act_obj.c:   if( 1 << bit == ITEM_WIELD || 1 << bit == ITEM_HOLD || obj->item_type == ITEM_LIGHT || 1 << bit == ITEM_WEAR_SHIELD )
act_obj.c:   else if( ch->race == RACE_DEFEL || ch->race == RACE_DUINUOGWUIN )
act_obj.c:      switch ( ch->race )
act_obj.c:      if( ch->race == RACE_DUINUOGWUIN )
act_obj.c:      if( ch->race == RACE_DEFEL )
act_obj.c:    * currently cannot have a light in non-light position 
act_obj.c:   if( obj->item_type == ITEM_LIGHT )
act_obj.c:         if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:   if( bit == -1 )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:         if( ch->race == RACE_VERPINE || ch->race == RACE_TWI_LEK )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:         if( ch->race == RACE_VERPINE )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:         if( ch->race == RACE_HUTT )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:         if( ch->race == RACE_HUTT )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:               if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:            if( !obj->action_desc || obj->action_desc[0] == '\0' )
act_obj.c:                  act( AT_ACTION, "$n dual-wields $p.", ch, obj, NULL, TO_ROOM );
act_obj.c:                  act( AT_ACTION, "You dual-wield $p.", ch, obj, NULL, TO_CHAR );
act_obj.c:         if( obj->item_type == ITEM_DEVICE
act_obj.c:             || obj->item_type == ITEM_GRENADE
act_obj.c:             || obj->item_type == ITEM_FOOD
act_obj.c:             || obj->item_type == ITEM_PILL
act_obj.c:             || obj->item_type == ITEM_POTION
act_obj.c:             || obj->item_type == ITEM_DRINK_CON
act_obj.c:             || obj->item_type == ITEM_PIPE
act_obj.c:             || obj->item_type == ITEM_HERB
act_obj.c:             || obj->item_type == ITEM_SALVE
act_obj.c:             || obj->item_type == ITEM_KEY || !oprog_use_trigger( ch, obj, NULL, NULL, NULL ) )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
act_obj.c:            wear_obj( ch, obj, FALSE, -1 );
act_obj.c:         wear_bit = -1;
act_obj.c:      for( obj = ch->first_carrying; obj != NULL; obj = obj_next )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) )
act_obj.c:            remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:   if( ( obj_next = get_eq_char( ch, obj->wear_loc ) ) != obj )
act_obj.c:   remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:      if( obj->item_type == ITEM_SHOVEL )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   switch ( ch->in_room->sector_type )
act_obj.c:   if( obj->weight > ( UMAX( 5, ( can_carry_w( ch ) / 10 ) ) ) && !shovel )
act_obj.c:   move = ( obj->weight * 50 * ( shovel ? 1 : 5 ) ) / UMAX( 1, can_carry_w( ch ) );
act_obj.c:   if( move > ch->move )
act_obj.c:   ch->move -= move;
act_obj.c:   SET_BIT( obj->extra_flags, ITEM_BURRIED );
act_obj.c:   if( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   if( cur_obj == obj->serial )
act_obj.c:   if( staff->item_type != ITEM_STAFF )
act_obj.c:   if( ( sn = staff->value[3] ) < 0 || sn >= top_sn || skill_table[sn]->spell_fun == NULL )
act_obj.c:   if( staff->value[2] > 0 )
act_obj.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:         vch_next = vch->next_in_room;
act_obj.c:         if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:            switch ( skill_table[sn]->target )
act_obj.c:         retcode = obj_cast_spell( staff->value[3], staff->value[0], ch, vch, NULL );
act_obj.c:   if( --staff->value[2] <= 0 )
act_obj.c:      if( staff->serial == cur_obj )
act_obj.c:   if( arg[0] == '\0' && !ch->fighting )
act_obj.c:   if( wand->item_type != ITEM_WAND )
act_obj.c:      if( ch->fighting )
act_obj.c:   if( wand->value[2] > 0 )
act_obj.c:      retcode = obj_cast_spell( wand->value[3], wand->value[0], ch, victim, obj );
act_obj.c:   if( --wand->value[2] <= 0 )
act_obj.c:      if( wand->serial == cur_obj )
act_obj.c: * Save items in a clan storage room			-Scryn & Thoric
act_obj.c:   sprintf( filename, "%s%s.vault", CLAN_DIR, clan->filename );
act_obj.c:      templvl = ch->top_level;
act_obj.c:      ch->top_level = LEVEL_HERO;   /* make sure EQ doesn't get lost */
act_obj.c:      contents = ch->in_room->last_content;
act_obj.c:      ch->top_level = templvl;
act_obj.c:   if( !IS_SET( ch->in_room->room_flags, ROOM_AUCTION ) )
act_obj.c:   if( ( time_info.hour > 18 || time_info.hour < 9 ) && auction->item == NULL )
act_obj.c:      if( auction->item != NULL )
act_obj.c:         obj = auction->item;
act_obj.c:         if( auction->bet > 0 )
act_obj.c:            sprintf( buf, "Current bid on this item is %d credits.\r\n", auction->bet );
act_obj.c:/*          spell_identify (0, LEVEL_HERO - 1, ch, auction->item); */
act_obj.c:                  obj->name,
act_obj.c:                  extra_bit_name( obj->extra_flags ), magic_bit_name( obj->magic_flags ), obj->weight, obj->cost );
act_obj.c:         sprintf( buf, "Worn on: %s\r\n", flag_string( obj->wear_flags - 1, w_flags ) );
act_obj.c:         switch ( obj->item_type )
act_obj.c:               ch_printf( ch, "Current armor class is %d. ( based on current condition )\r\n", obj->value[0] );
act_obj.c:               ch_printf( ch, "Maximum armor class is %d. ( based on top condition )\r\n", obj->value[1] );
act_obj.c:         for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
act_obj.c:         for( paf = obj->first_affect; paf; paf = paf->next )
act_obj.c:         if( ( obj->item_type == ITEM_CONTAINER ) && ( obj->first_content ) )
act_obj.c:            show_list_to_char( obj->first_content, ch, TRUE, FALSE );
act_obj.c:                     auction->seller->name, auction->buyer->name, ( auction->going + 1 ) );
act_obj.c:            sprintf( buf, "Time left in round: %d.\r\n", auction->pulse );
act_obj.c:      if( auction->item == NULL )
act_obj.c:         sprintf( buf, "Sale of %s has been stopped by an Immortal.", auction->item->short_descr );
act_obj.c:         obj_to_char( auction->item, auction->seller );
act_obj.c:            save_char_obj( auction->seller );
act_obj.c:         auction->item = NULL;
act_obj.c:         if( auction->buyer != NULL && auction->buyer != auction->seller ) /* return money to the buyer */
act_obj.c:            auction->buyer->gold += auction->bet;
act_obj.c:            send_to_char( "Your money has been returned.\r\n", auction->buyer );
act_obj.c:      if( auction->item != NULL )
act_obj.c:         if( ch == auction->seller )
act_obj.c:          * make - perhaps - a bet now 
act_obj.c:         newbet = parsebet( auction->bet, argument );
act_obj.c:         if( newbet < auction->starting )
act_obj.c:          * is higher up - changed to 10000 for our high economy
act_obj.c:         if( newbet < ( auction->bet + 10000 ) )
act_obj.c:         if( newbet > ch->gold )
act_obj.c:         if( auction->buyer != NULL && auction->buyer != auction->seller )
act_obj.c:            auction->buyer->gold += auction->bet;
act_obj.c:         ch->gold -= newbet;  /* substract the gold - important :) */
act_obj.c:         auction->buyer = ch;
act_obj.c:         auction->bet = newbet;
act_obj.c:         auction->going = 0;
act_obj.c:         auction->pulse = PULSE_AUCTION;  /* start the auction over again */
act_obj.c:         sprintf( buf, "A bid of %d credits has been received on %s.\r\n", newbet, auction->item->short_descr );
act_obj.c:   if( obj->timer > 0 )
act_obj.c:      auction->starting = 0;
act_obj.c:   if( auction->item == NULL )
act_obj.c:      switch ( obj->item_type )
act_obj.c:            auction->item = obj;
act_obj.c:            auction->bet = 0;
act_obj.c:            auction->buyer = ch;
act_obj.c:            auction->seller = ch;
act_obj.c:            auction->pulse = PULSE_AUCTION;
act_obj.c:            auction->going = 0;
act_obj.c:            auction->starting = atoi( arg2 );
act_obj.c:            if( auction->starting > 0 )
act_obj.c:               auction->bet = auction->starting;
act_obj.c:            sprintf( buf, "A new item is being auctioned: %s at %d credits.", obj->short_descr, auction->starting );
act_obj.c:      act( AT_TELL, "Try again later - $p is being auctioned right now!", ch, auction->item, NULL, TO_CHAR );
act_obj.c:/* Make objects in rooms that are nofloor fall - Scryn 1/23/96 */
act_obj.c:   static bool is_falling; /* Stop loops from the call to obj_to_room()  -- Altrag */
act_obj.c:   if( !obj->in_room || is_falling )
act_obj.c:   if( IS_SET( obj->in_room->room_flags, ROOM_NOFLOOR ) && CAN_GO( obj, DIR_DOWN ) && !IS_OBJ_STAT( obj, ITEM_MAGIC ) )
act_obj.c:      pexit = get_exit( obj->in_room, DIR_DOWN );
act_obj.c:      to_room = pexit->to_room;
act_obj.c:      if( obj->in_room == to_room )
act_obj.c:         sprintf( buf, "Object falling into same room, room %d", to_room->vnum );
act_obj.c:      if( obj->in_room->first_person )
act_obj.c:         act( AT_PLAIN, "$p falls far below...", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:         act( AT_PLAIN, "$p falls far below...", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:      if( obj->in_room->first_person )
act_obj.c:         act( AT_PLAIN, "$p falls from above...", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:         act( AT_PLAIN, "$p falls from above...", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:      if( !IS_SET( obj->in_room->room_flags, ROOM_NOFLOOR ) && through )
act_obj.c:/*		int dam = (int)9.81*sqrt(fall_count*2/9.81)*obj->weight/2;
act_obj.c:*/ int dam = fall_count * obj->weight / 2;
act_obj.c:         if( obj->in_room->first_person && number_percent(  ) > 15 )
act_obj.c:            for( rch = obj->in_room->first_person; rch; rch = rch->next_in_room, chcnt++ )
act_obj.c:            damage( vch, vch, dam * vch->top_level, TYPE_UNDEFINED );
act_obj.c:         switch ( obj->item_type )
act_obj.c:               if( ( obj->value[0] - dam ) <= 0 )
act_obj.c:                  if( obj->in_room->first_person )
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:                  obj->value[0] -= dam;
act_obj.c:                  if( obj->in_room->first_person )
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_wiz.c:*--------------------------------------------------------------------------*
act_wiz.c:* -------------------------------------------------------------------------*
act_wiz.c:*--------------------------------------------------------------------------*
act_wiz.c:* ------------------------------------------------------------------------ *
act_wiz.c:* ------------------------------------------------------------------------ *
act_wiz.c:  return -1;
act_wiz.c:      for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
act_wiz.c:         if( cmd->level >= LEVEL_HERO && cmd->level <= get_trust( ch ) )
act_wiz.c:            pager_printf( ch, "%-12s", cmd->name );
act_wiz.c:   for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
act_wiz.c:      if( !str_prefix( arg, cmd->name ) && cmd->level <= get_trust( ch ) )
act_wiz.c:         sprintf( buf, "%s show", cmd->name );
act_wiz.c:/*    		ch_printf( ch, "%s is at level %d.\r\n", cmd->name, cmd->level );*/
act_wiz.c:      cmd->level = level;
act_wiz.c:      ch_printf( ch, "You restrict %s to level %d\r\n", cmd->name, level );
act_wiz.c:      sprintf( buf, "%s restricting %s to level %d", ch->name, cmd->name, level );
act_wiz.c:   for( d = first_descriptor; d; d = d->next )
act_wiz.c:      if( d->character && ( !str_prefix( name, d->character->name ) ) && IS_WAITING_FOR_AUTH( d->character ) )
act_wiz.c:         ret_char = d->character;   /* return current char on exit */
act_wiz.c:      send_to_char( "---------------------------------------------\r\n", ch );
act_wiz.c:      for( d = first_descriptor; d; d = d->next )
act_wiz.c:         if( ( victim = d->character ) != NULL && IS_WAITING_FOR_AUTH( victim ) )
act_wiz.c:            ch_printf( ch, " %s@%s new %s...\r\n", victim->name, victim->desc->host, race_table[victim->race].race_name );
act_wiz.c:      victim->pcdata->auth_state = 3;
act_wiz.c:      REMOVE_BIT( victim->pcdata->flags, PCFLAG_UNAUTHED );
act_wiz.c:      if( victim->pcdata->authed_by )
act_wiz.c:         STRFREE( victim->pcdata->authed_by );
act_wiz.c:      victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:      sprintf( buf, "%s authorized %s", ch->name, victim->name );
act_wiz.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:      ch_printf( ch, "You have authorized %s.\r\n", victim->name );
act_wiz.c:       * Below sends a message to player when name is accepted - Brittany   
act_wiz.c:                 "You are now fully authorized to play Star Wars Reality.\r\n", victim->name ); /* B */
act_wiz.c:      sprintf( buf, "%s denied authorization to %s", ch->name, victim->name );
act_wiz.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:      ch_printf( ch, "You have denied %s.\r\n", victim->name );
act_wiz.c:      sprintf( buf, "%s has denied %s's name", ch->name, victim->name );
act_wiz.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
act_wiz.c:                 "to be unacceptable.\r\n" "Use 'name' to change it to something more apropriate.\r\n", victim->name );
act_wiz.c:      ch_printf( ch, "You requested %s change names.\r\n", victim->name );
act_wiz.c:      victim->pcdata->auth_state = 2;
act_wiz.c:      DISPOSE( ch->pcdata->bamfin );
act_wiz.c:      ch->pcdata->bamfin = str_dup( argument );
act_wiz.c:      DISPOSE( ch->pcdata->bamfout );
act_wiz.c:      ch->pcdata->bamfout = str_dup( argument );
act_wiz.c:   DISPOSE( ch->pcdata->rank );
act_wiz.c:      ch->pcdata->rank = str_dup( "" );
act_wiz.c:      ch->pcdata->rank = str_dup( argument );
act_wiz.c:   if( victim->top_level < LEVEL_SAVIOR )
act_wiz.c:      REMOVE_BIT( victim->pcdata->flags, PCFLAG_RETIRED );
act_wiz.c:      ch_printf( ch, "%s returns from retirement.\r\n", victim->name );
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\r\n", ch->name );
act_wiz.c:      SET_BIT( victim->pcdata->flags, PCFLAG_RETIRED );
act_wiz.c:      ch_printf( ch, "%s is now a retired immortal.\r\n", victim->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\r\n", ch->name );
act_wiz.c:   SET_BIT( victim->act, PLR_DENY );
act_wiz.c:   if( victim->desc == NULL )
act_wiz.c:   for( d = first_descriptor; d; d = d->next )
act_wiz.c:      if( d == victim->desc )
act_wiz.c:   if( victim->top_level != 1 )
act_wiz.c:   for( d = first_descriptor; d; d = d->next )
act_wiz.c:      if( d->descriptor == desc )
act_wiz.c:         if( d->character && get_trust( d->character ) >= get_trust( ch ) )
act_wiz.c:   for( d = first_descriptor; d; d = d->next )
act_wiz.c:       * miss out on important info like upcoming reboots. --Narn 
act_wiz.c:      if( d->connected == CON_PLAYING || d->connected == CON_EDITING )
act_wiz.c:         if( tar == ECHOTAR_PC && IS_NPC( d->character ) )
act_wiz.c:         else if( tar == ECHOTAR_IMM && !IS_IMMORTAL( d->character ) )
act_wiz.c:         set_char_color( AT_COLOR, d->character );
act_wiz.c:         send_to_char( argument, d->character );
act_wiz.c:         send_to_char( "\r\n", d->character );
act_wiz.c:   if( IS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:   for( vic = room->first_person; vic; vic = vic->next_in_room )
act_wiz.c:   if( IS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:      echo_to_room( color, ch->in_room, argument );
act_wiz.c:      echo_to_room( AT_IMMORT, ch->in_room, argument );
act_wiz.c:      return victim->in_room;
act_wiz.c:      return obj->in_room;
act_wiz.c:   if( !victim->in_room )
act_wiz.c:      bug( "%s: victim in NULL room: %s", __FUNCTION__, victim->name );
act_wiz.c:      progbug( "Mptransfer - Private room", ch );
act_wiz.c:   if( IS_NPC(ch) && NOT_AUTHED( victim ) && location->area != victim->in_room->area )
act_wiz.c:      snprintf( buf, MAX_STRING_LENGTH, "Mptransfer - unauthed char (%s)", victim->name );
act_wiz.c:   if( IS_NPC(ch) && !in_hard_range( victim, location->area ) && !IS_SET( location->room_flags, ROOM_PROTOTYPE ) )
act_wiz.c:   if( victim->fighting )
act_wiz.c:      victim->retran = victim->in_room->vnum;
act_wiz.c:      if( !IS_IMMORTAL( victim ) && !IS_NPC( victim ) && !in_hard_range( victim, location->area ) )
act_wiz.c:      location = ch->in_room;
act_wiz.c:      for( d = first_descriptor; d; d = d->next )
act_wiz.c:         if( d->connected == CON_PLAYING && d->character && d->character != ch && d->character->in_room )
act_wiz.c:            transfer_char( ch, d->character, location );
act_wiz.c:   sprintf( buf, "'%s' %d", victim->name, victim->retran );
act_wiz.c:   sprintf( buf, "%d", ch->regoto );
act_wiz.c:   original = ch->in_room;
act_wiz.c:   for( wch = first_char; wch; wch = wch->next )
act_wiz.c:   original = ch->in_room;
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:      if( ch->in_room->vnum < pArea->low_r_vnum || ch->in_room->vnum > pArea->hi_r_vnum )
act_wiz.c:      location = ch->in_room;
act_wiz.c:      ch_printf( ch, "Exits for room '%s.' vnum %d\r\n", location->name, location->vnum );
act_wiz.c:      for( cnt = 0, pexit = location->first_exit; pexit; pexit = pexit->next )
act_wiz.c:                    "%2d) %2s to %-5d.  Key: %d  Flags: %d  Keywords: '%s'.\r\nDescription: %sExit links back to vnum: %d  Exit's RoomVnum: %d  Distance: %d\r\n",
act_wiz.c:                    dir_text[pexit->vdir],
act_wiz.c:                    pexit->to_room ? pexit->to_room->vnum : 0,
act_wiz.c:                    pexit->key,
act_wiz.c:                    pexit->exit_info,
act_wiz.c:                    pexit->keyword,
act_wiz.c:                    pexit->description[0] != '\0'
act_wiz.c:                    ? pexit->description : "(none).\r\n",
act_wiz.c:                    pexit->rexit ? pexit->rexit->vnum : 0, pexit->rvnum, pexit->distance );
act_wiz.c:   location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:   if( ch->in_room != location && room_is_private( ch, location ) )
act_wiz.c:              location->name,
act_wiz.c:              location->area ? location->area->name : "None????", location->area ? location->area->filename : "None????" );
act_wiz.c:              location->vnum,
act_wiz.c:              location->sector_type, location->light, location->tele_delay, location->tele_vnum, location->tunnel );
act_wiz.c:   ch_printf( ch, "Room flags: %s\r\n", flag_string( location->room_flags, r_flags ) );
act_wiz.c:   ch_printf( ch, "Description:\r\n%s", location->description );
act_wiz.c:   if( location->first_extradesc )
act_wiz.c:      for( ed = location->first_extradesc; ed; ed = ed->next )
act_wiz.c:         send_to_char( ed->keyword, ch );
act_wiz.c:         if( ed->next )
act_wiz.c:   for( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:         one_argument( rch->name, buf );
act_wiz.c:   for( obj = location->first_content; obj; obj = obj->next_content )
act_wiz.c:      one_argument( obj->name, buf );
act_wiz.c:   if( location->first_exit )
act_wiz.c:      send_to_char( "------------------- EXITS -------------------\r\n", ch );
act_wiz.c:   for( cnt = 0, pexit = location->first_exit; pexit; pexit = pexit->next )
act_wiz.c:                 "%2d) %-2s to %-5d.  Key: %d  Flags: %d  Keywords: %s.\r\n",
act_wiz.c:                 dir_text[pexit->vdir],
act_wiz.c:                 pexit->to_room ? pexit->to_room->vnum : 0,
act_wiz.c:                 pexit->key, pexit->exit_info, pexit->keyword[0] != '\0' ? pexit->keyword : "(none)" );
act_wiz.c:   ch_printf( ch, "Name: %s.\r\n", obj->name );
act_wiz.c:   pdesc = get_extra_descr( arg, obj->first_extradesc );
act_wiz.c:      pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc );
act_wiz.c:      pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_wiz.c:      pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_wiz.c:              obj->pIndexData->vnum, item_type_name( obj ), obj->pIndexData->count, obj->count );
act_wiz.c:              obj->serial, obj->pIndexData->serial, cur_obj_serial );
act_wiz.c:   ch_printf( ch, "Short description: %s.\r\nLong description: %s\r\n", obj->short_descr, obj->description );
act_wiz.c:   if( obj->action_desc[0] != '\0' )
act_wiz.c:      ch_printf( ch, "Action description: %s.\r\n", obj->action_desc );
act_wiz.c:   ch_printf( ch, "Wear flags : %s\r\n", flag_string( obj->wear_flags, w_flags ) );
act_wiz.c:   ch_printf( ch, "Extra flags: %s\r\n", flag_string( obj->extra_flags, o_flags ) );
act_wiz.c:              1, get_obj_number( obj ), obj->weight, get_obj_weight( obj ), obj->pIndexData->layers );
act_wiz.c:              obj->cost, obj->pIndexData->rent, obj->timer, obj->level );
act_wiz.c:              obj->in_room == NULL ? 0 : obj->in_room->vnum,
act_wiz.c:              obj->in_obj == NULL ? "(none)" : obj->in_obj->short_descr,
act_wiz.c:              obj->carried_by == NULL ? "(none)" : obj->carried_by->name, obj->wear_loc );
act_wiz.c:              obj->pIndexData->value[0], obj->pIndexData->value[1],
act_wiz.c:              obj->pIndexData->value[2], obj->pIndexData->value[3], obj->pIndexData->value[4], obj->pIndexData->value[5] );
act_wiz.c:              obj->value[0], obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5] );
act_wiz.c:   if( obj->pIndexData->first_extradesc )
act_wiz.c:      for( ed = obj->pIndexData->first_extradesc; ed; ed = ed->next )
act_wiz.c:         send_to_char( ed->keyword, ch );
act_wiz.c:         if( ed->next )
act_wiz.c:   if( obj->first_extradesc )
act_wiz.c:      for( ed = obj->first_extradesc; ed; ed = ed->next )
act_wiz.c:         send_to_char( ed->keyword, ch );
act_wiz.c:         if( ed->next )
act_wiz.c:   for( paf = obj->first_affect; paf; paf = paf->next )
act_wiz.c:      ch_printf( ch, "Affects %s by %d. (extra)\r\n", affect_loc_name( paf->location ), paf->modifier );
act_wiz.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
act_wiz.c:      ch_printf( ch, "Affects %s by %d.\r\n", affect_loc_name( paf->location ), paf->modifier );
act_wiz.c:              victim->name, ( IS_NPC( victim ) || !victim->pcdata->clan ) ? "(none)" : victim->pcdata->clan->name );
act_wiz.c:   if( get_trust( ch ) >= LEVEL_GOD && !IS_NPC( victim ) && victim->desc )
act_wiz.c:                 victim->desc->host, victim->desc->descriptor,
act_wiz.c:                 victim->trust, victim->pcdata->authed_by[0] != '\0' ? victim->pcdata->authed_by : "(unknown)" );
act_wiz.c:   if( !IS_NPC( victim ) && victim->pcdata->release_date != 0 )
act_wiz.c:      ch_printf( ch, "Helled until %24.24s by %s.\r\n", ctime( &victim->pcdata->release_date ), victim->pcdata->helled_by );
act_wiz.c:              IS_NPC( victim ) ? victim->pIndexData->vnum : 0,
act_wiz.c:              victim->sex == SEX_MALE ? "male" :
act_wiz.c:              victim->sex == SEX_FEMALE ? "female" : "neutral",
act_wiz.c:              victim->in_room == NULL ? 0 : victim->in_room->vnum,
act_wiz.c:              IS_NPC( victim ) ? victim->pIndexData->count : 1,
act_wiz.c:              IS_NPC( victim ) ? victim->pIndexData->killed : victim->pcdata->mdeaths + victim->pcdata->pdeaths );
act_wiz.c:              victim->hit, victim->max_hit, victim->mana, victim->max_mana, victim->move, victim->max_move );
act_wiz.c:         ch_printf( ch, "%-15s   Level: %-3d   Max: %-3d   Exp: %-10ld   Next: %-10ld\r\n",
act_wiz.c:                    ability_name[ability], victim->skill_level[ability], max_level( victim, ability ),
act_wiz.c:                    victim->experience[ability], exp_level( victim->skill_level[ability] + 1 ) );
act_wiz.c:              victim->top_level, victim->race, victim->alignment, GET_AC( victim ), victim->gold );
act_wiz.c:   if( victim->race < MAX_NPC_RACE && victim->race >= 0 )
act_wiz.c:      ch_printf( ch, "Race: %s\r\n", npc_race[victim->race] );
act_wiz.c:              GET_HITROLL( victim ), GET_DAMROLL( victim ), victim->position, victim->wimpy );
act_wiz.c:              victim->fighting ? victim->fighting->who->name : "(none)",
act_wiz.c:              victim->master ? victim->master->name : "(none)", victim->leader ? victim->leader->name : "(none)" );
act_wiz.c:                 victim->pcdata->condition[COND_THIRST],
act_wiz.c:                 victim->pcdata->condition[COND_FULL],
act_wiz.c:                 victim->pcdata->condition[COND_DRUNK], victim->pcdata->quest_curr, victim->pcdata->quest_accum );
act_wiz.c:                 victim->pIndexData->hitnodice,
act_wiz.c:                 victim->pIndexData->hitsizedice,
act_wiz.c:                 victim->pIndexData->hitplus,
act_wiz.c:                 victim->pIndexData->damnodice, victim->pIndexData->damsizedice, victim->pIndexData->damplus );
act_wiz.c:   ch_printf( ch, "MentalState: %d   EmotionalState: %d\r\n", victim->mental_state, victim->emotional_state );
act_wiz.c:              victim->saving_poison_death,
act_wiz.c:              victim->saving_wand, victim->saving_para_petri, victim->saving_breath, victim->saving_spell_staff );
act_wiz.c:              victim->carry_number, can_carry_n( victim ), victim->carry_weight, can_carry_w( victim ), victim->numattacks );
act_wiz.c:              get_age( victim ), ( int )victim->played, victim->timer, victim->act );
act_wiz.c:      ch_printf( ch, "Act flags: %s\r\n", flag_string( victim->act, act_flags ) );
act_wiz.c:      ch_printf( ch, "VIP flags: %s\r\n", flag_string( victim->vip_flags, planet_flags ) );
act_wiz.c:      ch_printf( ch, "Player flags: %s\r\n", flag_string( victim->act, plr_flags ) );
act_wiz.c:      ch_printf( ch, "Pcflags: %s\r\n", flag_string( victim->pcdata->flags, pc_flags ) );
act_wiz.c:      ch_printf( ch, "Wanted flags: %s\r\n", flag_string( victim->pcdata->wanted_flags, planet_flags ) );
act_wiz.c:   ch_printf( ch, "Affected by: %s\r\n", affect_bit_name( victim->affected_by ) );
act_wiz.c:   ch_printf( ch, "Speaks: %d   Speaking: %d\r\n", victim->speaks, victim->speaking );
act_wiz.c:      if( knows_language( victim, lang_array[x], victim ) || ( IS_NPC( victim ) && victim->speaks == 0 ) )
act_wiz.c:         if( IS_SET( lang_array[x], victim->speaking ) || ( IS_NPC( victim ) && !victim->speaking ) )
act_wiz.c:      else if( IS_SET( lang_array[x], victim->speaking ) || ( IS_NPC( victim ) && !victim->speaking ) )
act_wiz.c:   if( victim->pcdata && victim->pcdata->bestowments && victim->pcdata->bestowments[0] != '\0' )
act_wiz.c:      ch_printf( ch, "Bestowments: %s\r\n", victim->pcdata->bestowments );
act_wiz.c:              victim->short_descr, victim->long_descr[0] != '\0' ? victim->long_descr : "(none)\r\n" );
act_wiz.c:   if( IS_NPC( victim ) && ( victim->spec_fun || victim->spec_2 ) )
act_wiz.c:                 victim->spec_funname, victim->spec_2 ? victim->spec_funname2 : "" );
act_wiz.c:   ch_printf( ch, "Body Parts : %s\r\n", flag_string( victim->xflags, part_flags ) );
act_wiz.c:   ch_printf( ch, "Resistant  : %s\r\n", flag_string( victim->resistant, ris_flags ) );
act_wiz.c:   ch_printf( ch, "Immune     : %s\r\n", flag_string( victim->immune, ris_flags ) );
act_wiz.c:   ch_printf( ch, "Susceptible: %s\r\n", flag_string( victim->susceptible, ris_flags ) );
act_wiz.c:   ch_printf( ch, "Attacks    : %s\r\n", flag_string( victim->attacks, attack_flags ) );
act_wiz.c:   ch_printf( ch, "Defenses   : %s\r\n", flag_string( victim->defenses, defense_flags ) );
act_wiz.c:   for( paf = victim->first_affect; paf; paf = paf->next )
act_wiz.c:      if( ( skill = get_skilltype( paf->type ) ) != NULL )
act_wiz.c:                    skill_tname[skill->type],
act_wiz.c:                    skill->name,
act_wiz.c:                    affect_loc_name( paf->location ), paf->modifier, paf->duration, affect_bit_name( paf->bitvector ) );
act_wiz.c:    * -- Furey
act_wiz.c:	    if ( fAll || is_name( arg, pMobIndex->player_name ) )
act_wiz.c:		    pMobIndex->vnum, capitalize( pMobIndex->short_descr ) );
act_wiz.c:    * get_mob_index()... which loops itself, an average of 1-2 times...
act_wiz.c:    * -Thoric
act_wiz.c:      for( pMobIndex = mob_index_hash[hash]; pMobIndex; pMobIndex = pMobIndex->next )
act_wiz.c:         if( fAll || nifty_is_name( arg, pMobIndex->player_name ) )
act_wiz.c:            pager_printf( ch, "[%5d] %s\r\n", pMobIndex->vnum, capitalize( pMobIndex->short_descr ) );
act_wiz.c:    * -- Furey
act_wiz.c:    if ( fAll || nifty_is_name( arg, pObjIndex->name ) )
act_wiz.c:    pObjIndex->vnum, capitalize( pObjIndex->short_descr ) );
act_wiz.c:    * get_obj_index()... which loops itself, an average of 2-3 times...
act_wiz.c:    * -Thoric
act_wiz.c:      for( pObjIndex = obj_index_hash[hash]; pObjIndex; pObjIndex = pObjIndex->next )
act_wiz.c:         if( fAll || nifty_is_name( arg, pObjIndex->name ) )
act_wiz.c:            pager_printf( ch, "[%5d] %s\r\n", pObjIndex->vnum, capitalize( pObjIndex->short_descr ) );
act_wiz.c:   for( victim = first_char; victim; victim = victim->next )
act_wiz.c:      if( IS_NPC( victim ) && victim->in_room && nifty_is_name( arg, victim->name ) )
act_wiz.c:         pager_printf( ch, "[%5d] %-28s [%5d] %s\r\n",
act_wiz.c:                       victim->pIndexData->vnum, victim->short_descr, victim->in_room->vnum, victim->in_room->name );
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:      if( obj->in_room && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && !str_cmp( buf2, obj->short_descr ) )
act_wiz.c:         ch_printf( ch, "Bagging body: [%5d] %-28s [%5d] %s\r\n",
act_wiz.c:                    obj->pIndexData->vnum, obj->short_descr, obj->in_room->vnum, obj->in_room->name );
act_wiz.c:         obj->timer = -1;
act_wiz.c:      for( ; obj->in_obj; obj = obj->in_obj )
act_wiz.c:         pager_printf( ch, "[%5d] %-28s in object [%5d] %s\r\n",
act_wiz.c:                       obj->pIndexData->vnum, obj_short( obj ), obj->in_obj->pIndexData->vnum, obj->in_obj->short_descr );
act_wiz.c:      sprintf( buf, "[%5d] %-28s in ", obj->pIndexData->vnum, obj_short( obj ) );
act_wiz.c:      if( obj->carried_by )
act_wiz.c:                  ( IS_NPC( obj->carried_by ) ? obj->carried_by->pIndexData->vnum : 0 ), PERS( obj->carried_by, ch ) );
act_wiz.c:      else if( obj->in_room )
act_wiz.c:         sprintf( buf + strlen( buf ), "room   [%5d] %s\r\n", obj->in_room->vnum, obj->in_room->name );
act_wiz.c:      else if( obj->in_obj )
act_wiz.c:         bug( "do_owhere: obj->in_obj after NULL!", 0 );
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:      if( !nifty_is_name( arg, obj->name ) )
act_wiz.c:      sprintf( buf, "(%3d) [%5d] %-28s in ", ++icnt, obj->pIndexData->vnum, obj_short( obj ) );
act_wiz.c:      if( obj->carried_by )
act_wiz.c:                  ( IS_NPC( obj->carried_by ) ? obj->carried_by->pIndexData->vnum : 0 ), PERS( obj->carried_by, ch ) );
act_wiz.c:      else if( obj->in_room )
act_wiz.c:         sprintf( buf + strlen( buf ), "room   [%5d] %s\r\n", obj->in_room->vnum, obj->in_room->name );
act_wiz.c:      else if( obj->in_obj )
act_wiz.c:         sprintf( buf + strlen( buf ), "object [%5d] %s\r\n", obj->in_obj->pIndexData->vnum, obj_short( obj->in_obj ) );
act_wiz.c:   if( auction->item )
act_wiz.c:   sprintf( buf, "Reboot by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   if( auction->item )
act_wiz.c:   sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   if( !victim->desc )
act_wiz.c:      for( d = first_descriptor; d; d = d->next )
act_wiz.c:         if( d->snoop_by == ch->desc )
act_wiz.c:            d->snoop_by = NULL;
act_wiz.c:   if( victim->desc->snoop_by )
act_wiz.c:   if( get_trust( victim ) >= get_trust( ch ) || ( victim->pcdata && victim->pcdata->min_snoop > get_trust( ch ) ) )
act_wiz.c:   if( ch->desc )
act_wiz.c:      for( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:         if( d->character == victim || d->original == victim )
act_wiz.c:      write_to_descriptor( victim->desc->descriptor, "\r\nYou feel like someone is watching your every move...\r\n", 0 );
act_wiz.c:   victim->desc->snoop_by = ch->desc;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( ch->desc->original )
act_wiz.c:   if( victim->desc )
act_wiz.c:   ch->desc->character = victim;
act_wiz.c:   ch->desc->original = ch;
act_wiz.c:   victim->desc = ch->desc;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:   ch->switched = victim;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( !ch->desc->original )
act_wiz.c:   if( IS_SET( ch->act, ACT_POLYMORPHED ) )
act_wiz.c:      REMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:/*    if ( IS_NPC( ch->desc->character ) )
act_wiz.c:      REMOVE_BIT( ch->desc->character->affected_by, AFF_POSSESS );*/
act_wiz.c:   ch->desc->character = ch->desc->original;
act_wiz.c:   ch->desc->original = NULL;
act_wiz.c:   ch->desc->character->desc = ch->desc;
act_wiz.c:   ch->desc->character->switched = NULL;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:      vnum = -1;
act_wiz.c:         for( pMobIndex = mob_index_hash[hash]; pMobIndex; pMobIndex = pMobIndex->next )
act_wiz.c:            if( nifty_is_name( arg2, pMobIndex->player_name ) && ++cnt == count )
act_wiz.c:               vnum = pMobIndex->vnum;
act_wiz.c:      if( vnum == -1 )
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:      if( vnum < pArea->low_m_vnum || vnum > pArea->hi_m_vnum )
act_wiz.c:   char_to_room( victim, ch->in_room );
act_wiz.c:      vnum = -1;
act_wiz.c:         for( pObjIndex = obj_index_hash[hash]; pObjIndex; pObjIndex = pObjIndex->next )
act_wiz.c:            if( nifty_is_name( arg, pObjIndex->name ) && ++cnt == count )
act_wiz.c:               vnum = pObjIndex->vnum;
act_wiz.c:      if( vnum == -1 )
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:      if( vnum < pArea->low_o_vnum || vnum > pArea->hi_o_vnum )
act_wiz.c:    &&	 pObjIndex->count > 5 )
act_wiz.c:      obj = obj_to_room( obj, ch->in_room );
act_wiz.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:         vnext = victim->next_in_room;
act_wiz.c:         if( IS_NPC( victim ) && victim != ch && !IS_SET( victim->act, ACT_POLYMORPHED ) )
act_wiz.c:      for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:         obj_next = obj->next_content;
act_wiz.c:         if( obj->item_type == ITEM_SPACECRAFT )
act_wiz.c:    * fixed to get things in room first -- i.e., purge portal (obj),
act_wiz.c:    * * -- Tri 
act_wiz.c:/* Single object purge in room for high level purge - Scryn 8/12*/
act_wiz.c:   if( IS_SET( victim->act, ACT_POLYMORPHED ) )
act_wiz.c:   victim->top_level = 1;
act_wiz.c:   victim->trust = 0;
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Balzhur screams, 'You are MINE %s!!!'", victim->name );
act_wiz.c:         victim->experience[ability] = 1;
act_wiz.c:         victim->skill_level[ability] = 1;
act_wiz.c:   victim->max_hit = 500;
act_wiz.c:   victim->max_mana = 0;
act_wiz.c:   victim->max_move = 1000;
act_wiz.c:      victim->pcdata->learned[sn] = 0;
act_wiz.c:   victim->hit = victim->max_hit;
act_wiz.c:   victim->mana = victim->max_mana;
act_wiz.c:   victim->move = victim->max_move;
act_wiz.c:   sprintf( buf, "%s%s", GOD_DIR, capitalize( victim->name ) );
act_wiz.c:      ch_printf( ch, "Unknown error #%d - %s (immortal data).  Report to Thoric\r\n", errno, strerror( errno ) );
act_wiz.c:      sprintf( buf2, "%s balzhuring %s", ch->name, buf );
act_wiz.c:   for( pArea = first_build; pArea; pArea = pArea->next )
act_wiz.c:      if( !strcmp( pArea->filename, buf2 ) )
act_wiz.c:         if( IS_SET( pArea->status, AREA_LOADED ) )
act_wiz.c:            ch_printf( ch, "Unknown error #%d - %s (area data).  Report to Thoric.\r\n", errno, strerror( errno ) );
act_wiz.c:            sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:   while( victim->first_carrying )
act_wiz.c:      extract_obj( victim->first_carrying );
act_wiz.c:   ability = -1;
act_wiz.c:   if( ability == -1 )
act_wiz.c:    *   -- Swiftest
act_wiz.c:   if( level <= victim->skill_level[ability] )
act_wiz.c:      victim->experience[ability] = 0;
act_wiz.c:      victim->skill_level[ability] = 1;
act_wiz.c:         victim->max_hit = 500;
act_wiz.c:         victim->max_mana = 0;
act_wiz.c:   for( iLevel = victim->skill_level[ability]; iLevel < level; iLevel++ )
act_wiz.c:      victim->experience[ability] = exp_level( iLevel + 1 );
act_wiz.c:   if( victim->top_level != LEVEL_AVATAR )
act_wiz.c:   while( victim->first_carrying )
act_wiz.c:      extract_obj( victim->first_carrying );
act_wiz.c:   victim->top_level = LEVEL_IMMORTAL;
act_wiz.c:   victim->trust = 0;
act_wiz.c:   victim->trust = level;
act_wiz.c:      if( !ch->pcdata )
act_wiz.c:            if( current_time - last_restore_all_time < RESTORE_INTERVAL )
act_wiz.c:      ch->pcdata->restore_time = current_time;
act_wiz.c:         vch_next = vch->next;
act_wiz.c:            vch->hit = vch->max_hit;
act_wiz.c:            vch->mana = vch->max_mana;
act_wiz.c:            vch->move = vch->max_move;
act_wiz.c:            vch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + vch->top_level );
act_wiz.c:      if( get_trust( ch ) < LEVEL_LESSER && victim != ch && !( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) ) )
act_wiz.c:      victim->hit = victim->max_hit;
act_wiz.c:      victim->mana = victim->max_mana;
act_wiz.c:      victim->move = victim->max_move;
act_wiz.c:      if( victim->pcdata )
act_wiz.c:         victim->pcdata->condition[COND_BLOODTHIRST] = ( 10 + victim->top_level );
act_wiz.c:      time_passed = current_time - last_restore_all_time;
act_wiz.c:      minute = ( int )( ( time_passed - ( hour * 3600 ) ) / 60 );
act_wiz.c:   if( !ch->pcdata )
act_wiz.c:   if( !ch->pcdata->restore_time )
act_wiz.c:   time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:   minute = ( int )( ( time_passed - ( hour * 3600 ) ) / 60 );
act_wiz.c:   if( victim->desc && victim->desc->original && get_trust(victim->desc->original) >= get_trust(ch) )
act_wiz.c:   if( IS_SET( victim->act, PLR_FREEZE ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_FREEZE );
act_wiz.c:      ch_printf( ch, "%s is now unfrozen.\r\n", victim->name );
act_wiz.c:      if( victim->switched )
act_wiz.c:         do_return( victim->switched, "" );
act_wiz.c:      SET_BIT( victim->act, PLR_FREEZE );
act_wiz.c:      ch_printf( ch, "You have frozen %s.\r\n", victim->name );
act_wiz.c:   if( IS_SET( victim->act, PLR_LOG ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_LOG );
act_wiz.c:      SET_BIT( victim->act, PLR_LOG );
act_wiz.c:   if( IS_SET( victim->act, PLR_LITTERBUG ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_LITTERBUG );
act_wiz.c:      SET_BIT( victim->act, PLR_LITTERBUG );
act_wiz.c:   if( IS_SET( victim->act, PLR_NO_EMOTE ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_NO_EMOTE );
act_wiz.c:      SET_BIT( victim->act, PLR_NO_EMOTE );
act_wiz.c:   if( IS_SET( victim->act, PLR_NO_TELL ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_NO_TELL );
act_wiz.c:      SET_BIT( victim->act, PLR_NO_TELL );
act_wiz.c:   if( IS_SET( victim->pcdata->flags, PCFLAG_NOTITLE ) )
act_wiz.c:      REMOVE_BIT( victim->pcdata->flags, PCFLAG_NOTITLE );
act_wiz.c:      SET_BIT( victim->pcdata->flags, PCFLAG_NOTITLE );
act_wiz.c:      sprintf( buf, "%s", victim->name );
act_wiz.c:   if( IS_SET( victim->act, PLR_SILENCE ) )
act_wiz.c:      SET_BIT( victim->act, PLR_SILENCE );
act_wiz.c:   if( IS_SET( victim->act, PLR_SILENCE ) )
act_wiz.c:      REMOVE_BIT( victim->act, PLR_SILENCE );
act_wiz.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:      if( rch->fighting )
act_wiz.c:   for( pban = first_ban; pban; pban = pban->next )
act_wiz.c:      fprintf( fp, "%d %s~~%s~\n", pban->level, pban->name, pban->ban_time );
act_wiz.c:   fprintf( fp, "-1\n" );
act_wiz.c:      send_to_pager( "---- ---- ------------------------ ---------------\r\n", ch );
act_wiz.c:      for( pban = first_ban, bnum = 1; pban; pban = pban->next, bnum++ )
act_wiz.c:         pager_printf( ch, "[%2d] (%2d) %-24s %s\r\n", bnum, pban->level, pban->ban_time, pban->name );
act_wiz.c:    * number in the site ip.                               -- Altrag 
act_wiz.c:      for( pban = first_ban, bnum = 1; pban; pban = pban->next, bnum++ )
act_wiz.c:            ch_printf( ch, "Level range: 1 - %d.\r\n", LEVEL_SUPREME );
act_wiz.c:         pban->level = atoi( arg );
act_wiz.c:         pban->level = 1;
act_wiz.c:         pban->level = LEVEL_AVATAR;
act_wiz.c:         pban->level = LEVEL_SUPREME;
act_wiz.c:   for( pban = first_ban; pban; pban = pban->next )
act_wiz.c:      if( !str_cmp( arg, pban->name ) )
act_wiz.c:   pban->name = str_dup( arg );
act_wiz.c:   pban->level = LEVEL_AVATAR;
act_wiz.c:   pban->ban_time = str_dup( buf );
act_wiz.c:   for( pban = first_ban; pban; pban = pban->next )
act_wiz.c:      if( !str_cmp( arg, pban->name ) )
act_wiz.c:         if( pban->ban_time )
act_wiz.c:            DISPOSE( pban->ban_time );
act_wiz.c:         DISPOSE( pban->name );
act_wiz.c:      send_to_char( "Game un-wizlocked.\r\n", ch );
act_wiz.c:/* Output of command reformmated by Samson 2-8-98, and again on 4-7-98 */
act_wiz.c:   send_to_pager( "----+-------------------+----+--------------+--------------------------\r\n", ch );
act_wiz.c:   for( d = first_descriptor; d; d = d->next )
act_wiz.c:      switch ( d->connected )
act_wiz.c:         if( get_trust( ch ) >= LEVEL_ASCENDANT || ( d->character && can_see( ch, d->character ) ) )
act_wiz.c:            pager_printf( ch, " %3d| %-17s |%4d| %-12s | %s \r\n", d->descriptor, st, d->idle / 4,
act_wiz.c:                          d->original ? d->original->name : d->character ? d->character->name : "(None!)", d->host );
act_wiz.c:         if( ( get_trust( ch ) >= LEVEL_SUPREME || ( d->character && can_see( ch, d->character ) ) )
act_wiz.c:             && ( !str_prefix( argument, d->host ) || ( d->character && !str_prefix( argument, d->character->name ) ) ) )
act_wiz.c:            pager_printf( ch, " %3d| %2d|%4d| %-12s | %s \r\n", d->descriptor, d->connected, d->idle / 4,
act_wiz.c:                          d->original ? d->original->name : d->character ? d->character->name : "(None!)", d->host );
act_wiz.c:         vch_next = vch->next;
act_wiz.c:         ch->pcdata->wizinvis = level;
act_wiz.c:         ch->mobinvis = level;
act_wiz.c:      if( ch->mobinvis < 2 )
act_wiz.c:         ch->mobinvis = ch->top_level;
act_wiz.c:   if( ch->pcdata->wizinvis < 2 )
act_wiz.c:      ch->pcdata->wizinvis = ch->top_level;
act_wiz.c:   if( IS_SET( ch->act, PLR_WIZINVIS ) )
act_wiz.c:      REMOVE_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:      SET_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:   if( IS_SET( ch->act, PLR_HOLYLIGHT ) )
act_wiz.c:      REMOVE_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:      SET_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:   if( low_range < area->low_r_vnum && area->low_r_vnum < hi_range )
act_wiz.c:   if( low_range < area->low_m_vnum && area->low_m_vnum < hi_range )
act_wiz.c:   if( low_range < area->low_o_vnum && area->low_o_vnum < hi_range )
act_wiz.c:   if( low_range < area->hi_r_vnum && area->hi_r_vnum < hi_range )
act_wiz.c:   if( low_range < area->hi_m_vnum && area->hi_m_vnum < hi_range )
act_wiz.c:   if( low_range < area->hi_o_vnum && area->hi_o_vnum < hi_range )
act_wiz.c:   if( ( low_range >= area->low_r_vnum ) && ( low_range <= area->hi_r_vnum ) )
act_wiz.c:   if( ( low_range >= area->low_m_vnum ) && ( low_range <= area->hi_m_vnum ) )
act_wiz.c:   if( ( low_range >= area->low_o_vnum ) && ( low_range <= area->hi_o_vnum ) )
act_wiz.c:   if( ( hi_range <= area->hi_r_vnum ) && ( hi_range >= area->low_r_vnum ) )
act_wiz.c:   if( ( hi_range <= area->hi_m_vnum ) && ( hi_range >= area->low_m_vnum ) )
act_wiz.c:   if( ( hi_range <= area->hi_o_vnum ) && ( hi_range >= area->low_o_vnum ) )
act_wiz.c:   for( area = first_area; area; area = area->next )
act_wiz.c:   for( area = first_build; area; area = area->next )
act_wiz.c: * Assigns room/obj/mob ranges and initializes new zone - Samson 2-12-99 
act_wiz.c:/* Bugfix: Vnum range would not be saved properly without placeholders at both ends - Samson 1-6-00 */
act_wiz.c:   int lo = -1, hi = -1;
act_wiz.c:      victim->pcdata->area = NULL;
act_wiz.c:      victim->pcdata->r_range_lo = 0;
act_wiz.c:      victim->pcdata->r_range_hi = 0;
act_wiz.c:      victim->pcdata->o_range_lo = 0;
act_wiz.c:      victim->pcdata->o_range_hi = 0;
act_wiz.c:      victim->pcdata->m_range_lo = 0;
act_wiz.c:      victim->pcdata->m_range_hi = 0;
act_wiz.c:      ch_printf( victim, "%s has removed your vnum range.\r\n", ch->name );
act_wiz.c:   if( victim->pcdata->area && lo != 0 )
act_wiz.c:   victim->pcdata->r_range_lo = lo;
act_wiz.c:   victim->pcdata->r_range_hi = hi;
act_wiz.c:   victim->pcdata->o_range_lo = lo;
act_wiz.c:   victim->pcdata->o_range_hi = hi;
act_wiz.c:   victim->pcdata->m_range_lo = lo;
act_wiz.c:   victim->pcdata->m_range_hi = hi;
act_wiz.c:   ch_printf( victim, "%s has assigned you the vnum range %d - %d.\r\n", ch->name, lo, hi );
act_wiz.c:   if( !victim->pcdata->area )
act_wiz.c:   tarea = victim->pcdata->area;
act_wiz.c:   if( !IS_SET( tarea->status, AREA_DELETED ) )
act_wiz.c:      snprintf( filename, 256, "%s%s", BUILD_DIR, tarea->filename );
act_wiz.c:   ch_printf( ch, "Vnum range set for %s and initialized.\r\n", victim->name );
act_wiz.c:      for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
act_wiz.c:            pager_printf( ch, "%-6.6s %4d\t", cmd->name, cmd->userec.num_uses );
act_wiz.c:            pager_printf( ch, "%-6.6s %4d\r\n", cmd->name, cmd->userec.num_uses );
act_wiz.c:   if( check_parse_name( name ) && lstat( fname, &fst ) != -1 )
act_wiz.c:      d->next = NULL;
act_wiz.c:      d->prev = NULL;
act_wiz.c:      d->connected = CON_GET_NAME;
act_wiz.c:      d->outsize = 2000;
act_wiz.c:      CREATE( d->outbuf, char, d->outsize );
act_wiz.c:      add_char( d->character );
act_wiz.c:      old_room_vnum = d->character->in_room->vnum;
act_wiz.c:      char_to_room( d->character, ch->in_room );
act_wiz.c:      if( get_trust( d->character ) >= get_trust( ch ) )
act_wiz.c:         do_say( d->character, "Do *NOT* disturb me again!" );
act_wiz.c:         d->character->desc = NULL;
act_wiz.c:         do_quit( d->character, "" );
act_wiz.c:      d->character->desc = NULL;
act_wiz.c:      d->character->retran = old_room_vnum;
act_wiz.c:      d->character = NULL;
act_wiz.c:      DISPOSE( d->outbuf );
act_wiz.c:/*  victim->armor	= 100;
act_wiz.c:    victim->mod_str	= 0;
act_wiz.c:    victim->mod_dex	= 0;
act_wiz.c:    victim->mod_wis	= 0;
act_wiz.c:    victim->mod_int	= 0;
act_wiz.c:    victim->mod_con	= 0;
act_wiz.c:    victim->mod_cha	= 0;
act_wiz.c:    victim->mod_lck	= 0;
act_wiz.c:    victim->damroll	= 0;
act_wiz.c:    victim->hitroll	= 0;
act_wiz.c:    victim->alignment	= URANGE( -1000, victim->alignment, 1000 );
act_wiz.c:    victim->saving_spell_staff = 0; */
act_wiz.c:   if( ( victim->top_level < 1 ) || ( victim->top_level > 5 ) )
act_wiz.c:   ch_printf( ch, "You have re-equipped %s.\r\n", victim->name );
act_wiz.c: * e.g. "aset joe.are sedit susan.are cset" --> "joe.are susan.are"
act_wiz.c: * - Gorog
act_wiz.c:      if( ( len = strlen( buf ) ) >= 5 && !strcmp( ".are", pbuf + len - 4 ) )
act_wiz.c: * e.g. "aset joe.are sedit susan.are cset" --> "aset sedit cset"
act_wiz.c: * - Gorog
act_wiz.c:      if( ( len = strlen( buf ) ) < 5 || strcmp( ".are", pbuf + len - 4 ) )
act_wiz.c:   if( !victim->pcdata->bestowments )
act_wiz.c:      victim->pcdata->bestowments = str_dup( "" );
act_wiz.c:      extract_area_names( victim->pcdata->bestowments, buf );
act_wiz.c:      remove_area_names( victim->pcdata->bestowments, buf );
act_wiz.c:      DISPOSE( victim->pcdata->bestowments );
act_wiz.c:      victim->pcdata->bestowments = str_dup( buf );
act_wiz.c:       || argument[arg_len - 4] != '.' || argument[arg_len - 3] != 'a'
act_wiz.c:       || argument[arg_len - 2] != 'r' || argument[arg_len - 1] != 'e' )
act_wiz.c:   sprintf( buf, "%s %s", victim->pcdata->bestowments, argument );
act_wiz.c:   DISPOSE( victim->pcdata->bestowments );
act_wiz.c:   victim->pcdata->bestowments = str_dup( buf );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the area: %s\r\n", ch->name, argument );
act_wiz.c:   if( !victim->pcdata->bestowments )
act_wiz.c:      victim->pcdata->bestowments = str_dup( "" );
act_wiz.c:      ch_printf( ch, "Current bestowed commands on %s: %s.\r\n", victim->name, victim->pcdata->bestowments );
act_wiz.c:      DISPOSE( victim->pcdata->bestowments );
act_wiz.c:      victim->pcdata->bestowments = str_dup( "" );
act_wiz.c:      ch_printf( ch, "Bestowments removed from %s.\r\n", victim->name );
act_wiz.c:      ch_printf( victim, "%s has removed your bestowed commands.\r\n", ch->name );
act_wiz.c:      else if( cmd->level > get_trust( ch ) )
act_wiz.c:      cmd_buf = victim->pcdata->bestowments;
act_wiz.c:   if( arg_buf[strlen( arg_buf ) - 1] == ' ' )
act_wiz.c:      arg_buf[strlen( arg_buf ) - 1] = '\0';
act_wiz.c:   sprintf( buf, "%s %s", victim->pcdata->bestowments, arg_buf );
act_wiz.c:   DISPOSE( victim->pcdata->bestowments );
act_wiz.c:   victim->pcdata->bestowments = str_dup( buf );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the command(s): %s\r\n", ch->name, arg_buf );
act_wiz.c:    * * too --Shaddai
act_wiz.c:   sprintf( oldname, "%s%c/%s", PLAYER_DIR, tolower( victim->name[0] ), capitalize( victim->name ) );
act_wiz.c:   sprintf( backname, "%s%c/%s", BACKUP_DIR, tolower( victim->name[0] ), capitalize( victim->name ) );
act_wiz.c:      sprintf( godname, "%s%s", GOD_DIR, capitalize( victim->name ) );
act_wiz.c:   if( victim->pcdata->area )
act_wiz.c:      sprintf( filename, "%s%s.are", BUILD_DIR, victim->name );
act_wiz.c:      sprintf( filename, "%s%s.are.bak", BUILD_DIR, victim->name );
act_wiz.c:   STRFREE( victim->name );
act_wiz.c:   victim->name = STRALLOC( capitalize( arg2 ) );
act_wiz.c:      ch_printf( ch, "Boot time is currently set to %s, manual bit is set to %d\r\n", reboot_time, set_boot_time->manual );
act_wiz.c:      if( ( now_time->tm_hour = atoi( arg ) ) < 0 || now_time->tm_hour > 23 )
act_wiz.c:      if( ( now_time->tm_min = atoi( arg1 ) ) < 0 || now_time->tm_min > 59 )
act_wiz.c:         if( ( now_time->tm_mday = atoi( arg ) ) < 1 || now_time->tm_mday > 31 )
act_wiz.c:            if( ( now_time->tm_mon = atoi( arg ) ) < 1 || now_time->tm_mon > 12 )
act_wiz.c:            now_time->tm_mon--;
act_wiz.c:            if( ( now_time->tm_year = atoi( arg ) - 1900 ) < 0 || now_time->tm_year > 199 )
act_wiz.c:      now_time->tm_sec = 0;
act_wiz.c:      if( set_boot_time->manual == 0 )
act_wiz.c:         set_boot_time->manual = 1;
act_wiz.c:      set_boot_time->manual = atoi( arg1 );
act_wiz.c:      set_boot_time->manual = 0;
act_wiz.c:      new_boot_time->tm_mday += 1;
act_wiz.c:      if( new_boot_time->tm_hour > 12 )
act_wiz.c:         new_boot_time->tm_mday += 1;
act_wiz.c:      new_boot_time->tm_hour = 6;
act_wiz.c:      new_boot_time->tm_min = 0;
act_wiz.c:      new_boot_time->tm_sec = 0;
act_wiz.c: * Purge a player file.  No more player.  -- Altrag
act_wiz.c: * This could have other applications too.. move if needed. -- Altrag
act_wiz.c:      ech_next = ech->next;
act_wiz.c:      if( ech->fighting )
act_wiz.c:         if( URANGE( pArea->low_m_vnum, ech->pIndexData->vnum, pArea->hi_m_vnum ) == ech->pIndexData->vnum
act_wiz.c:             || ( ech->in_room && ech->in_room->area == pArea ) )
act_wiz.c:      if( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:      eobj_next = eobj->next;
act_wiz.c:      if( URANGE( pArea->low_o_vnum, eobj->pIndexData->vnum, pArea->hi_o_vnum ) == eobj->pIndexData->vnum
act_wiz.c:          || ( eobj->in_room && eobj->in_room->area == pArea ) )
act_wiz.c:         rid_next = rid->next;
act_wiz.c:         if( rid->area != pArea )
act_wiz.c:         mid_next = mid->next;
act_wiz.c:         if( mid->vnum < pArea->low_m_vnum || mid->vnum > pArea->hi_m_vnum )
act_wiz.c:         oid_next = oid->next;
act_wiz.c:         if( oid->vnum < pArea->low_o_vnum || oid->vnum > pArea->hi_o_vnum )
act_wiz.c:   DISPOSE( pArea->name );
act_wiz.c:   DISPOSE( pArea->filename );
act_wiz.c:   DISPOSE( pArea->resetmsg );
act_wiz.c:   STRFREE( pArea->author );
act_wiz.c:   if( IS_SET( pArea->flags, AFLAG_PROTOTYPE ) )
act_wiz.c:      area_next = area->next;
act_wiz.c:      area_next = area->next;
act_wiz.c:    * is no need to go on. -Orion
act_wiz.c:   if( !check_parse_name( name ) || lstat( buf, &fst ) == -1 )
act_wiz.c:   for( victim = first_char; victim; victim = victim->next )
act_wiz.c:      if( !IS_NPC( victim ) && !str_cmp( victim->name, arg ) )
act_wiz.c:      for( d = first_descriptor; d; d = d->next )
act_wiz.c:         if( ( victim = d->character ) && !IS_NPC( victim ) && !str_cmp( victim->name, arg ) )
act_wiz.c:         ch_printf( ch, "Unknown error #%d - %s (immortal data).  Report to Thoric.\r\n", errno, strerror( errno ) );
act_wiz.c:         sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:      for( pArea = first_build; pArea; pArea = pArea->next )
act_wiz.c:         if( !strcmp( pArea->filename, buf2 ) )
act_wiz.c:            if( IS_SET( pArea->status, AREA_LOADED ) )
act_wiz.c:               ch_printf( ch, "Unknown error #%d - %s (area data).  Report to Thoric.\r\n", errno, strerror( errno ) );
act_wiz.c:               sprintf( buf2, "%s destroying %s", ch->name, buf );
act_wiz.c:      ch_printf( ch, "Unknown error #%d - %s.  Report to Thoric.\r\n", errno, strerror( errno ) );
act_wiz.c:      sprintf( buf, "%s destroying %s", ch->name, arg );
act_wiz.c:/* Super-AT command:
act_wiz.c:at least one target, but only once per room. # cannot be used with FOR EVERY-
act_wiz.c:FOR ALL SMILE -> you will only smile once in a room with 2 players.
act_wiz.c:FOR ALL TWIDDLE # -> In a room with A and B, you will twiddle A then B.
act_wiz.c:   character within a room. E.g. the second 'guard' -> 2. guard
act_wiz.c:      return ch->name;
act_wiz.c:   one_argument( ch->name, name );  /* copy the first word into name */
act_wiz.c:    * ->people changed to ->first_person -- TRI 
act_wiz.c:   for( rch = ch->in_room->first_person; rch && ( rch != ch ); rch = rch->next_in_room )
act_wiz.c:      if( is_name( name, rch->name ) )
act_wiz.c:   CHAR_DATA *p, *p_prev;  /* p_next to p_prev -- TRI */
act_wiz.c:       * char_list - last_char, p_next - gch_prev -- TRI 
act_wiz.c:         p_prev = p->prev; /* TRI */
act_wiz.c:          * p_next = p->next; 
act_wiz.c:         if( !( p->in_room ) || room_is_private( p, p->in_room ) || ( p == ch ) )
act_wiz.c:            old_room = ch->in_room;
act_wiz.c:            char_to_room( ch, p->in_room );
act_wiz.c:         for( room = room_index_hash[i]; room; room = room->next )
act_wiz.c:            else if( !room->first_person )   /* Skip it if room is empty */
act_wiz.c:             * ->people changed to first_person -- TRI 
act_wiz.c:             * ->people to ->first_person -- TRI 
act_wiz.c:            for( p = room->first_person; p && !found; p = p->next_in_room )
act_wiz.c:               old_room = ch->in_room;
act_wiz.c:      if( x == -1 )
act_wiz.c:   if( victim->pcdata->release_date != 0 )
act_wiz.c:                 ctime( &victim->pcdata->release_date ), victim->pcdata->helled_by );
act_wiz.c:      tms->tm_hour += htime;
act_wiz.c:      tms->tm_mday += htime;
act_wiz.c:   victim->pcdata->release_date = mktime( tms );
act_wiz.c:   victim->pcdata->helled_by = STRALLOC( ch->name );
act_wiz.c:   ch_printf( ch, "%s will be released from hell at %24.24s.\r\n", victim->name, ctime( &victim->pcdata->release_date ) );
act_wiz.c:   location = ch->in_room;
act_wiz.c:   ch->in_room = get_room_index( 6 );
act_wiz.c:   ch->in_room = location; /* The case of unhell self, etc. */
act_wiz.c:   if( !victim || IS_NPC( victim ) || victim->in_room->vnum != 6 )
act_wiz.c:      location = ch->in_room;
act_wiz.c:   if( victim->pcdata->helled_by )
act_wiz.c:      if( str_cmp( ch->name, victim->pcdata->helled_by ) )
act_wiz.c:                    victim->pcdata->helled_by );
act_wiz.c:      STRFREE( victim->pcdata->helled_by );
act_wiz.c:      victim->pcdata->helled_by = NULL;
act_wiz.c:   victim->pcdata->release_date = 0;
act_wiz.c:   for( obj = first_object; obj != NULL; obj = obj->next )
act_wiz.c:      if( !can_see_obj( ch, obj ) || !( argi == obj->pIndexData->vnum ) )
act_wiz.c:      for( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj );
act_wiz.c:      if( in_obj->carried_by != NULL )
act_wiz.c:                       obj_counter, obj->level, obj_short( obj ), PERS( in_obj->carried_by, ch ) );
act_wiz.c:         pager_printf( ch, "[%2d] [%-5d] %s in %s.\r\n", obj_counter,
act_wiz.c:                       ( ( in_obj->in_room ) ? in_obj->in_room->vnum : 0 ),
act_wiz.c:                       obj_short( obj ), ( in_obj->in_room == NULL ) ? "somewhere" : in_obj->in_room->name );
act_wiz.c:   if( victim->pcdata )
act_wiz.c:      victim->pcdata->condition[COND_DRUNK] = 0;
act_wiz.c: * Free a social structure					-Thoric
act_wiz.c:   if( social->name )
act_wiz.c:      DISPOSE( social->name );
act_wiz.c:   if( social->char_no_arg )
act_wiz.c:      DISPOSE( social->char_no_arg );
act_wiz.c:   if( social->others_no_arg )
act_wiz.c:      DISPOSE( social->others_no_arg );
act_wiz.c:   if( social->char_found )
act_wiz.c:      DISPOSE( social->char_found );
act_wiz.c:   if( social->others_found )
act_wiz.c:      DISPOSE( social->others_found );
act_wiz.c:   if( social->vict_found )
act_wiz.c:      DISPOSE( social->vict_found );
act_wiz.c:   if( social->char_auto )
act_wiz.c:      DISPOSE( social->char_auto );
act_wiz.c:   if( social->others_auto )
act_wiz.c:      DISPOSE( social->others_auto );
act_wiz.c: * Remove a social from it's hash index				-Thoric
act_wiz.c:   if( social->name[0] < 'a' || social->name[0] > 'z' )
act_wiz.c:      hash = ( social->name[0] - 'a' ) + 1;
act_wiz.c:      social_index[hash] = tmp->next;
act_wiz.c:      tmp_next = tmp->next;
act_wiz.c:         tmp->next = tmp_next->next;
act_wiz.c: * Add a social to the social index table			-Thoric
act_wiz.c:   if( !social->name )
act_wiz.c:      bug( "Add_social: NULL social->name", 0 );
act_wiz.c:   if( !social->char_no_arg )
act_wiz.c:      bug( "Add_social: NULL social->char_no_arg", 0 );
act_wiz.c:   for( x = 0; social->name[x] != '\0'; x++ )
act_wiz.c:     ( ( char* ) social->name )[x] = LOWER( social->name[x] );
act_wiz.c:   if( social->name[0] < 'a' || social->name[0] > 'z' )
act_wiz.c:      hash = ( social->name[0] - 'a' ) + 1;
act_wiz.c:      social->next = social_index[hash];
act_wiz.c:   for( ; tmp; tmp = tmp->next )
act_wiz.c:      if( ( x = strcmp( social->name, tmp->name ) ) == 0 )
act_wiz.c:            social->next = social_index[hash];
act_wiz.c:         prev->next = social;
act_wiz.c:         social->next = tmp;
act_wiz.c:   prev->next = social;
act_wiz.c:   social->next = NULL;
act_wiz.c: * Social editor/displayer/save/delete				-Thoric
act_wiz.c:      social->name = str_dup( arg1 );
act_wiz.c:      social->char_no_arg = str_dup( arg2 );
act_wiz.c:      ch_printf( ch, "Social: %s\r\n\r\nCNoArg: %s\r\n", social->name, social->char_no_arg );
act_wiz.c:                 social->others_no_arg ? social->others_no_arg : "(not set)",
act_wiz.c:                 social->char_found ? social->char_found : "(not set)",
act_wiz.c:                 social->others_found ? social->others_found : "(not set)" );
act_wiz.c:                 social->vict_found ? social->vict_found : "(not set)",
act_wiz.c:                 social->char_auto ? social->char_auto : "(not set)",
act_wiz.c:                 social->others_auto ? social->others_auto : "(not set)" );
act_wiz.c:      if( social->char_no_arg )
act_wiz.c:         DISPOSE( social->char_no_arg );
act_wiz.c:      social->char_no_arg = str_dup( argument );
act_wiz.c:      if( social->others_no_arg )
act_wiz.c:         DISPOSE( social->others_no_arg );
act_wiz.c:         social->others_no_arg = str_dup( argument );
act_wiz.c:      if( social->char_found )
act_wiz.c:         DISPOSE( social->char_found );
act_wiz.c:         social->char_found = str_dup( argument );
act_wiz.c:      if( social->others_found )
act_wiz.c:         DISPOSE( social->others_found );
act_wiz.c:         social->others_found = str_dup( argument );
act_wiz.c:      if( social->vict_found )
act_wiz.c:         DISPOSE( social->vict_found );
act_wiz.c:         social->vict_found = str_dup( argument );
act_wiz.c:      if( social->char_auto )
act_wiz.c:         DISPOSE( social->char_auto );
act_wiz.c:         social->char_auto = str_dup( argument );
act_wiz.c:      if( social->others_auto )
act_wiz.c:         DISPOSE( social->others_auto );
act_wiz.c:         social->others_auto = str_dup( argument );
act_wiz.c:      if( arg1[0] != social->name[0] )
act_wiz.c:      if( social->name )
act_wiz.c:         DISPOSE( social->name );
act_wiz.c:      social->name = str_dup( arg1 );
act_wiz.c: * Free a command structure					-Thoric
act_wiz.c:   if( command->name )
act_wiz.c:      DISPOSE( command->name );
act_wiz.c:   if( command->fun_name )
act_wiz.c:      DISPOSE( command->fun_name );
act_wiz.c: * Remove a command from it's hash index			-Thoric
act_wiz.c:   hash = command->name[0] % 126;
act_wiz.c:      command_hash[hash] = tmp->next;
act_wiz.c:      tmp_next = tmp->next;
act_wiz.c:         tmp->next = tmp_next->next;
act_wiz.c: * Add a command to the command hash table			-Thoric
act_wiz.c:   if( !command->name )
act_wiz.c:      bug( "Add_command: NULL command->name", 0 );
act_wiz.c:   if( !command->do_fun )
act_wiz.c:      bug( "Add_command: NULL command->do_fun", 0 );
act_wiz.c:   for( x = 0; command->name[x] != '\0'; x++ )
act_wiz.c:     ( ( char* ) command->name )[x] = LOWER( command->name[x] );
act_wiz.c:   hash = command->name[0] % 126;
act_wiz.c:      command->next = command_hash[hash];
act_wiz.c:   for( ; tmp; tmp = tmp->next )
act_wiz.c:      if( !tmp->next )
act_wiz.c:         tmp->next = command;
act_wiz.c:         command->next = NULL;
act_wiz.c: * Command editor/displayer/save/delete				-Thoric
act_wiz.c:      command->name = str_dup( arg1 );
act_wiz.c:      command->level = get_trust( ch );
act_wiz.c:      command->do_fun = skill_function( arg2 );
act_wiz.c:      command->fun_name = str_dup( arg2 );
act_wiz.c:      if( command->do_fun == skill_notfound )
act_wiz.c:   else if( command->level > get_trust( ch ) )
act_wiz.c:                 command->name, command->level, command->position, command->log, command->fun_name );
act_wiz.c:      if( command->userec.num_uses )
act_wiz.c:         send_timer( &command->userec, ch );
act_wiz.c:      command->do_fun = fun;
act_wiz.c:      DISPOSE( command->fun_name );
act_wiz.c:      command->fun_name = str_dup( argument );
act_wiz.c:      if ( level > command->level && command->do_fun == do_switch )
act_wiz.c:         command->level = level;
act_wiz.c:         command->level = level;
act_wiz.c:      command->log = clog;
act_wiz.c:      command->position = position;
act_wiz.c:      if( arg1[0] != command->name[0] )
act_wiz.c:      if( command->name )
act_wiz.c:         DISPOSE( command->name );
act_wiz.c:      command->name = str_dup( arg1 );
bet.h:*--------------------------------------------------------------------------*
bet.h:* -------------------------------------------------------------------------*
bet.h:*--------------------------------------------------------------------------*
bet.h:* ------------------------------------------------------------------------ *
bet.h:* ------------------------------------------------------------------------ *
bet.h:  util function, converts an 'advanced' ASCII-number-string into a number.
bet.h:      number = ( number * 10 ) + ( *s++ - '0' );
bet.h:         return 0;   /* not k nor m nor NULL - return 0! */
bet.h:      number = number + ( ( *s++ - '0' ) * multiplier );
bet.h:    * return 0 if non-digit character was found, other than NULL 
bet.h:    * anything left is likely extra digits (ie: 14k4443  -> 3 is extra) 
boards.c:*--------------------------------------------------------------------------*
boards.c:* -------------------------------------------------------------------------*
boards.c:*--------------------------------------------------------------------------*
boards.c:* ------------------------------------------------------------------------ *
boards.c:* ------------------------------------------------------------------------ *
boards.c:/* Defines for voting on notes. -- Narn */
boards.c:   if( get_trust( ch ) >= board->min_remove_level )
boards.c:   if( board->extra_removers[0] != '\0' )
boards.c:      if( is_name( ch->name, board->extra_removers ) )
boards.c:   if( get_trust( ch ) >= board->min_read_level )
boards.c:   if( board->read_group[0] != '\0' )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) )
boards.c:      if( ch->pcdata->clan && ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, board->read_group ) )
boards.c:   if( board->extra_readers[0] != '\0' )
boards.c:      if( is_name( ch->name, board->extra_readers ) )
boards.c:   if( get_trust( ch ) >= board->min_post_level )
boards.c:   if( board->post_group[0] != '\0' )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) )
boards.c:      if( ch->pcdata->clan && ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, board->post_group ) )
boards.c:   for( tboard = first_board; tboard; tboard = tboard->next )
boards.c:      fprintf( fpout, "Filename          %s~\n", tboard->note_file );
boards.c:      fprintf( fpout, "Vnum              %d\n", tboard->board_obj );
boards.c:      fprintf( fpout, "Min_read_level    %d\n", tboard->min_read_level );
boards.c:      fprintf( fpout, "Min_post_level    %d\n", tboard->min_post_level );
boards.c:      fprintf( fpout, "Min_remove_level  %d\n", tboard->min_remove_level );
boards.c:      fprintf( fpout, "Max_posts         %d\n", tboard->max_posts );
boards.c:      fprintf( fpout, "Type 	           %d\n", tboard->type );
boards.c:      fprintf( fpout, "Read_group        %s~\n", tboard->read_group );
boards.c:      fprintf( fpout, "Post_group        %s~\n", tboard->post_group );
boards.c:      fprintf( fpout, "Extra_readers     %s~\n", tboard->extra_readers );
boards.c:      fprintf( fpout, "Extra_removers    %s~\n", tboard->extra_removers );
boards.c:   for( board = first_board; board; board = board->next )
boards.c:      if( board->board_obj == obj->pIndexData->vnum )
boards.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
boards.c:   if( !str_cmp( ch->name, pnote->sender ) )
boards.c:   if( is_name( "all", pnote->to_list ) )
boards.c:   if( IS_HERO( ch ) && is_name( "immortal", pnote->to_list ) )
boards.c:   if( is_name( ch->name, pnote->to_list ) )
boards.c:   if( ch->pnote )
boards.c:   pnote->next = NULL;
boards.c:   pnote->prev = NULL;
boards.c:   pnote->sender = QUICKLINK( ch->name );
boards.c:   pnote->date = STRALLOC( "" );
boards.c:   pnote->to_list = STRALLOC( "" );
boards.c:   pnote->subject = STRALLOC( "" );
boards.c:   pnote->text = STRALLOC( "" );
boards.c:   ch->pnote = pnote;
boards.c:   sprintf( filename, "%s%s", BOARD_DIR, board->note_file );
boards.c:      for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:                  pnote->sender, pnote->date, pnote->to_list, pnote->subject, pnote->voting, pnote->yesvotes, pnote->novotes,
boards.c:                  pnote->abstentions, pnote->text );
boards.c:   STRFREE( pnote->text );
boards.c:   STRFREE( pnote->subject );
boards.c:   STRFREE( pnote->to_list );
boards.c:   STRFREE( pnote->date );
boards.c:   STRFREE( pnote->sender );
boards.c:   if( pnote->yesvotes )
boards.c:      DISPOSE( pnote->yesvotes );
boards.c:   if( pnote->novotes )
boards.c:      DISPOSE( pnote->novotes );
boards.c:   if( pnote->abstentions )
boards.c:      DISPOSE( pnote->abstentions );
boards.c:   UNLINK( pnote, board->first_note, board->last_note, next, prev );
boards.c:   --board->num_posts;
boards.c:   for( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:      if( quill->item_type == ITEM_PEN && can_see_obj( ch, quill ) )
boards.c:   switch ( ch->substate )
boards.c:         if( board->type != BOARD_NOTE )
boards.c:   switch ( ch->substate )
boards.c:         if( board->type != BOARD_MAIL )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:         if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:         ed = ( EXTRA_DESCR_DATA* )ch->dest_buf;
boards.c:         STRFREE( ed->description );
boards.c:         ed->description = copy_buffer( ch );
boards.c:         for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:               pager_printf( ch, "%2d%c %-12s%c %-12s %s\r\n",
boards.c:                             pnote->sender,
boards.c:                             ( pnote->voting != VOTE_NONE ) ? ( pnote->voting == VOTE_OPEN ? 'V' : 'C' ) : ':',
boards.c:                             pnote->to_list, pnote->subject );
boards.c:            for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:         for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:                          ++vnum, is_note_to( ch, pnote ) ? '-' : '}', pnote->sender, pnote->subject );
boards.c:         for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:                             vnum, pnote->sender, pnote->subject, pnote->date, pnote->to_list, pnote->text );
boards.c:               if( pnote->yesvotes[0] != '\0' || pnote->novotes[0] != '\0' || pnote->abstentions[0] != '\0' )
boards.c:                  send_to_pager( "------------------------------------------------------------\r\n", ch );
boards.c:                                pnote->yesvotes, pnote->novotes, pnote->abstentions );
boards.c:         for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:                  if( ch->gold < 10 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                     ch->gold -= 10;
boards.c:                                vnum, pnote->sender, pnote->subject, pnote->date, pnote->to_list, pnote->text );
boards.c:      for( pnote = board->first_note; pnote && vnum < anum; pnote = pnote->next )
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:         pnote->voting = VOTE_OPEN;
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:         pnote->voting = VOTE_CLOSED;
boards.c:      if( pnote->voting != VOTE_OPEN )
boards.c:      sprintf( buf, "%s %s %s", pnote->yesvotes, pnote->novotes, pnote->abstentions );
boards.c:      if( is_name( ch->name, buf ) )
boards.c:         sprintf( buf, "%s %s", pnote->yesvotes, ch->name );
boards.c:         DISPOSE( pnote->yesvotes );
boards.c:         pnote->yesvotes = str_dup( buf );
boards.c:         sprintf( buf, "%s %s", pnote->novotes, ch->name );
boards.c:         DISPOSE( pnote->novotes );
boards.c:         pnote->novotes = str_dup( buf );
boards.c:         sprintf( buf, "%s %s", pnote->abstentions, ch->name );
boards.c:         DISPOSE( pnote->abstentions );
boards.c:         pnote->abstentions = str_dup( buf );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         if( quill->value[0] < 1 )
boards.c:      if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:      if( paper->value[0] < 2 )
boards.c:         paper->value[0] = 1;
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:            --quill->value[0];
boards.c:         start_editing( ch, ed->description );
boards.c:         if( quill->value[0] < 1 )
boards.c:      if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:      if( paper->value[1] > 1 )
boards.c:         paper->value[1] = 1;
boards.c:         STRFREE( ed->description );
boards.c:         ed->description = STRALLOC( arg_passed );
boards.c:         if( quill->value[0] < 1 )
boards.c:      if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:      if( paper->value[2] > 1 )
boards.c:      if( !IS_MAIL || stat( fname, &fst ) != -1 || !str_cmp( ucase_arg_passed, "all" ) )
boards.c:         paper->value[2] = 1;
boards.c:         STRFREE( ed->description );
boards.c:         ed->description = STRALLOC( ucase_arg_passed );
boards.c:      if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:      if( ( subject = get_extra_descr( "_subject_", paper->first_extradesc ) ) == NULL )
boards.c:      if( ( to_list = get_extra_descr( "_to_", paper->first_extradesc ) ) == NULL )
boards.c:      sprintf( buf, "%s: %s\r\nTo: %s\r\n", ch->name, subject, to_list );
boards.c:      if( ( text = get_extra_descr( "_text_", paper->first_extradesc ) ) == NULL )
boards.c:      if( ( paper = get_eq_char( ch, WEAR_HOLD ) ) == NULL || paper->item_type != ITEM_PAPER )
boards.c:      if( paper->value[0] == 0 )
boards.c:      if( paper->value[1] == 0 )
boards.c:         paper->value[1] = 1;
boards.c:         STRFREE( ed->description );
boards.c:         ed->description = STRALLOC( "none" );
boards.c:      if( paper->value[2] == 0 )
boards.c:            paper->value[2] = 1;
boards.c:            STRFREE( ed->description );
boards.c:            ed->description = STRALLOC( "All" );
boards.c:      if( board->num_posts >= board->max_posts )
boards.c:      strtime[strlen( strtime ) - 1] = '\0';
boards.c:      pnote->date = STRALLOC( strtime );
boards.c:      text = get_extra_descr( "_text_", paper->first_extradesc );
boards.c:      pnote->text = text ? STRALLOC( text ) : STRALLOC( "" );
boards.c:      text = get_extra_descr( "_to_", paper->first_extradesc );
boards.c:      pnote->to_list = text ? STRALLOC( text ) : STRALLOC( "all" );
boards.c:      text = get_extra_descr( "_subject_", paper->first_extradesc );
boards.c:      pnote->subject = text ? STRALLOC( text ) : STRALLOC( "" );
boards.c:      pnote->sender = QUICKLINK( ch->name );
boards.c:      pnote->voting = 0;
boards.c:      pnote->yesvotes = str_dup( "" );
boards.c:      pnote->novotes = str_dup( "" );
boards.c:      pnote->abstentions = str_dup( "" );
boards.c:      LINK( pnote, board->first_note, board->last_note, next, prev );
boards.c:      board->num_posts++;
boards.c:      for( pnote = board->first_note; pnote; pnote = pnote->next )
boards.c:            if( ( is_name( "all", pnote->to_list ) ) && ( get_trust( ch ) < sysdata.take_others_mail ) && ( take == 1 ) )
boards.c:               if( ch->gold < 50 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                  ch->gold -= 50;
boards.c:               STRFREE( ed->description );
boards.c:               ed->description = QUICKLINK( pnote->sender );
boards.c:               STRFREE( ed->description );
boards.c:               ed->description = QUICKLINK( pnote->text );
boards.c:               STRFREE( ed->description );
boards.c:               ed->description = QUICKLINK( pnote->to_list );
boards.c:               STRFREE( ed->description );
boards.c:               ed->description = QUICKLINK( pnote->subject );
boards.c:               STRFREE( ed->description );
boards.c:               ed->description = QUICKLINK( pnote->date );
boards.c:               STRFREE( ed->description );
boards.c:               strcat( notebuf, pnote->sender );
boards.c:               strcat( notebuf, pnote->to_list );
boards.c:               strcat( notebuf, pnote->subject );
boards.c:               strcat( notebuf, pnote->text );
boards.c:               ed->description = STRALLOC( notebuf );
boards.c:               paper->value[0] = 2;
boards.c:               paper->value[1] = 2;
boards.c:               paper->value[2] = 2;
boards.c:               sprintf( short_desc_buf, "a note from %s to %s", pnote->sender, pnote->to_list );
boards.c:               STRFREE( paper->short_descr );
boards.c:               paper->short_descr = STRALLOC( short_desc_buf );
boards.c:               sprintf( long_desc_buf, "A note from %s to %s lies on the ground.", pnote->sender, pnote->to_list );
boards.c:               STRFREE( paper->description );
boards.c:               paper->description = STRALLOC( long_desc_buf );
boards.c:               sprintf( keyword_buf, "note parchment paper %s", pnote->to_list );
boards.c:               STRFREE( paper->name );
boards.c:               paper->name = STRALLOC( keyword_buf );
boards.c:            KEY( "Extra_readers", board->extra_readers, fread_string_nohash( fp ) );
boards.c:            KEY( "Extra_removers", board->extra_removers, fread_string_nohash( fp ) );
boards.c:               board->num_posts = 0;
boards.c:               board->first_note = NULL;
boards.c:               board->last_note = NULL;
boards.c:               board->next = NULL;
boards.c:               board->prev = NULL;
boards.c:               if( !board->read_group )
boards.c:                  board->read_group = str_dup( "" );
boards.c:               if( !board->post_group )
boards.c:                  board->post_group = str_dup( "" );
boards.c:               if( !board->extra_readers )
boards.c:                  board->extra_readers = str_dup( "" );
boards.c:               if( !board->extra_removers )
boards.c:                  board->extra_removers = str_dup( "" );
boards.c:            KEY( "Filename", board->note_file, fread_string_nohash( fp ) );
boards.c:            KEY( "Min_read_level", board->min_read_level, fread_number( fp ) );
boards.c:            KEY( "Min_post_level", board->min_post_level, fread_number( fp ) );
boards.c:            KEY( "Min_remove_level", board->min_remove_level, fread_number( fp ) );
boards.c:            KEY( "Max_posts", board->max_posts, fread_number( fp ) );
boards.c:            KEY( "Post_group", board->post_group, fread_string_nohash( fp ) );
boards.c:            KEY( "Read_group", board->read_group, fread_string_nohash( fp ) );
boards.c:            KEY( "Type", board->type, fread_number( fp ) );
boards.c:            KEY( "Vnum", board->board_obj, fread_number( fp ) );
boards.c:      pnote->sender = fread_string( fp );
boards.c:      pnote->date = fread_string( fp );
boards.c:      pnote->to_list = fread_string( fp );
boards.c:      pnote->subject = fread_string( fp );
boards.c:         pnote->voting = fread_number( fp );
boards.c:         pnote->yesvotes = fread_string_nohash( fp );
boards.c:         pnote->novotes = fread_string_nohash( fp );
boards.c:         pnote->abstentions = fread_string_nohash( fp );
boards.c:      pnote->text = fread_string( fp );
boards.c:      if( !pnote->yesvotes )
boards.c:         pnote->yesvotes = str_dup( "" );
boards.c:      if( !pnote->novotes )
boards.c:         pnote->novotes = str_dup( "" );
boards.c:      if( !pnote->abstentions )
boards.c:         pnote->abstentions = str_dup( "" );
boards.c:      pnote->next = NULL;
boards.c:      pnote->prev = NULL;
boards.c:      sprintf( notefile, "%s%s", BOARD_DIR, board->note_file );
boards.c:            LINK( pnote, board->first_note, board->last_note, next, prev );
boards.c:            board->num_posts++;
boards.c:   board->note_file = str_dup( strlower( argument ) );
boards.c:   board->read_group = str_dup( "" );
boards.c:   board->post_group = str_dup( "" );
boards.c:   board->extra_readers = str_dup( "" );
boards.c:   board->extra_removers = str_dup( "" );
boards.c:   for( board = first_board; board; board = board->next )
boards.c:      if( !str_cmp( arg1, board->note_file ) )
boards.c:      board->board_obj = value;
boards.c:      board->min_read_level = value;
boards.c:      DISPOSE( board->read_group );
boards.c:         board->read_group = str_dup( "" );
boards.c:         board->read_group = str_dup( argument );
boards.c:      DISPOSE( board->post_group );
boards.c:         board->post_group = str_dup( "" );
boards.c:         board->post_group = str_dup( argument );
boards.c:         sprintf( buf, "%s %s", board->extra_removers, argument );
boards.c:      DISPOSE( board->extra_removers );
boards.c:      board->extra_removers = str_dup( buf );
boards.c:         sprintf( buf, "%s %s", board->extra_readers, argument );
boards.c:      DISPOSE( board->extra_readers );
boards.c:      board->extra_readers = str_dup( buf );
boards.c:      snprintf( filename, sizeof( filename ), "%s%s", BOARD_DIR, board->note_file );
boards.c:      DISPOSE( board->note_file );
boards.c:      board->note_file = str_dup( argument );
boards.c:      board->min_post_level = value;
boards.c:      board->min_remove_level = value;
boards.c:      board->max_posts = value;
boards.c:      board->type = value;
boards.c:   for( board = first_board; board; board = board->next )
boards.c:      if( !str_cmp( arg, board->note_file ) )
boards.c:   ch_printf( ch, "%-12s Vnum: %5d Read: %2d Post: %2d Rmv: %2d Max: %2d Posts: %d Type: %d\r\n",
boards.c:              board->note_file, board->board_obj,
boards.c:              board->min_read_level, board->min_post_level,
boards.c:              board->min_remove_level, board->max_posts, board->num_posts, board->type );
boards.c:   ch_printf( ch, "Read_group: %-15s Post_group: %-15s \r\nExtra_readers: %-10s\r\n",
boards.c:              board->read_group, board->post_group, board->extra_readers );
boards.c:   for( board = first_board; board; board = board->next )
boards.c:      ch_printf( ch, "%-16s Vnum: %5d Read: %2d Post: %2d Rmv: %2d Max: %2d Posts: %d Type: %d\r\n",
boards.c:                 board->note_file, board->board_obj,
boards.c:                 board->min_read_level, board->min_post_level,
boards.c:                 board->min_remove_level, board->max_posts, board->num_posts, board->type );
boards.c:   for( board = first_board; board; board = board->next )
boards.c:      if( board->type == BOARD_MAIL && can_read( ch, board ) )
boards.c:         for( note = board->first_note; note; note = note->next )
bounty.c:*--------------------------------------------------------------------------*
bounty.c:* -------------------------------------------------------------------------*
bounty.c:*--------------------------------------------------------------------------*
bounty.c:* ------------------------------------------------------------------------ *
bounty.c:* ------------------------------------------------------------------------ *
bounty.c:   for( tbounty = first_disintigration; tbounty; tbounty = tbounty->next )
bounty.c:      fprintf( fpout, "%s\n", tbounty->target );
bounty.c:      fprintf( fpout, "%ld\n", tbounty->amount );
bounty.c:   for( bounty = first_disintigration; bounty; bounty = bounty->next )
bounty.c:      if( !str_cmp( victim->name, bounty->target ) )
bounty.c:   for( bounty = first_disintigration; bounty; bounty = bounty->next )
bounty.c:      if( !str_cmp( target, bounty->target ) )
bounty.c:      bounty->target = STRALLOC( target );
bounty.c:      bounty->amount = amount;
bounty.c:   for( bounty = first_disintigration; bounty; bounty = bounty->next )
bounty.c:      ch_printf( ch, "%-26s %-14ld\r\n", bounty->target, bounty->amount );
bounty.c:   for( bounty = first_disintigration; bounty; bounty = bounty->next )
bounty.c:      if( !str_cmp( bounty->target, victim->name ) )
bounty.c:      bounty->target = STRALLOC( victim->name );
bounty.c:      bounty->amount = 0;
bounty.c:   bounty->amount = bounty->amount + amount;
bounty.c:   sprintf( buf, "%s has added %ld credits to the bounty on %s.", ch->name, amount, victim->name );
bounty.c:   if( ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, "the hunters guild" ) )
bounty.c:   if( !ch->in_room || ch->in_room->vnum != 6604 )
bounty.c:   if( ch->gold < amount )
bounty.c:   ch->gold = ch->gold - amount;
bounty.c:   STRFREE( bounty->target );
bounty.c:   bounty = get_disintigration( victim->name );
bounty.c:   if( bounty && ( !ch->pcdata || !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name, "the hunters guild" ) ) )
bounty.c:      if( IS_SET( victim->act, PLR_KILLER ) && !IS_NPC( ch ) )
bounty.c:                    ( exp_level( ch->skill_level[HUNTING_ABILITY] + 1 ) - exp_level( ch->skill_level[HUNTING_ABILITY] ) ) );
bounty.c:         SET_BIT( ch->act, PLR_KILLER );
bounty.c:         ch_printf( ch, "You are now wanted for the murder of %s.\r\n", victim->name );
bounty.c:      sprintf( buf, "%s is Dead!", victim->name );
bounty.c:   ch->gold += bounty->amount;
bounty.c:      URANGE( 1, bounty->amount + xp_compute( ch, victim ),
bounty.c:              ( exp_level( ch->skill_level[HUNTING_ABILITY] + 1 ) - exp_level( ch->skill_level[HUNTING_ABILITY] ) ) );
bounty.c:   ch_printf( ch, "You receive %ld experience and %ld credits,\r\n from the bounty on %s\r\n", gexp, bounty->amount,
bounty.c:              bounty->target );
bounty.c:   sprintf( buf, "%s has claimed the disintigration bounty on %s!", ch->name, victim->name );
bounty.c:   sprintf( buf, "%s is Dead!", victim->name );
bounty.c:   if( !IS_SET( victim->act, PLR_KILLER ) )
bounty.c:      SET_BIT( ch->act, PLR_KILLER );
build.c:*--------------------------------------------------------------------------*
build.c:* -------------------------------------------------------------------------*
build.c:*--------------------------------------------------------------------------*
build.c:* ------------------------------------------------------------------------ *
build.c:* ------------------------------------------------------------------------ *
build.c:   "vibro-axe", "vibro-blade", "lightsaber", "whip", "claw",
build.c:   "non-adegan", "kathracite", "relacite", "danite", "mephite", "ponite", "illum", "corusca"
build.c: * ie: drop -- for an object, it would be triggered when that object is
build.c: * dropped; -- for a room, it would be triggered when anything is dropped
build.c: *          -- for a mob, it would be triggered when anything is dropped
build.c:      buf[--x] = '\0';
build.c:   int vnum = room->vnum;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( vnum >= pArea->low_r_vnum && vnum <= pArea->hi_r_vnum )
build.c:   int vnum = obj->pIndexData->vnum;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( vnum >= pArea->low_o_vnum && vnum <= pArea->hi_o_vnum )
build.c:   int vnum = obj->vnum;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( vnum >= pArea->low_o_vnum && vnum <= pArea->hi_o_vnum )
build.c:   vnum = mob->pIndexData->vnum;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( vnum >= pArea->low_m_vnum && vnum <= pArea->hi_m_vnum )
build.c:   int vnum = mob->vnum;
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( vnum >= pArea->low_m_vnum && vnum <= pArea->hi_m_vnum )
build.c:  return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:   return -1;
build.c:      last = strptr[len - 1];
build.c:         *str = '-';
build.c:      strptr[len - 1] = last;
build.c:   if( !ch->desc )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:      bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
build.c:   send_to_char( "--------------------------------------------------------------------------\r\n> ", ch );
build.c:   if( ch->editor )
build.c:   edit->numlines = 0;
build.c:   edit->on_line = 0;
build.c:   edit->size = 0;
build.c:            edit->line[lines][lpos] = '\0';
build.c:            edit->line[lines][lpos] = '\0';
build.c:            edit->line[lines][lpos++] = c;
build.c:            edit->line[lines][lpos] = '\0';
build.c:   edit->numlines = lines;
build.c:   edit->size = size;
build.c:   edit->on_line = lines;
build.c:   ch->editor = edit;
build.c:   ch->desc->connected = CON_EDITING;
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      strcpy( tmp, ch->editor->line[x] );
build.c:      if( tmp[len - 1] == '~' )
build.c:         tmp[len - 1] = '\0';
build.c:   DISPOSE( ch->editor );
build.c:   ch->editor = NULL;
build.c:   ch->dest_buf = NULL;
build.c:   ch->spare_ptr = NULL;
build.c:   ch->substate = SUB_NONE;
build.c:   if( !ch->desc )
build.c:   ch->desc->connected = CON_PLAYING;
build.c:      if( vnum < 1 || IS_NPC( ch ) || !ch->pcdata->area )
build.c:         if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:         if( vnum < pArea->low_r_vnum || vnum > pArea->hi_r_vnum )
build.c:      location = make_room( vnum, ch->pcdata->area );
build.c:      location->area = ch->pcdata->area;
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( vnum < pArea->low_r_vnum || vnum > pArea->hi_r_vnum )
build.c:      if( ( ch->in_room->vnum < pArea->low_r_vnum
build.c:            || ch->in_room->vnum > pArea->hi_r_vnum ) && !IS_SET( ch->in_room->room_flags, ROOM_HOTEL ) )
build.c:   in_room = ch->in_room;
build.c:   if( ch->fighting )
build.c:   if( !IS_SET( ch->act, PLR_WIZINVIS ) )
build.c:      if( ch->pcdata && ch->pcdata->bamfout[0] != '\0' )
build.c:         act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfout, TO_ROOM );
build.c:   ch->regoto = ch->in_room->vnum;
build.c:   if( ch->mount )
build.c:      char_from_room( ch->mount );
build.c:      char_to_room( ch->mount, location );
build.c:   if( !IS_SET( ch->act, PLR_WIZINVIS ) )
build.c:      if( ch->pcdata && ch->pcdata->bamfin[0] != '\0' )
build.c:         act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfin, TO_ROOM );
build.c:   if( ch->in_room == in_room )
build.c:   for( fch = in_room->first_person; fch; fch = fch_next )
build.c:      fch_next = fch->next_in_room;
build.c:      if( fch->master == ch && IS_IMMORTAL( fch ) )
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_mset: sub_mob_desc: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         victim = ( CHAR_DATA* ) ch->dest_buf;
build.c:         STRFREE( victim->description );
build.c:         victim->description = copy_buffer( ch );
build.c:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:            STRFREE( victim->pIndexData->description );
build.c:            victim->pIndexData->description = QUICKLINK( victim->description );
build.c:         ch->substate = ch->tempnum;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:     victim = ( CHAR_DATA* ) ch->dest_buf;
build.c:            do_mstat( ch, victim->name );
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:      strcpy( arg1, victim->name );
build.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:      ch_printf( ch, "Mset mode on. (Editing %s).\r\n", victim->name );
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = victim;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            sprintf( buf, "<&CMset &W#%d&w> %%i", victim->pIndexData->vnum );
build.c:            sprintf( buf, "<&CMset &W%s&w> %%i", victim->name );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:   value = is_number( arg3 ) ? atoi( arg3 ) : -1;
build.c:   if( atoi( arg3 ) < -1 && value == -1 )
build.c:      victim->perm_str = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_str = value;
build.c:      victim->perm_int = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_int = value;
build.c:      victim->perm_wis = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_wis = value;
build.c:      victim->perm_dex = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_dex = value;
build.c:      victim->perm_con = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_con = value;
build.c:      victim->perm_cha = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_cha = value;
build.c:      victim->perm_lck = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_lck = value;
build.c:      victim->perm_frc = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->perm_frc = value;
build.c:      if( value < -30 || value > 30 )
build.c:         send_to_char( "Saving throw range vs poison is -30 to 30.\r\n", ch );
build.c:      victim->saving_poison_death = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->saving_poison_death = value;
build.c:      if( value < -30 || value > 30 )
build.c:         send_to_char( "Saving throw range vs wands is -30 to 30.\r\n", ch );
build.c:      victim->saving_wand = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->saving_wand = value;
build.c:      if( value < -30 || value > 30 )
build.c:         send_to_char( "Saving throw range vs para is -30 to 30.\r\n", ch );
build.c:      victim->saving_para_petri = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->saving_para_petri = value;
build.c:      if( value < -30 || value > 30 )
build.c:         send_to_char( "Saving throw range vs bad breath is -30 to 30.\r\n", ch );
build.c:      victim->saving_breath = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->saving_breath = value;
build.c:      if( value < -30 || value > 30 )
build.c:         send_to_char( "Saving throw range vs force powers is -30 to 30.\r\n", ch );
build.c:      victim->saving_spell_staff = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->saving_spell_staff = value;
build.c:      victim->sex = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->sex = value;
build.c:         ch_printf( ch, "Race range is 0 to %d.\n", MAX_RACE - 1 );
build.c:         ch_printf( ch, "Race range is 0 to %d.\n", MAX_NPC_RACE - 1 );
build.c:      victim->race = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->race = value;
build.c:      if( value < -300 || value > 300 )
build.c:         send_to_char( "AC range is -300 to 300.\r\n", ch );
build.c:      victim->armor = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->ac = value;
build.c:            victim->skill_level[ability] = value;
build.c:      victim->top_level = value;
build.c:      victim->armor = ( int )( LEVEL_HERO - value * 2.5 );
build.c:      victim->hitroll = value / 5;
build.c:      victim->damroll = value / 5;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->level = value;
build.c:         victim->pIndexData->ac = ( int )( 100 - value * 2.5 );
build.c:         victim->pIndexData->hitroll = victim->hitroll;
build.c:         victim->pIndexData->damroll = victim->damroll;
build.c:      victim->numattacks = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->numattacks = value;
build.c:      victim->gold = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->gold = value;
build.c:      victim->hitroll = URANGE( 0, value, 85 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->hitroll = victim->hitroll;
build.c:      victim->damroll = URANGE( 0, value, 65 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->damroll = victim->damroll;
build.c:      victim->max_hit = value;
build.c:      victim->max_mana = value;
build.c:      victim->max_move = value;
build.c:      if( value < -1000 || value > 1000 )
build.c:         send_to_char( "Alignment range is -1000 to 1000.\r\n", ch );
build.c:      victim->alignment = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->alignment = value;
build.c:      DISPOSE( victim->pcdata->pwd );
build.c:      victim->pcdata->pwd = str_dup( pwdnew );
build.c:      ch_printf( victim, "Your password has been changed by %s.\r\n", ch->name );
build.c:      victim->pcdata->quest_number = value;
build.c:      victim->pcdata->quest_accum = value;
build.c:      victim->pcdata->quest_curr = value;
build.c:      if( value < -100 || value > 100 )
build.c:         send_to_char( "Value must be in range -100 to +100.\r\n", ch );
build.c:      victim->mental_state = value;
build.c:      if( value < -100 || value > 100 )
build.c:         send_to_char( "Value must be in range -100 to +100.\r\n", ch );
build.c:      victim->emotional_state = value;
build.c:      victim->pcdata->condition[COND_THIRST] = value;
build.c:      victim->pcdata->condition[COND_DRUNK] = value;
build.c:      victim->pcdata->condition[COND_FULL] = value;
build.c:      victim->pcdata->condition[COND_BLOODTHIRST] = value;
build.c:      STRFREE( victim->name );
build.c:      victim->name = STRALLOC( arg3 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         STRFREE( victim->pIndexData->player_name );
build.c:         victim->pIndexData->player_name = QUICKLINK( victim->name );
build.c:      if( victim->pcdata )
build.c:         victim->pcdata->min_snoop = value;
build.c:          * * But it was early in the morning :P --Shaddai 
build.c:         if( victim->pcdata->clan == NULL )
build.c:          * * any membership space. --Shaddai
build.c:            --victim->pcdata->clan->members;
build.c:            if( victim->pcdata->clan->members < 0 )
build.c:               victim->pcdata->clan->members = 0;
build.c:            save_clan( victim->pcdata->clan );
build.c:         STRFREE( victim->pcdata->clan_name );
build.c:         victim->pcdata->clan_name = STRALLOC( "" );
build.c:         victim->pcdata->clan = NULL;
build.c:      if( victim->pcdata->clan != NULL && !IS_IMMORTAL( victim ) )
build.c:         --victim->pcdata->clan->members;
build.c:         if( victim->pcdata->clan->members < 0 )
build.c:            victim->pcdata->clan->members = 0;
build.c:         save_clan( victim->pcdata->clan );
build.c:      STRFREE( victim->pcdata->clan_name );
build.c:      victim->pcdata->clan_name = QUICKLINK( clan->name );
build.c:      victim->pcdata->clan = clan;
build.c:         ++victim->pcdata->clan->members;
build.c:         save_clan( victim->pcdata->clan );
build.c:      STRFREE( victim->short_descr );
build.c:      victim->short_descr = STRALLOC( arg3 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         STRFREE( victim->pIndexData->short_descr );
build.c:         victim->pIndexData->short_descr = QUICKLINK( victim->short_descr );
build.c:      STRFREE( victim->long_descr );
build.c:      victim->long_descr = STRALLOC( buf );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         STRFREE( victim->pIndexData->long_descr );
build.c:         victim->pIndexData->long_descr = QUICKLINK( victim->long_descr );
build.c:         STRFREE( victim->description );
build.c:         victim->description = STRALLOC( arg3 );
build.c:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:            STRFREE( victim->pIndexData->description );
build.c:            victim->pIndexData->description = QUICKLINK( victim->description );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_MOB_DESC;
build.c:      ch->dest_buf = victim;
build.c:      start_editing( ch, victim->description );
build.c:         victim->spec_fun = NULL;
build.c:	   STRFREE( victim->spec_funname );
build.c:	   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:	      victim->pIndexData->spec_fun = NULL;
build.c:		STRFREE( victim->pIndexData->spec_funname );
build.c:	victim->spec_fun = specfun;
build.c:	STRFREE( victim->spec_funname );
build.c:	victim->spec_funname = STRALLOC( arg3 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->spec_fun = victim->spec_fun;
build.c:	   STRFREE( victim->pIndexData->spec_funname );
build.c:	   victim->pIndexData->spec_funname = STRALLOC( arg3 );
build.c:         victim->spec_2 = NULL;
build.c:	   STRFREE( victim->spec_funname2 );
build.c:	   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:	      victim->pIndexData->spec_2 = NULL;
build.c:		STRFREE( victim->pIndexData->spec_funname2 );
build.c:	victim->spec_2 = specfun;
build.c:	STRFREE( victim->spec_funname2 );
build.c:	victim->spec_funname2 = STRALLOC( arg3 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->spec_2 = victim->spec_2;
build.c:	   STRFREE( victim->pIndexData->spec_funname2 );
build.c:	   victim->pIndexData->spec_funname2 = STRALLOC( arg3 );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:            else if( 1 << value == ACT_PROTOTYPE && ch->top_level < sysdata.level_modify_proto )
build.c:               TOGGLE_BIT( victim->act, 1 << value );
build.c:               TOGGLE_BIT( victim->act, 1 << value );
build.c:      if( IS_NPC( victim ) && ( IS_SET( victim->act, ACT_PROTOTYPE ) || ( 1 << value == ACT_PROTOTYPE && protoflag ) ) )
build.c:         victim->pIndexData->act = victim->act;
build.c:            TOGGLE_BIT( victim->pcdata->wanted_flags, 1 << value );
build.c:            TOGGLE_BIT( victim->vip_flags, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->vip_flags = victim->vip_flags;
build.c:            TOGGLE_BIT( victim->affected_by, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->affected_by = victim->affected_by;
build.c:    * save some more finger-leather for setting RIS stuff
build.c:            TOGGLE_BIT( victim->resistant, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->resistant = victim->resistant;
build.c:            TOGGLE_BIT( victim->immune, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->immune = victim->immune;
build.c:            TOGGLE_BIT( victim->susceptible, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->susceptible = victim->susceptible;
build.c:            TOGGLE_BIT( victim->xflags, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->xflags = victim->xflags;
build.c:            TOGGLE_BIT( victim->attacks, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->attacks = victim->attacks;
build.c:            TOGGLE_BIT( victim->defenses, 1 << value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->defenses = victim->defenses;
build.c:      victim->position = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->position = victim->position;
build.c:      victim->defposition = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->defposition = victim->defposition;
build.c:    * save some finger-leather
build.c:    * save some more finger-leather
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->hitnodice = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->hitsizedice = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->hitplus = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->damnodice = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->damsizedice = value;
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->damplus = value;
build.c:       * Make sure they have an area assigned -Druid 
build.c:      if( !victim->pcdata->area )
build.c:      if( !IS_SET( victim->pcdata->area->status, AREA_LOADED ) )
build.c:         SET_BIT( victim->pcdata->area->status, AREA_LOADED );
build.c:         REMOVE_BIT( victim->pcdata->area->status, AREA_LOADED );
build.c:         send_to_char( "Your area set to NOT-LOADED!\r\n", victim );
build.c:            send_to_char( "Area set to NON-LOADED!\r\n", ch );
build.c:         TOGGLE_BIT( victim->speaks, value );
build.c:         REMOVE_BIT( victim->speaks, race_table[victim->race].language );
build.c:         if( !knows_language( victim, victim->speaking, victim ) )
build.c:            victim->speaking = race_table[victim->race].language;
build.c:      else if( IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->speaks = victim->speaks;
build.c:            TOGGLE_BIT( victim->speaking, value );
build.c:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         victim->pIndexData->speaking = victim->speaking;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_mset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_extra: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:          * the object and index-object lists, searching through the
build.c:         ed = ( EXTRA_DESCR_DATA* ) ch->dest_buf;
build.c:         STRFREE( ed->description );
build.c:         ed->description = copy_buffer( ch );
build.c:         tmpobj = ( OBJ_DATA* ) ch->spare_ptr;
build.c:         ch->dest_buf = tmpobj;
build.c:         ch->substate = ch->tempnum;
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_oset: sub_obj_long: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         obj = ( OBJ_DATA* ) ch->dest_buf;
build.c:         STRFREE( obj->description );
build.c:         obj->description = copy_buffer( ch );
build.c:            STRFREE( obj->pIndexData->description );
build.c:            obj->pIndexData->description = QUICKLINK( obj->description );
build.c:         tmpobj = ( OBJ_DATA* ) ch->spare_ptr;
build.c:         ch->substate = ch->tempnum;
build.c:         ch->dest_buf = tmpobj;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:     obj = ( OBJ_DATA* ) ch->dest_buf;
build.c:            do_ostat( ch, obj->name );
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:      strcpy( arg1, obj->name );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      send_to_char( "  slevel spell1 spell2 maxdoses delay (keep low - delay is anoying)\r\n", ch );
build.c:      ch->dest_buf = obj;
build.c:      ch_printf( ch, "Oset mode on. (Editing '%s' vnum %d).\r\n", obj->name, obj->pIndexData->vnum );
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         sprintf( buf, "<&COset &W#%d&w> %%i", obj->pIndexData->vnum );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      obj->value[0] = value;
build.c:         obj->pIndexData->value[0] = value;
build.c:      obj->value[1] = value;
build.c:         obj->pIndexData->value[1] = value;
build.c:      obj->value[2] = value;
build.c:         obj->pIndexData->value[2] = value;
build.c:         if( obj->item_type == ITEM_WEAPON && value != 0 )
build.c:            obj->value[2] = obj->pIndexData->value[1] * obj->pIndexData->value[2];
build.c:      obj->value[3] = value;
build.c:         obj->pIndexData->value[3] = value;
build.c:      obj->value[4] = value;
build.c:         obj->pIndexData->value[4] = value;
build.c:      obj->value[5] = value;
build.c:         obj->pIndexData->value[5] = value;
build.c:      obj->item_type = ( short )value;
build.c:         obj->pIndexData->item_type = obj->item_type;
build.c:            TOGGLE_BIT( obj->extra_flags, 1 << value );
build.c:               obj->pIndexData->extra_flags = obj->extra_flags;
build.c:         obj->pIndexData->extra_flags = obj->extra_flags;
build.c:            TOGGLE_BIT( obj->wear_flags, 1 << value );
build.c:         obj->pIndexData->wear_flags = obj->wear_flags;
build.c:      obj->level = value;
build.c:      obj->weight = value;
build.c:         obj->pIndexData->weight = value;
build.c:      obj->cost = value;
build.c:         obj->pIndexData->cost = value;
build.c:         obj->pIndexData->rent = value;
build.c:         obj->pIndexData->layers = value;
build.c:      obj->timer = value;
build.c:      STRFREE( obj->name );
build.c:      obj->name = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->name );
build.c:         obj->pIndexData->name = QUICKLINK( obj->name );
build.c:      STRFREE( obj->short_descr );
build.c:      obj->short_descr = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->short_descr );
build.c:         obj->pIndexData->short_descr = QUICKLINK( obj->short_descr );
build.c:         if( str_infix( "rename", obj->name ) )
build.c:            sprintf( buf, "%s %s", obj->name, "rename" );
build.c:            STRFREE( obj->name );
build.c:            obj->name = STRALLOC( buf );
build.c:      STRFREE( obj->action_desc );
build.c:      obj->action_desc = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->action_desc );
build.c:         obj->pIndexData->action_desc = QUICKLINK( obj->action_desc );
build.c:         STRFREE( obj->description );
build.c:         obj->description = STRALLOC( arg3 );
build.c:            STRFREE( obj->pIndexData->description );
build.c:            obj->pIndexData->description = QUICKLINK( obj->description );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_LONG;
build.c:      ch->dest_buf = obj;
build.c:      start_editing( ch, obj->description );
build.c:      paf->type = -1;
build.c:      paf->duration = -1;
build.c:      paf->location = loc;
build.c:      paf->modifier = value;
build.c:      paf->bitvector = 0;
build.c:      paf->next = NULL;
build.c:            for( vch = first_char; vch; vch = vch->next )
build.c:               for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:                  if( eq->pIndexData == obj->pIndexData && eq->wear_loc != WEAR_NONE )
build.c:         LINK( paf, obj->pIndexData->first_affect, obj->pIndexData->last_affect, next, prev );
build.c:         LINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c:         pObjIndex = obj->pIndexData;
build.c:         for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c:               UNLINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
build.c:               if( paf->location != APPLY_WEARSPELL && paf->location != APPLY_REMOVESPELL && paf->location != APPLY_STRIPSN
build.c:                && paf->location != APPLY_WEAPONSPELL )
build.c:                  for( vch = first_char; vch; vch = vch->next )
build.c:                     for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:                        if( eq->pIndexData == pObjIndex && eq->wear_loc != WEAR_NONE )
build.c:               --top_affect;
build.c:         for( paf = obj->first_affect; paf; paf = paf->next )
build.c:               UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c:               --top_affect;
build.c:      if( obj->timer )
build.c:      if( obj->item_type == ITEM_PAPER )
build.c:         ed = SetOExtraProto( obj->pIndexData, arg3 );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:      start_editing( ch, ed->description );
build.c:      if( obj->timer )
build.c:      if( obj->item_type == ITEM_PAPER )
build.c:         ed = SetOExtraProto( obj->pIndexData, obj->name );
build.c:         ed = SetOExtra( obj, obj->name );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:      start_editing( ch, ed->description );
build.c:         if( DelOExtraProto( obj->pIndexData, arg3 ) )
build.c:    * save some finger-leather
build.c:    *                  -Thoric
build.c:   tmp = -1;
build.c:   switch ( obj->item_type )
build.c:            value = -1;
build.c:               send_to_char( "   none, lightsaber, vibro-blade, blaster, force pike, bowcaster, bludgeon\r\n", ch );
build.c:            value = -1;
build.c:            value = -1;
build.c:               send_to_char( "   non-adegan, kathracite, relacite, danite, mephite, ponite, illum, corusca\r\n", ch );
build.c:      obj->value[tmp] = value;
build.c:         obj->pIndexData->value[tmp] = value;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_oset;
build.c:      if( IS_SET( location->room_flags, ROOM_PROTOTYPE ) )
build.c:      location->room_flags = value;
build.c:         SET_BIT( location->room_flags, ROOM_PROTOTYPE );
build.c:      location->sector_type = value;
build.c: * Returns value 0 - 9 based on directional text.
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:	location = ( ROOM_INDEX_DATA* ) ch->dest_buf;
build.c:            bug( "redit: sub_room_desc: NULL ch->dest_buf", 0 );
build.c:            location = ch->in_room;
build.c:         STRFREE( location->description );
build.c:         location->description = copy_buffer( ch );
build.c:         ch->substate = ch->tempnum;
build.c:	ed = ( EXTRA_DESCR_DATA* ) ch->dest_buf;
build.c:            bug( "redit: sub_room_extra: NULL ch->dest_buf", 0 );
build.c:         STRFREE( ed->description );
build.c:         ed->description = copy_buffer( ch );
build.c:         ch->substate = ch->tempnum;
build.c:   location = ch->in_room;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->substate = SUB_NONE;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:      STRFREE( location->name );
build.c:      location->name = STRALLOC( argument );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_DESC;
build.c:      ch->dest_buf = location;
build.c:      start_editing( ch, location->description );
build.c:      location->tunnel = URANGE( 0, atoi( argument ), 1000 );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:      start_editing( ch, ed->description );
build.c:      if( !location->first_reset )
build.c:      for( pReset = location->first_reset; pReset; pReset = pReset->next )
build.c:            TOGGLE_BIT( location->room_flags, 1 << value );
build.c:      location->tele_delay = atoi( argument );
build.c:      location->tele_vnum = atoi( argument );
build.c:      location->sector_type = atoi( argument );
build.c:      if( location->sector_type < 0 || location->sector_type >= SECT_MAX )
build.c:         location->sector_type = 1;
build.c:      xit->key = value;
build.c:      STRFREE( xit->keyword );
build.c:      xit->keyword = STRALLOC( argument );
build.c:         sprintf( buf, "Flags for exit direction: %d  Keywords: %s  Key: %d\r\n[ ", xit->vdir, xit->keyword, xit->key );
build.c:            if( IS_SET( xit->exit_info, 1 << value ) )
build.c:            TOGGLE_BIT( xit->exit_info, 1 << value );
build.c:            edir = xit->vdir;
build.c:         send_to_char( "Non-existant room.\r\n", ch );
build.c:      if( get_trust( ch ) <= LEVEL_IMMORTAL && tmp->area != location->area )
build.c:         if( addexit && xit && get_exit_to( location, edir, tmp->vnum ) )
build.c:         xit->keyword = STRALLOC( "" );
build.c:         xit->description = STRALLOC( "" );
build.c:         xit->key = -1;
build.c:         xit->exit_info = 0;
build.c:      if( xit->to_room != tmp )
build.c:         xit->to_room = tmp;
build.c:         xit->vnum = evnum;
build.c:         texit = get_exit_to( xit->to_room, rev_dir[edir], location->vnum );
build.c:            texit->rexit = xit;
build.c:            xit->rexit = texit;
build.c:         xit->exit_info = atoi( arg3 );
build.c:            xit->key = ekey;
build.c:            STRFREE( xit->keyword );
build.c:            xit->keyword = STRALLOC( argument );
build.c:    * Twisted and evil, but works           -Thoric
build.c:         send_to_char( "Create, change or remove a two-way exit.\r\n", ch );
build.c:            edir = nxit->vdir;
build.c:         vnum = nxit->vnum;
build.c:            sprintf( rvnum, "%d", tmploc->vnum );
build.c:         if( nxit->to_room )
build.c:            rxit = get_exit( nxit->to_room, rev_dir[edir] );
build.c:         vnum = nxit->vnum;
build.c:            sprintf( rvnum, "%d", tmploc->vnum );
build.c:         if( nxit->to_room )
build.c:            rxit = get_exit( nxit->to_room, rev_dir[edir] );
build.c:         xit->distance = URANGE( 1, atoi( argument ), 50 );
build.c:         STRFREE( xit->description );
build.c:            xit->description = STRALLOC( "" );
build.c:            xit->description = STRALLOC( buf );
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_redit;
build.c:   vnum = is_number( arg ) ? atoi( arg ) : -1;
build.c:   if( vnum == -1 || !argument || argument[0] == '\0' )
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( vnum < pArea->low_o_vnum || vnum > pArea->hi_o_vnum )
build.c:   vnum = is_number( arg ) ? atoi( arg ) : -1;
build.c:   if( vnum == -1 || !argument || argument[0] == '\0' )
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( vnum < pArea->low_m_vnum || vnum > pArea->hi_m_vnum )
build.c:   char_to_room( mob, ch->in_room );
build.c: * Simple but nice and handle line editor.			-Thoric
build.c:   if( ( d = ch->desc ) == NULL )
build.c:   if( d->connected != CON_EDITING )
build.c:      bug( "%s: d->connected != CON_EDITING", __FUNCTION__ );
build.c:   if( ch->substate <= SUB_PAUSE )
build.c:      bug( "%s: illegal ch->substate (%d)", __FUNCTION__, ch->substate );
build.c:      d->connected = CON_PLAYING;
build.c:   if( !ch->editor )
build.c:      d->connected = CON_PLAYING;
build.c:   edit = ch->editor;
build.c:         send_to_char( "Editing commands\r\n---------------------------------\r\n", ch );
build.c:         edit->numlines = 0;
build.c:         edit->on_line = 0;
build.c:         for( x = 0; x < edit->numlines; x++ )
build.c:            lwptr = edit->line[x];
build.c:               if( lineln + wptr - edit->line[x] > 79 )
build.c:       * added format command - shogar 
build.c:         for( x = 0; x < edit->numlines; x++ )
build.c:            strncpy( temp_buf + p, edit->line[x], MAX_STRING_LENGTH + max_buf_lines - p );
build.c:            p += strlen( edit->line[x] );
build.c:         edit->on_line = 0;
build.c:         edit->numlines = 0;
build.c:               p--;
build.c:               edit->line[edit->on_line][ep] = temp_buf[x];
build.c:            edit->line[edit->on_line][ep] = '\0';
build.c:            edit->on_line++;
build.c:            edit->numlines++;
build.c:         if( edit->numlines >= max_buf_lines )
build.c:               line = atoi( argument + 2 ) - 1;
build.c:               line = edit->on_line;
build.c:               line = edit->on_line;
build.c:            if( line < 0 || line > edit->numlines )
build.c:               for( x = ++edit->numlines; x > line; x-- )
build.c:                  mudstrlcpy( edit->line[x], edit->line[x - 1], MAX_STRING_LENGTH );
build.c:               mudstrlcpy( edit->line[line], "", MAX_STRING_LENGTH );
build.c:         if( edit->numlines == 0 )
build.c:               line = atoi( argument + 2 ) - 1;
build.c:               line = edit->on_line;
build.c:               line = edit->on_line;
build.c:            if( line < 0 || line > edit->numlines )
build.c:               if( line == 0 && edit->numlines == 1 )
build.c:                  edit->numlines = 0;
build.c:                  edit->on_line = 0;
build.c:               for( x = line; x < ( edit->numlines - 1 ); x++ )
build.c:                  mudstrlcpy( edit->line[x], edit->line[x + 1], MAX_STRING_LENGTH );
build.c:               mudstrlcpy( edit->line[edit->numlines--], "", MAX_STRING_LENGTH );
build.c:               if( edit->on_line > edit->numlines )
build.c:                  edit->on_line = edit->numlines;
build.c:         if( edit->numlines == 0 )
build.c:               line = atoi( argument + 2 ) - 1;
build.c:               line = edit->on_line;
build.c:            if( line < 0 || line > edit->numlines )
build.c:               edit->on_line = line;
build.c:         if( edit->numlines == 0 )
build.c:            send_to_char( "------------------\r\n", ch );
build.c:            for( x = 0; x < edit->numlines; x++ )
build.c:               ch_printf( ch, "%2d> %s\r\n", x + 1, edit->line[x] );
build.c:            send_to_char( "------------------\r\n> ", ch );
build.c:         int substate = ch->substate;
build.c:         last_cmd = ch->last_cmd;
build.c:         ch->substate = SUB_RESTRICTED;
build.c:         ch->substate = substate;
build.c:         ch->last_cmd = last_cmd;
build.c:         d->connected = CON_PLAYING;
build.c:         if( !ch->last_cmd )
build.c:         ( *ch->last_cmd ) ( ch, "" );
build.c:   if( edit->size + strlen( argument ) + 1 >= MAX_STRING_LENGTH - 1 )
build.c:      mudstrlcpy( edit->line[edit->on_line++], buf, MAX_STRING_LENGTH );
build.c:      if( edit->on_line > edit->numlines )
build.c:         edit->numlines++;
build.c:      if( edit->numlines > max_buf_lines )
build.c:         edit->numlines = max_buf_lines;
build.c:      d->connected = CON_PLAYING;
build.c:      if( !ch->last_cmd )
build.c:      ( *ch->last_cmd ) ( ch, "" );
build.c:   if( get_trust( ch ) >= LEVEL_AVATAR && ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
build.c:      tarea = ch->pcdata->area;
build.c:      sprintf( taf, "%s.are", capitalize( ch->name ) );
build.c:         for( tmp = first_build; tmp; tmp = tmp->next )
build.c:            if( !str_cmp( taf, tmp->filename ) )
build.c:         sprintf( buf, "Creating area entry for %s", ch->name );
build.c:         log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c:         tarea->first_room = tarea->last_room = NULL;
build.c:         sprintf( buf, "{PROTO} %s's area in progress", ch->name );
build.c:         tarea->name = str_dup( buf );
build.c:         tarea->filename = str_dup( taf );
build.c:         sprintf( buf2, "%s", ch->name );
build.c:         tarea->author = STRALLOC( buf2 );
build.c:         tarea->age = 0;
build.c:         tarea->nplayer = 0;
build.c:         sprintf( buf, "Updating area entry for %s", ch->name );
build.c:         log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c:      tarea->low_r_vnum = ch->pcdata->r_range_lo;
build.c:      tarea->low_o_vnum = ch->pcdata->o_range_lo;
build.c:      tarea->low_m_vnum = ch->pcdata->m_range_lo;
build.c:      tarea->hi_r_vnum = ch->pcdata->r_range_hi;
build.c:      tarea->hi_o_vnum = ch->pcdata->o_range_hi;
build.c:      tarea->hi_m_vnum = ch->pcdata->m_range_hi;
build.c:      ch->pcdata->area = tarea;
build.c:      ch->pcdata->area = NULL;
build.c:      if( !ch->pcdata->area )
build.c:       || ( is_name( buf, ch->pcdata->bestowments ) && get_trust( ch ) >= sysdata.level_modify_proto ) )
build.c:      for( tmp = first_area; tmp; tmp = tmp->next )
build.c:         if( !str_cmp( buf, tmp->filename ) )
build.c:      for( tmp = first_build; tmp; tmp = tmp->next )
build.c:         if( !str_cmp( buf, tmp->filename ) )
build.c:            if( get_trust( ch ) >= LEVEL_GREATER || is_name( tmp->filename, ch->pcdata->bestowments ) )
build.c:   ch->pcdata->area = tarea;
build.c:   ch_printf( ch, "Assigning you: %s\r\n", tarea->name );
build.c:   for( ed = room->first_extradesc; ed; ed = ed->next )
build.c:      if( is_name( keywords, ed->keyword ) )
build.c:      LINK( ed, room->first_extradesc, room->last_extradesc, next, prev );
build.c:      ed->keyword = STRALLOC( keywords );
build.c:      ed->description = STRALLOC( "" );
build.c:   for( rmed = room->first_extradesc; rmed; rmed = rmed->next )
build.c:      if( is_name( keywords, rmed->keyword ) )
build.c:   UNLINK( rmed, room->first_extradesc, room->last_extradesc, next, prev );
build.c:   STRFREE( rmed->keyword );
build.c:   STRFREE( rmed->description );
build.c:   top_ed--;
build.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c:      if( is_name( keywords, ed->keyword ) )
build.c:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:      ed->keyword = STRALLOC( keywords );
build.c:      ed->description = STRALLOC( "" );
build.c:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c:      if( is_name( keywords, rmed->keyword ) )
build.c:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:   STRFREE( rmed->keyword );
build.c:   STRFREE( rmed->description );
build.c:   top_ed--;
build.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c:      if( is_name( keywords, ed->keyword ) )
build.c:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:      ed->keyword = STRALLOC( keywords );
build.c:      ed->description = STRALLOC( "" );
build.c:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c:      if( is_name( keywords, rmed->keyword ) )
build.c:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:   STRFREE( rmed->keyword );
build.c:   STRFREE( rmed->description );
build.c:   top_ed--;
build.c:   fprintf( fpout, "ExDescKey    %s~\n", ed->keyword );
build.c:   if( ed->description && ed->description[0] != '\0' )
build.c:      fprintf( fpout, "ExDesc       %s~\n", strip_cr( ed->description ) );
build.c:   fprintf( fpout, "Direction %s~\n", strip_cr( dir_name[pexit->vdir] ) );
build.c:   fprintf( fpout, "ToRoom    %d\n", pexit->vnum );
build.c:   if( pexit->key != -1 && pexit->key > 0 )
build.c:      fprintf( fpout, "Key       %d\n", pexit->key );
build.c:   if( pexit->distance > 1 )
build.c:      fprintf( fpout, "Distance  %d\n", pexit->distance );
build.c:   if( pexit->description && pexit->description[0] != '\0' )
build.c:      fprintf( fpout, "Desc      %s~\n", strip_cr( pexit->description ) );
build.c:   if( pexit->keyword && pexit->keyword[0] != '\0' )
build.c:      fprintf( fpout, "Keywords  %s~\n", strip_cr( pexit->keyword ) );
build.c:   if( pexit->exit_info )
build.c:      fprintf( fpout, "Flags     %s~\n", flag_string( pexit->exit_info, ex_flags ) );
build.c:   if( paf->type < 0 || paf->type >= top_sn )
build.c:               paf->type,
build.c:               paf->duration,
build.c:               ( ( paf->location == APPLY_WEAPONSPELL
build.c:                   || paf->location == APPLY_WEARSPELL
build.c:                   || paf->location == APPLY_REMOVESPELL
build.c:                   || paf->location == APPLY_STRIPSN )
build.c:                 && IS_VALID_SN( paf->modifier ) )
build.c:               ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
build.c:               skill_table[paf->type]->name,
build.c:               paf->duration,
build.c:               ( ( paf->location == APPLY_WEAPONSPELL
build.c:                   || paf->location == APPLY_WEARSPELL
build.c:                   || paf->location == APPLY_REMOVESPELL
build.c:                   || paf->location == APPLY_STRIPSN )
build.c:                 && IS_VALID_SN( paf->modifier ) )
build.c:               ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
build.c:   if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c:      fprintf( fpout, "Progtype  %s~\n", mprog_type_to_name( mprog->type ) );
build.c:      fprintf( fpout, "Arglist   %s~\n", mprog->arglist );
build.c:      if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c:         fprintf( fpout, "Comlist   %s~\n", strip_cr( mprog->comlist ) );
build.c:      switch ( UPPER( reset->command ) )  /* extra arg1 arg2 arg3 */
build.c:                     UPPER( reset->command ), reset->extra, reset->arg1, reset->arg2, reset->arg3 );
build.c:                     UPPER( reset->command ), reset->extra, reset->arg1, reset->arg2 );
build.c:      save_reset_level( fpout, reset->first_reset, level + 1 );
build.c:       * where we go next depends on if this is a top-level reset or not - for some reason 
build.c:         reset = reset->next;
build.c:         reset = reset->next_reset;
build.c:      REMOVE_BIT( room->room_flags, ROOM_PROTOTYPE );
build.c:      for( victim = room->first_person; victim; victim = vnext )
build.c:         vnext = victim->next_in_room;
build.c:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:      for( obj = room->first_content; obj; obj = obj_next )
build.c:         obj_next = obj->next_content;
build.c:         if( IS_SET( obj->extra_flags, ITEM_PROTOTYPE ) )
build.c:   //REMOVE_BIT( room->room_flags, ROOM_BFS_MARK );
build.c:   fprintf( fpout, "Vnum     %d\n", room->vnum );
build.c:   fprintf( fpout, "Name     %s~\n", room->name );
build.c:   fprintf( fpout, "Sector   %s~\n", strip_cr( sector_name[room->sector_type] ) );
build.c:   if( room->room_flags )
build.c:      fprintf( fpout, "Flags    %s~\n", flag_string( room->room_flags, r_flags ) );
build.c:   if( room->tele_delay > 0 || room->tele_vnum > 0 || room->tunnel > 0 )
build.c:      fprintf( fpout, "Stats    %d %d %d\n", room->tele_delay, room->tele_vnum, room->tunnel );
build.c:   if( room->description && room->description[0] != '\0' )
build.c:      fprintf( fpout, "Desc     %s~\n", strip_cr( room->description ) );
build.c:   for( xit = room->first_exit; xit; xit = xit->next )
build.c:      if( IS_SET( xit->exit_info, EX_PORTAL ) ) /* don't fold portals */
build.c:   save_reset_level( fpout, room->first_reset, 0 );
build.c:  // for( paf = room->first_permaffect; paf; paf = paf->next )
build.c:   for( ed = room->first_extradesc; ed; ed = ed->next )
build.c:   if( room->mudprogs )
build.c:      for( mprog = room->mudprogs; mprog; mprog = mprog->next )
build.c:      REMOVE_BIT( pObjIndex->extra_flags, ITEM_PROTOTYPE );
build.c:   fprintf( fpout, "Vnum     %d\n", pObjIndex->vnum );
build.c:   fprintf( fpout, "Keywords %s~\n", pObjIndex->name );
build.c:   fprintf( fpout, "Type     %s~\n", o_types[pObjIndex->item_type] );
build.c:   fprintf( fpout, "Short    %s~\n", pObjIndex->short_descr );
build.c:   if( pObjIndex->description && pObjIndex->description[0] != '\0' )
build.c:      fprintf( fpout, "Long     %s~\n", pObjIndex->description );
build.c:   if( pObjIndex->action_desc && pObjIndex->action_desc[0] != '\0' )
build.c:      fprintf( fpout, "Action   %s~\n", pObjIndex->action_desc );
build.c:   if( pObjIndex->extra_flags )
build.c:      fprintf( fpout, "Flags    %s~\n", flag_string( pObjIndex->extra_flags, o_flags ) );
build.c:   if( pObjIndex->wear_flags )
build.c:      fprintf( fpout, "WFlags   %s~\n", flag_string( pObjIndex->wear_flags, w_flags ) );
build.c:   val0 = pObjIndex->value[0];
build.c:   val1 = pObjIndex->value[1];
build.c:   val2 = pObjIndex->value[2];
build.c:   val3 = pObjIndex->value[3];
build.c:   val4 = pObjIndex->value[4];
build.c:   val5 = pObjIndex->value[5];
build.c:   switch ( pObjIndex->item_type )
build.c:   fprintf( fpout, "Stats    %d %d %d %d %d\n", pObjIndex->weight,
build.c:            pObjIndex->cost, pObjIndex->rent ? pObjIndex->rent : ( int )( pObjIndex->cost / 10 ),
build.c:            pObjIndex->level, pObjIndex->layers );
build.c:   for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c:   switch ( pObjIndex->item_type )
build.c:                  IS_VALID_SN( pObjIndex->value[1] ) ?
build.c:                  skill_table[pObjIndex->value[1]]->name : "NONE",
build.c:                  IS_VALID_SN( pObjIndex->value[2] ) ?
build.c:                  skill_table[pObjIndex->value[2]]->name : "NONE",
build.c:                  IS_VALID_SN( pObjIndex->value[3] ) ? skill_table[pObjIndex->value[3]]->name : "NONE" );
build.c:                  IS_VALID_SN( pObjIndex->value[3] ) ? skill_table[pObjIndex->value[3]]->name : "NONE" );
build.c:                  IS_VALID_SN( pObjIndex->value[4] ) ?
build.c:                  skill_table[pObjIndex->value[4]]->name : "NONE",
build.c:                  IS_VALID_SN( pObjIndex->value[5] ) ? skill_table[pObjIndex->value[5]]->name : "NONE" );
build.c:   for( ed = pObjIndex->first_extradesc; ed; ed = ed->next )
build.c:   if( pObjIndex->mudprogs )
build.c:      for( mprog = pObjIndex->mudprogs; mprog; mprog = mprog->next )
build.c:      REMOVE_BIT( pMobIndex->act, ACT_PROTOTYPE );
build.c:   fprintf( fpout, "Vnum       %d\n", pMobIndex->vnum );
build.c:   fprintf( fpout, "Keywords   %s~\n", pMobIndex->player_name );
build.c:   fprintf( fpout, "Short      %s~\n", pMobIndex->short_descr );
build.c:   if( pMobIndex->long_descr && pMobIndex->long_descr[0] != '\0' )
build.c:      fprintf( fpout, "Long       %s~\n", strip_cr( pMobIndex->long_descr ) );
build.c:   if( pMobIndex->description && pMobIndex->description[0] != '\0' )
build.c:      fprintf( fpout, "Desc       %s~\n", strip_cr( pMobIndex->description ) );
build.c:   fprintf( fpout, "Race       %s~\n", npc_race[pMobIndex->race] );
build.c:   fprintf( fpout, "Position   %s~\n", npc_position[pMobIndex->position] );
build.c:   fprintf( fpout, "DefPos     %s~\n", npc_position[pMobIndex->defposition] );
build.c:   if( pMobIndex->spec_fun && pMobIndex->spec_funname && pMobIndex->spec_funname[0] != '\0' )
build.c:      fprintf( fpout, "Specfun    %s~\n", pMobIndex->spec_funname );
build.c:   if( pMobIndex->spec_2 && pMobIndex->spec_funname2 && pMobIndex->spec_funname2[0] != '\0' )
build.c:      fprintf( fpout, "Specfun2    %s~\n", pMobIndex->spec_funname2 );
build.c:   fprintf( fpout, "Gender     %s~\n", npc_sex[pMobIndex->sex] );
build.c:   fprintf( fpout, "Actflags   %s~\n", flag_string( pMobIndex->act, act_flags ) );
build.c:   if( pMobIndex->affected_by )
build.c:      fprintf( fpout, "Affected   %s~\n", flag_string( pMobIndex->affected_by, a_flags ) );
build.c:   fprintf( fpout, "Stats1     %d %d %d %d %d %d\n", pMobIndex->alignment, pMobIndex->level, pMobIndex->mobthac0,
build.c:            pMobIndex->ac, pMobIndex->gold, pMobIndex->exp );
build.c:   fprintf( fpout, "Stats2     %d %d %d\n", pMobIndex->hitnodice, pMobIndex->hitsizedice, pMobIndex->hitplus );
build.c:   fprintf( fpout, "Stats3     %d %d %d\n", pMobIndex->damnodice, pMobIndex->damsizedice, pMobIndex->damplus );
build.c:            pMobIndex->height, pMobIndex->weight, pMobIndex->numattacks, pMobIndex->hitroll, pMobIndex->damroll );
build.c:            pMobIndex->perm_str,
build.c:            pMobIndex->perm_int,
build.c:            pMobIndex->perm_wis, pMobIndex->perm_dex, pMobIndex->perm_con, pMobIndex->perm_cha, pMobIndex->perm_lck, pMobIndex->perm_frc );
build.c:            pMobIndex->saving_poison_death,
build.c:            pMobIndex->saving_wand, pMobIndex->saving_para_petri, pMobIndex->saving_breath, pMobIndex->saving_spell_staff );
build.c:   if( pMobIndex->speaks )
build.c:      fprintf( fpout, "Speaks     %s~\n", flag_string( pMobIndex->speaks, lang_names_save ) );
build.c:   if( pMobIndex->speaking )
build.c:      fprintf( fpout, "Speaking   %s~\n", flag_string( pMobIndex->speaking, lang_names_save ) );
build.c:   if( pMobIndex->xflags )
build.c:      fprintf( fpout, "Bodyparts  %s~\n", flag_string( pMobIndex->xflags, part_flags ) );
build.c:   if( pMobIndex->resistant )
build.c:      fprintf( fpout, "Resist     %s~\n", flag_string( pMobIndex->resistant, ris_flags ) );
build.c:   if( pMobIndex->immune )
build.c:      fprintf( fpout, "Immune     %s~\n", flag_string( pMobIndex->immune, ris_flags ) );
build.c:   if( pMobIndex->susceptible )
build.c:      fprintf( fpout, "Suscept    %s~\n", flag_string( pMobIndex->susceptible, ris_flags ) );
build.c:   if( pMobIndex->attacks )
build.c:      fprintf( fpout, "Attacks    %s~\n", flag_string( pMobIndex->attacks, attack_flags ) );
build.c:   if( pMobIndex->defenses )
build.c:      fprintf( fpout, "Defenses   %s~\n", flag_string( pMobIndex->defenses, defense_flags ) );
build.c:   if( pMobIndex->vip_flags )
build.c:      fprintf( fpout, "VIPFlags   %s~\n", flag_string( pMobIndex->vip_flags, planet_flags ) );
build.c:   if( ( pShop = pMobIndex->pShop ) != NULL )
build.c:               pShop->buy_type[0], pShop->buy_type[1], pShop->buy_type[2], pShop->buy_type[3], pShop->buy_type[4],
build.c:               pShop->profit_buy, pShop->profit_sell, pShop->open_hour, pShop->close_hour );
build.c:   if( ( pRepair = pMobIndex->rShop ) != NULL )
build.c:               pRepair->fix_type[0], pRepair->fix_type[1], pRepair->fix_type[2], pRepair->profit_fix, pRepair->shop_type,
build.c:               pRepair->open_hour, pRepair->close_hour );
build.c:   if( pMobIndex->mudprogs )
build.c:      for( mprog = pMobIndex->mudprogs; mprog; mprog = mprog->next )
build.c:      REMOVE_BIT( tarea->flags, AFLAG_PROTOTYPE );
build.c:   fprintf( fpout, "Version      %d\n", tarea->version );
build.c:   fprintf( fpout, "Name         %s~\n", tarea->name );
build.c:   fprintf( fpout, "Author       %s~\n", tarea->author );
build.c:            tarea->low_soft_range, tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c:   if( tarea->high_economy || tarea->low_economy )
build.c:      fprintf( fpout, "Economy      %d %d\n", tarea->high_economy, tarea->low_economy );
build.c:   if( tarea->resetmsg )   
build.c:      fprintf( fpout, "ResetMsg     %s~\n", tarea->resetmsg );
build.c:   if( tarea->reset_frequency )
build.c:      fprintf( fpout, "ResetFreq    %d\n", tarea->reset_frequency );
build.c:   if( tarea->flags )
build.c:      fprintf( fpout, "Flags        %s~\n", flag_string( tarea->flags, area_flags ) );
build.c:   tarea->version = AREA_VERSION_WRITE;
build.c:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; ++vnum )
build.c:   for( vnum = tarea->low_o_vnum; vnum <= tarea->hi_o_vnum; ++vnum )
build.c:   for( vnum = tarea->low_r_vnum; vnum <= tarea->hi_r_vnum; ++vnum )
build.c:   sprintf( buf, "Saving %s...", tarea->filename );
build.c:      REMOVE_BIT( tarea->flags, AFLAG_PROTOTYPE );
build.c:   fprintf( fpout, "#AREA   %s~\n\n\n\n", tarea->name );
build.c:   fprintf( fpout, "#AUTHOR %s~\n\n", tarea->author );
build.c:   fprintf( fpout, "%d %d %d %d\n", tarea->low_soft_range,
build.c:            tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c:   if( tarea->resetmsg )   /* Rennard */
build.c:      fprintf( fpout, "#RESETMSG %s~\n\n", tarea->resetmsg );
build.c:   if( tarea->reset_frequency )
build.c:      fprintf( fpout, "#FLAGS\n%d %d\n\n", tarea->flags, tarea->reset_frequency );
build.c:      fprintf( fpout, "#FLAGS\n%d\n\n", tarea->flags );
build.c:   fprintf( fpout, "#ECONOMY %d %d\n\n", tarea->high_economy, tarea->low_economy );
build.c:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c:         REMOVE_BIT( pMobIndex->act, ACT_PROTOTYPE );
build.c:      if( pMobIndex->perm_str != 13 || pMobIndex->perm_int != 13
build.c:          || pMobIndex->perm_wis != 13 || pMobIndex->perm_dex != 13
build.c:          || pMobIndex->perm_con != 13 || pMobIndex->perm_cha != 13
build.c:          || pMobIndex->perm_lck != 13
build.c:          || pMobIndex->hitroll != 0 || pMobIndex->damroll != 0
build.c:          || pMobIndex->race != 0
build.c:          || pMobIndex->attacks != 0 || pMobIndex->defenses != 0
build.c:          || pMobIndex->height != 0 || pMobIndex->weight != 0
build.c:          || pMobIndex->speaks != 0 || pMobIndex->speaking != 0
build.c:          || pMobIndex->xflags != 0 || pMobIndex->numattacks != 1 || pMobIndex->vip_flags != 0 )
build.c:      fprintf( fpout, "%s~\n", pMobIndex->player_name );
build.c:      fprintf( fpout, "%s~\n", pMobIndex->short_descr );
build.c:      fprintf( fpout, "%s~\n", strip_cr( pMobIndex->long_descr ) );
build.c:      fprintf( fpout, "%s~\n", strip_cr( pMobIndex->description ) );
build.c:      fprintf( fpout, "%d %d %d %c\n", pMobIndex->act,
build.c:               pMobIndex->affected_by, pMobIndex->alignment, complexmob ? 'Z' : 'S' );
build.c:      fprintf( fpout, "%d %d %d ", pMobIndex->level, pMobIndex->mobthac0, pMobIndex->ac );
build.c:      fprintf( fpout, "%dd%d+%d ", pMobIndex->hitnodice, pMobIndex->hitsizedice, pMobIndex->hitplus );
build.c:      fprintf( fpout, "%dd%d+%d\n", pMobIndex->damnodice, pMobIndex->damsizedice, pMobIndex->damplus );
build.c:      fprintf( fpout, "%d 0\n", pMobIndex->gold );
build.c:      fprintf( fpout, "%d %d %d\n", pMobIndex->position, pMobIndex->defposition, pMobIndex->sex );
build.c:                  pMobIndex->perm_str,
build.c:                  pMobIndex->perm_int,
build.c:                  pMobIndex->perm_wis, pMobIndex->perm_dex, pMobIndex->perm_con, pMobIndex->perm_cha, pMobIndex->perm_lck );
build.c:                  pMobIndex->saving_poison_death,
build.c:                  pMobIndex->saving_wand,
build.c:                  pMobIndex->saving_para_petri, pMobIndex->saving_breath, pMobIndex->saving_spell_staff );
build.c:                  pMobIndex->race,
build.c:                  pMobIndex->height, pMobIndex->weight, pMobIndex->speaks, pMobIndex->speaking, pMobIndex->numattacks );
build.c:                  pMobIndex->hitroll,
build.c:                  pMobIndex->damroll,
build.c:                  pMobIndex->xflags,
build.c:                  pMobIndex->resistant, pMobIndex->immune, pMobIndex->susceptible, pMobIndex->attacks, pMobIndex->defenses );
build.c:         fprintf( fpout, "%d 0 0 0 0 0 0 0\n", pMobIndex->vip_flags );
build.c:      if( pMobIndex->mudprogs )
build.c:         for( mprog = pMobIndex->mudprogs; mprog; mprog = mprog->next )
build.c:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c:               if( mprog->type == IN_FILE_PROG )
build.c:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c:   if( install && vnum < tarea->hi_m_vnum )
build.c:      tarea->hi_m_vnum = vnum - 1;
build.c:   for( vnum = tarea->low_o_vnum; vnum <= tarea->hi_o_vnum; vnum++ )
build.c:         REMOVE_BIT( pObjIndex->extra_flags, ITEM_PROTOTYPE );
build.c:      fprintf( fpout, "%s~\n", pObjIndex->name );
build.c:      fprintf( fpout, "%s~\n", pObjIndex->short_descr );
build.c:      fprintf( fpout, "%s~\n", pObjIndex->description );
build.c:      fprintf( fpout, "%s~\n", pObjIndex->action_desc );
build.c:      if( pObjIndex->layers )
build.c:         fprintf( fpout, "%d %d %d %d\n", pObjIndex->item_type,
build.c:                  pObjIndex->extra_flags, pObjIndex->wear_flags, pObjIndex->layers );
build.c:         fprintf( fpout, "%d %d %d\n", pObjIndex->item_type, pObjIndex->extra_flags, pObjIndex->wear_flags );
build.c:      val0 = pObjIndex->value[0];
build.c:      val1 = pObjIndex->value[1];
build.c:      val2 = pObjIndex->value[2];
build.c:      val3 = pObjIndex->value[3];
build.c:      val4 = pObjIndex->value[4];
build.c:      val5 = pObjIndex->value[5];
build.c:      switch ( pObjIndex->item_type )
build.c:               val1 = skill_table[val1]->slot;
build.c:               val2 = skill_table[val2]->slot;
build.c:               val3 = skill_table[val3]->slot;
build.c:               val3 = skill_table[val3]->slot;
build.c:               val4 = skill_table[val4]->slot;
build.c:               val5 = skill_table[val5]->slot;
build.c:      fprintf( fpout, "%d %d %d\n", pObjIndex->weight,
build.c:               pObjIndex->cost, pObjIndex->rent ? pObjIndex->rent : ( int )( pObjIndex->cost / 10 ) );
build.c:      for( ed = pObjIndex->first_extradesc; ed; ed = ed->next )
build.c:         fprintf( fpout, "E\n%s~\n%s~\n", ed->keyword, strip_cr( ed->description ) );
build.c:      for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c:         fprintf( fpout, "A\n%d %d\n", paf->location,
build.c:                  ( ( paf->location == APPLY_WEAPONSPELL
build.c:                      || paf->location == APPLY_WEARSPELL
build.c:                      || paf->location == APPLY_REMOVESPELL
build.c:                      || paf->location == APPLY_STRIPSN )
build.c:                    && IS_VALID_SN( paf->modifier ) ) ? skill_table[paf->modifier]->slot : paf->modifier );
build.c:      if( pObjIndex->mudprogs )
build.c:         for( mprog = pObjIndex->mudprogs; mprog; mprog = mprog->next )
build.c:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c:               if( mprog->type == IN_FILE_PROG )
build.c:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c:   if( install && vnum < tarea->hi_o_vnum )
build.c:      tarea->hi_o_vnum = vnum - 1;
build.c:   for( vnum = tarea->low_r_vnum; vnum <= tarea->hi_r_vnum; vnum++ )
build.c:         REMOVE_BIT( room->room_flags, ROOM_PROTOTYPE );
build.c:         for( victim = room->first_person; victim; victim = vnext )
build.c:            vnext = victim->next_in_room;
build.c:            if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:         for( obj = room->first_content; obj; obj = obj_next )
build.c:            obj_next = obj->next_content;
build.c:            if( IS_SET( obj->extra_flags, ITEM_PROTOTYPE ) )
build.c:      fprintf( fpout, "%s~\n", room->name );
build.c:      fprintf( fpout, "%s~\n", strip_cr( room->description ) );
build.c:      if( ( room->tele_delay > 0 && room->tele_vnum > 0 ) || room->tunnel > 0 )
build.c:         fprintf( fpout, "0 %d %d %d %d %d\n", room->room_flags,
build.c:                  room->sector_type, room->tele_delay, room->tele_vnum, room->tunnel );
build.c:         fprintf( fpout, "0 %d %d\n", room->room_flags, room->sector_type );
build.c:      for( xit = room->first_exit; xit; xit = xit->next )
build.c:         if( IS_SET( xit->exit_info, EX_PORTAL ) ) /* don't fold portals */
build.c:         fprintf( fpout, "D%d\n", xit->vdir );
build.c:         fprintf( fpout, "%s~\n", strip_cr( xit->description ) );
build.c:         fprintf( fpout, "%s~\n", strip_cr( xit->keyword ) );
build.c:         if( xit->distance > 1 )
build.c:            fprintf( fpout, "%d %d %d %d\n", xit->exit_info & ~EX_BASHED, xit->key, xit->vnum, xit->distance );
build.c:            fprintf( fpout, "%d %d %d\n", xit->exit_info & ~EX_BASHED, xit->key, xit->vnum );
build.c:      for( pReset = room->first_reset; pReset; pReset = pReset->next )
build.c:	   switch( pReset->command ) /* extra arg1 arg2 arg3 */
build.c:		   fprintf( fpout, "R %c %d %d %d %d\n", UPPER( pReset->command ),
build.c:		      pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3 );
build.c:               for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
build.c:                     switch( tReset->command )
build.c:                           fprintf( fpout, "  R %c %d %d %d %d\n", UPPER( tReset->command ),
build.c:                              tReset->extra, tReset->arg1, tReset->arg2, tReset->arg3 );
build.c:                           if( tReset->first_reset )
build.c:                              for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
build.c:                                 if( gReset->command != 'p' && gReset->command != 'P' )
build.c:                                 fprintf( fpout, "    R %c %d %d %d %d\n", UPPER( gReset->command ),
build.c:                                    gReset->extra, gReset->arg1, gReset->arg2, gReset->arg3 );
build.c:                           fprintf( fpout, "  R %c %d %d %d\n", UPPER( tReset->command ),
build.c:                              tReset->extra, tReset->arg1, tReset->arg2 );
build.c:                           if( tReset->first_reset )
build.c:                              for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
build.c:                                 if( gReset->command != 'p' && gReset->command != 'P' )
build.c:                                 fprintf( fpout, "    R %c %d %d %d %d\n", UPPER( gReset->command ),
build.c:                                    gReset->extra, gReset->arg1, gReset->arg2, gReset->arg3 );
build.c:                           fprintf( fpout, "  R %c %d %d %d %d\n", UPPER( tReset->command ),
build.c:                              tReset->extra, tReset->arg1, tReset->arg2, tReset->arg3 );
build.c:		   fprintf( fpout, "R %c %d %d %d %d\n", UPPER( pReset->command ),
build.c:		      pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3 );
build.c:		   fprintf( fpout, "R %c %d %d %d\n", UPPER( pReset->command ), pReset->extra, pReset->arg1, pReset->arg2 );
build.c:      for( ed = room->first_extradesc; ed; ed = ed->next )
build.c:         fprintf( fpout, "E\n%s~\n%s~\n", ed->keyword, strip_cr( ed->description ) );
build.c:      if( room->mudprogs )
build.c:         for( mprog = room->mudprogs; mprog; mprog = mprog->next )
build.c:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c:               if( mprog->type == IN_FILE_PROG )
build.c:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c:   if( install && vnum < tarea->hi_r_vnum )
build.c:      tarea->hi_r_vnum = vnum - 1;
build.c:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c:      if( ( pShop = pMobIndex->pShop ) == NULL )
build.c:               pShop->keeper,
build.c:               pShop->buy_type[0],
build.c:               pShop->buy_type[1],
build.c:               pShop->buy_type[2], pShop->buy_type[3], pShop->buy_type[4], pShop->profit_buy, pShop->profit_sell );
build.c:      fprintf( fpout, "        %2d %2d    ; %s\n", pShop->open_hour, pShop->close_hour, pMobIndex->short_descr );
build.c:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c:      if( ( pRepair = pMobIndex->rShop ) == NULL )
build.c:               pRepair->keeper,
build.c:               pRepair->fix_type[0], pRepair->fix_type[1], pRepair->fix_type[2], pRepair->profit_fix, pRepair->shop_type );
build.c:      fprintf( fpout, "        %2d %2d    ; %s\n", pRepair->open_hour, pRepair->close_hour, pMobIndex->short_descr );
build.c:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c:         if( pMobIndex->spec_fun )
build.c:	      fprintf( fpout, "M  %d %s\n", pMobIndex->vnum, pMobIndex->spec_funname );
build.c:         if( pMobIndex->spec_2 )
build.c:	      fprintf( fpout, "M  %d %s\n", pMobIndex->vnum, pMobIndex->spec_funname2 );
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:      for( found = FALSE, tarea = first_build; tarea; tarea = tarea->next )
build.c:         if( !str_cmp( tarea->filename, argument ) )
build.c:/* Ensure not wiping out their area with save before load - Scryn 8/11 */
build.c:   if( !IS_SET( tarea->status, AREA_LOADED ) )
build.c:   sprintf( filename, "%s%s", BUILD_DIR, tarea->filename );
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:      for( found = FALSE, tarea = first_build; tarea; tarea = tarea->next )
build.c:         if( !str_cmp( tarea->filename, argument ) )
build.c:/* Stops char from loading when already loaded - Scryn 8/11 */
build.c:   if( IS_SET( tarea->status, AREA_LOADED ) )
build.c:   sprintf( filename, "%s%s", BUILD_DIR, tarea->filename );
build.c:   if( tarea->first_room )
build.c:      tmp = tarea->nplayer;
build.c:      tarea->nplayer = 0;
build.c:      tarea->nplayer = tmp;
build.c: * NOTE: Use of this command is not recommended.		-Thoric
build.c:      for( tarea = first_area; tarea; tarea = tarea->next )
build.c:         fold_area( tarea, tarea->filename, FALSE );
build.c:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c:      if( !str_cmp( tarea->filename, arg ) )
build.c:            fold_area( tarea, tarea->filename, TRUE );
build.c:            fold_area( tarea, tarea->filename, FALSE );
build.c:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c:      fprintf( fpout, "%s\n", tarea->filename );
build.c: * A complicated to use command as it currently exists.		-Thoric
build.c: * Once area->author and area->name are cleaned up... it will be easier
build.c:   for( tarea = first_build; tarea; tarea = tarea->next )
build.c:      if( !str_cmp( tarea->filename, arg ) )
build.c:            DISPOSE( tarea->name );
build.c:            tarea->name = str_dup( argument );
build.c:          * Fold area with install flag -- auto-removes prototype flags 
build.c:         fold_area( tarea, tarea->filename, TRUE );
build.c:          * Remove it from the prototype sort list. BUGFIX: Samson 4-15-03 
build.c:          * Sort the area into it's proper sort list. BUGFIX: Samson 4-15-03 
build.c:         for( d = first_descriptor; d; d = d->next )
build.c:            if( d->character && d->character->pcdata && d->character->pcdata->area == tarea )
build.c:               d->character->pcdata->area = NULL;
build.c:               d->character->pcdata->r_range_lo = 0;
build.c:               d->character->pcdata->r_range_hi = 0;
build.c:               d->character->pcdata->o_range_lo = 0;
build.c:               d->character->pcdata->o_range_hi = 0;
build.c:               d->character->pcdata->m_range_lo = 0;
build.c:               d->character->pcdata->m_range_hi = 0;
build.c:         num = tarea->nplayer;
build.c:         tarea->nplayer = 0;
build.c:         tarea->nplayer = num;
build.c:         sprintf( buf, "%s%s.installed", BUILD_DIR, tarea->filename );
build.c:         sprintf( arg, "%s%s", BUILD_DIR, tarea->filename );
build.c:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c:      if( !str_cmp( tarea->filename, argument ) )
build.c:      for( tarea = first_build; tarea; tarea = tarea->next )
build.c:         if( !str_cmp( tarea->filename, argument ) )
build.c:         tarea = ch->in_room->area;
build.c:   ch_printf( ch, "Name: %s\r\nFilename: %-20s  Prototype: %s\r\n", tarea->name, tarea->filename, proto ? "yes" : "no" );
build.c:                 tarea->max_players, tarea->illegal_pk, tarea->gold_looted );
build.c:      if( tarea->high_economy )
build.c:         ch_printf( ch, "Area economy: %d billion and %d credits.\r\n", tarea->high_economy, tarea->low_economy );
build.c:         ch_printf( ch, "Area economy: %d credits.\r\n", tarea->low_economy );
build.c:      if( tarea->planet )
build.c:         ch_printf( ch, "Planet: %s.\r\n", tarea->planet->name );
build.c:                 tarea->mdeaths, tarea->mkills, tarea->pdeaths, tarea->pkills );
build.c:   ch_printf( ch, "Author: %s\r\nAge: %d   Number of players: %d\r\n", tarea->author, tarea->age, tarea->nplayer );
build.c:   ch_printf( ch, "Area flags: %s\r\n", flag_string( tarea->flags, area_flags ) );
build.c:   ch_printf( ch, "low_room: %5d  hi_room: %d\r\n", tarea->low_r_vnum, tarea->hi_r_vnum );
build.c:   ch_printf( ch, "low_obj : %5d  hi_obj : %d\r\n", tarea->low_o_vnum, tarea->hi_o_vnum );
build.c:   ch_printf( ch, "low_mob : %5d  hi_mob : %d\r\n", tarea->low_m_vnum, tarea->hi_m_vnum );
build.c:   ch_printf( ch, "soft range: %d - %d.  hard range: %d - %d.\r\n",
build.c:              tarea->low_soft_range, tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c:   ch_printf( ch, "Resetmsg: %s\r\n", tarea->resetmsg ? tarea->resetmsg : "(default)" );  /* Rennard */
build.c:   ch_printf( ch, "Reset frequency: %d minutes.\r\n", tarea->reset_frequency ? tarea->reset_frequency : 15 );
build.c:   for( area = first_area; area; area = area->next )
build.c:   for( area = first_build; area; area = area->next )
build.c:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c:      if( !str_cmp( tarea->filename, arg1 ) )
build.c:      for( tarea = first_build; tarea; tarea = tarea->next )
build.c:         if( !str_cmp( tarea->filename, arg1 ) )
build.c:      for( uarea = first_area; uarea; uarea = uarea->next )
build.c:         if( !str_cmp( uarea->name, argument ) )
build.c:      for( uarea = first_build; uarea; uarea = uarea->next )
build.c:         if( !str_cmp( uarea->name, argument ) )
build.c:      DISPOSE( tarea->name );
build.c:      tarea->name = str_dup( argument );
build.c:         if( tarea->planet )
build.c:            old_planet = tarea->planet;
build.c:            UNLINK( tarea, old_planet->first_area, old_planet->last_area, next_on_planet, prev_on_planet );
build.c:         tarea->planet = planet;
build.c:         LINK( tarea, planet->first_area, planet->last_area, next_on_planet, prev_on_planet );
build.c:      strncpy( filename, tarea->filename, 256 );
build.c:      DISPOSE( tarea->filename );
build.c:      tarea->filename = str_dup( argument );
build.c:      rename( filename, tarea->filename );
build.c:      tarea->low_economy = vnum;
build.c:      tarea->high_economy = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->low_r_vnum, vnum ) )
build.c:      if( tarea->hi_r_vnum < vnum )
build.c:      tarea->low_r_vnum = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->hi_r_vnum, vnum ) )
build.c:      if( tarea->low_r_vnum > vnum )
build.c:      tarea->hi_r_vnum = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->low_o_vnum, vnum ) )
build.c:      if( tarea->hi_o_vnum < vnum )
build.c:      tarea->low_o_vnum = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->hi_o_vnum, vnum ) )
build.c:      if( tarea->low_o_vnum > vnum )
build.c:      tarea->hi_o_vnum = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->low_m_vnum, vnum ) )
build.c:      if( tarea->hi_m_vnum < vnum )
build.c:      tarea->low_m_vnum = vnum;
build.c:      if( check_for_area_conflicts( tarea, tarea->hi_m_vnum, vnum ) )
build.c:      if( tarea->low_m_vnum > vnum )
build.c:      tarea->hi_m_vnum = vnum;
build.c:      tarea->low_soft_range = vnum;
build.c:      tarea->hi_soft_range = vnum;
build.c:      tarea->low_hard_range = vnum;
build.c:      tarea->hi_hard_range = vnum;
build.c:      STRFREE( tarea->author );
build.c:      tarea->author = STRALLOC( argument );
build.c:      if( tarea->resetmsg )
build.c:         DISPOSE( tarea->resetmsg );
build.c:         tarea->resetmsg = str_dup( argument );
build.c:      tarea->reset_frequency = vnum;
build.c:            if( IS_SET( tarea->flags, 1 << value ) )
build.c:               REMOVE_BIT( tarea->flags, 1 << value );
build.c:               SET_BIT( tarea->flags, 1 << value );
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:         lrange = tarea->low_r_vnum;   /* here.     -Thoric */
build.c:         trange = tarea->hi_r_vnum;
build.c:      if( ( lrange < tarea->low_r_vnum || trange > tarea->hi_r_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c:      ch_printf( ch, "%5d) %s\r\n", vnum, room->name );
build.c:    * Greater+ can list out of assigned range - Tri (mlist/rlist as well)
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:         lrange = tarea->low_o_vnum;   /* here.     -Thoric */
build.c:         trange = tarea->hi_o_vnum;
build.c:      if( ( lrange < tarea->low_o_vnum || trange > tarea->hi_o_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c:      ch_printf( ch, "%5d) %-20s (%s)\r\n", vnum, obj->name, obj->short_descr );
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:         lrange = tarea->low_m_vnum;   /* here.     -Thoric */
build.c:         trange = tarea->hi_m_vnum;
build.c:      if( ( lrange < tarea->low_m_vnum || trange > tarea->hi_m_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c:      ch_printf( ch, "%5d) %-20s '%s'\r\n", vnum, mob->player_name, mob->short_descr );
build.c:   if( mptype != -1 )
build.c:      mprg->type = 1 << mptype;
build.c:      if( mprg->arglist )
build.c:         STRFREE( mprg->arglist );
build.c:      mprg->arglist = STRALLOC( argument );
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !mprg->comlist )
build.c:      mprg->comlist = STRALLOC( "" );
build.c:   start_editing( ch, mprg->comlist );
build.c: * Mobprogram editing - cumbersome				-Thoric
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_mpedit: sub_mprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c:         if( mprog->comlist )
build.c:            STRFREE( mprog->comlist );
build.c:         mprog->comlist = copy_buffer( ch );
build.c:   if( !IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c:   mprog = victim->pIndexData->mudprogs;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c:         if( mptype == -1 )
build.c:         mptype = -1;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            victim->pIndexData->progtypes = 0;
build.c:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c:               victim->pIndexData->progtypes |= mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            mptype = mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( IS_SET( mprg->type, mptype ) )
build.c:         mprg_next = victim->pIndexData->mudprogs;
build.c:         victim->pIndexData->mudprogs = mprg_next->next;
build.c:            mprg_next = mprg->next;
build.c:            if( ++cnt == ( value - 1 ) )
build.c:               mprg->next = mprg_next->next;
build.c:      STRFREE( mprg_next->arglist );
build.c:      STRFREE( mprg_next->comlist );
build.c:         REMOVE_BIT( victim->pIndexData->progtypes, mptype );
build.c:      if( mptype == -1 )
build.c:         victim->pIndexData->progtypes |= ( 1 << mptype );
build.c:         mprg->next = mprog;
build.c:         victim->pIndexData->mudprogs = mprg;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( ++cnt == value && mprg->next )
build.c:            victim->pIndexData->progtypes |= ( 1 << mptype );
build.c:            mprg_next->next = mprg->next;
build.c:            mprg->next = mprg_next;
build.c:      if( mptype == -1 )
build.c:         for( ; mprog->next; mprog = mprog->next );
build.c:         mprog->next = mprg;
build.c:         victim->pIndexData->mudprogs = mprg;
build.c:      victim->pIndexData->progtypes |= ( 1 << mptype );
build.c:      mprg->next = NULL;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c:         if( mprog->comlist )
build.c:            STRFREE( mprog->comlist );
build.c:         mprog->comlist = copy_buffer( ch );
build.c:   mprog = obj->pIndexData->mudprogs;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c:         if( mptype == -1 )
build.c:         mptype = -1;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            obj->pIndexData->progtypes = 0;
build.c:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c:               obj->pIndexData->progtypes |= mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            mptype = mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( IS_SET( mprg->type, mptype ) )
build.c:         mprg_next = obj->pIndexData->mudprogs;
build.c:         obj->pIndexData->mudprogs = mprg_next->next;
build.c:            mprg_next = mprg->next;
build.c:            if( ++cnt == ( value - 1 ) )
build.c:               mprg->next = mprg_next->next;
build.c:      STRFREE( mprg_next->arglist );
build.c:      STRFREE( mprg_next->comlist );
build.c:         REMOVE_BIT( obj->pIndexData->progtypes, mptype );
build.c:      if( mptype == -1 )
build.c:         obj->pIndexData->progtypes |= ( 1 << mptype );
build.c:         mprg->next = mprog;
build.c:         obj->pIndexData->mudprogs = mprg;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( ++cnt == value && mprg->next )
build.c:            obj->pIndexData->progtypes |= ( 1 << mptype );
build.c:            mprg_next->next = mprg->next;
build.c:            mprg->next = mprg_next;
build.c:      if( mptype == -1 )
build.c:         for( ; mprog->next; mprog = mprog->next );
build.c:         mprog->next = mprg;
build.c:         obj->pIndexData->mudprogs = mprg;
build.c:      obj->pIndexData->progtypes |= ( 1 << mptype );
build.c:      mprg->next = NULL;
build.c:   if( mptype != -1 )
build.c:      mprg->type = 1 << mptype;
build.c:      if( mprg->arglist )
build.c:         STRFREE( mprg->arglist );
build.c:      mprg->arglist = STRALLOC( argument );
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !mprg->comlist )
build.c:      mprg->comlist = STRALLOC( "" );
build.c:   start_editing( ch, mprg->comlist );
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c:         if( mprog->comlist )
build.c:            STRFREE( mprog->comlist );
build.c:         mprog->comlist = copy_buffer( ch );
build.c:   if( !can_rmodify( ch, ch->in_room ) )
build.c:   mprog = ch->in_room->mudprogs;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c:         if( mptype == -1 )
build.c:         mptype = -1;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            ch->in_room->progtypes = 0;
build.c:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c:               ch->in_room->progtypes |= mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:            mptype = mprg->type;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( IS_SET( mprg->type, mptype ) )
build.c:         mprg_next = ch->in_room->mudprogs;
build.c:         ch->in_room->mudprogs = mprg_next->next;
build.c:            mprg_next = mprg->next;
build.c:            if( ++cnt == ( value - 1 ) )
build.c:               mprg->next = mprg_next->next;
build.c:      STRFREE( mprg_next->arglist );
build.c:      STRFREE( mprg_next->comlist );
build.c:         REMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:      if( mptype == -1 )
build.c:         ch->in_room->progtypes |= ( 1 << mptype );
build.c:         mprg->next = mprog;
build.c:         ch->in_room->mudprogs = mprg;
build.c:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c:         if( ++cnt == value && mprg->next )
build.c:            ch->in_room->progtypes |= ( 1 << mptype );
build.c:            mprg_next->next = mprg->next;
build.c:            mprg->next = mprg_next;
build.c:      if( mptype == -1 )
build.c:         for( ; mprog->next; mprog = mprog->next );
build.c:         mprog->next = mprg;
build.c:         ch->in_room->mudprogs = mprg;
build.c:      ch->in_room->progtypes |= ( 1 << mptype );
build.c:      mprg->next = NULL;
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( location->vnum < ch->pcdata->area->low_r_vnum || location->vnum > ch->pcdata->area->hi_r_vnum ) )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( obj->vnum < ch->pcdata->area->low_o_vnum || obj->vnum > ch->pcdata->area->hi_o_vnum ) )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( mob->vnum < ch->pcdata->area->low_m_vnum || mob->vnum > ch->pcdata->area->hi_m_vnum ) )
build.c:   for( tmp = first_relation; tmp; tmp = tmp->next )
build.c:      if( tmp->Type == tp && tmp->Actor == actor && tmp->Subject == subject )
build.c:   tmp->Type = tp;
build.c:   tmp->Actor = actor;
build.c:   tmp->Subject = subject;
build.c:   for( rq = first_relation; rq; rq = rq->next )
build.c:      if( rq->Type == tp && rq->Actor == actor && rq->Subject == subject )
build.c:   types: 0=room, 1=obj, 2=mob                     -->Keberus 12/03/08 */
build.c:   int low_value =-1, hi_value =-1;
build.c:   for( area = first_area; area; area = area->next )
build.c:            low_value = area->low_r_vnum;
build.c:            hi_value = area->hi_r_vnum;
build.c:            low_value = area->low_o_vnum;
build.c:            hi_value = area->hi_o_vnum;
build.c:            low_value = area->low_m_vnum;
build.c:            hi_value = area->hi_m_vnum;
build.c:   for( area = first_build; area; area = area->next )
build.c:         low_value = area->low_r_vnum;
build.c:         hi_value = area->hi_r_vnum;
build.c:         low_value = area->low_o_vnum;
build.c:         hi_value = area->hi_o_vnum;
build.c:         low_value = area->low_m_vnum;
build.c:         hi_value = area->hi_m_vnum;
build.c~:*--------------------------------------------------------------------------*
build.c~:* -------------------------------------------------------------------------*
build.c~:*--------------------------------------------------------------------------*
build.c~:* ------------------------------------------------------------------------ *
build.c~:* ------------------------------------------------------------------------ *
build.c~:   "vibro-axe", "vibro-blade", "lightsaber", "whip", "claw",
build.c~:   "non-adegan", "kathracite", "relacite", "danite", "mephite", "ponite", "illum", "corusca"
build.c~: * ie: drop -- for an object, it would be triggered when that object is
build.c~: * dropped; -- for a room, it would be triggered when anything is dropped
build.c~: *          -- for a mob, it would be triggered when anything is dropped
build.c~:      buf[--x] = '\0';
build.c~:   int vnum = room->vnum;
build.c~:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:   if( vnum >= pArea->low_r_vnum && vnum <= pArea->hi_r_vnum )
build.c~:   int vnum = obj->pIndexData->vnum;
build.c~:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:   if( vnum >= pArea->low_o_vnum && vnum <= pArea->hi_o_vnum )
build.c~:   int vnum = obj->vnum;
build.c~:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:   if( vnum >= pArea->low_o_vnum && vnum <= pArea->hi_o_vnum )
build.c~:   vnum = mob->pIndexData->vnum;
build.c~:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:   if( vnum >= pArea->low_m_vnum && vnum <= pArea->hi_m_vnum )
build.c~:   int vnum = mob->vnum;
build.c~:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:   if( vnum >= pArea->low_m_vnum && vnum <= pArea->hi_m_vnum )
build.c~:  return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:   return -1;
build.c~:      last = strptr[len - 1];
build.c~:         *str = '-';
build.c~:      strptr[len - 1] = last;
build.c~:   if( !ch->desc )
build.c~:   if( ch->substate == SUB_RESTRICTED )
build.c~:      bug( "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED", 0 );
build.c~:   send_to_char( "--------------------------------------------------------------------------\r\n> ", ch );
build.c~:   if( ch->editor )
build.c~:   edit->numlines = 0;
build.c~:   edit->on_line = 0;
build.c~:   edit->size = 0;
build.c~:            edit->line[lines][lpos] = '\0';
build.c~:            edit->line[lines][lpos] = '\0';
build.c~:            edit->line[lines][lpos++] = c;
build.c~:            edit->line[lines][lpos] = '\0';
build.c~:   edit->numlines = lines;
build.c~:   edit->size = size;
build.c~:   edit->on_line = lines;
build.c~:   ch->editor = edit;
build.c~:   ch->desc->connected = CON_EDITING;
build.c~:   if( !ch->editor )
build.c~:   for( x = 0; x < ch->editor->numlines; x++ )
build.c~:      strcpy( tmp, ch->editor->line[x] );
build.c~:      if( tmp[len - 1] == '~' )
build.c~:         tmp[len - 1] = '\0';
build.c~:   DISPOSE( ch->editor );
build.c~:   ch->editor = NULL;
build.c~:   ch->dest_buf = NULL;
build.c~:   ch->spare_ptr = NULL;
build.c~:   ch->substate = SUB_NONE;
build.c~:   if( !ch->desc )
build.c~:   ch->desc->connected = CON_PLAYING;
build.c~:      if( vnum < 1 || IS_NPC( ch ) || !ch->pcdata->area )
build.c~:         if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:         if( vnum < pArea->low_r_vnum || vnum > pArea->hi_r_vnum )
build.c~:      location = make_room( vnum, ch->pcdata->area );
build.c~:      location->area = ch->pcdata->area;
build.c~:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:      if( vnum < pArea->low_r_vnum || vnum > pArea->hi_r_vnum )
build.c~:      if( ( ch->in_room->vnum < pArea->low_r_vnum
build.c~:            || ch->in_room->vnum > pArea->hi_r_vnum ) && !IS_SET( ch->in_room->room_flags, ROOM_HOTEL ) )
build.c~:   in_room = ch->in_room;
build.c~:   if( ch->fighting )
build.c~:   if( !IS_SET( ch->act, PLR_WIZINVIS ) )
build.c~:      if( ch->pcdata && ch->pcdata->bamfout[0] != '\0' )
build.c~:         act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfout, TO_ROOM );
build.c~:   ch->regoto = ch->in_room->vnum;
build.c~:   if( ch->mount )
build.c~:      char_from_room( ch->mount );
build.c~:      char_to_room( ch->mount, location );
build.c~:   if( !IS_SET( ch->act, PLR_WIZINVIS ) )
build.c~:      if( ch->pcdata && ch->pcdata->bamfin[0] != '\0' )
build.c~:         act( AT_IMMORT, "$T", ch, NULL, ch->pcdata->bamfin, TO_ROOM );
build.c~:   if( ch->in_room == in_room )
build.c~:   for( fch = in_room->first_person; fch; fch = fch_next )
build.c~:      fch_next = fch->next_in_room;
build.c~:      if( fch->master == ch && IS_IMMORTAL( fch ) )
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_mset: sub_mob_desc: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:         victim = ( CHAR_DATA* ) ch->dest_buf;
build.c~:         STRFREE( victim->description );
build.c~:         victim->description = copy_buffer( ch );
build.c~:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:            STRFREE( victim->pIndexData->description );
build.c~:            victim->pIndexData->description = QUICKLINK( victim->description );
build.c~:         ch->substate = ch->tempnum;
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:     victim = ( CHAR_DATA* ) ch->dest_buf;
build.c~:            do_mstat( ch, victim->name );
build.c~:         if( ch->dest_buf )
build.c~:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c~:         ch->substate = SUB_NONE;
build.c~:         ch->dest_buf = NULL;
build.c~:         if( ch->pcdata && ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:      strcpy( arg1, victim->name );
build.c~:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:      ch->dest_buf = NULL;
build.c~:      ch->dest_buf = NULL;
build.c~:      ch->dest_buf = victim;
build.c~:      ch_printf( ch, "Mset mode on. (Editing %s).\r\n", victim->name );
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      ch->dest_buf = victim;
build.c~:      if( ch->pcdata )
build.c~:         if( ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:            sprintf( buf, "<&CMset &W#%d&w> %%i", victim->pIndexData->vnum );
build.c~:            sprintf( buf, "<&CMset &W%s&w> %%i", victim->name );
build.c~:         ch->pcdata->subprompt = STRALLOC( buf );
build.c~:   value = is_number( arg3 ) ? atoi( arg3 ) : -1;
build.c~:   if( atoi( arg3 ) < -1 && value == -1 )
build.c~:      victim->perm_str = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_str = value;
build.c~:      victim->perm_int = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_int = value;
build.c~:      victim->perm_wis = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_wis = value;
build.c~:      victim->perm_dex = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_dex = value;
build.c~:      victim->perm_con = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_con = value;
build.c~:      victim->perm_cha = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_cha = value;
build.c~:      victim->perm_lck = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_lck = value;
build.c~:      victim->perm_frc = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->perm_frc = value;
build.c~:      if( value < -30 || value > 30 )
build.c~:         send_to_char( "Saving throw range vs poison is -30 to 30.\r\n", ch );
build.c~:      victim->saving_poison_death = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->saving_poison_death = value;
build.c~:      if( value < -30 || value > 30 )
build.c~:         send_to_char( "Saving throw range vs wands is -30 to 30.\r\n", ch );
build.c~:      victim->saving_wand = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->saving_wand = value;
build.c~:      if( value < -30 || value > 30 )
build.c~:         send_to_char( "Saving throw range vs para is -30 to 30.\r\n", ch );
build.c~:      victim->saving_para_petri = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->saving_para_petri = value;
build.c~:      if( value < -30 || value > 30 )
build.c~:         send_to_char( "Saving throw range vs bad breath is -30 to 30.\r\n", ch );
build.c~:      victim->saving_breath = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->saving_breath = value;
build.c~:      if( value < -30 || value > 30 )
build.c~:         send_to_char( "Saving throw range vs force powers is -30 to 30.\r\n", ch );
build.c~:      victim->saving_spell_staff = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->saving_spell_staff = value;
build.c~:      victim->sex = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->sex = value;
build.c~:         ch_printf( ch, "Race range is 0 to %d.\n", MAX_RACE - 1 );
build.c~:         ch_printf( ch, "Race range is 0 to %d.\n", MAX_NPC_RACE - 1 );
build.c~:      victim->race = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->race = value;
build.c~:      if( value < -300 || value > 300 )
build.c~:         send_to_char( "AC range is -300 to 300.\r\n", ch );
build.c~:      victim->armor = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->ac = value;
build.c~:            victim->skill_level[ability] = value;
build.c~:      victim->top_level = value;
build.c~:      victim->armor = ( int )( LEVEL_HERO - value * 2.5 );
build.c~:      victim->hitroll = value / 5;
build.c~:      victim->damroll = value / 5;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->level = value;
build.c~:         victim->pIndexData->ac = ( int )( 100 - value * 2.5 );
build.c~:         victim->pIndexData->hitroll = victim->hitroll;
build.c~:         victim->pIndexData->damroll = victim->damroll;
build.c~:      victim->numattacks = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->numattacks = value;
build.c~:      victim->gold = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->gold = value;
build.c~:      victim->hitroll = URANGE( 0, value, 85 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->hitroll = victim->hitroll;
build.c~:      victim->damroll = URANGE( 0, value, 65 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->damroll = victim->damroll;
build.c~:      victim->max_hit = value;
build.c~:      victim->max_mana = value;
build.c~:      victim->max_move = value;
build.c~:      if( value < -1000 || value > 1000 )
build.c~:         send_to_char( "Alignment range is -1000 to 1000.\r\n", ch );
build.c~:      victim->alignment = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->alignment = value;
build.c~:      DISPOSE( victim->pcdata->pwd );
build.c~:      victim->pcdata->pwd = str_dup( pwdnew );
build.c~:      ch_printf( victim, "Your password has been changed by %s.\r\n", ch->name );
build.c~:      victim->pcdata->quest_number = value;
build.c~:      victim->pcdata->quest_accum = value;
build.c~:      victim->pcdata->quest_curr = value;
build.c~:      if( value < -100 || value > 100 )
build.c~:         send_to_char( "Value must be in range -100 to +100.\r\n", ch );
build.c~:      victim->mental_state = value;
build.c~:      if( value < -100 || value > 100 )
build.c~:         send_to_char( "Value must be in range -100 to +100.\r\n", ch );
build.c~:      victim->emotional_state = value;
build.c~:      victim->pcdata->condition[COND_THIRST] = value;
build.c~:      victim->pcdata->condition[COND_DRUNK] = value;
build.c~:      victim->pcdata->condition[COND_FULL] = value;
build.c~:      victim->pcdata->condition[COND_BLOODTHIRST] = value;
build.c~:      STRFREE( victim->name );
build.c~:      victim->name = STRALLOC( arg3 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         STRFREE( victim->pIndexData->player_name );
build.c~:         victim->pIndexData->player_name = QUICKLINK( victim->name );
build.c~:      if( victim->pcdata )
build.c~:         victim->pcdata->min_snoop = value;
build.c~:          * * But it was early in the morning :P --Shaddai 
build.c~:         if( victim->pcdata->clan == NULL )
build.c~:          * * any membership space. --Shaddai
build.c~:            --victim->pcdata->clan->members;
build.c~:            if( victim->pcdata->clan->members < 0 )
build.c~:               victim->pcdata->clan->members = 0;
build.c~:            save_clan( victim->pcdata->clan );
build.c~:         STRFREE( victim->pcdata->clan_name );
build.c~:         victim->pcdata->clan_name = STRALLOC( "" );
build.c~:         victim->pcdata->clan = NULL;
build.c~:      if( victim->pcdata->clan != NULL && !IS_IMMORTAL( victim ) )
build.c~:         --victim->pcdata->clan->members;
build.c~:         if( victim->pcdata->clan->members < 0 )
build.c~:            victim->pcdata->clan->members = 0;
build.c~:         save_clan( victim->pcdata->clan );
build.c~:      STRFREE( victim->pcdata->clan_name );
build.c~:      victim->pcdata->clan_name = QUICKLINK( clan->name );
build.c~:      victim->pcdata->clan = clan;
build.c~:         ++victim->pcdata->clan->members;
build.c~:         save_clan( victim->pcdata->clan );
build.c~:      STRFREE( victim->short_descr );
build.c~:      victim->short_descr = STRALLOC( arg3 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         STRFREE( victim->pIndexData->short_descr );
build.c~:         victim->pIndexData->short_descr = QUICKLINK( victim->short_descr );
build.c~:      STRFREE( victim->long_descr );
build.c~:      victim->long_descr = STRALLOC( buf );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         STRFREE( victim->pIndexData->long_descr );
build.c~:         victim->pIndexData->long_descr = QUICKLINK( victim->long_descr );
build.c~:         STRFREE( victim->description );
build.c~:         victim->description = STRALLOC( arg3 );
build.c~:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:            STRFREE( victim->pIndexData->description );
build.c~:            victim->pIndexData->description = QUICKLINK( victim->description );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:      ch->substate = SUB_MOB_DESC;
build.c~:      ch->dest_buf = victim;
build.c~:      start_editing( ch, victim->description );
build.c~:         victim->spec_fun = NULL;
build.c~:	   STRFREE( victim->spec_funname );
build.c~:	   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:	      victim->pIndexData->spec_fun = NULL;
build.c~:		STRFREE( victim->pIndexData->spec_funname );
build.c~:	victim->spec_fun = specfun;
build.c~:	STRFREE( victim->spec_funname );
build.c~:	victim->spec_funname = STRALLOC( arg3 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->spec_fun = victim->spec_fun;
build.c~:	   STRFREE( victim->pIndexData->spec_funname );
build.c~:	   victim->pIndexData->spec_funname = STRALLOC( arg3 );
build.c~:         victim->spec_2 = NULL;
build.c~:	   STRFREE( victim->spec_funname2 );
build.c~:	   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:	      victim->pIndexData->spec_2 = NULL;
build.c~:		STRFREE( victim->pIndexData->spec_funname2 );
build.c~:	victim->spec_2 = specfun;
build.c~:	STRFREE( victim->spec_funname2 );
build.c~:	victim->spec_funname2 = STRALLOC( arg3 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->spec_2 = victim->spec_2;
build.c~:	   STRFREE( victim->pIndexData->spec_funname2 );
build.c~:	   victim->pIndexData->spec_funname2 = STRALLOC( arg3 );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:            else if( 1 << value == ACT_PROTOTYPE && ch->top_level < sysdata.level_modify_proto )
build.c~:               TOGGLE_BIT( victim->act, 1 << value );
build.c~:               TOGGLE_BIT( victim->act, 1 << value );
build.c~:      if( IS_NPC( victim ) && ( IS_SET( victim->act, ACT_PROTOTYPE ) || ( 1 << value == ACT_PROTOTYPE && protoflag ) ) )
build.c~:         victim->pIndexData->act = victim->act;
build.c~:            TOGGLE_BIT( victim->pcdata->wanted_flags, 1 << value );
build.c~:            TOGGLE_BIT( victim->vip_flags, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->vip_flags = victim->vip_flags;
build.c~:            TOGGLE_BIT( victim->affected_by, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->affected_by = victim->affected_by;
build.c~:    * save some more finger-leather for setting RIS stuff
build.c~:            TOGGLE_BIT( victim->resistant, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->resistant = victim->resistant;
build.c~:            TOGGLE_BIT( victim->immune, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->immune = victim->immune;
build.c~:            TOGGLE_BIT( victim->susceptible, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->susceptible = victim->susceptible;
build.c~:            TOGGLE_BIT( victim->xflags, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->xflags = victim->xflags;
build.c~:            TOGGLE_BIT( victim->attacks, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->attacks = victim->attacks;
build.c~:            TOGGLE_BIT( victim->defenses, 1 << value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->defenses = victim->defenses;
build.c~:      victim->position = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->position = victim->position;
build.c~:      victim->defposition = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->defposition = victim->defposition;
build.c~:    * save some finger-leather
build.c~:    * save some more finger-leather
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->hitnodice = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->hitsizedice = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->hitplus = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->damnodice = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->damsizedice = value;
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->damplus = value;
build.c~:       * Make sure they have an area assigned -Druid 
build.c~:      if( !victim->pcdata->area )
build.c~:      if( !IS_SET( victim->pcdata->area->status, AREA_LOADED ) )
build.c~:         SET_BIT( victim->pcdata->area->status, AREA_LOADED );
build.c~:         REMOVE_BIT( victim->pcdata->area->status, AREA_LOADED );
build.c~:         send_to_char( "Your area set to NOT-LOADED!\r\n", victim );
build.c~:            send_to_char( "Area set to NON-LOADED!\r\n", ch );
build.c~:         TOGGLE_BIT( victim->speaks, value );
build.c~:         REMOVE_BIT( victim->speaks, race_table[victim->race].language );
build.c~:         if( !knows_language( victim, victim->speaking, victim ) )
build.c~:            victim->speaking = race_table[victim->race].language;
build.c~:      else if( IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->speaks = victim->speaks;
build.c~:            TOGGLE_BIT( victim->speaking, value );
build.c~:      if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         victim->pIndexData->speaking = victim->speaking;
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:      ch->substate = SUB_RESTRICTED;
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      ch->last_cmd = do_mset;
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_oset: sub_obj_extra: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:          * the object and index-object lists, searching through the
build.c~:         ed = ( EXTRA_DESCR_DATA* ) ch->dest_buf;
build.c~:         STRFREE( ed->description );
build.c~:         ed->description = copy_buffer( ch );
build.c~:         tmpobj = ( OBJ_DATA* ) ch->spare_ptr;
build.c~:         ch->dest_buf = tmpobj;
build.c~:         ch->substate = ch->tempnum;
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_oset: sub_obj_long: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:         obj = ( OBJ_DATA* ) ch->dest_buf;
build.c~:         STRFREE( obj->description );
build.c~:         obj->description = copy_buffer( ch );
build.c~:            STRFREE( obj->pIndexData->description );
build.c~:            obj->pIndexData->description = QUICKLINK( obj->description );
build.c~:         tmpobj = ( OBJ_DATA* ) ch->spare_ptr;
build.c~:         ch->substate = ch->tempnum;
build.c~:         ch->dest_buf = tmpobj;
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:     obj = ( OBJ_DATA* ) ch->dest_buf;
build.c~:            do_ostat( ch, obj->name );
build.c~:         if( ch->dest_buf )
build.c~:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c~:         ch->substate = SUB_NONE;
build.c~:         ch->dest_buf = NULL;
build.c~:         if( ch->pcdata && ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:      strcpy( arg1, obj->name );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:      send_to_char( "  slevel spell1 spell2 maxdoses delay (keep low - delay is anoying)\r\n", ch );
build.c~:      ch->dest_buf = obj;
build.c~:      ch_printf( ch, "Oset mode on. (Editing '%s' vnum %d).\r\n", obj->name, obj->pIndexData->vnum );
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      ch->dest_buf = obj;
build.c~:      if( ch->pcdata )
build.c~:         if( ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:         sprintf( buf, "<&COset &W#%d&w> %%i", obj->pIndexData->vnum );
build.c~:         ch->pcdata->subprompt = STRALLOC( buf );
build.c~:      obj->value[0] = value;
build.c~:         obj->pIndexData->value[0] = value;
build.c~:      obj->value[1] = value;
build.c~:         obj->pIndexData->value[1] = value;
build.c~:      obj->value[2] = value;
build.c~:         obj->pIndexData->value[2] = value;
build.c~:         if( obj->item_type == ITEM_WEAPON && value != 0 )
build.c~:            obj->value[2] = obj->pIndexData->value[1] * obj->pIndexData->value[2];
build.c~:      obj->value[3] = value;
build.c~:         obj->pIndexData->value[3] = value;
build.c~:      obj->value[4] = value;
build.c~:         obj->pIndexData->value[4] = value;
build.c~:      obj->value[5] = value;
build.c~:         obj->pIndexData->value[5] = value;
build.c~:      obj->item_type = ( short )value;
build.c~:         obj->pIndexData->item_type = obj->item_type;
build.c~:            TOGGLE_BIT( obj->extra_flags, 1 << value );
build.c~:               obj->pIndexData->extra_flags = obj->extra_flags;
build.c~:         obj->pIndexData->extra_flags = obj->extra_flags;
build.c~:            TOGGLE_BIT( obj->wear_flags, 1 << value );
build.c~:         obj->pIndexData->wear_flags = obj->wear_flags;
build.c~:      obj->level = value;
build.c~:      obj->weight = value;
build.c~:         obj->pIndexData->weight = value;
build.c~:      obj->cost = value;
build.c~:         obj->pIndexData->cost = value;
build.c~:         obj->pIndexData->rent = value;
build.c~:         obj->pIndexData->layers = value;
build.c~:      obj->timer = value;
build.c~:      STRFREE( obj->name );
build.c~:      obj->name = STRALLOC( arg3 );
build.c~:         STRFREE( obj->pIndexData->name );
build.c~:         obj->pIndexData->name = QUICKLINK( obj->name );
build.c~:      STRFREE( obj->short_descr );
build.c~:      obj->short_descr = STRALLOC( arg3 );
build.c~:         STRFREE( obj->pIndexData->short_descr );
build.c~:         obj->pIndexData->short_descr = QUICKLINK( obj->short_descr );
build.c~:         if( str_infix( "rename", obj->name ) )
build.c~:            sprintf( buf, "%s %s", obj->name, "rename" );
build.c~:            STRFREE( obj->name );
build.c~:            obj->name = STRALLOC( buf );
build.c~:      STRFREE( obj->action_desc );
build.c~:      obj->action_desc = STRALLOC( arg3 );
build.c~:         STRFREE( obj->pIndexData->action_desc );
build.c~:         obj->pIndexData->action_desc = QUICKLINK( obj->action_desc );
build.c~:         STRFREE( obj->description );
build.c~:         obj->description = STRALLOC( arg3 );
build.c~:            STRFREE( obj->pIndexData->description );
build.c~:            obj->pIndexData->description = QUICKLINK( obj->description );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:         ch->spare_ptr = obj;
build.c~:         ch->spare_ptr = NULL;
build.c~:      ch->substate = SUB_OBJ_LONG;
build.c~:      ch->dest_buf = obj;
build.c~:      start_editing( ch, obj->description );
build.c~:      paf->type = -1;
build.c~:      paf->duration = -1;
build.c~:      paf->location = loc;
build.c~:      paf->modifier = value;
build.c~:      paf->bitvector = 0;
build.c~:      paf->next = NULL;
build.c~:            for( vch = first_char; vch; vch = vch->next )
build.c~:               for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c~:                  if( eq->pIndexData == obj->pIndexData && eq->wear_loc != WEAR_NONE )
build.c~:         LINK( paf, obj->pIndexData->first_affect, obj->pIndexData->last_affect, next, prev );
build.c~:         LINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c~:         pObjIndex = obj->pIndexData;
build.c~:         for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c~:               UNLINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
build.c~:               if( paf->location != APPLY_WEARSPELL && paf->location != APPLY_REMOVESPELL && paf->location != APPLY_STRIPSN
build.c~:                && paf->location != APPLY_WEAPONSPELL )
build.c~:                  for( vch = first_char; vch; vch = vch->next )
build.c~:                     for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c~:                        if( eq->pIndexData == pObjIndex && eq->wear_loc != WEAR_NONE )
build.c~:               --top_affect;
build.c~:         for( paf = obj->first_affect; paf; paf = paf->next )
build.c~:               UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c~:               --top_affect;
build.c~:      if( obj->timer )
build.c~:      if( obj->item_type == ITEM_PAPER )
build.c~:         ed = SetOExtraProto( obj->pIndexData, arg3 );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:         ch->spare_ptr = obj;
build.c~:         ch->spare_ptr = NULL;
build.c~:      ch->substate = SUB_OBJ_EXTRA;
build.c~:      ch->dest_buf = ed;
build.c~:      start_editing( ch, ed->description );
build.c~:      if( obj->timer )
build.c~:      if( obj->item_type == ITEM_PAPER )
build.c~:         ed = SetOExtraProto( obj->pIndexData, obj->name );
build.c~:         ed = SetOExtra( obj, obj->name );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:         ch->spare_ptr = obj;
build.c~:         ch->spare_ptr = NULL;
build.c~:      ch->substate = SUB_OBJ_EXTRA;
build.c~:      ch->dest_buf = ed;
build.c~:      start_editing( ch, ed->description );
build.c~:         if( DelOExtraProto( obj->pIndexData, arg3 ) )
build.c~:    * save some finger-leather
build.c~:    *                  -Thoric
build.c~:   tmp = -1;
build.c~:   switch ( obj->item_type )
build.c~:            value = -1;
build.c~:               send_to_char( "   none, lightsaber, vibro-blade, blaster, force pike, bowcaster, bludgeon\r\n", ch );
build.c~:            value = -1;
build.c~:            value = -1;
build.c~:               send_to_char( "   non-adegan, kathracite, relacite, danite, mephite, ponite, illum, corusca\r\n", ch );
build.c~:      obj->value[tmp] = value;
build.c~:         obj->pIndexData->value[tmp] = value;
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:      ch->substate = SUB_RESTRICTED;
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      ch->last_cmd = do_oset;
build.c~:      if( IS_SET( location->room_flags, ROOM_PROTOTYPE ) )
build.c~:      location->room_flags = value;
build.c~:         SET_BIT( location->room_flags, ROOM_PROTOTYPE );
build.c~:      location->sector_type = value;
build.c~: * Returns value 0 - 9 based on directional text.
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:	location = ( ROOM_INDEX_DATA* ) ch->dest_buf;
build.c~:            bug( "redit: sub_room_desc: NULL ch->dest_buf", 0 );
build.c~:            location = ch->in_room;
build.c~:         STRFREE( location->description );
build.c~:         location->description = copy_buffer( ch );
build.c~:         ch->substate = ch->tempnum;
build.c~:	ed = ( EXTRA_DESCR_DATA* ) ch->dest_buf;
build.c~:            bug( "redit: sub_room_extra: NULL ch->dest_buf", 0 );
build.c~:         STRFREE( ed->description );
build.c~:         ed->description = copy_buffer( ch );
build.c~:         ch->substate = ch->tempnum;
build.c~:   location = ch->in_room;
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:         if( ch->pcdata && ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:         ch->substate = SUB_NONE;
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      if( ch->pcdata )
build.c~:         if( ch->pcdata->subprompt )
build.c~:            STRFREE( ch->pcdata->subprompt );
build.c~:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c~:      STRFREE( location->name );
build.c~:      location->name = STRALLOC( argument );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:      ch->substate = SUB_ROOM_DESC;
build.c~:      ch->dest_buf = location;
build.c~:      start_editing( ch, location->description );
build.c~:      location->tunnel = URANGE( 0, atoi( argument ), 1000 );
build.c~:      if( ch->substate == SUB_REPEATCMD )
build.c~:         ch->tempnum = SUB_REPEATCMD;
build.c~:         ch->tempnum = SUB_NONE;
build.c~:      ch->substate = SUB_ROOM_EXTRA;
build.c~:      ch->dest_buf = ed;
build.c~:      start_editing( ch, ed->description );
build.c~:      if( !location->first_reset )
build.c~:      for( pReset = location->first_reset; pReset; pReset = pReset->next )
build.c~:            TOGGLE_BIT( location->room_flags, 1 << value );
build.c~:      location->tele_delay = atoi( argument );
build.c~:      location->tele_vnum = atoi( argument );
build.c~:      location->sector_type = atoi( argument );
build.c~:      if( location->sector_type < 0 || location->sector_type >= SECT_MAX )
build.c~:         location->sector_type = 1;
build.c~:      xit->key = value;
build.c~:      STRFREE( xit->keyword );
build.c~:      xit->keyword = STRALLOC( argument );
build.c~:         sprintf( buf, "Flags for exit direction: %d  Keywords: %s  Key: %d\r\n[ ", xit->vdir, xit->keyword, xit->key );
build.c~:            if( IS_SET( xit->exit_info, 1 << value ) )
build.c~:            TOGGLE_BIT( xit->exit_info, 1 << value );
build.c~:            edir = xit->vdir;
build.c~:         send_to_char( "Non-existant room.\r\n", ch );
build.c~:      if( get_trust( ch ) <= LEVEL_IMMORTAL && tmp->area != location->area )
build.c~:         if( addexit && xit && get_exit_to( location, edir, tmp->vnum ) )
build.c~:         xit->keyword = STRALLOC( "" );
build.c~:         xit->description = STRALLOC( "" );
build.c~:         xit->key = -1;
build.c~:         xit->exit_info = 0;
build.c~:      if( xit->to_room != tmp )
build.c~:         xit->to_room = tmp;
build.c~:         xit->vnum = evnum;
build.c~:         texit = get_exit_to( xit->to_room, rev_dir[edir], location->vnum );
build.c~:            texit->rexit = xit;
build.c~:            xit->rexit = texit;
build.c~:         xit->exit_info = atoi( arg3 );
build.c~:            xit->key = ekey;
build.c~:            STRFREE( xit->keyword );
build.c~:            xit->keyword = STRALLOC( argument );
build.c~:    * Twisted and evil, but works           -Thoric
build.c~:         send_to_char( "Create, change or remove a two-way exit.\r\n", ch );
build.c~:            edir = nxit->vdir;
build.c~:         vnum = nxit->vnum;
build.c~:            sprintf( rvnum, "%d", tmploc->vnum );
build.c~:         if( nxit->to_room )
build.c~:            rxit = get_exit( nxit->to_room, rev_dir[edir] );
build.c~:         vnum = nxit->vnum;
build.c~:            sprintf( rvnum, "%d", tmploc->vnum );
build.c~:         if( nxit->to_room )
build.c~:            rxit = get_exit( nxit->to_room, rev_dir[edir] );
build.c~:         xit->distance = URANGE( 1, atoi( argument ), 50 );
build.c~:         STRFREE( xit->description );
build.c~:            xit->description = STRALLOC( "" );
build.c~:            xit->description = STRALLOC( buf );
build.c~:   if( ch->substate == SUB_REPEATCMD )
build.c~:      ch->substate = SUB_RESTRICTED;
build.c~:      ch->substate = SUB_REPEATCMD;
build.c~:      ch->last_cmd = do_redit;
build.c~:   vnum = is_number( arg ) ? atoi( arg ) : -1;
build.c~:   if( vnum == -1 || !argument || argument[0] == '\0' )
build.c~:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:      if( vnum < pArea->low_o_vnum || vnum > pArea->hi_o_vnum )
build.c~:   vnum = is_number( arg ) ? atoi( arg ) : -1;
build.c~:   if( vnum == -1 || !argument || argument[0] == '\0' )
build.c~:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c~:      if( vnum < pArea->low_m_vnum || vnum > pArea->hi_m_vnum )
build.c~:   char_to_room( mob, ch->in_room );
build.c~: * Simple but nice and handle line editor.			-Thoric
build.c~:   if( ( d = ch->desc ) == NULL )
build.c~:   if( d->connected != CON_EDITING )
build.c~:      bug( "%s: d->connected != CON_EDITING", __FUNCTION__ );
build.c~:   if( ch->substate <= SUB_PAUSE )
build.c~:      bug( "%s: illegal ch->substate (%d)", __FUNCTION__, ch->substate );
build.c~:      d->connected = CON_PLAYING;
build.c~:   if( !ch->editor )
build.c~:      d->connected = CON_PLAYING;
build.c~:   edit = ch->editor;
build.c~:         send_to_char( "Editing commands\r\n---------------------------------\r\n", ch );
build.c~:         edit->numlines = 0;
build.c~:         edit->on_line = 0;
build.c~:         for( x = 0; x < edit->numlines; x++ )
build.c~:            lwptr = edit->line[x];
build.c~:               if( lineln + wptr - edit->line[x] > 79 )
build.c~:       * added format command - shogar 
build.c~:         for( x = 0; x < edit->numlines; x++ )
build.c~:            strncpy( temp_buf + p, edit->line[x], MAX_STRING_LENGTH + max_buf_lines - p );
build.c~:            p += strlen( edit->line[x] );
build.c~:         edit->on_line = 0;
build.c~:         edit->numlines = 0;
build.c~:               p--;
build.c~:               edit->line[edit->on_line][ep] = temp_buf[x];
build.c~:            edit->line[edit->on_line][ep] = '\0';
build.c~:            edit->on_line++;
build.c~:            edit->numlines++;
build.c~:         if( edit->numlines >= max_buf_lines )
build.c~:               line = atoi( argument + 2 ) - 1;
build.c~:               line = edit->on_line;
build.c~:               line = edit->on_line;
build.c~:            if( line < 0 || line > edit->numlines )
build.c~:               for( x = ++edit->numlines; x > line; x-- )
build.c~:                  mudstrlcpy( edit->line[x], edit->line[x - 1], MAX_STRING_LENGTH );
build.c~:               mudstrlcpy( edit->line[line], "", MAX_STRING_LENGTH );
build.c~:         if( edit->numlines == 0 )
build.c~:               line = atoi( argument + 2 ) - 1;
build.c~:               line = edit->on_line;
build.c~:               line = edit->on_line;
build.c~:            if( line < 0 || line > edit->numlines )
build.c~:               if( line == 0 && edit->numlines == 1 )
build.c~:                  edit->numlines = 0;
build.c~:                  edit->on_line = 0;
build.c~:               for( x = line; x < ( edit->numlines - 1 ); x++ )
build.c~:                  mudstrlcpy( edit->line[x], edit->line[x + 1], MAX_STRING_LENGTH );
build.c~:               mudstrlcpy( edit->line[edit->numlines--], "", MAX_STRING_LENGTH );
build.c~:               if( edit->on_line > edit->numlines )
build.c~:                  edit->on_line = edit->numlines;
build.c~:         if( edit->numlines == 0 )
build.c~:               line = atoi( argument + 2 ) - 1;
build.c~:               line = edit->on_line;
build.c~:            if( line < 0 || line > edit->numlines )
build.c~:               edit->on_line = line;
build.c~:         if( edit->numlines == 0 )
build.c~:            send_to_char( "------------------\r\n", ch );
build.c~:            for( x = 0; x < edit->numlines; x++ )
build.c~:               ch_printf( ch, "%2d> %s\r\n", x + 1, edit->line[x] );
build.c~:            send_to_char( "------------------\r\n> ", ch );
build.c~:         int substate = ch->substate;
build.c~:         last_cmd = ch->last_cmd;
build.c~:         ch->substate = SUB_RESTRICTED;
build.c~:         ch->substate = substate;
build.c~:         ch->last_cmd = last_cmd;
build.c~:         d->connected = CON_PLAYING;
build.c~:         if( !ch->last_cmd )
build.c~:         ( *ch->last_cmd ) ( ch, "" );
build.c~:   if( edit->size + strlen( argument ) + 1 >= MAX_STRING_LENGTH - 1 )
build.c~:      mudstrlcpy( edit->line[edit->on_line++], buf, MAX_STRING_LENGTH );
build.c~:      if( edit->on_line > edit->numlines )
build.c~:         edit->numlines++;
build.c~:      if( edit->numlines > max_buf_lines )
build.c~:         edit->numlines = max_buf_lines;
build.c~:      d->connected = CON_PLAYING;
build.c~:      if( !ch->last_cmd )
build.c~:      ( *ch->last_cmd ) ( ch, "" );
build.c~:   if( get_trust( ch ) >= LEVEL_AVATAR && ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
build.c~:      tarea = ch->pcdata->area;
build.c~:      sprintf( taf, "%s.are", capitalize( ch->name ) );
build.c~:         for( tmp = first_build; tmp; tmp = tmp->next )
build.c~:            if( !str_cmp( taf, tmp->filename ) )
build.c~:         sprintf( buf, "Creating area entry for %s", ch->name );
build.c~:         log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c~:         tarea->first_room = tarea->last_room = NULL;
build.c~:         sprintf( buf, "{PROTO} %s's area in progress", ch->name );
build.c~:         tarea->name = str_dup( buf );
build.c~:         tarea->filename = str_dup( taf );
build.c~:         sprintf( buf2, "%s", ch->name );
build.c~:         tarea->author = STRALLOC( buf2 );
build.c~:         tarea->age = 0;
build.c~:         tarea->nplayer = 0;
build.c~:         sprintf( buf, "Updating area entry for %s", ch->name );
build.c~:         log_string_plus( buf, LOG_NORMAL, ch->top_level );
build.c~:      tarea->low_r_vnum = ch->pcdata->r_range_lo;
build.c~:      tarea->low_o_vnum = ch->pcdata->o_range_lo;
build.c~:      tarea->low_m_vnum = ch->pcdata->m_range_lo;
build.c~:      tarea->hi_r_vnum = ch->pcdata->r_range_hi;
build.c~:      tarea->hi_o_vnum = ch->pcdata->o_range_hi;
build.c~:      tarea->hi_m_vnum = ch->pcdata->m_range_hi;
build.c~:      ch->pcdata->area = tarea;
build.c~:      ch->pcdata->area = NULL;
build.c~:      if( !ch->pcdata->area )
build.c~:       || ( is_name( buf, ch->pcdata->bestowments ) && get_trust( ch ) >= sysdata.level_modify_proto ) )
build.c~:      for( tmp = first_area; tmp; tmp = tmp->next )
build.c~:         if( !str_cmp( buf, tmp->filename ) )
build.c~:      for( tmp = first_build; tmp; tmp = tmp->next )
build.c~:         if( !str_cmp( buf, tmp->filename ) )
build.c~:            if( get_trust( ch ) >= LEVEL_GREATER || is_name( tmp->filename, ch->pcdata->bestowments ) )
build.c~:   ch->pcdata->area = tarea;
build.c~:   ch_printf( ch, "Assigning you: %s\r\n", tarea->name );
build.c~:   for( ed = room->first_extradesc; ed; ed = ed->next )
build.c~:      if( is_name( keywords, ed->keyword ) )
build.c~:      LINK( ed, room->first_extradesc, room->last_extradesc, next, prev );
build.c~:      ed->keyword = STRALLOC( keywords );
build.c~:      ed->description = STRALLOC( "" );
build.c~:   for( rmed = room->first_extradesc; rmed; rmed = rmed->next )
build.c~:      if( is_name( keywords, rmed->keyword ) )
build.c~:   UNLINK( rmed, room->first_extradesc, room->last_extradesc, next, prev );
build.c~:   STRFREE( rmed->keyword );
build.c~:   STRFREE( rmed->description );
build.c~:   top_ed--;
build.c~:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c~:      if( is_name( keywords, ed->keyword ) )
build.c~:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c~:      ed->keyword = STRALLOC( keywords );
build.c~:      ed->description = STRALLOC( "" );
build.c~:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c~:      if( is_name( keywords, rmed->keyword ) )
build.c~:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c~:   STRFREE( rmed->keyword );
build.c~:   STRFREE( rmed->description );
build.c~:   top_ed--;
build.c~:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c~:      if( is_name( keywords, ed->keyword ) )
build.c~:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c~:      ed->keyword = STRALLOC( keywords );
build.c~:      ed->description = STRALLOC( "" );
build.c~:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c~:      if( is_name( keywords, rmed->keyword ) )
build.c~:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c~:   STRFREE( rmed->keyword );
build.c~:   STRFREE( rmed->description );
build.c~:   top_ed--;
build.c~:   fprintf( fpout, "ExDescKey    %s~\n", ed->keyword );
build.c~:   if( ed->description && ed->description[0] != '\0' )
build.c~:      fprintf( fpout, "ExDesc       %s~\n", strip_cr( ed->description ) );
build.c~:   fprintf( fpout, "Direction %s~\n", strip_cr( dir_name[pexit->vdir] ) );
build.c~:   fprintf( fpout, "ToRoom    %d\n", pexit->vnum );
build.c~:   if( pexit->key != -1 && pexit->key > 0 )
build.c~:      fprintf( fpout, "Key       %d\n", pexit->key );
build.c~:   if( pexit->distance > 1 )
build.c~:      fprintf( fpout, "Distance  %d\n", pexit->distance );
build.c~:   if( pexit->description && pexit->description[0] != '\0' )
build.c~:      fprintf( fpout, "Desc      %s~\n", strip_cr( pexit->description ) );
build.c~:   if( pexit->keyword && pexit->keyword[0] != '\0' )
build.c~:      fprintf( fpout, "Keywords  %s~\n", strip_cr( pexit->keyword ) );
build.c~:   if( pexit->exit_info )
build.c~:      fprintf( fpout, "Flags     %s~\n", flag_string( pexit->exit_info, ex_flags ) );
build.c~:   if( paf->type < 0 || paf->type >= top_sn )
build.c~:               paf->type,
build.c~:               paf->duration,
build.c~:               ( ( paf->location == APPLY_WEAPONSPELL
build.c~:                   || paf->location == APPLY_WEARSPELL
build.c~:                   || paf->location == APPLY_REMOVESPELL
build.c~:                   || paf->location == APPLY_STRIPSN )
build.c~:                 && IS_VALID_SN( paf->modifier ) )
build.c~:               ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
build.c~:               skill_table[paf->type]->name,
build.c~:               paf->duration,
build.c~:               ( ( paf->location == APPLY_WEAPONSPELL
build.c~:                   || paf->location == APPLY_WEARSPELL
build.c~:                   || paf->location == APPLY_REMOVESPELL
build.c~:                   || paf->location == APPLY_STRIPSN )
build.c~:                 && IS_VALID_SN( paf->modifier ) )
build.c~:               ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
build.c~:   if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c~:      fprintf( fpout, "Progtype  %s~\n", mprog_type_to_name( mprog->type ) );
build.c~:      fprintf( fpout, "Arglist   %s~\n", mprog->arglist );
build.c~:      if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c~:         fprintf( fpout, "Comlist   %s~\n", strip_cr( mprog->comlist ) );
build.c~:      switch ( UPPER( reset->command ) )  /* extra arg1 arg2 arg3 */
build.c~:                     UPPER( reset->command ), reset->extra, reset->arg1, reset->arg2, reset->arg3 );
build.c~:                     UPPER( reset->command ), reset->extra, reset->arg1, reset->arg2 );
build.c~:      save_reset_level( fpout, reset->first_reset, level + 1 );
build.c~:       * where we go next depends on if this is a top-level reset or not - for some reason 
build.c~:         reset = reset->next;
build.c~:         reset = reset->next_reset;
build.c~:      REMOVE_BIT( room->room_flags, ROOM_PROTOTYPE );
build.c~:      for( victim = room->first_person; victim; victim = vnext )
build.c~:         vnext = victim->next_in_room;
build.c~:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:      for( obj = room->first_content; obj; obj = obj_next )
build.c~:         obj_next = obj->next_content;
build.c~:         if( IS_SET( obj->extra_flags, ITEM_PROTOTYPE ) )
build.c~:   //REMOVE_BIT( room->room_flags, ROOM_BFS_MARK );
build.c~:   fprintf( fpout, "Vnum     %d\n", room->vnum );
build.c~:   fprintf( fpout, "Name     %s~\n", room->name );
build.c~:   fprintf( fpout, "Sector   %s~\n", strip_cr( sector_name[room->sector_type] ) );
build.c~:   if( room->room_flags )
build.c~:      fprintf( fpout, "Flags    %s~\n", flag_string( room->room_flags, r_flags ) );
build.c~:   if( room->tele_delay > 0 || room->tele_vnum > 0 || room->tunnel > 0 )
build.c~:      fprintf( fpout, "Stats    %d %d %d\n", room->tele_delay, room->tele_vnum, room->tunnel );
build.c~:   if( room->description && room->description[0] != '\0' )
build.c~:      fprintf( fpout, "Desc     %s~\n", strip_cr( room->description ) );
build.c~:   for( xit = room->first_exit; xit; xit = xit->next )
build.c~:      if( IS_SET( xit->exit_info, EX_PORTAL ) ) /* don't fold portals */
build.c~:   save_reset_level( fpout, room->first_reset, 0 );
build.c~:  // for( paf = room->first_permaffect; paf; paf = paf->next )
build.c~:   for( ed = room->first_extradesc; ed; ed = ed->next )
build.c~:   if( room->mudprogs )
build.c~:      for( mprog = room->mudprogs; mprog; mprog = mprog->next )
build.c~:      REMOVE_BIT( pObjIndex->extra_flags, ITEM_PROTOTYPE );
build.c~:   fprintf( fpout, "Vnum     %d\n", pObjIndex->vnum );
build.c~:   fprintf( fpout, "Keywords %s~\n", pObjIndex->name );
build.c~:   fprintf( fpout, "Type     %s~\n", o_types[pObjIndex->item_type] );
build.c~:   fprintf( fpout, "Short    %s~\n", pObjIndex->short_descr );
build.c~:   if( pObjIndex->description && pObjIndex->description[0] != '\0' )
build.c~:      fprintf( fpout, "Long     %s~\n", pObjIndex->description );
build.c~:   if( pObjIndex->action_desc && pObjIndex->action_desc[0] != '\0' )
build.c~:      fprintf( fpout, "Action   %s~\n", pObjIndex->action_desc );
build.c~:   if( pObjIndex->extra_flags )
build.c~:      fprintf( fpout, "Flags    %s~\n", flag_string( pObjIndex->extra_flags, o_flags ) );
build.c~:   if( pObjIndex->wear_flags )
build.c~:      fprintf( fpout, "WFlags   %s~\n", flag_string( pObjIndex->wear_flags, w_flags ) );
build.c~:   val0 = pObjIndex->value[0];
build.c~:   val1 = pObjIndex->value[1];
build.c~:   val2 = pObjIndex->value[2];
build.c~:   val3 = pObjIndex->value[3];
build.c~:   val4 = pObjIndex->value[4];
build.c~:   val5 = pObjIndex->value[5];
build.c~:   switch ( pObjIndex->item_type )
build.c~:   fprintf( fpout, "Stats    %d %d %d %d %d\n", pObjIndex->weight,
build.c~:            pObjIndex->cost, pObjIndex->rent ? pObjIndex->rent : ( int )( pObjIndex->cost / 10 ),
build.c~:            pObjIndex->level, pObjIndex->layers );
build.c~:   for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c~:   switch ( pObjIndex->item_type )
build.c~:                  IS_VALID_SN( pObjIndex->value[1] ) ?
build.c~:                  skill_table[pObjIndex->value[1]]->name : "NONE",
build.c~:                  IS_VALID_SN( pObjIndex->value[2] ) ?
build.c~:                  skill_table[pObjIndex->value[2]]->name : "NONE",
build.c~:                  IS_VALID_SN( pObjIndex->value[3] ) ? skill_table[pObjIndex->value[3]]->name : "NONE" );
build.c~:                  IS_VALID_SN( pObjIndex->value[3] ) ? skill_table[pObjIndex->value[3]]->name : "NONE" );
build.c~:                  IS_VALID_SN( pObjIndex->value[4] ) ?
build.c~:                  skill_table[pObjIndex->value[4]]->name : "NONE",
build.c~:                  IS_VALID_SN( pObjIndex->value[5] ) ? skill_table[pObjIndex->value[5]]->name : "NONE" );
build.c~:   for( ed = pObjIndex->first_extradesc; ed; ed = ed->next )
build.c~:   if( pObjIndex->mudprogs )
build.c~:      for( mprog = pObjIndex->mudprogs; mprog; mprog = mprog->next )
build.c~:      REMOVE_BIT( pMobIndex->act, ACT_PROTOTYPE );
build.c~:   fprintf( fpout, "Vnum       %d\n", pMobIndex->vnum );
build.c~:   fprintf( fpout, "Keywords   %s~\n", pMobIndex->player_name );
build.c~:   fprintf( fpout, "Short      %s~\n", pMobIndex->short_descr );
build.c~:   if( pMobIndex->long_descr && pMobIndex->long_descr[0] != '\0' )
build.c~:      fprintf( fpout, "Long       %s~\n", strip_cr( pMobIndex->long_descr ) );
build.c~:   if( pMobIndex->description && pMobIndex->description[0] != '\0' )
build.c~:      fprintf( fpout, "Desc       %s~\n", strip_cr( pMobIndex->description ) );
build.c~:   fprintf( fpout, "Race       %s~\n", npc_race[pMobIndex->race] );
build.c~:   fprintf( fpout, "Position   %s~\n", npc_position[pMobIndex->position] );
build.c~:   fprintf( fpout, "DefPos     %s~\n", npc_position[pMobIndex->defposition] );
build.c~:   if( pMobIndex->spec_fun && pMobIndex->spec_funname && pMobIndex->spec_funname[0] != '\0' )
build.c~:      fprintf( fpout, "Specfun    %s~\n", pMobIndex->spec_funname );
build.c~:   if( pMobIndex->spec_2 && pMobIndex->spec_funname2 && pMobIndex->spec_funname2[0] != '\0' )
build.c~:      fprintf( fpout, "Specfun2    %s~\n", pMobIndex->spec_funname2 );
build.c~:   fprintf( fpout, "Gender     %s~\n", npc_sex[pMobIndex->sex] );
build.c~:   fprintf( fpout, "Actflags   %s~\n", flag_string( pMobIndex->act, act_flags ) );
build.c~:   if( pMobIndex->affected_by )
build.c~:      fprintf( fpout, "Affected   %s~\n", flag_string( pMobIndex->affected_by, a_flags ) );
build.c~:   fprintf( fpout, "Stats1     %d %d %d %d %d %d\n", pMobIndex->alignment, pMobIndex->level, pMobIndex->mobthac0,
build.c~:            pMobIndex->ac, pMobIndex->gold, pMobIndex->exp );
build.c~:   fprintf( fpout, "Stats2     %d %d %d\n", pMobIndex->hitnodice, pMobIndex->hitsizedice, pMobIndex->hitplus );
build.c~:   fprintf( fpout, "Stats3     %d %d %d\n", pMobIndex->damnodice, pMobIndex->damsizedice, pMobIndex->damplus );
build.c~:            pMobIndex->height, pMobIndex->weight, pMobIndex->numattacks, pMobIndex->hitroll, pMobIndex->damroll );
build.c~:            pMobIndex->perm_str,
build.c~:            pMobIndex->perm_int,
build.c~:            pMobIndex->perm_wis, pMobIndex->perm_dex, pMobIndex->perm_con, pMobIndex->perm_cha, pMobIndex->perm_lck, pMobIndex->perm_frc );
build.c~:            pMobIndex->saving_poison_death,
build.c~:            pMobIndex->saving_wand, pMobIndex->saving_para_petri, pMobIndex->saving_breath, pMobIndex->saving_spell_staff );
build.c~:   if( pMobIndex->speaks )
build.c~:      fprintf( fpout, "Speaks     %s~\n", flag_string( pMobIndex->speaks, lang_names_save ) );
build.c~:   if( pMobIndex->speaking )
build.c~:      fprintf( fpout, "Speaking   %s~\n", flag_string( pMobIndex->speaking, lang_names_save ) );
build.c~:   if( pMobIndex->xflags )
build.c~:      fprintf( fpout, "Bodyparts  %s~\n", flag_string( pMobIndex->xflags, part_flags ) );
build.c~:   if( pMobIndex->resistant )
build.c~:      fprintf( fpout, "Resist     %s~\n", flag_string( pMobIndex->resistant, ris_flags ) );
build.c~:   if( pMobIndex->immune )
build.c~:      fprintf( fpout, "Immune     %s~\n", flag_string( pMobIndex->immune, ris_flags ) );
build.c~:   if( pMobIndex->susceptible )
build.c~:      fprintf( fpout, "Suscept    %s~\n", flag_string( pMobIndex->susceptible, ris_flags ) );
build.c~:   if( pMobIndex->attacks )
build.c~:      fprintf( fpout, "Attacks    %s~\n", flag_string( pMobIndex->attacks, attack_flags ) );
build.c~:   if( pMobIndex->defenses )
build.c~:      fprintf( fpout, "Defenses   %s~\n", flag_string( pMobIndex->defenses, defense_flags ) );
build.c~:   if( pMobIndex->vip_flags )
build.c~:      fprintf( fpout, "VIPFlags   %s~\n", flag_string( pMobIndex->vip_flags, planet_flags ) );
build.c~:   if( ( pShop = pMobIndex->pShop ) != NULL )
build.c~:               pShop->buy_type[0], pShop->buy_type[1], pShop->buy_type[2], pShop->buy_type[3], pShop->buy_type[4],
build.c~:               pShop->profit_buy, pShop->profit_sell, pShop->open_hour, pShop->close_hour );
build.c~:   if( ( pRepair = pMobIndex->rShop ) != NULL )
build.c~:               pRepair->fix_type[0], pRepair->fix_type[1], pRepair->fix_type[2], pRepair->profit_fix, pRepair->shop_type,
build.c~:               pRepair->open_hour, pRepair->close_hour );
build.c~:   if( pMobIndex->mudprogs )
build.c~:      for( mprog = pMobIndex->mudprogs; mprog; mprog = mprog->next )
build.c~:      REMOVE_BIT( tarea->flags, AFLAG_PROTOTYPE );
build.c~:   fprintf( fpout, "Version      %d\n", tarea->version );
build.c~:   fprintf( fpout, "Name         %s~\n", tarea->name );
build.c~:   fprintf( fpout, "Author       %s~\n", tarea->author );
build.c~:            tarea->low_soft_range, tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c~:   if( tarea->high_economy || tarea->low_economy )
build.c~:      fprintf( fpout, "Economy      %d %d\n", tarea->high_economy, tarea->low_economy );
build.c~:   if( tarea->resetmsg )   
build.c~:      fprintf( fpout, "ResetMsg     %s~\n", tarea->resetmsg );
build.c~:   if( tarea->reset_frequency )
build.c~:      fprintf( fpout, "ResetFreq    %d\n", tarea->reset_frequency );
build.c~:   if( tarea->flags )
build.c~:      fprintf( fpout, "Flags        %s~\n", flag_string( tarea->flags, area_flags ) );
build.c~:   tarea->version = AREA_VERSION_WRITE;
build.c~:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; ++vnum )
build.c~:   for( vnum = tarea->low_o_vnum; vnum <= tarea->hi_o_vnum; ++vnum )
build.c~:   for( vnum = tarea->low_r_vnum; vnum <= tarea->hi_r_vnum; ++vnum )
build.c~:   sprintf( buf, "Saving %s...", tarea->filename );
build.c~:      REMOVE_BIT( tarea->flags, AFLAG_PROTOTYPE );
build.c~:   fprintf( fpout, "#AREA   %s~\n\n\n\n", tarea->name );
build.c~:   fprintf( fpout, "#AUTHOR %s~\n\n", tarea->author );
build.c~:   fprintf( fpout, "%d %d %d %d\n", tarea->low_soft_range,
build.c~:            tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c~:   if( tarea->resetmsg )   /* Rennard */
build.c~:      fprintf( fpout, "#RESETMSG %s~\n\n", tarea->resetmsg );
build.c~:   if( tarea->reset_frequency )
build.c~:      fprintf( fpout, "#FLAGS\n%d %d\n\n", tarea->flags, tarea->reset_frequency );
build.c~:      fprintf( fpout, "#FLAGS\n%d\n\n", tarea->flags );
build.c~:   fprintf( fpout, "#ECONOMY %d %d\n\n", tarea->high_economy, tarea->low_economy );
build.c~:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c~:         REMOVE_BIT( pMobIndex->act, ACT_PROTOTYPE );
build.c~:      if( pMobIndex->perm_str != 13 || pMobIndex->perm_int != 13
build.c~:          || pMobIndex->perm_wis != 13 || pMobIndex->perm_dex != 13
build.c~:          || pMobIndex->perm_con != 13 || pMobIndex->perm_cha != 13
build.c~:          || pMobIndex->perm_lck != 13
build.c~:          || pMobIndex->hitroll != 0 || pMobIndex->damroll != 0
build.c~:          || pMobIndex->race != 0
build.c~:          || pMobIndex->attacks != 0 || pMobIndex->defenses != 0
build.c~:          || pMobIndex->height != 0 || pMobIndex->weight != 0
build.c~:          || pMobIndex->speaks != 0 || pMobIndex->speaking != 0
build.c~:          || pMobIndex->xflags != 0 || pMobIndex->numattacks != 1 || pMobIndex->vip_flags != 0 )
build.c~:      fprintf( fpout, "%s~\n", pMobIndex->player_name );
build.c~:      fprintf( fpout, "%s~\n", pMobIndex->short_descr );
build.c~:      fprintf( fpout, "%s~\n", strip_cr( pMobIndex->long_descr ) );
build.c~:      fprintf( fpout, "%s~\n", strip_cr( pMobIndex->description ) );
build.c~:      fprintf( fpout, "%d %d %d %c\n", pMobIndex->act,
build.c~:               pMobIndex->affected_by, pMobIndex->alignment, complexmob ? 'Z' : 'S' );
build.c~:      fprintf( fpout, "%d %d %d ", pMobIndex->level, pMobIndex->mobthac0, pMobIndex->ac );
build.c~:      fprintf( fpout, "%dd%d+%d ", pMobIndex->hitnodice, pMobIndex->hitsizedice, pMobIndex->hitplus );
build.c~:      fprintf( fpout, "%dd%d+%d\n", pMobIndex->damnodice, pMobIndex->damsizedice, pMobIndex->damplus );
build.c~:      fprintf( fpout, "%d 0\n", pMobIndex->gold );
build.c~:      fprintf( fpout, "%d %d %d\n", pMobIndex->position, pMobIndex->defposition, pMobIndex->sex );
build.c~:                  pMobIndex->perm_str,
build.c~:                  pMobIndex->perm_int,
build.c~:                  pMobIndex->perm_wis, pMobIndex->perm_dex, pMobIndex->perm_con, pMobIndex->perm_cha, pMobIndex->perm_lck );
build.c~:                  pMobIndex->saving_poison_death,
build.c~:                  pMobIndex->saving_wand,
build.c~:                  pMobIndex->saving_para_petri, pMobIndex->saving_breath, pMobIndex->saving_spell_staff );
build.c~:                  pMobIndex->race,
build.c~:                  pMobIndex->height, pMobIndex->weight, pMobIndex->speaks, pMobIndex->speaking, pMobIndex->numattacks );
build.c~:                  pMobIndex->hitroll,
build.c~:                  pMobIndex->damroll,
build.c~:                  pMobIndex->xflags,
build.c~:                  pMobIndex->resistant, pMobIndex->immune, pMobIndex->susceptible, pMobIndex->attacks, pMobIndex->defenses );
build.c~:         fprintf( fpout, "%d 0 0 0 0 0 0 0\n", pMobIndex->vip_flags );
build.c~:      if( pMobIndex->mudprogs )
build.c~:         for( mprog = pMobIndex->mudprogs; mprog; mprog = mprog->next )
build.c~:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c~:               if( mprog->type == IN_FILE_PROG )
build.c~:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c~:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c~:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c~:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c~:   if( install && vnum < tarea->hi_m_vnum )
build.c~:      tarea->hi_m_vnum = vnum - 1;
build.c~:   for( vnum = tarea->low_o_vnum; vnum <= tarea->hi_o_vnum; vnum++ )
build.c~:         REMOVE_BIT( pObjIndex->extra_flags, ITEM_PROTOTYPE );
build.c~:      fprintf( fpout, "%s~\n", pObjIndex->name );
build.c~:      fprintf( fpout, "%s~\n", pObjIndex->short_descr );
build.c~:      fprintf( fpout, "%s~\n", pObjIndex->description );
build.c~:      fprintf( fpout, "%s~\n", pObjIndex->action_desc );
build.c~:      if( pObjIndex->layers )
build.c~:         fprintf( fpout, "%d %d %d %d\n", pObjIndex->item_type,
build.c~:                  pObjIndex->extra_flags, pObjIndex->wear_flags, pObjIndex->layers );
build.c~:         fprintf( fpout, "%d %d %d\n", pObjIndex->item_type, pObjIndex->extra_flags, pObjIndex->wear_flags );
build.c~:      val0 = pObjIndex->value[0];
build.c~:      val1 = pObjIndex->value[1];
build.c~:      val2 = pObjIndex->value[2];
build.c~:      val3 = pObjIndex->value[3];
build.c~:      val4 = pObjIndex->value[4];
build.c~:      val5 = pObjIndex->value[5];
build.c~:      switch ( pObjIndex->item_type )
build.c~:               val1 = skill_table[val1]->slot;
build.c~:               val2 = skill_table[val2]->slot;
build.c~:               val3 = skill_table[val3]->slot;
build.c~:               val3 = skill_table[val3]->slot;
build.c~:               val4 = skill_table[val4]->slot;
build.c~:               val5 = skill_table[val5]->slot;
build.c~:      fprintf( fpout, "%d %d %d\n", pObjIndex->weight,
build.c~:               pObjIndex->cost, pObjIndex->rent ? pObjIndex->rent : ( int )( pObjIndex->cost / 10 ) );
build.c~:      for( ed = pObjIndex->first_extradesc; ed; ed = ed->next )
build.c~:         fprintf( fpout, "E\n%s~\n%s~\n", ed->keyword, strip_cr( ed->description ) );
build.c~:      for( paf = pObjIndex->first_affect; paf; paf = paf->next )
build.c~:         fprintf( fpout, "A\n%d %d\n", paf->location,
build.c~:                  ( ( paf->location == APPLY_WEAPONSPELL
build.c~:                      || paf->location == APPLY_WEARSPELL
build.c~:                      || paf->location == APPLY_REMOVESPELL
build.c~:                      || paf->location == APPLY_STRIPSN )
build.c~:                    && IS_VALID_SN( paf->modifier ) ) ? skill_table[paf->modifier]->slot : paf->modifier );
build.c~:      if( pObjIndex->mudprogs )
build.c~:         for( mprog = pObjIndex->mudprogs; mprog; mprog = mprog->next )
build.c~:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c~:               if( mprog->type == IN_FILE_PROG )
build.c~:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c~:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c~:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c~:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c~:   if( install && vnum < tarea->hi_o_vnum )
build.c~:      tarea->hi_o_vnum = vnum - 1;
build.c~:   for( vnum = tarea->low_r_vnum; vnum <= tarea->hi_r_vnum; vnum++ )
build.c~:         REMOVE_BIT( room->room_flags, ROOM_PROTOTYPE );
build.c~:         for( victim = room->first_person; victim; victim = vnext )
build.c~:            vnext = victim->next_in_room;
build.c~:            if( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:         for( obj = room->first_content; obj; obj = obj_next )
build.c~:            obj_next = obj->next_content;
build.c~:            if( IS_SET( obj->extra_flags, ITEM_PROTOTYPE ) )
build.c~:      fprintf( fpout, "%s~\n", room->name );
build.c~:      fprintf( fpout, "%s~\n", strip_cr( room->description ) );
build.c~:      if( ( room->tele_delay > 0 && room->tele_vnum > 0 ) || room->tunnel > 0 )
build.c~:         fprintf( fpout, "0 %d %d %d %d %d\n", room->room_flags,
build.c~:                  room->sector_type, room->tele_delay, room->tele_vnum, room->tunnel );
build.c~:         fprintf( fpout, "0 %d %d\n", room->room_flags, room->sector_type );
build.c~:      for( xit = room->first_exit; xit; xit = xit->next )
build.c~:         if( IS_SET( xit->exit_info, EX_PORTAL ) ) /* don't fold portals */
build.c~:         fprintf( fpout, "D%d\n", xit->vdir );
build.c~:         fprintf( fpout, "%s~\n", strip_cr( xit->description ) );
build.c~:         fprintf( fpout, "%s~\n", strip_cr( xit->keyword ) );
build.c~:         if( xit->distance > 1 )
build.c~:            fprintf( fpout, "%d %d %d %d\n", xit->exit_info & ~EX_BASHED, xit->key, xit->vnum, xit->distance );
build.c~:            fprintf( fpout, "%d %d %d\n", xit->exit_info & ~EX_BASHED, xit->key, xit->vnum );
build.c~:      for( pReset = room->first_reset; pReset; pReset = pReset->next )
build.c~:	   switch( pReset->command ) /* extra arg1 arg2 arg3 */
build.c~:		   fprintf( fpout, "R %c %d %d %d %d\n", UPPER( pReset->command ),
build.c~:		      pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3 );
build.c~:               for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
build.c~:                     switch( tReset->command )
build.c~:                           fprintf( fpout, "  R %c %d %d %d %d\n", UPPER( tReset->command ),
build.c~:                              tReset->extra, tReset->arg1, tReset->arg2, tReset->arg3 );
build.c~:                           if( tReset->first_reset )
build.c~:                              for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
build.c~:                                 if( gReset->command != 'p' && gReset->command != 'P' )
build.c~:                                 fprintf( fpout, "    R %c %d %d %d %d\n", UPPER( gReset->command ),
build.c~:                                    gReset->extra, gReset->arg1, gReset->arg2, gReset->arg3 );
build.c~:                           fprintf( fpout, "  R %c %d %d %d\n", UPPER( tReset->command ),
build.c~:                              tReset->extra, tReset->arg1, tReset->arg2 );
build.c~:                           if( tReset->first_reset )
build.c~:                              for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
build.c~:                                 if( gReset->command != 'p' && gReset->command != 'P' )
build.c~:                                 fprintf( fpout, "    R %c %d %d %d %d\n", UPPER( gReset->command ),
build.c~:                                    gReset->extra, gReset->arg1, gReset->arg2, gReset->arg3 );
build.c~:                           fprintf( fpout, "  R %c %d %d %d %d\n", UPPER( tReset->command ),
build.c~:                              tReset->extra, tReset->arg1, tReset->arg2, tReset->arg3 );
build.c~:		   fprintf( fpout, "R %c %d %d %d %d\n", UPPER( pReset->command ),
build.c~:		      pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3 );
build.c~:		   fprintf( fpout, "R %c %d %d %d\n", UPPER( pReset->command ), pReset->extra, pReset->arg1, pReset->arg2 );
build.c~:      for( ed = room->first_extradesc; ed; ed = ed->next )
build.c~:         fprintf( fpout, "E\n%s~\n%s~\n", ed->keyword, strip_cr( ed->description ) );
build.c~:      if( room->mudprogs )
build.c~:         for( mprog = room->mudprogs; mprog; mprog = mprog->next )
build.c~:            if( ( mprog->arglist && mprog->arglist[0] != '\0' ) )
build.c~:               if( mprog->type == IN_FILE_PROG )
build.c~:                  fprintf( fpout, "> %s %s~\n", mprog_type_to_name( mprog->type ), mprog->arglist );
build.c~:               else if( mprog->comlist && mprog->comlist[0] != '\0' && !mprog->fileprog )
build.c~:                  fprintf( fpout, "> %s %s~\n%s~\n", mprog_type_to_name( mprog->type ),
build.c~:                     mprog->arglist, strip_cr( mprog->comlist ) );
build.c~:   if( install && vnum < tarea->hi_r_vnum )
build.c~:      tarea->hi_r_vnum = vnum - 1;
build.c~:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c~:      if( ( pShop = pMobIndex->pShop ) == NULL )
build.c~:               pShop->keeper,
build.c~:               pShop->buy_type[0],
build.c~:               pShop->buy_type[1],
build.c~:               pShop->buy_type[2], pShop->buy_type[3], pShop->buy_type[4], pShop->profit_buy, pShop->profit_sell );
build.c~:      fprintf( fpout, "        %2d %2d    ; %s\n", pShop->open_hour, pShop->close_hour, pMobIndex->short_descr );
build.c~:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c~:      if( ( pRepair = pMobIndex->rShop ) == NULL )
build.c~:               pRepair->keeper,
build.c~:               pRepair->fix_type[0], pRepair->fix_type[1], pRepair->fix_type[2], pRepair->profit_fix, pRepair->shop_type );
build.c~:      fprintf( fpout, "        %2d %2d    ; %s\n", pRepair->open_hour, pRepair->close_hour, pMobIndex->short_descr );
build.c~:   for( vnum = tarea->low_m_vnum; vnum <= tarea->hi_m_vnum; vnum++ )
build.c~:         if( pMobIndex->spec_fun )
build.c~:	      fprintf( fpout, "M  %d %s\n", pMobIndex->vnum, pMobIndex->spec_funname );
build.c~:         if( pMobIndex->spec_2 )
build.c~:	      fprintf( fpout, "M  %d %s\n", pMobIndex->vnum, pMobIndex->spec_funname2 );
build.c~:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c~:      tarea = ch->pcdata->area;
build.c~:      for( found = FALSE, tarea = first_build; tarea; tarea = tarea->next )
build.c~:         if( !str_cmp( tarea->filename, argument ) )
build.c~:/* Ensure not wiping out their area with save before load - Scryn 8/11 */
build.c~:   if( !IS_SET( tarea->status, AREA_LOADED ) )
build.c~:   sprintf( filename, "%s%s", BUILD_DIR, tarea->filename );
build.c~:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c~:      tarea = ch->pcdata->area;
build.c~:      for( found = FALSE, tarea = first_build; tarea; tarea = tarea->next )
build.c~:         if( !str_cmp( tarea->filename, argument ) )
build.c~:/* Stops char from loading when already loaded - Scryn 8/11 */
build.c~:   if( IS_SET( tarea->status, AREA_LOADED ) )
build.c~:   sprintf( filename, "%s%s", BUILD_DIR, tarea->filename );
build.c~:   if( tarea->first_room )
build.c~:      tmp = tarea->nplayer;
build.c~:      tarea->nplayer = 0;
build.c~:      tarea->nplayer = tmp;
build.c~: * NOTE: Use of this command is not recommended.		-Thoric
build.c~:      for( tarea = first_area; tarea; tarea = tarea->next )
build.c~:         fold_area( tarea, tarea->filename, FALSE );
build.c~:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c~:      if( !str_cmp( tarea->filename, arg ) )
build.c~:            fold_area( tarea, tarea->filename, TRUE );
build.c~:            fold_area( tarea, tarea->filename, FALSE );
build.c~:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c~:      fprintf( fpout, "%s\n", tarea->filename );
build.c~: * A complicated to use command as it currently exists.		-Thoric
build.c~: * Once area->author and area->name are cleaned up... it will be easier
build.c~:   for( tarea = first_build; tarea; tarea = tarea->next )
build.c~:      if( !str_cmp( tarea->filename, arg ) )
build.c~:            DISPOSE( tarea->name );
build.c~:            tarea->name = str_dup( argument );
build.c~:          * Fold area with install flag -- auto-removes prototype flags 
build.c~:         fold_area( tarea, tarea->filename, TRUE );
build.c~:          * Remove it from the prototype sort list. BUGFIX: Samson 4-15-03 
build.c~:          * Sort the area into it's proper sort list. BUGFIX: Samson 4-15-03 
build.c~:         for( d = first_descriptor; d; d = d->next )
build.c~:            if( d->character && d->character->pcdata && d->character->pcdata->area == tarea )
build.c~:               d->character->pcdata->area = NULL;
build.c~:               d->character->pcdata->r_range_lo = 0;
build.c~:               d->character->pcdata->r_range_hi = 0;
build.c~:               d->character->pcdata->o_range_lo = 0;
build.c~:               d->character->pcdata->o_range_hi = 0;
build.c~:               d->character->pcdata->m_range_lo = 0;
build.c~:               d->character->pcdata->m_range_hi = 0;
build.c~:         num = tarea->nplayer;
build.c~:         tarea->nplayer = 0;
build.c~:         tarea->nplayer = num;
build.c~:         sprintf( buf, "%s%s.installed", BUILD_DIR, tarea->filename );
build.c~:         sprintf( arg, "%s%s", BUILD_DIR, tarea->filename );
build.c~:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c~:      if( !str_cmp( tarea->filename, argument ) )
build.c~:      for( tarea = first_build; tarea; tarea = tarea->next )
build.c~:         if( !str_cmp( tarea->filename, argument ) )
build.c~:         tarea = ch->in_room->area;
build.c~:   ch_printf( ch, "Name: %s\r\nFilename: %-20s  Prototype: %s\r\n", tarea->name, tarea->filename, proto ? "yes" : "no" );
build.c~:                 tarea->max_players, tarea->illegal_pk, tarea->gold_looted );
build.c~:      if( tarea->high_economy )
build.c~:         ch_printf( ch, "Area economy: %d billion and %d credits.\r\n", tarea->high_economy, tarea->low_economy );
build.c~:         ch_printf( ch, "Area economy: %d credits.\r\n", tarea->low_economy );
build.c~:      if( tarea->planet )
build.c~:         ch_printf( ch, "Planet: %s.\r\n", tarea->planet->name );
build.c~:                 tarea->mdeaths, tarea->mkills, tarea->pdeaths, tarea->pkills );
build.c~:   ch_printf( ch, "Author: %s\r\nAge: %d   Number of players: %d\r\n", tarea->author, tarea->age, tarea->nplayer );
build.c~:   ch_printf( ch, "Area flags: %s\r\n", flag_string( tarea->flags, area_flags ) );
build.c~:   ch_printf( ch, "low_room: %5d  hi_room: %d\r\n", tarea->low_r_vnum, tarea->hi_r_vnum );
build.c~:   ch_printf( ch, "low_obj : %5d  hi_obj : %d\r\n", tarea->low_o_vnum, tarea->hi_o_vnum );
build.c~:   ch_printf( ch, "low_mob : %5d  hi_mob : %d\r\n", tarea->low_m_vnum, tarea->hi_m_vnum );
build.c~:   ch_printf( ch, "soft range: %d - %d.  hard range: %d - %d.\r\n",
build.c~:              tarea->low_soft_range, tarea->hi_soft_range, tarea->low_hard_range, tarea->hi_hard_range );
build.c~:   ch_printf( ch, "Resetmsg: %s\r\n", tarea->resetmsg ? tarea->resetmsg : "(default)" );  /* Rennard */
build.c~:   ch_printf( ch, "Reset frequency: %d minutes.\r\n", tarea->reset_frequency ? tarea->reset_frequency : 15 );
build.c~:   for( area = first_area; area; area = area->next )
build.c~:   for( area = first_build; area; area = area->next )
build.c~:   for( tarea = first_area; tarea; tarea = tarea->next )
build.c~:      if( !str_cmp( tarea->filename, arg1 ) )
build.c~:      for( tarea = first_build; tarea; tarea = tarea->next )
build.c~:         if( !str_cmp( tarea->filename, arg1 ) )
build.c~:      for( uarea = first_area; uarea; uarea = uarea->next )
build.c~:         if( !str_cmp( uarea->name, argument ) )
build.c~:      for( uarea = first_build; uarea; uarea = uarea->next )
build.c~:         if( !str_cmp( uarea->name, argument ) )
build.c~:      DISPOSE( tarea->name );
build.c~:      tarea->name = str_dup( argument );
build.c~:         if( tarea->planet )
build.c~:            old_planet = tarea->planet;
build.c~:            UNLINK( tarea, old_planet->first_area, old_planet->last_area, next_on_planet, prev_on_planet );
build.c~:         tarea->planet = planet;
build.c~:         LINK( tarea, planet->first_area, planet->last_area, next_on_planet, prev_on_planet );
build.c~:      strncpy( filename, tarea->filename, 256 );
build.c~:      DISPOSE( tarea->filename );
build.c~:      tarea->filename = str_dup( argument );
build.c~:      rename( filename, tarea->filename );
build.c~:      tarea->low_economy = vnum;
build.c~:      tarea->high_economy = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->low_r_vnum, vnum ) )
build.c~:      if( tarea->hi_r_vnum < vnum )
build.c~:      tarea->low_r_vnum = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->hi_r_vnum, vnum ) )
build.c~:      if( tarea->low_r_vnum > vnum )
build.c~:      tarea->hi_r_vnum = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->low_o_vnum, vnum ) )
build.c~:      if( tarea->hi_o_vnum < vnum )
build.c~:      tarea->low_o_vnum = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->hi_o_vnum, vnum ) )
build.c~:      if( tarea->low_o_vnum > vnum )
build.c~:      tarea->hi_o_vnum = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->low_m_vnum, vnum ) )
build.c~:      if( tarea->hi_m_vnum < vnum )
build.c~:      tarea->low_m_vnum = vnum;
build.c~:      if( check_for_area_conflicts( tarea, tarea->hi_m_vnum, vnum ) )
build.c~:      if( tarea->low_m_vnum > vnum )
build.c~:      tarea->hi_m_vnum = vnum;
build.c~:      tarea->low_soft_range = vnum;
build.c~:      tarea->hi_soft_range = vnum;
build.c~:      tarea->low_hard_range = vnum;
build.c~:      tarea->hi_hard_range = vnum;
build.c~:      STRFREE( tarea->author );
build.c~:      tarea->author = STRALLOC( argument );
build.c~:      if( tarea->resetmsg )
build.c~:         DISPOSE( tarea->resetmsg );
build.c~:         tarea->resetmsg = str_dup( argument );
build.c~:      tarea->reset_frequency = vnum;
build.c~:            if( IS_SET( tarea->flags, 1 << value ) )
build.c~:               REMOVE_BIT( tarea->flags, 1 << value );
build.c~:               SET_BIT( tarea->flags, 1 << value );
build.c~:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_AVATAR || !ch->pcdata
build.c~:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c~:   tarea = ch->pcdata->area;
build.c~:         lrange = tarea->low_r_vnum;   /* here.     -Thoric */
build.c~:         trange = tarea->hi_r_vnum;
build.c~:      if( ( lrange < tarea->low_r_vnum || trange > tarea->hi_r_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c~:      ch_printf( ch, "%5d) %s\r\n", vnum, room->name );
build.c~:    * Greater+ can list out of assigned range - Tri (mlist/rlist as well)
build.c~:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c~:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c~:   tarea = ch->pcdata->area;
build.c~:         lrange = tarea->low_o_vnum;   /* here.     -Thoric */
build.c~:         trange = tarea->hi_o_vnum;
build.c~:      if( ( lrange < tarea->low_o_vnum || trange > tarea->hi_o_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c~:      ch_printf( ch, "%5d) %-20s (%s)\r\n", vnum, obj->name, obj->short_descr );
build.c~:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c~:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c~:   tarea = ch->pcdata->area;
build.c~:         lrange = tarea->low_m_vnum;   /* here.     -Thoric */
build.c~:         trange = tarea->hi_m_vnum;
build.c~:      if( ( lrange < tarea->low_m_vnum || trange > tarea->hi_m_vnum ) && get_trust( ch ) < LEVEL_GREATER )
build.c~:      ch_printf( ch, "%5d) %-20s '%s'\r\n", vnum, mob->player_name, mob->short_descr );
build.c~:   if( mptype != -1 )
build.c~:      mprg->type = 1 << mptype;
build.c~:      if( mprg->arglist )
build.c~:         STRFREE( mprg->arglist );
build.c~:      mprg->arglist = STRALLOC( argument );
build.c~:   ch->substate = SUB_MPROG_EDIT;
build.c~:   ch->dest_buf = mprg;
build.c~:   if( !mprg->comlist )
build.c~:      mprg->comlist = STRALLOC( "" );
build.c~:   start_editing( ch, mprg->comlist );
build.c~: * Mobprogram editing - cumbersome				-Thoric
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_mpedit: sub_mprog_edit: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c~:         if( mprog->comlist )
build.c~:            STRFREE( mprog->comlist );
build.c~:         mprog->comlist = copy_buffer( ch );
build.c~:   if( !IS_SET( victim->act, ACT_PROTOTYPE ) )
build.c~:   mprog = victim->pIndexData->mudprogs;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c~:         if( mptype == -1 )
build.c~:         mptype = -1;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            victim->pIndexData->progtypes = 0;
build.c~:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:               victim->pIndexData->progtypes |= mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            mptype = mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( IS_SET( mprg->type, mptype ) )
build.c~:         mprg_next = victim->pIndexData->mudprogs;
build.c~:         victim->pIndexData->mudprogs = mprg_next->next;
build.c~:            mprg_next = mprg->next;
build.c~:            if( ++cnt == ( value - 1 ) )
build.c~:               mprg->next = mprg_next->next;
build.c~:      STRFREE( mprg_next->arglist );
build.c~:      STRFREE( mprg_next->comlist );
build.c~:         REMOVE_BIT( victim->pIndexData->progtypes, mptype );
build.c~:      if( mptype == -1 )
build.c~:         victim->pIndexData->progtypes |= ( 1 << mptype );
build.c~:         mprg->next = mprog;
build.c~:         victim->pIndexData->mudprogs = mprg;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( ++cnt == value && mprg->next )
build.c~:            victim->pIndexData->progtypes |= ( 1 << mptype );
build.c~:            mprg_next->next = mprg->next;
build.c~:            mprg->next = mprg_next;
build.c~:      if( mptype == -1 )
build.c~:         for( ; mprog->next; mprog = mprog->next );
build.c~:         mprog->next = mprg;
build.c~:         victim->pIndexData->mudprogs = mprg;
build.c~:      victim->pIndexData->progtypes |= ( 1 << mptype );
build.c~:      mprg->next = NULL;
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c~:         if( mprog->comlist )
build.c~:            STRFREE( mprog->comlist );
build.c~:         mprog->comlist = copy_buffer( ch );
build.c~:   mprog = obj->pIndexData->mudprogs;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c~:         if( mptype == -1 )
build.c~:         mptype = -1;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            obj->pIndexData->progtypes = 0;
build.c~:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:               obj->pIndexData->progtypes |= mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            mptype = mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( IS_SET( mprg->type, mptype ) )
build.c~:         mprg_next = obj->pIndexData->mudprogs;
build.c~:         obj->pIndexData->mudprogs = mprg_next->next;
build.c~:            mprg_next = mprg->next;
build.c~:            if( ++cnt == ( value - 1 ) )
build.c~:               mprg->next = mprg_next->next;
build.c~:      STRFREE( mprg_next->arglist );
build.c~:      STRFREE( mprg_next->comlist );
build.c~:         REMOVE_BIT( obj->pIndexData->progtypes, mptype );
build.c~:      if( mptype == -1 )
build.c~:         obj->pIndexData->progtypes |= ( 1 << mptype );
build.c~:         mprg->next = mprog;
build.c~:         obj->pIndexData->mudprogs = mprg;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( ++cnt == value && mprg->next )
build.c~:            obj->pIndexData->progtypes |= ( 1 << mptype );
build.c~:            mprg_next->next = mprg->next;
build.c~:            mprg->next = mprg_next;
build.c~:      if( mptype == -1 )
build.c~:         for( ; mprog->next; mprog = mprog->next );
build.c~:         mprog->next = mprg;
build.c~:         obj->pIndexData->mudprogs = mprg;
build.c~:      obj->pIndexData->progtypes |= ( 1 << mptype );
build.c~:      mprg->next = NULL;
build.c~:   if( mptype != -1 )
build.c~:      mprg->type = 1 << mptype;
build.c~:      if( mprg->arglist )
build.c~:         STRFREE( mprg->arglist );
build.c~:      mprg->arglist = STRALLOC( argument );
build.c~:   ch->substate = SUB_MPROG_EDIT;
build.c~:   ch->dest_buf = mprg;
build.c~:   if( !mprg->comlist )
build.c~:      mprg->comlist = STRALLOC( "" );
build.c~:   start_editing( ch, mprg->comlist );
build.c~:   if( !ch->desc )
build.c~:   switch ( ch->substate )
build.c~:         if( !ch->dest_buf )
build.c~:            bug( "do_opedit: sub_oprog_edit: NULL ch->dest_buf", 0 );
build.c~:            ch->substate = SUB_NONE;
build.c~:         mprog = ( MPROG_DATA* ) ch->dest_buf;
build.c~:         if( mprog->comlist )
build.c~:            STRFREE( mprog->comlist );
build.c~:         mprog->comlist = copy_buffer( ch );
build.c~:   if( !can_rmodify( ch, ch->in_room ) )
build.c~:   mprog = ch->in_room->mudprogs;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         ch_printf( ch, "%d>%s %s\r\n%s\r\n", ++cnt, mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
build.c~:         if( mptype == -1 )
build.c~:         mptype = -1;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            ch->in_room->progtypes = 0;
build.c~:            for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:               ch->in_room->progtypes |= mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:            mptype = mprg->type;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( IS_SET( mprg->type, mptype ) )
build.c~:         mprg_next = ch->in_room->mudprogs;
build.c~:         ch->in_room->mudprogs = mprg_next->next;
build.c~:            mprg_next = mprg->next;
build.c~:            if( ++cnt == ( value - 1 ) )
build.c~:               mprg->next = mprg_next->next;
build.c~:      STRFREE( mprg_next->arglist );
build.c~:      STRFREE( mprg_next->comlist );
build.c~:         REMOVE_BIT( ch->in_room->progtypes, mptype );
build.c~:      if( mptype == -1 )
build.c~:         ch->in_room->progtypes |= ( 1 << mptype );
build.c~:         mprg->next = mprog;
build.c~:         ch->in_room->mudprogs = mprg;
build.c~:      for( mprg = mprog; mprg; mprg = mprg->next )
build.c~:         if( ++cnt == value && mprg->next )
build.c~:            ch->in_room->progtypes |= ( 1 << mptype );
build.c~:            mprg_next->next = mprg->next;
build.c~:            mprg->next = mprg_next;
build.c~:      if( mptype == -1 )
build.c~:         for( ; mprog->next; mprog = mprog->next );
build.c~:         mprog->next = mprg;
build.c~:         ch->in_room->mudprogs = mprg;
build.c~:      ch->in_room->progtypes |= ( 1 << mptype );
build.c~:      mprg->next = NULL;
build.c~:   if( ch->substate == SUB_RESTRICTED )
build.c~:       && ( location->vnum < ch->pcdata->area->low_r_vnum || location->vnum > ch->pcdata->area->hi_r_vnum ) )
build.c~:   if( ch->substate == SUB_RESTRICTED )
build.c~:       && ( obj->vnum < ch->pcdata->area->low_o_vnum || obj->vnum > ch->pcdata->area->hi_o_vnum ) )
build.c~:   if( ch->substate == SUB_RESTRICTED )
build.c~:       && ( mob->vnum < ch->pcdata->area->low_m_vnum || mob->vnum > ch->pcdata->area->hi_m_vnum ) )
build.c~:   for( tmp = first_relation; tmp; tmp = tmp->next )
build.c~:      if( tmp->Type == tp && tmp->Actor == actor && tmp->Subject == subject )
build.c~:   tmp->Type = tp;
build.c~:   tmp->Actor = actor;
build.c~:   tmp->Subject = subject;
build.c~:   for( rq = first_relation; rq; rq = rq->next )
build.c~:      if( rq->Type == tp && rq->Actor == actor && rq->Subject == subject )
build.c~:   types: 0=room, 1=obj, 2=mob                     -->Keberus 12/03/08 */
build.c~:   int low_value =-1, hi_value =-1;
build.c~:   for( area = first_area; area; area = area->next )
build.c~:            low_value = area->low_r_vnum;
build.c~:            hi_value = area->hi_r_vnum;
build.c~:            low_value = area->low_o_vnum;
build.c~:            hi_value = area->hi_o_vnum;
build.c~:            low_value = area->low_m_vnum;
build.c~:            hi_value = area->hi_m_vnum;
build.c~:   for( area = first_build; area; area = area->next )
build.c~:         low_value = area->low_r_vnum;
build.c~:         hi_value = area->hi_r_vnum;
build.c~:         low_value = area->low_o_vnum;
build.c~:         hi_value = area->hi_o_vnum;
build.c~:         low_value = area->low_m_vnum;
build.c~:         hi_value = area->hi_m_vnum;
clans.c:*--------------------------------------------------------------------------*
clans.c:* -------------------------------------------------------------------------*
clans.c:*--------------------------------------------------------------------------*
clans.c:* ------------------------------------------------------------------------ *
clans.c:* ------------------------------------------------------------------------ *
clans.c:   for( clan = first_clan; clan; clan = clan->next )
clans.c:      if( !str_cmp( name, clan->name ) )
clans.c:   for( planet = first_planet; planet; planet = planet->next )
clans.c:      if( !str_cmp( name, planet->name ) )
clans.c:   for( tclan = first_clan; tclan; tclan = tclan->next )
clans.c:      fprintf( fpout, "%s\n", tclan->filename );
clans.c:   for( tplanet = first_planet; tplanet; tplanet = tplanet->next )
clans.c:      fprintf( fpout, "%s\n", tplanet->filename );
clans.c:   if( !clan->filename || clan->filename[0] == '\0' )
clans.c:      bug( "save_clan: %s has no filename", clan->name );
clans.c:   sprintf( filename, "%s%s", CLAN_DIR, clan->filename );
clans.c:      fprintf( fp, "Name         %s~\n", clan->name );
clans.c:      fprintf( fp, "Filename     %s~\n", clan->filename );
clans.c:      fprintf( fp, "Description  %s~\n", clan->description );
clans.c:      fprintf( fp, "Leader       %s~\n", clan->leader );
clans.c:      fprintf( fp, "NumberOne    %s~\n", clan->number1 );
clans.c:      fprintf( fp, "NumberTwo    %s~\n", clan->number2 );
clans.c:      fprintf( fp, "PKills       %d\n", clan->pkills );
clans.c:      fprintf( fp, "PDeaths      %d\n", clan->pdeaths );
clans.c:      fprintf( fp, "MKills       %d\n", clan->mkills );
clans.c:      fprintf( fp, "MDeaths      %d\n", clan->mdeaths );
clans.c:      fprintf( fp, "Type         %d\n", clan->clan_type );
clans.c:      fprintf( fp, "Members      %d\n", clan->members );
clans.c:      fprintf( fp, "Board        %d\n", clan->board );
clans.c:      fprintf( fp, "Storeroom    %d\n", clan->storeroom );
clans.c:      fprintf( fp, "GuardOne     %d\n", clan->guard1 );
clans.c:      fprintf( fp, "GuardTwo     %d\n", clan->guard2 );
clans.c:      fprintf( fp, "PatrolOne    %d\n", clan->patrol1 );
clans.c:      fprintf( fp, "PatrolTwo    %d\n", clan->patrol2 );
clans.c:      fprintf( fp, "TrooperOne   %d\n", clan->trooper1 );
clans.c:      fprintf( fp, "TrooperTwo   %d\n", clan->trooper2 );
clans.c:      fprintf( fp, "Funds        %ld\n", clan->funds );
clans.c:      fprintf( fp, "Jail         %d\n", clan->jail );
clans.c:      if( clan->mainclan )
clans.c:         fprintf( fp, "MainClan     %s~\n", clan->mainclan->name );
clans.c:   if( !planet->filename || planet->filename[0] == '\0' )
clans.c:      bug( "save_planet: %s has no filename", planet->name );
clans.c:   sprintf( filename, "%s%s", PLANET_DIR, planet->filename );
clans.c:      fprintf( fp, "Name         %s~\n", planet->name );
clans.c:      fprintf( fp, "Filename     %s~\n", planet->filename );
clans.c:      fprintf( fp, "BaseValue    %ld\n", planet->base_value );
clans.c:      fprintf( fp, "Flags        %d\n", planet->flags );
clans.c:      fprintf( fp, "PopSupport   %f\n", planet->pop_support );
clans.c:      if( planet->starsystem && planet->starsystem->name )
clans.c:         fprintf( fp, "Starsystem   %s~\n", planet->starsystem->name );
clans.c:      if( planet->governed_by && planet->governed_by->name )
clans.c:         fprintf( fp, "GovernedBy   %s~\n", planet->governed_by->name );
clans.c:      for( pArea = planet->first_area; pArea; pArea = pArea->next_on_planet )
clans.c:         if( pArea->filename )
clans.c:            fprintf( fp, "Area         %s~\n", pArea->filename );
clans.c:            KEY( "Board", clan->board, fread_number( fp ) );
clans.c:            KEY( "Description", clan->description, fread_string( fp ) );
clans.c:               if( !clan->name )
clans.c:                  clan->name = STRALLOC( "" );
clans.c:               if( !clan->leader )
clans.c:                  clan->leader = STRALLOC( "" );
clans.c:               if( !clan->description )
clans.c:                  clan->description = STRALLOC( "" );
clans.c:               if( !clan->number1 )
clans.c:                  clan->number1 = STRALLOC( "" );
clans.c:               if( !clan->number2 )
clans.c:                  clan->number2 = STRALLOC( "" );
clans.c:               if( !clan->tmpstr )
clans.c:                  clan->tmpstr = STRALLOC( "" );
clans.c:            KEY( "Funds", clan->funds, fread_number( fp ) );
clans.c:            KEY( "Filename", clan->filename, fread_string_nohash( fp ) );
clans.c:            KEY( "GuardOne", clan->guard1, fread_number( fp ) );
clans.c:            KEY( "GuardTwo", clan->guard2, fread_number( fp ) );
clans.c:            KEY( "Jail", clan->jail, fread_number( fp ) );
clans.c:            KEY( "Leader", clan->leader, fread_string( fp ) );
clans.c:            KEY( "MDeaths", clan->mdeaths, fread_number( fp ) );
clans.c:            KEY( "Members", clan->members, fread_number( fp ) );
clans.c:            KEY( "MKills", clan->mkills, fread_number( fp ) );
clans.c:            KEY( "MainClan", clan->tmpstr, fread_string( fp ) );
clans.c:            KEY( "Name", clan->name, fread_string( fp ) );
clans.c:            KEY( "NumberOne", clan->number1, fread_string( fp ) );
clans.c:            KEY( "NumberTwo", clan->number2, fread_string( fp ) );
clans.c:            KEY( "PDeaths", clan->pdeaths, fread_number( fp ) );
clans.c:            KEY( "PKills", clan->pkills, fread_number( fp ) );
clans.c:            KEY( "PatrolOne", clan->patrol1, fread_number( fp ) );
clans.c:            KEY( "PatrolTwo", clan->patrol2, fread_number( fp ) );
clans.c:            KEY( "Storeroom", clan->storeroom, fread_number( fp ) );
clans.c:            KEY( "Type", clan->clan_type, fread_number( fp ) );
clans.c:            KEY( "TrooperOne", clan->trooper1, fread_number( fp ) );
clans.c:            KEY( "TrooperTwo", clan->trooper2, fread_number( fp ) );
clans.c:               for( pArea = first_area; pArea; pArea = pArea->next )
clans.c:                  if( pArea->filename && !str_cmp( pArea->filename, aName ) )
clans.c:                     pArea->planet = planet;
clans.c:                     LINK( pArea, planet->first_area, planet->last_area, next_on_planet, prev_on_planet );
clans.c:            KEY( "BaseValue", planet->base_value, fread_number( fp ) );
clans.c:               if( !planet->name )
clans.c:                  planet->name = STRALLOC( "" );
clans.c:            KEY( "Filename", planet->filename, fread_string_nohash( fp ) );
clans.c:            KEY( "Flags", planet->flags, fread_number( fp ) );
clans.c:               planet->governed_by = get_clan( clan_name );
clans.c:            KEY( "Name", planet->name, fread_string( fp ) );
clans.c:            KEY( "PopSupport", planet->pop_support, fread_float( fp ) );
clans.c:               planet->starsystem = starsystem_from_name( starsystem_name );
clans.c:               if( planet->starsystem )
clans.c:                  SPACE_DATA *starsystem = planet->starsystem;
clans.c:                  LINK( planet, starsystem->first_planet, starsystem->last_planet, next_in_system, prev_in_system );
clans.c:            KEY( "Taxes", planet->base_value, fread_number( fp ) );
clans.c:   clan->next_subclan = NULL;
clans.c:   clan->prev_subclan = NULL;
clans.c:   clan->last_subclan = NULL;
clans.c:   clan->first_subclan = NULL;
clans.c:   clan->mainclan = NULL;
clans.c:      if( clan->storeroom == 0 || ( storeroom = get_room_index( clan->storeroom ) ) == NULL )
clans.c:      sprintf( filename, "%s%s.vault", CLAN_DIR, clan->filename );
clans.c:               bug( clan->name, 0 );
clans.c:               bug( clan->name, 0 );
clans.c:         for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
clans.c:            tobj_next = tobj->next_content;
clans.c:   planet->governed_by = NULL;
clans.c:   planet->next_in_system = NULL;
clans.c:   planet->prev_in_system = NULL;
clans.c:   planet->starsystem = NULL;
clans.c:   planet->first_area = NULL;
clans.c:   planet->last_area = NULL;
clans.c:   planet->first_guard = NULL;
clans.c:   planet->last_guard = NULL;
clans.c:   for( clan = first_clan; clan; clan = clan->next )
clans.c:      if( !clan->tmpstr || clan->tmpstr[0] == '\0' )
clans.c:      bosclan = get_clan( clan->tmpstr );
clans.c:      LINK( clan, bosclan->first_subclan, bosclan->last_subclan, next_subclan, prev_subclan );
clans.c:      clan->mainclan = bosclan;
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "induct", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( victim->pcdata->clan )
clans.c:      if( victim->pcdata->clan->clan_type == CLAN_CRIME )
clans.c:         if( victim->pcdata->clan == clan )
clans.c:      else if( victim->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:         if( victim->pcdata->clan == clan )
clans.c:         if( victim->pcdata->clan == clan )
clans.c:   clan->members++;
clans.c:   victim->pcdata->clan = clan;
clans.c:   STRFREE( victim->pcdata->clan_name );
clans.c:   victim->pcdata->clan_name = QUICKLINK( clan->name );
clans.c:   act( AT_MAGIC, "You induct $N into $t", ch, clan->name, victim, TO_CHAR );
clans.c:   act( AT_MAGIC, "$n inducts $N into $t", ch, clan->name, victim, TO_NOTVICT );
clans.c:   act( AT_MAGIC, "$n inducts you into $t", ch, clan->name, victim, TO_VICT );
clans.c:   if( !str_cmp( ch->name, clan->leader ) )
clans.c:   if( !str_cmp( victim->name, clan->leader ) )
clans.c:   if( !str_cmp( ch->name, clan->number1 ) )
clans.c:   if( !str_cmp( victim->name, clan->number1 ) )
clans.c:   if( !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( !str_cmp( victim->name, clan->number2 ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "outcast", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( victim->pcdata->clan != ch->pcdata->clan )
clans.c:   if( victim->speaking & LANG_CLAN )
clans.c:      victim->speaking = LANG_COMMON;
clans.c:   REMOVE_BIT( victim->speaks, LANG_CLAN );
clans.c:   --clan->members;
clans.c:    if( clan->members < 0 )
clans.c:       clan->members = 0;
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   victim->pcdata->clan = NULL;
clans.c:   STRFREE( victim->pcdata->clan_name );
clans.c:   victim->pcdata->clan_name = STRALLOC( "" );
clans.c:   act( AT_MAGIC, "You outcast $N from $t", ch, clan->name, victim, TO_CHAR );
clans.c:   act( AT_MAGIC, "$n outcasts $N from $t", ch, clan->name, victim, TO_ROOM );
clans.c:   act( AT_MAGIC, "$n outcasts you from $t", ch, clan->name, victim, TO_VICT );
clans.c:   sprintf( buf, "%s has been outcast from %s!", victim->name, clan->name );
clans.c:   DISPOSE( victim->pcdata->bestowments );
clans.c:   victim->pcdata->bestowments = str_dup( "" );
clans.c:      STRFREE( clan->leader );
clans.c:      clan->leader = STRALLOC( argument );
clans.c:      if( subclan->clan_type == CLAN_SUBCLAN || subclan->mainclan )
clans.c:      if( subclan->first_subclan )
clans.c:      subclan->clan_type = CLAN_SUBCLAN;
clans.c:      subclan->mainclan = clan;
clans.c:      LINK( subclan, clan->first_subclan, clan->last_subclan, next_subclan, prev_subclan );
clans.c:      STRFREE( clan->number1 );
clans.c:      clan->number1 = STRALLOC( argument );
clans.c:      STRFREE( clan->number2 );
clans.c:      clan->number2 = STRALLOC( argument );
clans.c:      clan->board = atoi( argument );
clans.c:      clan->members = atoi( argument );
clans.c:      clan->funds = atoi( argument );
clans.c:      clan->storeroom = atoi( argument );
clans.c:      clan->guard1 = atoi( argument );
clans.c:      clan->jail = atoi( argument );
clans.c:      clan->guard2 = atoi( argument );
clans.c:      clan->trooper1 = atoi( argument );
clans.c:      clan->trooper2 = atoi( argument );
clans.c:      clan->patrol1 = atoi( argument );
clans.c:      clan->patrol2 = atoi( argument );
clans.c:      if( clan->mainclan )
clans.c:         UNLINK( clan, clan->mainclan->first_subclan, clan->mainclan->last_subclan, next_subclan, prev_subclan );
clans.c:         clan->mainclan = NULL;
clans.c:         clan->clan_type = CLAN_CRIME;
clans.c:         clan->clan_type = CLAN_CRIME;
clans.c:         clan->clan_type = CLAN_GUILD;
clans.c:         clan->clan_type = 0;
clans.c:      STRFREE( clan->name );
clans.c:      clan->name = STRALLOC( argument );
clans.c:      snprintf( filename, sizeof( filename ), "%s%s", CLAN_DIR, clan->filename );
clans.c:      DISPOSE( clan->filename );
clans.c:      clan->filename = str_dup( argument );
clans.c:      STRFREE( clan->description );
clans.c:      clan->description = STRALLOC( argument );
clans.c:      STRFREE( planet->name );
clans.c:      planet->name = STRALLOC( argument );
clans.c:         planet->governed_by = clan;
clans.c:      if( ( starsystem = planet->starsystem ) != NULL )
clans.c:         UNLINK( planet, starsystem->first_planet, starsystem->last_planet, next_in_system, prev_in_system );
clans.c:      if( ( planet->starsystem = starsystem_from_name( argument ) ) )
clans.c:         starsystem = planet->starsystem;
clans.c:         LINK( planet, starsystem->first_planet, starsystem->last_planet, next_in_system, prev_in_system );
clans.c:      for( tplanet = first_planet; tplanet; tplanet = tplanet->next )
clans.c:          if( !str_cmp( tplanet->filename, argument ) )
clans.c:      DISPOSE( planet->filename );
clans.c:      planet->filename = str_dup( argument );
clans.c:      planet->base_value = atoi( argument );
clans.c:            TOGGLE_BIT( planet->flags, PLANET_NOCAPTURE );
clans.c:              clan->clan_type == CLAN_CRIME ? "Crime Family " :
clans.c:              clan->clan_type == CLAN_GUILD ? "Guild " : "Organization ", clan->name, clan->filename );
clans.c:   ch_printf( ch, "Description: %s\r\nLeader: %s\r\n", clan->description, clan->leader );
clans.c:              clan->number1, clan->number2, clan->pkills, clan->pdeaths );
clans.c:   ch_printf( ch, "MKills: %6d    MDeaths: %6d\r\n", clan->mkills, clan->mdeaths );
clans.c:   ch_printf( ch, "Type: %d\r\n", clan->clan_type );
clans.c:   ch_printf( ch, "Members: %3d\r\n", clan->members );
clans.c:   ch_printf( ch, "Board: %5d   Jail: %5d\r\n", clan->board, clan->jail );
clans.c:   ch_printf( ch, "Guard1: %5d  Guard2: %5d\r\n", clan->guard1, clan->guard2 );
clans.c:   ch_printf( ch, "Patrol1: %5d  Patrol2: %5d\r\n", clan->patrol1, clan->patrol2 );
clans.c:   ch_printf( ch, "Trooper1: %5d  Trooper2: %5d\r\n", clan->trooper1, clan->trooper2 );
clans.c:   ch_printf( ch, "Funds: %ld\r\n", clan->funds );
clans.c:   ch_printf( ch, "%s\r\nFilename: %s\r\n", planet->name, planet->filename );
clans.c:   clan->next_subclan = NULL;
clans.c:   clan->prev_subclan = NULL;
clans.c:   clan->last_subclan = NULL;
clans.c:   clan->first_subclan = NULL;
clans.c:   clan->mainclan = NULL;
clans.c:   clan->name = STRALLOC( argument );
clans.c:   clan->description = STRALLOC( "" );
clans.c:   clan->leader = STRALLOC( "" );
clans.c:   clan->number1 = STRALLOC( "" );
clans.c:   clan->number2 = STRALLOC( "" );
clans.c:   clan->tmpstr = STRALLOC( "" );
clans.c:   planet->governed_by = NULL;
clans.c:   planet->next_in_system = NULL;
clans.c:   planet->prev_in_system = NULL;
clans.c:   planet->starsystem = NULL;
clans.c:   planet->first_area = NULL;
clans.c:   planet->last_area = NULL;
clans.c:   planet->first_guard = NULL;
clans.c:   planet->last_guard = NULL;
clans.c:   planet->name = STRALLOC( argument );
clans.c:   planet->flags = 0;
clans.c:   for( clan = first_clan; clan; clan = clan->next )
clans.c:      if( clan->clan_type == CLAN_CRIME || clan->clan_type == CLAN_GUILD || clan->clan_type == CLAN_SUBCLAN )
clans.c:      for( planet = first_planet; planet; planet = planet->next )
clans.c:         if( clan == planet->governed_by )
clans.c:	   support += ( int ) planet->pop_support;
clans.c:      ch_printf( ch, "&WOrganization: &Y%s\r\n", clan->name );
clans.c:      ch_printf( ch, "  &WPlanets: &O%-2d       &WAvg Pop Support: &O%-3d&W    &WRevenue: &O%-10ld\r\n",
clans.c:      ch_printf( ch, "  &O%-20s %-10s %-10s %-10s %-2d %-2d %-3d %ld\r\n",
clans.c:                 "Main", clan->leader, clan->number1, clan->number2, clan->spacecraft, clan->vehicles, clan->members,
clans.c:                 clan->funds );
clans.c:      if( clan->first_subclan )
clans.c:         for( subclan = clan->first_subclan; subclan; subclan = subclan->next_subclan )
clans.c:            ch_printf( ch, "  &O%-20s %-10s %-10s %-10s %-2d %-2d %-3d %ld\r\n",
clans.c:                       subclan->name, subclan->leader, subclan->number1, subclan->number2, subclan->spacecraft,
clans.c:                       subclan->vehicles, subclan->members, subclan->funds );
clans.c:   for( clan = first_clan; clan; clan = clan->next )
clans.c:      if( clan->clan_type != CLAN_CRIME && clan->clan_type != CLAN_GUILD )
clans.c:      ch_printf( ch, "&Y%-22s &O%-10s %-10s %-10s %-2d %-2d %-3d %ld\r\n",
clans.c:                 clan->name, clan->leader, clan->number1, clan->number2, clan->spacecraft, clan->vehicles, clan->members,
clans.c:                 clan->funds );
clans.c:   for( planet = first_planet; planet; planet = planet->next )
clans.c:      ch_printf( ch, "&WPlanet: &G%-15s   &WGoverned By: &G%s %s\r\n",
clans.c:                 planet->name,
clans.c:                 planet->governed_by ? planet->governed_by->name : "",
clans.c:                 IS_SET( planet->flags, PLANET_NOCAPTURE ) ? "(permanent)" : "" );
clans.c:      ch_printf( ch, "&WValue: &G%-10ld&W/&G%-10d   ", get_taxes( planet ), planet->base_value );
clans.c:      ch_printf( ch, "&WPopulation: &G%-5d   &W Pop Support: &G%.1f\r\n", planet->population, planet->pop_support );
clans.c:         for( area = planet->first_area; area; area = area->next_on_planet )
clans.c:            ch_printf( ch, "%s,  ", area->filename );
clans.c:   if( ( victim->position ) != POS_STANDING )
clans.c:   if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) && get_timer( victim, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   victim->position = POS_SHOVE;
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:      if( IS_SET( pexit->exit_info, EX_CLOSED )
clans.c:          && ( !IS_AFFECTED( victim, AFF_PASS_DOOR ) || IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
clans.c:      victim->position = POS_STANDING;
clans.c:   to_room = pexit->to_room;
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:      victim->position = POS_STANDING;
clans.c:   schance += ( ( get_curr_str( ch ) - 15 ) * 3 );
clans.c:   schance += ( ch->top_level - victim->top_level );
clans.c:/* Debugging purposes - show percentage for testing */
clans.c:/* sprintf(buf, "Shove percentage of %s = %d", ch->name, chance);
clans.c:      victim->position = POS_STANDING;
clans.c:   move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:      victim->position = POS_STANDING;
clans.c:    * Remove protection from shove/drag if char shoves -- Blodkai 
clans.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   if( victim->fighting )
clans.c:   if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) && get_timer( victim, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:      if( IS_SET( pexit->exit_info, EX_CLOSED )
clans.c:          && ( !IS_AFFECTED( victim, AFF_PASS_DOOR ) || IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
clans.c:   to_room = pexit->to_room;
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:      victim->position = POS_STANDING;
clans.c:sprintf(buf, "Drag percentage of %s = %d", ch->name, chance);
clans.c:      victim->position = POS_STANDING;
clans.c:   if( victim->position < POS_STANDING )
clans.c:      temp = victim->position;
clans.c:      victim->position = POS_DRAG;
clans.c:      move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:         victim->position = temp;
clans.c:/* Move ch to the room too.. they are doing dragging - Scryn */
clans.c:      move_char( ch, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata )
clans.c:   if( ch->pcdata->clan )
clans.c:      ch_printf( ch, "You will have to resign from %s before you can join a new organization.\r\n", ch->pcdata->clan->name );
clans.c:   if( IS_SET( ch->in_room->room_flags, ROOM_R_RECRUIT ) )
clans.c:   else if( IS_SET( ch->in_room->room_flags, ROOM_E_RECRUIT ) )
clans.c:   SET_BIT( ch->speaks, LANG_CLAN );
clans.c:   ++clan->members;
clans.c:   STRFREE( ch->pcdata->clan_name );
clans.c:   ch->pcdata->clan_name = QUICKLINK( clan->name );
clans.c:   ch->pcdata->clan = clan;
clans.c:   ch_printf( ch, "Welcome to %s.\r\n", clan->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:      ch_printf( ch, "You can't resign from %s ... you are the leader!\r\n", clan->name );
clans.c:   if( ch->speaking & LANG_CLAN )
clans.c:      ch->speaking = LANG_COMMON;
clans.c:   REMOVE_BIT( ch->speaks, LANG_CLAN );
clans.c:   --clan->members;
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( ch->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   ch->pcdata->clan = NULL;
clans.c:   STRFREE( ch->pcdata->clan_name );
clans.c:   ch->pcdata->clan_name = STRALLOC( "" );
clans.c:   act( AT_MAGIC, "You resign your position in $t", ch, clan->name, NULL, TO_CHAR );
clans.c:   sprintf( buf, "%s has quit %s!", ch->name, clan->name );
clans.c:   lose_exp = UMAX( ch->experience[DIPLOMACY_ABILITY] - exp_level( ch->skill_level[DIPLOMACY_ABILITY] ), 0 );
clans.c:   ch->experience[DIPLOMACY_ABILITY] -= lose_exp;
clans.c:   DISPOSE( ch->pcdata->bestowments );
clans.c:   ch->pcdata->bestowments = str_dup( "" );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( !ch->in_room || !IS_SET( ch->in_room->room_flags, ROOM_BANK ) )
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "withdraw", ch->pcdata->bestowments ) ) || !str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( amount > clan->funds )
clans.c:      ch_printf( ch, "%s doesn't have that much!\r\n", clan->name );
clans.c:   ch_printf( ch, "You withdraw %ld credits from %s's funds.\r\n", amount, clan->name );
clans.c:   clan->funds -= amount;
clans.c:   ch->gold += amount;
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( !ch->in_room || !IS_SET( ch->in_room->room_flags, ROOM_BANK ) )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( amount > ch->gold )
clans.c:   ch_printf( ch, "You donate %ld credits to %s's funds.\r\n", amount, clan->name );
clans.c:   clan->funds += amount;
clans.c:   ch->gold -= amount;
clans.c:   if( IS_NPC( ch ) || !ch->pcdata )
clans.c:   if( !ch->pcdata->clan )
clans.c:   if( str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:      if( ch->pcdata->clan->number1 && str_cmp( ch->pcdata->clan->number1, "" ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( arg );
clans.c:      if( ch->pcdata->clan->number2 && str_cmp( ch->pcdata->clan->number2, "" ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( arg );
clans.c:   save_clan( ch->pcdata->clan );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata )
clans.c:   if( !ch->pcdata->clan )
clans.c:   if( str_cmp( ch->name, ch->pcdata->clan->leader ) )
clans.c:   if( !str_cmp( argument, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   else if( !str_cmp( argument, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   save_clan( ch->pcdata->clan );
clans.c:   if( !ch->in_room || !ch->in_room->area )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata )
clans.c:   if( !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->mainclan )
clans.c:      clan = ch->pcdata->clan->mainclan;
clans.c:      clan = ch->pcdata->clan;
clans.c:   if( clan->clan_type == CLAN_CRIME )
clans.c:   if( clan->clan_type == CLAN_GUILD )
clans.c:   if( ( planet = ch->in_room->area->planet ) == NULL )
clans.c:   if( clan == planet->governed_by )
clans.c:   if( planet->starsystem )
clans.c:      for( ship = planet->starsystem->first_ship; ship; ship = ship->next_in_starsystem )
clans.c:         sClan = get_clan( ship->owner );
clans.c:         if( sClan->mainclan )
clans.c:            sClan = sClan->mainclan;
clans.c:         if( sClan == planet->governed_by )
clans.c:   if( IS_SET( planet->flags, PLANET_NOCAPTURE ) )
clans.c:   if( planet->pop_support > 0 )
clans.c:   for( cPlanet = first_planet; cPlanet; cPlanet = cPlanet->next )
clans.c:      if( clan == cPlanet->governed_by )
clans.c:         support += cPlanet->pop_support;
clans.c:   planet->governed_by = clan;
clans.c:   planet->pop_support = 50;
clans.c:   sprintf( buf, "%s has been captured by %s!", planet->name, clan->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "withdraw", ch->pcdata->bestowments ) ) || !str_cmp( ch->name, clan->leader ) )
clans.c:   if( victim->pcdata->clan != ch->pcdata->clan )
clans.c:   if( !victim->pcdata->bestowments )
clans.c:      victim->pcdata->bestowments = str_dup( "" );
clans.c:      ch_printf( ch, "Current bestowed commands on %s: %s.\r\n", victim->name, victim->pcdata->bestowments );
clans.c:   if( str_cmp( ch->name, clan->leader ) && !str_cmp( ch->name, clan->number1 ) )
clans.c:      if( !is_name( arg2, ch->pcdata->bestowments ) )
clans.c:      DISPOSE( victim->pcdata->bestowments );
clans.c:      victim->pcdata->bestowments = str_dup( "" );
clans.c:      ch_printf( ch, "Bestowments removed from %s.\r\n", victim->name );
clans.c:      ch_printf( victim, "%s has removed your bestowed clan abilities.\r\n", ch->name );
clans.c:      sprintf( buf, "%s %s", victim->pcdata->bestowments, arg2 );
clans.c:      DISPOSE( victim->pcdata->bestowments );
clans.c:      victim->pcdata->bestowments = str_dup( buf );
clans.c:      ch_printf( victim, "%s has given you permission to fly clan ships.\r\n", ch->name );
clans.c:      sprintf( buf, "%s %s", victim->pcdata->bestowments, arg2 );
clans.c:      DISPOSE( victim->pcdata->bestowments );
clans.c:      victim->pcdata->bestowments = str_dup( buf );
clans.c:      ch_printf( victim, "%s has given you permission to withdraw clan funds.\r\n", ch->name );
clans.c:      sprintf( buf, "%s %s", victim->pcdata->bestowments, arg2 );
clans.c:      DISPOSE( victim->pcdata->bestowments );
clans.c:      victim->pcdata->bestowments = str_dup( buf );
clans.c:      ch_printf( victim, "%s has given you permission to buy clan ships.\r\n", ch->name );
clans.c:      sprintf( buf, "%s %s", victim->pcdata->bestowments, arg2 );
clans.c:      DISPOSE( victim->pcdata->bestowments );
clans.c:      victim->pcdata->bestowments = str_dup( buf );
clans.c:      ch_printf( victim, "%s has given you permission to induct new members.\r\n", ch->name );
clans.c:    for ( tbounty = first_bounty; tbounty; tbounty = tbounty->next )
clans.c:        fprintf( fpout, "%s\n", tbounty->target );
clans.c:        fprintf( fpout, "%ld\n", tbounty->amount );
clans.c:	bounty->target = STRALLOC(target);
clans.c:	bounty->amount = amount;
clans.c:    for ( gov = first_gov; gov; gov = gov->next )
clans.c:        ch_printf( ch, "%-30s %-25s %-15ld\r\n", gov->name, gov->controlled_by , gov->value );
clans.c:    gov->name		= STRALLOC( argument );
clans.c:    gov->value          = atoi( arg2 );
clans.c:    gov->vnum           = object;
clans.c:    gov->controlled_by  = STRALLOC( "" );
clans.c:	STRFREE( bounty->target );
clans.c:   gain = planet->base_value;
clans.c:   gain += ( long )( planet->base_value * planet->pop_support / 100 );
clans.c:   gain += UMAX( 0, ( int )( planet->pop_support / 10 * planet->population ) );
clans.c:    (link)->prev		= (insert)->prev;		
clans.c:    if ( !(insert)->prev )					
clans.c:      (insert)->prev->next	= (link);			
clans.c:    (insert)->prev		= (link);			
clans.c:    (link)->next		= (insert);			
color.c: *                   ^     +----- |  / ^     ^ |     | +-\                  *
color.c: *                 /   \   +---   |<   | \ / | |     | |  |                 *
color.c: *                /-----\  |      | \  |  v  | |     | |  /                 *
color.c: *               /       \ |      |  \ |     | +-----+ +-/                  *
color.c: * AFKMud Copyright 1997-2005 by Roger Libiez (Samson),                     *
color.c: * Registered with the United States Copyright Office. TX 5-877-286         *
color.c: *               Color Module -- Allow user customizable Colors.            *
color.c: *                                   --Matthew                              *
color.c:* you may e-mail the following address:
color.c:like it, change it around to suite your own needs - Samson */
color.c:      if( !str_cmp( dentry->d_name, "CVS" ) )
color.c:      if( dentry->d_name[0] != '.' )
color.c:         pager_printf( ch, "%s%-15.15s", color_str( AT_PLAIN, ch ), dentry->d_name );
color.c:      pager_printf( ch, "%s%-10s", color_str( count, ch ), pc_displays[count] );
color.c:      pager_printf( ch, "%s%-10s%s", color_str( count, ch ), pc_displays[count], ANSI_RESET );
color.c:      pager_printf( ch, "%s%-10s", color_str( AT_PLAIN, ch ), valid_color[count] );
color.c:         memcpy( &ch->colors, &default_set, sizeof( default_set ) );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      log_printf( "%s: Attempting to reset NPC colors: %s", __FUNCTION__, ch->short_descr );
color.c:	      pager_printf( ch, "%s[%d] %s%-10s", color_str(AT_WHITE,ch), count, color_str( count, ch ), pc_displays[count] );
color.c:		ch->textcolor = textcolor;
color.c:		pager_printf( ch,"Your new text color is: [%d] %s%-10s",textcolor,color_str(textcolor,ch),pc_displays[textcolor]);
color.c:         fprintf( fp, " %d", ch->colors[x] );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:      count = -1;
color.c:         ch->colors[count] = default_set[count];
color.c:         pager_printf( ch, "%-10s", valid_color[count] );
color.c:      pager_printf( ch, "%-10s\r\n", "default" );
color.c:      pager_printf( ch, "Color type %s set to color %s.\r\n", count == -1 ? "_all_" : pc_displays[count], valid_color[y] );
color.c:   if( count == -1 )
color.c:         ch->colors[ccount] = y;
color.c:                    valid_color[y > AT_BLINK ? y - AT_BLINK : y], y > AT_BLINK ? " [BLINKING]" : "", ANSI_RESET );
color.c:      ch->colors[count] = y;
color.c:                    pc_displays[count], valid_color[y - AT_BLINK], ANSI_RESET );
color.c:   if( IS_NPC( ch ) || !IS_SET( ch->act, PLR_ANSI ) )
color.c:   switch ( ch->colors[AType] )
color.c:/* Random Ansi Color Code -- Xorith */
color.c:      case 1: /* Default ANSI Fore-ground */
color.c: * Quixadhal - I rewrote this from scratch.  It now returns the number of
color.c: * NOTE:  dstlen is the length of your pre-allocated buffer that you passed
color.c: * longest translation sequence (probably around 16-32).
color.c:      ch = d->original ? d->original : d->character;
color.c:         ansi = ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_ANSI ) );
color.c:                  sublen = sympos - src - 2;
color.c:                  if( ch && ch->desc )
color.c:                     mudstrlcat( dst, color_str( ch->desc->pagecolor, ch ), dstlen );
color.c: * Quixadhal - I rewrote this too, so that it uses colorcode.  It may not
color.c:            break;   /* this was missing - if you have issues, remove it */
color.c: * Quixadhal - And this one needs to use the new version too.
color.c:   space = ( size - len );
color.c: * Quixadhal - This takes a string and converts any and all color tokens
color.c:            if( ( MAX_STRING_LENGTH - ( reslen = strlen( result ) ) ) <= ( colstr - prevstr ) )
color.c:            strncat( result, prevstr, ( colstr - prevstr ) );  /* Leave this one alone! BAD THINGS(TM) will happen if you don't! */
color.c:            result[reslen + ( colstr - prevstr )] = '\0';   /* strncat will NOT NULL terminate this! */
color.c:   if( !ch || !ch->desc )
color.c:   write_to_buffer( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "set_char_color: NULL descriptor after WTB! CH: %s", ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( !d->pagebuf )
color.c:      d->pagesize = MAX_STRING_LENGTH;
color.c:      CREATE( d->pagebuf, char, d->pagesize );
color.c:   if( !d->pagepoint )
color.c:      d->pagepoint = d->pagebuf;
color.c:      d->pagetop = 0;
color.c:      d->pagecmd = '\0';
color.c:   if( d->pagetop == 0 && !d->fcommand )
color.c:      d->pagebuf[0] = '\r';
color.c:      d->pagebuf[1] = '\n';
color.c:      d->pagetop = 2;
color.c:   pageroffset = d->pagepoint - d->pagebuf;  /* pager fix (goofup fixed 08/21/97) */
color.c:   while( d->pagetop + length >= d->pagesize )
color.c:      if( d->pagesize > MAX_STRING_LENGTH * 16 )
color.c:         d->pagetop = 0;
color.c:         d->pagepoint = NULL;
color.c:         DISPOSE( d->pagebuf );
color.c:         d->pagesize = MAX_STRING_LENGTH;
color.c:      d->pagesize *= 2;
color.c:      RECREATE( d->pagebuf, char, d->pagesize );
color.c:   d->pagepoint = d->pagebuf + pageroffset;  /* pager fix (goofup fixed 08/21/97) */
color.c:   strncpy( d->pagebuf + d->pagetop, txt, length );   /* Leave this one alone! BAD THINGS(TM) will happen if you don't! */
color.c:   d->pagetop += length;
color.c:   d->pagebuf[d->pagetop] = '\0';
color.c:   if( !ch || !ch->desc )
color.c:   write_to_pager( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "%s: NULL descriptor after WTP! CH: %s", __FUNCTION__, ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( !txt || !d->descriptor )
color.c:   if( txt && ch->desc )
color.c:      send_to_desc_color( txt, ch->desc );
color.c:   if( txt && ch->desc )
color.c:      DESCRIPTOR_DATA *d = ch->desc;
color.c:      ch = d->original ? d->original : d->character;
color.c:      if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
color.c:         if( ch->desc )
color.c:            send_to_desc_color( txt, ch->desc );
color.c:         if( ch->desc )
color.c:            write_to_pager( ch->desc, colorize( txt, ch->desc ), 0 );
color.c:/* Major overhaul. -- Alty */
color.h: *                   ^     +----- |  / ^     ^ |     | +-\                  *
color.h: *                 /   \   +---   |<   | \ / | |     | |  |                 *
color.h: *                /-----\  |      | \  |  v  | |     | |  /                 *
color.h: *               /       \ |      |  \ |     | +-----+ +-/                  *
color.h: * AFKMud Copyright 1997-2005 by Roger Libiez (Samson),                     *
color.h: * Registered with the United States Copyright Office. TX 5-877-286         *
color.h: *               Color Module -- Allow user customizable Colors.            *
color.h: *                                   --Matthew                              *
color.h:/* These should be 17 - 31 normaly */
color.h:#define AT_AFLAGS          78 /* Added by Samson 9-29-98 for area flag display line */
color.h:#define AT_WHO            79  /* Added by Samson 9-29-98 for wholist */
color.h:#define AT_RACETALK       80  /* Added by Samson 9-29-98 for version 1.4 code */
color.h:#define AT_IGNORE         81  /* Added by Samson 9-29-98 for version 1.4 code */
color.h:#define AT_WHISPER        82  /* Added by Samson 9-29-98 for version 1.4 code */
color.h:#define AT_DIVIDER        83  /* Added by Samson 9-29-98 for version 1.4 code */
color.h:#define AT_MORPH          84  /* Added by Samson 9-29-98 for version 1.4 code */
color.h:#define AT_SHOUT        85 /* Added by Samson 9-29-98 for shout channel */
color.h:#define AT_RFLAGS       86 /* Added by Samson 12-20-98 for room flag display line */
color.h:#define AT_STYPE        87 /* Added by Samson 12-20-98 for sector display line */
color.h:#define AT_ANAME        88 /* Added by Samson 12-20-98 for filename display line */
color.h:#define AT_AUCTION      89 /* Added by Samson 12-25-98 for auction channel */
color.h:#define AT_SCORE2       90 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_SCORE3       91 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_SCORE4       92 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_WHO2         93 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_WHO3         94 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_WHO4         95 /* Added by Samson 2-3-99 for DOTD code */
color.h:#define AT_INTERMUD     96 /* Added by Samson 1-15-01 for Intermud3 Channels */
color.h:#define AT_HELP         97 /* Added by Samson 1-15-01 for helpfiles */
color.h:#define AT_WHO5         98 /* Added by Samson 2-7-01 for guild names on who */
color.h:#define AT_SCORE5       99 /* Added by Samson 1-14-02 */
color.h:#define AT_WHO6        100 /* Added by Samson 1-14-02 */
color.h:#define AT_WHO7        101 /* Added by Samson 1-14-02 */
color.h:#define AT_PRAC        102 /* Added by Samson 1-21-02 */
color.h:#define AT_PRAC2       103 /* Added by Samson 1-21-02 */
color.h:#define AT_PRAC3       104 /* Added by Samson 1-21-02 */
color.h:#define AT_PRAC4       105 /* Added by Samson 1-21-02 */
color.h:#define AT_MXPPROMPT   106 /* Added by Samson 2-27-02 */
color.h:#define AT_BOARD       108 /* Samson 10-14-03 */
color.h:#define AT_BOARD2      109 /* Samson 10-14-03 */
color.h:#define AT_BOARD3      110 /* Samson 10-14-03 */
comm.c:*--------------------------------------------------------------------------*
comm.c:* -------------------------------------------------------------------------*
comm.c:*--------------------------------------------------------------------------*
comm.c:* ------------------------------------------------------------------------ *
comm.c:* ------------------------------------------------------------------------ *
comm.c:*			 Low-level communication module			   *
comm.c: * OS-dependent local functions.
comm.c: * Other local functions (OS-independent).
comm.c:   int imcsocket = -1;
comm.c:   boot_time = time( 0 );  /*  <-- I think this is what you wanted */
comm.c:    * set_boot_time->hour   = 6;
comm.c:    * set_boot_time->min    = 0;
comm.c:    * set_boot_time->sec    = 0;
comm.c:   set_boot_time->manual = 0;
comm.c:    * new_boot_time to new_boot_struct again. -- Alty 
comm.c:   new_boot_time->tm_mday += 1;
comm.c:   if( new_boot_time->tm_hour > 12 )
comm.c:      new_boot_time->tm_mday += 1;
comm.c:   new_boot_time->tm_sec = 0;
comm.c:   new_boot_time->tm_min = 0;
comm.c:   new_boot_time->tm_hour = 6;
comm.c:   dnew->next = NULL;
comm.c:   dnew->descriptor = desc;
comm.c:   dnew->connected = CON_GET_NAME;
comm.c:   dnew->outsize = 2000;
comm.c:   dnew->idle = 0;
comm.c:   dnew->lines = 0;
comm.c:   dnew->scrlen = 24;
comm.c:   dnew->newstate = 0;
comm.c:   dnew->prevcolor = 0x07;
comm.c:   dnew->can_compress = FALSE;
comm.c:   dnew->ifd = -1; /* Descriptor pipes, used for DNS resolution and such */
comm.c:   dnew->ipid = -1;
comm.c:   CREATE( dnew->mccp, MCCP, 1 );
comm.c:   CREATE( dnew->outbuf, char, dnew->outsize );
comm.c:   sa.sin_family = AF_INET;   /* hp->h_addrtype; */
comm.c:   if( bind( fd, ( struct sockaddr * )&sa, sizeof( sa ) ) == -1 )
comm.c:  for ( ch = first_char; ch; ch = ch->next )
comm.c:    sprintf( buf, "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ',
comm.c:    		ch->name, ch->in_room->vnum );
comm.c: * LAG alarm!							-Thoric
comm.c:   for( d = first_descriptor; d; d = d->next )
comm.c:      maxdesc = UMAX( maxdesc, d->descriptor );
comm.c:      FD_SET( d->descriptor, &in_set );
comm.c:      FD_SET( d->descriptor, &out_set );
comm.c:      FD_SET( d->descriptor, &exc_set );
comm.c:      if( d->ifd != -1 && d->ipid != -1 )
comm.c:         maxdesc = UMAX( maxdesc, d->ifd );
comm.c:         FD_SET( d->ifd, &in_set );
comm.c:         if( d == d->next )
comm.c:            d->next = NULL;
comm.c:         d_next = d->next;
comm.c:         d->idle++;  /* make it so a descriptor can idle out */
comm.c:         if( FD_ISSET( d->descriptor, &exc_set ) )
comm.c:            FD_CLR( d->descriptor, &in_set );
comm.c:            FD_CLR( d->descriptor, &out_set );
comm.c:            if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c:               save_char_obj( d->character );
comm.c:            d->outtop = 0;
comm.c:         else if( ( !d->character && d->idle > 360 )  /* 2 mins */
comm.c:                  || ( d->connected != CON_PLAYING && d->idle > 1200 )  /* 5 mins */
comm.c:                  || d->idle > 28800 ) /* 2 hrs  */
comm.c:            d->outtop = 0;
comm.c:            d->fcommand = FALSE;
comm.c:            if( FD_ISSET( d->descriptor, &in_set ) )
comm.c:               d->idle = 0;
comm.c:               if( d->character )
comm.c:                  d->character->timer = 0;
comm.c:                  FD_CLR( d->descriptor, &out_set );
comm.c:                  if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c:                     save_char_obj( d->character );
comm.c:                  d->outtop = 0;
comm.c:            if( ( d->connected == CON_PLAYING || d->character != NULL ) && d->ifd != -1 && FD_ISSET( d->ifd, &in_set ) )
comm.c:            if( d->character && d->character->wait > 0 )
comm.c:               --d->character->wait;
comm.c:            if( d->incomm[0] != '\0' )
comm.c:               d->fcommand = TRUE;
comm.c:               stop_idling( d->character );
comm.c:               strcpy( cmdline, d->incomm );
comm.c:               d->incomm[0] = '\0';
comm.c:               if( d->character )
comm.c:                  set_cur_char( d->character );
comm.c:               if( d->pagepoint )
comm.c:                  switch ( d->connected )
comm.c:                        interpret( d->character, cmdline );
comm.c:                        edit_buffer( d->character, cmdline );
comm.c:         d_next = d->next;
comm.c:         if( ( d->fcommand || d->outtop > 0 ) && FD_ISSET( d->descriptor, &out_set ) )
comm.c:            if( d->pagepoint )
comm.c:                  if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c:                     save_char_obj( d->character );
comm.c:                  d->outtop = 0;
comm.c:               if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c:                  save_char_obj( d->character );
comm.c:               d->outtop = 0;
comm.c:       * Sleep( last_time + 1/PULSE_PER_SECOND - now ).
comm.c:         usecDelta = ( ( int )last_time.tv_usec ) - ( ( int )now_time.tv_usec ) + 1000000 / PULSE_PER_SECOND;
comm.c:         secDelta = ( ( int )last_time.tv_sec ) - ( ( int )now_time.tv_sec );
comm.c:            secDelta -= 1;
comm.c:            usecDelta -= 1000000;
comm.c:   if( fcntl( desc, F_SETFL, FNDELAY ) == -1 )
comm.c:   dnew->port = ntohs( sock.sin_port );
comm.c:   dnew->host = STRALLOC( log_buf );
comm.c:         STRFREE( dnew->host );
comm.c:         dnew->host = STRALLOC( buf );
comm.c:   for( pban = first_ban; pban; pban = pban->next )
comm.c:      if( ( !str_prefix( pban->name, dnew->host ) || !str_suffix( pban->name, dnew->host ) ) && pban->level >= LEVEL_SUPREME )
comm.c:      for( d = first_descriptor; d; d = d->next )
comm.c:         if( !d->next )
comm.c:    * Send the greeting. Forces new color function - Tawnos
comm.c:      sprintf( log_buf, "Broke all-time maximum player record: %d", sysdata.alltimemax );
comm.c:   close( d->descriptor );
comm.c:   STRFREE( d->host );
comm.c:   DISPOSE( d->outbuf );
comm.c:   if( d->pagebuf )
comm.c:      DISPOSE( d->pagebuf );
comm.c:   DISPOSE( d->mccp );
comm.c:   --num_descriptors;
comm.c:   if( dclose->ipid != -1 )
comm.c:      kill( dclose->ipid, SIGKILL );
comm.c:      waitpid( dclose->ipid, &status, 0 );
comm.c:   if( dclose->ifd != -1 )
comm.c:      close( dclose->ifd );
comm.c:   if( !force && dclose->outtop > 0 )
comm.c:   if( dclose->snoop_by )
comm.c:      write_to_buffer( dclose->snoop_by, "Your victim has left the game.\r\n", 0 );
comm.c:   for( d = first_descriptor; d; d = d->next )
comm.c:      if( d->snoop_by == dclose )
comm.c:         d->snoop_by = NULL;
comm.c:    * Check for switched people who go link-dead. -- Altrag 
comm.c:   if( dclose->original )
comm.c:      if( ( ch = dclose->character ) != NULL )
comm.c:         bug( "Close_socket: dclose->original without character %s",
comm.c:              ( dclose->original->name ? dclose->original->name : "unknown" ) );
comm.c:         dclose->character = dclose->original;
comm.c:         dclose->original = NULL;
comm.c:   ch = dclose->character;
comm.c:   if( !dclose->prev && dclose != first_descriptor )
comm.c:      bug( "Close_socket: %s desc:%p != first_desc:%p and desc->prev = NULL!",
comm.c:           ch ? ch->name : d->host, dclose, first_descriptor );
comm.c:         dn = d->next;
comm.c:            bug( "Close_socket: %s desc:%p found, prev should be:%p, fixing.", ch ? ch->name : d->host, dclose, dp );
comm.c:            dclose->prev = dp;
comm.c:      if( !dclose->prev )
comm.c:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c:   if( !dclose->next && dclose != last_descriptor )
comm.c:      bug( "Close_socket: %s desc:%p != last_desc:%p and desc->next = NULL!",
comm.c:           ch ? ch->name : d->host, dclose, last_descriptor );
comm.c:         dp = d->prev;
comm.c:            bug( "Close_socket: %s desc:%p found, next should be:%p, fixing.", ch ? ch->name : d->host, dclose, dn );
comm.c:            dclose->next = dn;
comm.c:      if( !dclose->next )
comm.c:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c:   if( dclose->character )
comm.c:      sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:      log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:	if ( ch->top_level < LEVEL_DEMI )
comm.c:	  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
comm.c:      if( dclose->connected == CON_PLAYING || dclose->connected == CON_EDITING )
comm.c:         ch->desc = NULL;
comm.c:         dclose->character->desc = NULL;
comm.c:         free_char( dclose->character );
comm.c:         d_next = d_next->next;
comm.c:   if( dclose->descriptor == maxdesc )
comm.c:      --maxdesc;
comm.c:   if( d->incomm[0] != '\0' )
comm.c:   iStart = strlen( d->inbuf );
comm.c:   if( iStart >= sizeof( d->inbuf ) - 10 )
comm.c:      sprintf( log_buf, "%s input overflow!", d->host );
comm.c:      nRead = read( d->descriptor, d->inbuf + iStart, sizeof( d->inbuf ) - 10 - iStart );
comm.c:         if( d->inbuf[iStart - 1] == '\n' || d->inbuf[iStart - 1] == '\r' )
comm.c:   d->inbuf[iStart] = '\0';
comm.c:   if( d->incomm[0] != '\0' )
comm.c:   for( i = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r' && i < MAX_INBUF_SIZE; i++ )
comm.c:      if( d->inbuf[i] == '\0' )
comm.c:   for( i = 0, k = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c:          * for ( ; d->inbuf[i] != '\0' || i>= MAX_INBUF_SIZE ; i++ )
comm.c:          * if ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:         d->inbuf[i] = '\n';
comm.c:         d->inbuf[i + 1] = '\0';
comm.c:      if( d->inbuf[i] == ( signed char )IAC )
comm.c:               && ( d->inbuf[i] == ( signed char )DO || d->inbuf[i] == ( signed char )DONT
comm.c:                    || d->inbuf[i] == ( signed char )WILL ) )
comm.c:         if( d->inbuf[i] == ( signed char )TELOPT_COMPRESS2 )
comm.c:            if( d->inbuf[i - 1] == ( signed char )DO )
comm.c:            else if( d->inbuf[i - 1] == ( signed char )DONT )
comm.c:      else if( d->inbuf[i] == '\b' && k > 0 )
comm.c:         --k;
comm.c:      else if( isascii( d->inbuf[i] ) && isprint( d->inbuf[i] ) )
comm.c:         d->incomm[k++] = d->inbuf[i];
comm.c:      d->incomm[k++] = ' ';
comm.c:   d->incomm[k] = '\0';
comm.c:   if( k > 1 || d->incomm[0] == '!' )
comm.c:      if( d->incomm[0] != '!' && strcmp( d->incomm, d->inlast ) )
comm.c:         d->repeat = 0;
comm.c:         if( ++d->repeat >= 20 )
comm.c:/*		sprintf( log_buf, "%s input spamming!", d->host );
comm.c:   if( d->incomm[0] == '!' )
comm.c:      strcpy( d->incomm, d->inlast );
comm.c:      strcpy( d->inlast, d->incomm );
comm.c:   while( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c:   for( j = 0; ( d->inbuf[j] = d->inbuf[i + j] ) != '\0'; j++ )
comm.c:   ch = d->original ? d->original : d->character;
comm.c:   if( ch && ch->fighting && ch->fighting->who )
comm.c:      show_condition( ch, ch->fighting->who );
comm.c:    * If buffer has more than 4K inside, spit out .5K at a time   -Thoric
comm.c:   if( !mud_down && d->outtop > 4096 )
comm.c:      memcpy( buf, d->outbuf, 512 );
comm.c:      memmove( d->outbuf, d->outbuf + 512, d->outtop - 512 );
comm.c:      d->outtop -= 512;
comm.c:      if( d->snoop_by )
comm.c:         if( d->character && d->character->name )
comm.c:            if( d->original && d->original->name )
comm.c:               sprintf( snoopbuf, "%s (%s)", d->character->name, d->original->name );
comm.c:               sprintf( snoopbuf, "%s", d->character->name );
comm.c:            write_to_buffer( d->snoop_by, snoopbuf, 0 );
comm.c:         write_to_buffer( d->snoop_by, "% ", 2 );
comm.c:         write_to_buffer( d->snoop_by, buf, 0 );
comm.c:         d->outtop = 0;
comm.c:   if( fPrompt && !mud_down && d->connected == CON_PLAYING )
comm.c:      ch = d->original ? d->original : d->character;
comm.c:      if( IS_SET( ch->act, PLR_BLANK ) )
comm.c:      if( IS_SET( ch->act, PLR_PROMPT ) )
comm.c:	if(ch->piloting == NULL)
comm.c:      if( IS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:    * Short-circuit if nothing to write.
comm.c:   if( d->outtop == 0 )
comm.c:    * Snoop-o-rama.
comm.c:   if( d->snoop_by )
comm.c:       * without check, 'force mortal quit' while snooped caused crash, -h 
comm.c:      if( d->character && d->character->name )
comm.c:          * Show original snooped names. -- Altrag 
comm.c:         if( d->original && d->original->name )
comm.c:            sprintf( buf, "%s (%s)", d->character->name, d->original->name );
comm.c:            sprintf( buf, "%s", d->character->name );
comm.c:         write_to_buffer( d->snoop_by, buf, 0 );
comm.c:      write_to_buffer( d->snoop_by, "% ", 2 );
comm.c:      write_to_buffer( d->snoop_by, d->outbuf, d->outtop );
comm.c:    * OS-dependent output.
comm.c:   if( !write_to_descriptor( d, d->outbuf, d->outtop ) )
comm.c:      d->outtop = 0;
comm.c:      d->outtop = 0;
comm.c:   if( !d->outbuf )
comm.c:   if( d->outtop == 0 && !d->fcommand )
comm.c:      d->outbuf[0] = '\n';
comm.c:      d->outbuf[1] = '\r';
comm.c:      d->outtop = 2;
comm.c:   while( d->outtop + length >= d->outsize )
comm.c:      if( d->outsize > 32000 )
comm.c:         d->outtop = 0;
comm.c:         bug( "Buffer overflow. Closing (%s).", d->character ? d->character->name : "???" );
comm.c:      d->outsize *= 2;
comm.c:      RECREATE( d->outbuf, char, d->outsize );
comm.c:   strncpy( d->outbuf + d->outtop, txt, length );
comm.c:   d->outtop += length;
comm.c:   d->outbuf[d->outtop] = '\0';
comm.c:* This is the MCCP version. Use write_to_descriptor_old to send non-compressed
comm.c:* him.;P -Orion
comm.c:   if( d && d->mccp->out_compress )
comm.c:      d->mccp->out_compress->next_in = ( unsigned char * )txt;
comm.c:      d->mccp->out_compress->avail_in = length;
comm.c:      while( d->mccp->out_compress->avail_in )
comm.c:         d->mccp->out_compress->avail_out =
comm.c:            COMPRESS_BUF_SIZE - ( d->mccp->out_compress->next_out - d->mccp->out_compress_buf );
comm.c:         if( d->mccp->out_compress->avail_out )
comm.c:            int status = deflate( d->mccp->out_compress, Z_SYNC_FLUSH );
comm.c:         len = d->mccp->out_compress->next_out - d->mccp->out_compress_buf;
comm.c:               nBlock = UMIN( len - iStart, 4096 );
comm.c:               nWrite = send( d->descriptor, d->mccp->out_compress_buf + iStart, nBlock, 0 );
comm.c:               if( nWrite == -1 )
comm.c:                      * not using it, but I've included it in case. -Orion
comm.c:               memmove( d->mccp->out_compress_buf, d->mccp->out_compress_buf + iStart, len - iStart );
comm.c:            d->mccp->out_compress->next_out = d->mccp->out_compress_buf + len - iStart;
comm.c:      nBlock = UMIN( length - iStart, 4096 );
comm.c:      nWrite = send( d->descriptor, txt + iStart, nBlock, 0 );
comm.c:      if( nWrite == -1 )
comm.c:             * not using it, but I've included it in case. -Orion
comm.c: * out to Rustry for his suggestions. -Orion
comm.c:      nBlock = UMIN( length - iStart, 4096 );
comm.c:      if( nWrite == -1 )
comm.c:             * not using it, but I've included it in case. -Orion
comm.c:   ch = d->character;
comm.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:      if( IS_SET( ch->act, PLR_ANSI ) )
comm.c:   d->connected = CON_PRESS_ENTER;
comm.c:  switch( d->connected )
comm.c:      bug( "Nanny: bad d->connected %d.", d->connected );
comm.c:      if( d->newstate == 0 )
comm.c:	  d->newstate++;
comm.c:	  d->connected = CON_GET_NAME;
comm.c:  if( !d->character )
comm.c:      sprintf( log_buf, "Bad player file %s@%s.", argument, d->host );
comm.c:  ch = d->character;
comm.c:  for( pban = first_ban; pban; pban = pban->next )
comm.c:      if( ( !str_prefix( pban->name, d->host )
comm.c:	    || !str_suffix( pban->name, d->host ) ) && pban->level >= ch->top_level )
comm.c:  if( IS_SET( ch->act, PLR_DENY ) )
comm.c:      sprintf( log_buf, "Denying access to %s@%s.", argument, d->host );
comm.c:      if( d->newstate != 0 )
comm.c:	  d->connected = CON_GET_NAME;
comm.c:      if( d->newstate != 0 )
comm.c:	  d->connected = CON_GET_NAME;
comm.c:      d->connected = CON_GET_OLD_PASSWORD;
comm.c:      d->connected = CON_CONFIRM_NEW_NAME;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:      d->character->desc = NULL;
comm.c:  if( check_playing( d, ch->name, TRUE ) )
comm.c:  chk = check_reconnect( d, ch->name, TRUE );
comm.c:      if( d->character && d->character->desc )
comm.c:	d->character->desc = NULL;
comm.c:  if( check_multi( d, ch->name ) )
comm.c:  strcpy( buf, ch->name );
comm.c:  d->character->desc = NULL;
comm.c:  free_char( d->character );
comm.c:  ch = d->character;
comm.c:  sprintf( log_buf, "%s (%s) has connected.", ch->name, d->host );
comm.c:  if( ch->top_level < LEVEL_DEMI )
comm.c:    log_string_plus( log_buf, LOG_COMM, ch->top_level );
comm.c:  if( ch->pcdata->area )
comm.c:  CHAR_DATA *ch = d->character;
comm.c:	       "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c:      d->connected = CON_GET_NEW_PASSWORD;
comm.c:      d->character->desc = NULL;
comm.c:      free_char( d->character );
comm.c:      d->character = NULL;
comm.c:      d->connected = CON_GET_NAME;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  pwdnew = sha256_crypt( argument );   /* SHA-256 Encryption */
comm.c:  DISPOSE( ch->pcdata->pwd );
comm.c:  ch->pcdata->pwd = str_dup( pwdnew );
comm.c:  d->connected = CON_CONFIRM_NEW_PASSWORD;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:      d->connected = CON_GET_NEW_PASSWORD;
comm.c:  d->connected = CON_GET_NEW_SEX;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:      ch->sex = SEX_MALE;
comm.c:      ch->sex = SEX_FEMALE;
comm.c:      ch->sex = SEX_NEUTRAL;
comm.c:  d->connected = CON_GET_NEW_RACE;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  ch = d->character;
comm.c:	  ch->race = iRace;
comm.c:  d->connected = CON_GET_NEW_CLASS;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:	  ch->main_ability = iClass;
comm.c:  d->connected = CON_ROLL_STATS;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  ch->perm_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_int = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_wis = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_dex = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_con = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_cha = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:  ch->perm_str += race_table[ch->race].str_plus;
comm.c:  ch->perm_int += race_table[ch->race].int_plus;
comm.c:  ch->perm_wis += race_table[ch->race].wis_plus;
comm.c:  ch->perm_dex += race_table[ch->race].dex_plus;
comm.c:  ch->perm_con += race_table[ch->race].con_plus;
comm.c:  ch->perm_cha += race_table[ch->race].cha_plus;
comm.c:	   ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha );
comm.c:  d->connected = CON_STATS_OK;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:      ch->perm_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_int = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_wis = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_dex = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_con = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_cha = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c:      ch->perm_str += race_table[ch->race].str_plus;
comm.c:      ch->perm_int += race_table[ch->race].int_plus;
comm.c:      ch->perm_wis += race_table[ch->race].wis_plus;
comm.c:      ch->perm_dex += race_table[ch->race].dex_plus;
comm.c:      ch->perm_con += race_table[ch->race].con_plus;
comm.c:      ch->perm_cha += race_table[ch->race].cha_plus;
comm.c:	       ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex,
comm.c:	       ch->perm_con, ch->perm_cha );
comm.c:  d->connected = CON_GET_WANT_RIPANSI;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:      SET_BIT( ch->act, PLR_ANSI );
comm.c:  d->connected = CON_GET_MSP;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:      SET_BIT( ch->act, PLR_SOUND );
comm.c:  sprintf( log_buf, "%s@%s new %s.", ch->name, d->host,
comm.c:	      race_table[ch->race].race_name );
comm.c:      ch->skill_level[ability] = 0;
comm.c:  ch->top_level = 0;
comm.c:  ch->position = POS_STANDING;
comm.c:  d->connected = CON_PRESS_ENTER;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  if( IS_SET( ch->act, PLR_ANSI ) )
comm.c:  if( ch->top_level > 0 )
comm.c:  if( ch->top_level >= LEVEL_HERO )
comm.c:  if( ch->top_level == 0 )
comm.c:  d->connected = CON_READ_MOTD;
comm.c:  CHAR_DATA *ch = d->character;
comm.c:  d->connected = CON_PLAYING;
comm.c:  if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SOUND ) )
comm.c:  if( ch->top_level == 0 )
comm.c:      ch->pcdata->clan = NULL;
comm.c:      ch->perm_lck = number_range( 6, 18 );
comm.c:      ch->perm_frc = number_range( -2000, 20 );
comm.c:      ch->affected_by = race_table[ch->race].affected;
comm.c:      ch->perm_lck += race_table[ch->race].lck_plus;
comm.c:      ch->perm_frc += race_table[ch->race].frc_plus;
comm.c:      if( ch->race == RACE_DUINUOGWUIN || ch->main_ability == FORCE_ABILITY )
comm.c:	ch->perm_frc = URANGE( 1, ch->perm_frc, 20 );
comm.c:	ch->perm_frc = URANGE( 0, ch->perm_frc, 20 );
comm.c:       * ch->pcdata->learned[iLang] = 100;
comm.c:	if( lang_array[iLang] == race_table[ch->race].language )
comm.c:	      ch->pcdata->learned[iLang] = 100;
comm.c:	      ch->speaking = race_table[ch->race].language;
comm.c:	      if( ch->race == RACE_QUARREN && ( iLang = skill_lookup( "quarren" ) ) >= 0 )
comm.c:		  ch->pcdata->learned[iLang] = 100;
comm.c:		  SET_BIT( ch->speaks, LANG_QUARREN );
comm.c:	      if( ch->race == RACE_MON_CALAMARI && ( iLang = skill_lookup( "common" ) ) >= 0 )
comm.c:		ch->pcdata->learned[iLang] = 100;
comm.c:       * ch->resist           += race_table[ch->race].resist;    drats
comm.c:       * ch->susceptible     += race_table[ch->race].suscept;    drats
comm.c:	    ch->skill_level[ability] = 1;
comm.c:	    ch->experience[ability] = 0;
comm.c:      ch->top_level = 1;
comm.c:      ch->hit = ch->max_hit;
comm.c:      ch->hit += race_table[ch->race].hit;
comm.c:      ch->move = ch->max_move;
comm.c:      if( ch->perm_frc > 0 )
comm.c:	ch->max_mana = 100 + 100 * ch->perm_frc;
comm.c:	ch->max_mana = 0;
comm.c:      ch->mana = ch->max_mana;
comm.c:      sprintf( buf, "%s the %s", ch->name, race_table[ch->race].race_name );
comm.c:      SET_BIT( ch->act, PLR_AUTOGOLD );
comm.c:      SET_BIT( ch->act, PLR_AUTOEXIT );
comm.c:	  ch->pcdata->auth_state = 3;
comm.c:	  ch->pcdata->auth_state = 1;
comm.c:	  SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c:  else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > current_time )
comm.c:  else if( ch->in_room && !IS_IMMORTAL( ch )
comm.c:	   && !IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ) && ch->in_room != get_room_index( 6 ) )
comm.c:      char_to_room( ch, ch->in_room );
comm.c:  else if( ch->in_room && !IS_IMMORTAL( ch )
comm.c:	   && IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ) && ch->in_room != get_room_index( 6 ) )
comm.c:      for( ship = first_ship; ship; ship = ship->next )
comm.c:	if( ch->in_room->vnum >= ship->firstroom && ch->in_room->vnum <= ship->lastroom )
comm.c:	  if( ship->ship_class != SHIP_PLATFORM || ship->starsystem )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:  if( ch->plr_home != NULL )
comm.c:      ROOM_INDEX_DATA *storeroom = ch->plr_home;
comm.c:      for( obj = storeroom->first_content; obj; obj = obj_next )
comm.c:	  obj_next = obj->next_content;
comm.c:      sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
comm.c:		  bug( ch->name, 0 );
comm.c:		  bug( ch->name, 0 );
comm.c:	  for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
comm.c:	      tobj_next = tobj->next_content;
comm.c: * Look for link-dead player to reconnect.
comm.c:   for( ch = first_char; ch; ch = ch->next )
comm.c:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->name && !str_cmp( name, ch->name ) )
comm.c:         if( fConn && ch->switched )
comm.c:            d->connected = CON_GET_NAME;
comm.c:            if( d->character )
comm.c:               d->character->desc = NULL;
comm.c:               free_char( d->character );
comm.c:               d->character = NULL;
comm.c:            DISPOSE( d->character->pcdata->pwd );
comm.c:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:            d->character->desc = NULL;
comm.c:            free_char( d->character );
comm.c:            d->character = ch;
comm.c:            ch->desc = d;
comm.c:            ch->timer = 0;
comm.c:            sprintf( log_buf, "%s (%s) reconnected.", ch->name, d->host );
comm.c:            log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:            d->connected = CON_PLAYING;
comm.c:   for( dold = first_descriptor; dold; dold = dold->next )
comm.c:          && ( dold->character || dold->original )
comm.c:          && str_cmp( name, dold->original
comm.c:                      ? dold->original->name : dold->character->name ) && !str_cmp( dold->host, d->host ) )
comm.c:         if( get_trust( d->character ) >= LEVEL_SUPREME
comm.c:             || get_trust( dold->original ? dold->original : dold->character ) >= LEVEL_SUPREME )
comm.c:            if( ok[iloop] != d->host[iloop] )
comm.c:            if( ok2[iloop] != d->host[iloop] )
comm.c:         write_to_buffer( d, "Sorry multi-playing is not allowed ... have you other character quit first.\r\n", 0 );
comm.c:                  dold->original ? dold->original->name : dold->character->name, d->character->name );
comm.c:         d->character = NULL;
comm.c:         free_char( d->character );
comm.c:   for( dold = first_descriptor; dold; dold = dold->next )
comm.c:          && ( dold->character || dold->original )
comm.c:          && !str_cmp( name, dold->original ? dold->original->name : dold->character->name ) )
comm.c:         cstate = dold->connected;
comm.c:         ch = dold->original ? dold->original : dold->character;
comm.c:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING ) )
comm.c:            write_to_buffer( d, "Already connected - try again.\r\n", 0 );
comm.c:            sprintf( log_buf, "%s already connected.", ch->name );
comm.c:         d->character->desc = NULL;
comm.c:         free_char( d->character );
comm.c:         d->character = ch;
comm.c:         ch->desc = d;
comm.c:         ch->timer = 0;
comm.c:         if( ch->switched )
comm.c:            do_return( ch->switched, "" );
comm.c:         ch->switched = NULL;
comm.c:         sprintf( log_buf, "%s@%s reconnected, kicking off old link.", ch->name, d->host );
comm.c:         log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c:         d->connected = cstate;
comm.c:       || !ch->desc
comm.c:       || ch->desc->connected != CON_PLAYING || !ch->was_in_room || ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:   ch->timer = 0;
comm.c:   char_to_room( ch, ch->was_in_room );
comm.c:   ch->was_in_room = NULL;
comm.c:   if( obj->count > 1 )
comm.c:      sprintf( buf, "%s (%d)", obj->short_descr, obj->count );
comm.c:   return obj->short_descr;
comm.c:/* Major overhaul. -- Alty */
comm.c:#define NAME(ch)	(IS_NPC(ch) ? ch->short_descr : ch->name)
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c:    * Discard null and zero-length messages.
comm.c:   if( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c:         bug( "%s (%s)", ch->name, format );
comm.c:      if( !vch->in_room )
comm.c:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:/*	to = vch->in_room->first_person;*/
comm.c:      if( IS_SET( to->in_room->progtypes, ACT_PROG ) )
comm.c:         rprog_act_trigger( txt, to->in_room, ch, ( OBJ_DATA * ) arg1, ( void * )arg2 );
comm.c:      for( to_obj = to->in_room->first_content; to_obj; to_obj = to_obj->next_content )
comm.c:         if( IS_SET( to_obj->pIndexData->progtypes, ACT_PROG ) )
comm.c:    * room when we're only sending to one char anyways..? -- Alty 
comm.c:   for( ; to; to = ( type == TO_CHAR || type == TO_VICT ) ? NULL : to->next_in_room )
comm.c:      if( ( !to->desc && ( IS_NPC( to ) && !IS_SET( to->pIndexData->progtypes, ACT_PROG ) ) ) || !IS_AWAKE( to ) )
comm.c:      if( to->desc )
comm.c:          * Note: use original string, not string with ANSI. -- Alty 
comm.c:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c:   for( tmp = first_char; tmp; tmp = tmp->next )
comm.c:      if( !str_cmp( ucase_argument, tmp->name ) )
comm.c:   if( stat( fname, &fst ) != -1 )
comm.c:   STRFREE( ch->name );
comm.c:   ch->name = STRALLOC( ucase_argument );
comm.c:   ch->pcdata->auth_state = 0;
comm.c:   if( ch->skill_level[FORCE_ABILITY] > 1 || get_trust( ch ) >= LEVEL_IMMORTAL )
comm.c:   return -1;
comm.c:   CHAR_DATA *ch = d->character;
comm.c:   CHAR_DATA *och = ( d->original ? d->original : d->character );
comm.c:   bool ansi = ( !IS_NPC( och ) && IS_SET( och->act, PLR_ANSI ) );
comm.c:   if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c:      prompt = ch->pcdata->subprompt;
comm.c:   else if( IS_NPC( ch ) || !ch->pcdata->prompt || !*ch->pcdata->prompt )
comm.c:      prompt = ch->pcdata->prompt;
comm.c:      d->prevcolor = 0x08;
comm.c:      if( *prompt == *( prompt - 1 ) )
comm.c:      switch ( *( prompt - 1 ) )
comm.c:            bug( "Display_prompt: bad command char '%c'.", *( prompt - 1 ) );
comm.c:                  if( ch->top_level >= 10 )
comm.c:                     pstat = ch->alignment;
comm.c:                  pstat = ch->hit;
comm.c:                  pstat = ch->max_hit;
comm.c:                  if( IS_IMMORTAL( ch ) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c:                     pstat = ch->mana;
comm.c:                  if( IS_IMMORTAL( ch ) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c:                     pstat = ch->max_mana;
comm.c:                  pstat = ch->move;
comm.c:                  pstat = ch->max_move;
comm.c:                  pstat = ch->gold;
comm.c:                     pstat = ch->in_room->vnum;
comm.c:                  if( IS_SET( och->act, PLR_ROOMVNUM ) )
comm.c:                     sprintf( pbuf, "<#%d> ", ch->in_room->vnum );
comm.c:                  if( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c:                      ( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c:                     sprintf( pbuf, "(Invis %d) ", ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c:                  pstat = ( IS_NPC( ch ) ? ( IS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c:                            : ( IS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c:   CHAR_DATA *ch = d->character;
comm.c:   CHAR_DATA *och = ( d->original ? d->original : d->character );
comm.c:   bool ansi = ( !IS_NPC( och ) && IS_SET( och->act, PLR_ANSI ) );
comm.c:   if( !ch->piloting)
comm.c:   if( IS_NPC( ch ) || !ch->pcdata->pilotprompt || !*ch->pcdata->pilotprompt )
comm.c:      prompt = ch->pcdata->pilotprompt;
comm.c:      d->prevcolor = 0x08;
comm.c:      if( *prompt == *( prompt - 1 ) )
comm.c:      switch ( *( prompt - 1 ) )
comm.c:            bug( "Display_pilot_prompt: bad command char '%c'.", *( prompt - 1 ) );
comm.c:		  sprintf( pbuf, "%0.2f", radianstodegrees(ch->piloting->heading) );
comm.c:		  sprintf( pbuf, "%0.2f", radianstodegrees(ch->piloting->turnarc) );
comm.c:                  if( ch->piloting->track0 != NULL)
comm.c:			  sprintf( pbuf, "%0.2f", radianstodegrees(s2sbearing(ch->piloting,ch->piloting->track0)) );
comm.c:                  pstat = ch->piloting->energy;
comm.c:                  pstat = ch->piloting->maxenergy;
comm.c:                  pstat = ch->piloting->hull;
comm.c:                  pstat = ch->piloting->maxhull;
comm.c:                  if( ch->piloting->statet0 == LASER_DAMAGED)
comm.c:                  else if( ch->piloting->statet0 >= ch->piloting->lasers && ch->piloting->lasers != 0 )
comm.c:                  else if( ch->piloting->statet0 <= ch->piloting->lasers && ch->piloting->lasers != 0)
comm.c:                  if( ch->piloting->missilestate == MISSILE_DAMAGED)
comm.c:                  else if( ch->piloting->missilestate != MISSILE_READY )
comm.c:                  else if( ch->piloting->missilestate == MISSILE_READY && ch->piloting->missiles > 0)
comm.c:                  else if (ch->piloting->missiles <= 0 && ch->piloting->maxmissiles > 0)
comm.c:                  pstat = ch->piloting->currspeed;
comm.c:                  pstat = ch->piloting->realspeed;
comm.c:                  if( ch->piloting->track0 != NULL)
comm.c:	                  pstat = ship2shipdist(ch->piloting,ch->piloting->track0);
comm.c:                  pstat = ch->piloting->shield;
comm.c:                  pstat = ch->piloting->maxshield;
comm.c:                  if( ch->piloting->track0 != NULL)
comm.c:	                  strcpy( pbuf, ch->piloting->track0->name );
comm.c:		     else if (IS_SET(ch->piloting->flightflags,SHIP_TRACKINGRADAR))
comm.c:   d->pagecmd = *argument;
comm.c:   if( !d || !d->pagepoint || d->pagecmd == -1 )
comm.c:   ch = d->original ? d->original : d->character;
comm.c:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c:   switch ( LOWER( d->pagecmd ) )
comm.c:         lines = -1 - ( pclines * 2 );
comm.c:         lines = -1 - pclines;
comm.c:         d->pagetop = 0;
comm.c:         d->pagepoint = NULL;
comm.c:         DISPOSE( d->pagebuf );
comm.c:         d->pagesize = MAX_STRING_LENGTH;
comm.c:   while( lines < 0 && d->pagepoint >= d->pagebuf )
comm.c:      if( *( --d->pagepoint ) == '\n' )
comm.c:   if( *d->pagepoint == '\r' && *( ++d->pagepoint ) == '\n' )
comm.c:      ++d->pagepoint;
comm.c:   if( d->pagepoint < d->pagebuf )
comm.c:      d->pagepoint = d->pagebuf;
comm.c:   for( lines = 0, last = d->pagepoint; lines < pclines; ++last )
comm.c:   if( last != d->pagepoint )
comm.c:      if( !write_to_descriptor( d, d->pagepoint, ( last - d->pagepoint ) ) )
comm.c:      d->pagepoint = last;
comm.c:      d->pagetop = 0;
comm.c:      d->pagepoint = NULL;
comm.c:      DISPOSE( d->pagebuf );
comm.c:      d->pagesize = MAX_STRING_LENGTH;
comm.c:   d->pagecmd = -1;
comm.c:   if( IS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( IS_SET( ch->act, PLR_ANSI ) )
comm.c:      sprintf( buf, "%s", color_str( d->pagecolor, ch ) );
comm.c~:*--------------------------------------------------------------------------*
comm.c~:* -------------------------------------------------------------------------*
comm.c~:*--------------------------------------------------------------------------*
comm.c~:* ------------------------------------------------------------------------ *
comm.c~:* ------------------------------------------------------------------------ *
comm.c~:*			 Low-level communication module			   *
comm.c~: * OS-dependent local functions.
comm.c~: * Other local functions (OS-independent).
comm.c~:   int imcsocket = -1;
comm.c~:   boot_time = time( 0 );  /*  <-- I think this is what you wanted */
comm.c~:    * set_boot_time->hour   = 6;
comm.c~:    * set_boot_time->min    = 0;
comm.c~:    * set_boot_time->sec    = 0;
comm.c~:   set_boot_time->manual = 0;
comm.c~:    * new_boot_time to new_boot_struct again. -- Alty 
comm.c~:   new_boot_time->tm_mday += 1;
comm.c~:   if( new_boot_time->tm_hour > 12 )
comm.c~:      new_boot_time->tm_mday += 1;
comm.c~:   new_boot_time->tm_sec = 0;
comm.c~:   new_boot_time->tm_min = 0;
comm.c~:   new_boot_time->tm_hour = 6;
comm.c~:   dnew->next = NULL;
comm.c~:   dnew->descriptor = desc;
comm.c~:   dnew->connected = CON_GET_NAME;
comm.c~:   dnew->outsize = 2000;
comm.c~:   dnew->idle = 0;
comm.c~:   dnew->lines = 0;
comm.c~:   dnew->scrlen = 24;
comm.c~:   dnew->newstate = 0;
comm.c~:   dnew->prevcolor = 0x07;
comm.c~:   dnew->can_compress = FALSE;
comm.c~:   dnew->ifd = -1; /* Descriptor pipes, used for DNS resolution and such */
comm.c~:   dnew->ipid = -1;
comm.c~:   CREATE( dnew->mccp, MCCP, 1 );
comm.c~:   CREATE( dnew->outbuf, char, dnew->outsize );
comm.c~:   sa.sin_family = AF_INET;   /* hp->h_addrtype; */
comm.c~:   if( bind( fd, ( struct sockaddr * )&sa, sizeof( sa ) ) == -1 )
comm.c~:  for ( ch = first_char; ch; ch = ch->next )
comm.c~:    sprintf( buf, "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ',
comm.c~:    		ch->name, ch->in_room->vnum );
comm.c~: * LAG alarm!							-Thoric
comm.c~:   for( d = first_descriptor; d; d = d->next )
comm.c~:      maxdesc = UMAX( maxdesc, d->descriptor );
comm.c~:      FD_SET( d->descriptor, &in_set );
comm.c~:      FD_SET( d->descriptor, &out_set );
comm.c~:      FD_SET( d->descriptor, &exc_set );
comm.c~:      if( d->ifd != -1 && d->ipid != -1 )
comm.c~:         maxdesc = UMAX( maxdesc, d->ifd );
comm.c~:         FD_SET( d->ifd, &in_set );
comm.c~:         if( d == d->next )
comm.c~:            d->next = NULL;
comm.c~:         d_next = d->next;
comm.c~:         d->idle++;  /* make it so a descriptor can idle out */
comm.c~:         if( FD_ISSET( d->descriptor, &exc_set ) )
comm.c~:            FD_CLR( d->descriptor, &in_set );
comm.c~:            FD_CLR( d->descriptor, &out_set );
comm.c~:            if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c~:               save_char_obj( d->character );
comm.c~:            d->outtop = 0;
comm.c~:         else if( ( !d->character && d->idle > 360 )  /* 2 mins */
comm.c~:                  || ( d->connected != CON_PLAYING && d->idle > 1200 )  /* 5 mins */
comm.c~:                  || d->idle > 28800 ) /* 2 hrs  */
comm.c~:            d->outtop = 0;
comm.c~:            d->fcommand = FALSE;
comm.c~:            if( FD_ISSET( d->descriptor, &in_set ) )
comm.c~:               d->idle = 0;
comm.c~:               if( d->character )
comm.c~:                  d->character->timer = 0;
comm.c~:                  FD_CLR( d->descriptor, &out_set );
comm.c~:                  if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c~:                     save_char_obj( d->character );
comm.c~:                  d->outtop = 0;
comm.c~:            if( ( d->connected == CON_PLAYING || d->character != NULL ) && d->ifd != -1 && FD_ISSET( d->ifd, &in_set ) )
comm.c~:            if( d->character && d->character->wait > 0 )
comm.c~:               --d->character->wait;
comm.c~:            if( d->incomm[0] != '\0' )
comm.c~:               d->fcommand = TRUE;
comm.c~:               stop_idling( d->character );
comm.c~:               strcpy( cmdline, d->incomm );
comm.c~:               d->incomm[0] = '\0';
comm.c~:               if( d->character )
comm.c~:                  set_cur_char( d->character );
comm.c~:               if( d->pagepoint )
comm.c~:                  switch ( d->connected )
comm.c~:                        interpret( d->character, cmdline );
comm.c~:                        edit_buffer( d->character, cmdline );
comm.c~:         d_next = d->next;
comm.c~:         if( ( d->fcommand || d->outtop > 0 ) && FD_ISSET( d->descriptor, &out_set ) )
comm.c~:            if( d->pagepoint )
comm.c~:                  if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c~:                     save_char_obj( d->character );
comm.c~:                  d->outtop = 0;
comm.c~:               if( d->character && ( d->connected == CON_PLAYING || d->connected == CON_EDITING ) )
comm.c~:                  save_char_obj( d->character );
comm.c~:               d->outtop = 0;
comm.c~:       * Sleep( last_time + 1/PULSE_PER_SECOND - now ).
comm.c~:         usecDelta = ( ( int )last_time.tv_usec ) - ( ( int )now_time.tv_usec ) + 1000000 / PULSE_PER_SECOND;
comm.c~:         secDelta = ( ( int )last_time.tv_sec ) - ( ( int )now_time.tv_sec );
comm.c~:            secDelta -= 1;
comm.c~:            usecDelta -= 1000000;
comm.c~:   if( fcntl( desc, F_SETFL, FNDELAY ) == -1 )
comm.c~:   dnew->port = ntohs( sock.sin_port );
comm.c~:   dnew->host = STRALLOC( log_buf );
comm.c~:         STRFREE( dnew->host );
comm.c~:         dnew->host = STRALLOC( buf );
comm.c~:   for( pban = first_ban; pban; pban = pban->next )
comm.c~:      if( ( !str_prefix( pban->name, dnew->host ) || !str_suffix( pban->name, dnew->host ) ) && pban->level >= LEVEL_SUPREME )
comm.c~:      for( d = first_descriptor; d; d = d->next )
comm.c~:         if( !d->next )
comm.c~:    * Send the greeting. Forces new color function - Tawnos
comm.c~:      sprintf( log_buf, "Broke all-time maximum player record: %d", sysdata.alltimemax );
comm.c~:   close( d->descriptor );
comm.c~:   STRFREE( d->host );
comm.c~:   DISPOSE( d->outbuf );
comm.c~:   if( d->pagebuf )
comm.c~:      DISPOSE( d->pagebuf );
comm.c~:   DISPOSE( d->mccp );
comm.c~:   --num_descriptors;
comm.c~:   if( dclose->ipid != -1 )
comm.c~:      kill( dclose->ipid, SIGKILL );
comm.c~:      waitpid( dclose->ipid, &status, 0 );
comm.c~:   if( dclose->ifd != -1 )
comm.c~:      close( dclose->ifd );
comm.c~:   if( !force && dclose->outtop > 0 )
comm.c~:   if( dclose->snoop_by )
comm.c~:      write_to_buffer( dclose->snoop_by, "Your victim has left the game.\r\n", 0 );
comm.c~:   for( d = first_descriptor; d; d = d->next )
comm.c~:      if( d->snoop_by == dclose )
comm.c~:         d->snoop_by = NULL;
comm.c~:    * Check for switched people who go link-dead. -- Altrag 
comm.c~:   if( dclose->original )
comm.c~:      if( ( ch = dclose->character ) != NULL )
comm.c~:         bug( "Close_socket: dclose->original without character %s",
comm.c~:              ( dclose->original->name ? dclose->original->name : "unknown" ) );
comm.c~:         dclose->character = dclose->original;
comm.c~:         dclose->original = NULL;
comm.c~:   ch = dclose->character;
comm.c~:   if( !dclose->prev && dclose != first_descriptor )
comm.c~:      bug( "Close_socket: %s desc:%p != first_desc:%p and desc->prev = NULL!",
comm.c~:           ch ? ch->name : d->host, dclose, first_descriptor );
comm.c~:         dn = d->next;
comm.c~:            bug( "Close_socket: %s desc:%p found, prev should be:%p, fixing.", ch ? ch->name : d->host, dclose, dp );
comm.c~:            dclose->prev = dp;
comm.c~:      if( !dclose->prev )
comm.c~:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c~:   if( !dclose->next && dclose != last_descriptor )
comm.c~:      bug( "Close_socket: %s desc:%p != last_desc:%p and desc->next = NULL!",
comm.c~:           ch ? ch->name : d->host, dclose, last_descriptor );
comm.c~:         dp = d->prev;
comm.c~:            bug( "Close_socket: %s desc:%p found, next should be:%p, fixing.", ch ? ch->name : d->host, dclose, dn );
comm.c~:            dclose->next = dn;
comm.c~:      if( !dclose->next )
comm.c~:         bug( "Close_socket: %s desc:%p could not be found!.", ch ? ch->name : dclose->host, dclose );
comm.c~:   if( dclose->character )
comm.c~:      sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c~:      log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c~:	if ( ch->top_level < LEVEL_DEMI )
comm.c~:	  to_channel( log_buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
comm.c~:      if( dclose->connected == CON_PLAYING || dclose->connected == CON_EDITING )
comm.c~:         ch->desc = NULL;
comm.c~:         dclose->character->desc = NULL;
comm.c~:         free_char( dclose->character );
comm.c~:         d_next = d_next->next;
comm.c~:   if( dclose->descriptor == maxdesc )
comm.c~:      --maxdesc;
comm.c~:   if( d->incomm[0] != '\0' )
comm.c~:   iStart = strlen( d->inbuf );
comm.c~:   if( iStart >= sizeof( d->inbuf ) - 10 )
comm.c~:      sprintf( log_buf, "%s input overflow!", d->host );
comm.c~:      nRead = read( d->descriptor, d->inbuf + iStart, sizeof( d->inbuf ) - 10 - iStart );
comm.c~:         if( d->inbuf[iStart - 1] == '\n' || d->inbuf[iStart - 1] == '\r' )
comm.c~:   d->inbuf[iStart] = '\0';
comm.c~:   if( d->incomm[0] != '\0' )
comm.c~:   for( i = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r' && i < MAX_INBUF_SIZE; i++ )
comm.c~:      if( d->inbuf[i] == '\0' )
comm.c~:   for( i = 0, k = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
comm.c~:          * for ( ; d->inbuf[i] != '\0' || i>= MAX_INBUF_SIZE ; i++ )
comm.c~:          * if ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c~:         d->inbuf[i] = '\n';
comm.c~:         d->inbuf[i + 1] = '\0';
comm.c~:      if( d->inbuf[i] == ( signed char )IAC )
comm.c~:               && ( d->inbuf[i] == ( signed char )DO || d->inbuf[i] == ( signed char )DONT
comm.c~:                    || d->inbuf[i] == ( signed char )WILL ) )
comm.c~:         if( d->inbuf[i] == ( signed char )TELOPT_COMPRESS2 )
comm.c~:            if( d->inbuf[i - 1] == ( signed char )DO )
comm.c~:            else if( d->inbuf[i - 1] == ( signed char )DONT )
comm.c~:      else if( d->inbuf[i] == '\b' && k > 0 )
comm.c~:         --k;
comm.c~:      else if( isascii( d->inbuf[i] ) && isprint( d->inbuf[i] ) )
comm.c~:         d->incomm[k++] = d->inbuf[i];
comm.c~:      d->incomm[k++] = ' ';
comm.c~:   d->incomm[k] = '\0';
comm.c~:   if( k > 1 || d->incomm[0] == '!' )
comm.c~:      if( d->incomm[0] != '!' && strcmp( d->incomm, d->inlast ) )
comm.c~:         d->repeat = 0;
comm.c~:         if( ++d->repeat >= 20 )
comm.c~:/*		sprintf( log_buf, "%s input spamming!", d->host );
comm.c~:   if( d->incomm[0] == '!' )
comm.c~:      strcpy( d->incomm, d->inlast );
comm.c~:      strcpy( d->inlast, d->incomm );
comm.c~:   while( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
comm.c~:   for( j = 0; ( d->inbuf[j] = d->inbuf[i + j] ) != '\0'; j++ )
comm.c~:   ch = d->original ? d->original : d->character;
comm.c~:   if( ch && ch->fighting && ch->fighting->who )
comm.c~:      show_condition( ch, ch->fighting->who );
comm.c~:    * If buffer has more than 4K inside, spit out .5K at a time   -Thoric
comm.c~:   if( !mud_down && d->outtop > 4096 )
comm.c~:      memcpy( buf, d->outbuf, 512 );
comm.c~:      memmove( d->outbuf, d->outbuf + 512, d->outtop - 512 );
comm.c~:      d->outtop -= 512;
comm.c~:      if( d->snoop_by )
comm.c~:         if( d->character && d->character->name )
comm.c~:            if( d->original && d->original->name )
comm.c~:               sprintf( snoopbuf, "%s (%s)", d->character->name, d->original->name );
comm.c~:               sprintf( snoopbuf, "%s", d->character->name );
comm.c~:            write_to_buffer( d->snoop_by, snoopbuf, 0 );
comm.c~:         write_to_buffer( d->snoop_by, "% ", 2 );
comm.c~:         write_to_buffer( d->snoop_by, buf, 0 );
comm.c~:         d->outtop = 0;
comm.c~:   if( fPrompt && !mud_down && d->connected == CON_PLAYING )
comm.c~:      ch = d->original ? d->original : d->character;
comm.c~:      if( IS_SET( ch->act, PLR_BLANK ) )
comm.c~:      if( IS_SET( ch->act, PLR_PROMPT ) )
comm.c~:	if(ch->piloting == NULL)
comm.c~:      if( IS_SET( ch->act, PLR_TELNET_GA ) )
comm.c~:    * Short-circuit if nothing to write.
comm.c~:   if( d->outtop == 0 )
comm.c~:    * Snoop-o-rama.
comm.c~:   if( d->snoop_by )
comm.c~:       * without check, 'force mortal quit' while snooped caused crash, -h 
comm.c~:      if( d->character && d->character->name )
comm.c~:          * Show original snooped names. -- Altrag 
comm.c~:         if( d->original && d->original->name )
comm.c~:            sprintf( buf, "%s (%s)", d->character->name, d->original->name );
comm.c~:            sprintf( buf, "%s", d->character->name );
comm.c~:         write_to_buffer( d->snoop_by, buf, 0 );
comm.c~:      write_to_buffer( d->snoop_by, "% ", 2 );
comm.c~:      write_to_buffer( d->snoop_by, d->outbuf, d->outtop );
comm.c~:    * OS-dependent output.
comm.c~:   if( !write_to_descriptor( d, d->outbuf, d->outtop ) )
comm.c~:      d->outtop = 0;
comm.c~:      d->outtop = 0;
comm.c~:   if( !d->outbuf )
comm.c~:   if( d->outtop == 0 && !d->fcommand )
comm.c~:      d->outbuf[0] = '\n';
comm.c~:      d->outbuf[1] = '\r';
comm.c~:      d->outtop = 2;
comm.c~:   while( d->outtop + length >= d->outsize )
comm.c~:      if( d->outsize > 32000 )
comm.c~:         d->outtop = 0;
comm.c~:         bug( "Buffer overflow. Closing (%s).", d->character ? d->character->name : "???" );
comm.c~:      d->outsize *= 2;
comm.c~:      RECREATE( d->outbuf, char, d->outsize );
comm.c~:   strncpy( d->outbuf + d->outtop, txt, length );
comm.c~:   d->outtop += length;
comm.c~:   d->outbuf[d->outtop] = '\0';
comm.c~:* This is the MCCP version. Use write_to_descriptor_old to send non-compressed
comm.c~:* him.;P -Orion
comm.c~:   if( d && d->mccp->out_compress )
comm.c~:      d->mccp->out_compress->next_in = ( unsigned char * )txt;
comm.c~:      d->mccp->out_compress->avail_in = length;
comm.c~:      while( d->mccp->out_compress->avail_in )
comm.c~:         d->mccp->out_compress->avail_out =
comm.c~:            COMPRESS_BUF_SIZE - ( d->mccp->out_compress->next_out - d->mccp->out_compress_buf );
comm.c~:         if( d->mccp->out_compress->avail_out )
comm.c~:            int status = deflate( d->mccp->out_compress, Z_SYNC_FLUSH );
comm.c~:         len = d->mccp->out_compress->next_out - d->mccp->out_compress_buf;
comm.c~:               nBlock = UMIN( len - iStart, 4096 );
comm.c~:               nWrite = send( d->descriptor, d->mccp->out_compress_buf + iStart, nBlock, 0 );
comm.c~:               if( nWrite == -1 )
comm.c~:                      * not using it, but I've included it in case. -Orion
comm.c~:               memmove( d->mccp->out_compress_buf, d->mccp->out_compress_buf + iStart, len - iStart );
comm.c~:            d->mccp->out_compress->next_out = d->mccp->out_compress_buf + len - iStart;
comm.c~:      nBlock = UMIN( length - iStart, 4096 );
comm.c~:      nWrite = send( d->descriptor, txt + iStart, nBlock, 0 );
comm.c~:      if( nWrite == -1 )
comm.c~:             * not using it, but I've included it in case. -Orion
comm.c~: * out to Rustry for his suggestions. -Orion
comm.c~:      nBlock = UMIN( length - iStart, 4096 );
comm.c~:      if( nWrite == -1 )
comm.c~:             * not using it, but I've included it in case. -Orion
comm.c~:   ch = d->character;
comm.c~:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c~:      if( IS_SET( ch->act, PLR_ANSI ) )
comm.c~:   d->connected = CON_PRESS_ENTER;
comm.c~:  switch( d->connected )
comm.c~:      bug( "Nanny: bad d->connected %d.", d->connected );
comm.c~:      if( d->newstate == 0 )
comm.c~:	  d->newstate++;
comm.c~:	  d->connected = CON_GET_NAME;
comm.c~:  if( !d->character )
comm.c~:      sprintf( log_buf, "Bad player file %s@%s.", argument, d->host );
comm.c~:  ch = d->character;
comm.c~:  for( pban = first_ban; pban; pban = pban->next )
comm.c~:      if( ( !str_prefix( pban->name, d->host )
comm.c~:	    || !str_suffix( pban->name, d->host ) ) && pban->level >= ch->top_level )
comm.c~:  if( IS_SET( ch->act, PLR_DENY ) )
comm.c~:      sprintf( log_buf, "Denying access to %s@%s.", argument, d->host );
comm.c~:      if( d->newstate != 0 )
comm.c~:	  d->connected = CON_GET_NAME;
comm.c~:      if( d->newstate != 0 )
comm.c~:	  d->connected = CON_GET_NAME;
comm.c~:      d->connected = CON_GET_OLD_PASSWORD;
comm.c~:      d->connected = CON_CONFIRM_NEW_NAME;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c~:      d->character->desc = NULL;
comm.c~:  if( check_playing( d, ch->name, TRUE ) )
comm.c~:  chk = check_reconnect( d, ch->name, TRUE );
comm.c~:      if( d->character && d->character->desc )
comm.c~:	d->character->desc = NULL;
comm.c~:  if( check_multi( d, ch->name ) )
comm.c~:  strcpy( buf, ch->name );
comm.c~:  d->character->desc = NULL;
comm.c~:  free_char( d->character );
comm.c~:  ch = d->character;
comm.c~:  sprintf( log_buf, "%s (%s) has connected.", ch->name, d->host );
comm.c~:  if( ch->top_level < LEVEL_DEMI )
comm.c~:    log_string_plus( log_buf, LOG_COMM, ch->top_level );
comm.c~:  if( ch->pcdata->area )
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:	       "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c~:      d->connected = CON_GET_NEW_PASSWORD;
comm.c~:      d->character->desc = NULL;
comm.c~:      free_char( d->character );
comm.c~:      d->character = NULL;
comm.c~:      d->connected = CON_GET_NAME;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  pwdnew = sha256_crypt( argument );   /* SHA-256 Encryption */
comm.c~:  DISPOSE( ch->pcdata->pwd );
comm.c~:  ch->pcdata->pwd = str_dup( pwdnew );
comm.c~:  d->connected = CON_CONFIRM_NEW_PASSWORD;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c~:      d->connected = CON_GET_NEW_PASSWORD;
comm.c~:  d->connected = CON_GET_NEW_SEX;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:      ch->sex = SEX_MALE;
comm.c~:      ch->sex = SEX_FEMALE;
comm.c~:      ch->sex = SEX_NEUTRAL;
comm.c~:  d->connected = CON_GET_NEW_RACE;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  ch = d->character;
comm.c~:	  ch->race = iRace;
comm.c~:  d->connected = CON_GET_NEW_CLASS;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:	  ch->main_ability = iClass;
comm.c~:  d->connected = CON_ROLL_STATS;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  ch->perm_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_int = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_wis = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_dex = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_con = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_cha = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:  ch->perm_str += race_table[ch->race].str_plus;
comm.c~:  ch->perm_int += race_table[ch->race].int_plus;
comm.c~:  ch->perm_wis += race_table[ch->race].wis_plus;
comm.c~:  ch->perm_dex += race_table[ch->race].dex_plus;
comm.c~:  ch->perm_con += race_table[ch->race].con_plus;
comm.c~:  ch->perm_cha += race_table[ch->race].cha_plus;
comm.c~:	   ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha );
comm.c~:  d->connected = CON_STATS_OK;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:      ch->perm_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_int = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_wis = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_dex = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_con = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_cha = number_range( 3, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 );
comm.c~:      ch->perm_str += race_table[ch->race].str_plus;
comm.c~:      ch->perm_int += race_table[ch->race].int_plus;
comm.c~:      ch->perm_wis += race_table[ch->race].wis_plus;
comm.c~:      ch->perm_dex += race_table[ch->race].dex_plus;
comm.c~:      ch->perm_con += race_table[ch->race].con_plus;
comm.c~:      ch->perm_cha += race_table[ch->race].cha_plus;
comm.c~:	       ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex,
comm.c~:	       ch->perm_con, ch->perm_cha );
comm.c~:  d->connected = CON_GET_WANT_RIPANSI;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:      SET_BIT( ch->act, PLR_ANSI );
comm.c~:  d->connected = CON_GET_MSP;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:      SET_BIT( ch->act, PLR_SOUND );
comm.c~:  sprintf( log_buf, "%s@%s new %s.", ch->name, d->host,
comm.c~:	      race_table[ch->race].race_name );
comm.c~:      ch->skill_level[ability] = 0;
comm.c~:  ch->top_level = 0;
comm.c~:  ch->position = POS_STANDING;
comm.c~:  d->connected = CON_PRESS_ENTER;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  if( IS_SET( ch->act, PLR_ANSI ) )
comm.c~:  if( ch->top_level > 0 )
comm.c~:  if( ch->top_level >= LEVEL_HERO )
comm.c~:  if( ch->top_level == 0 )
comm.c~:  d->connected = CON_READ_MOTD;
comm.c~:  CHAR_DATA *ch = d->character;
comm.c~:  d->connected = CON_PLAYING;
comm.c~:  if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SOUND ) )
comm.c~:  if( ch->top_level == 0 )
comm.c~:      ch->pcdata->clan = NULL;
comm.c~:      ch->perm_lck = number_range( 6, 18 );
comm.c~:      ch->perm_frc = number_range( -2000, 20 );
comm.c~:      ch->affected_by = race_table[ch->race].affected;
comm.c~:      ch->perm_lck += race_table[ch->race].lck_plus;
comm.c~:      ch->perm_frc += race_table[ch->race].frc_plus;
comm.c~:      if( ch->race == RACE_DUINUOGWUIN || ch->main_ability == FORCE_ABILITY )
comm.c~:	ch->perm_frc = URANGE( 1, ch->perm_frc, 20 );
comm.c~:	ch->perm_frc = URANGE( 0, ch->perm_frc, 20 );
comm.c~:       * ch->pcdata->learned[iLang] = 100;
comm.c~:	if( lang_array[iLang] == race_table[ch->race].language )
comm.c~:	      ch->pcdata->learned[iLang] = 100;
comm.c~:	      ch->speaking = race_table[ch->race].language;
comm.c~:	      if( ch->race == RACE_QUARREN && ( iLang = skill_lookup( "quarren" ) ) >= 0 )
comm.c~:		  ch->pcdata->learned[iLang] = 100;
comm.c~:		  SET_BIT( ch->speaks, LANG_QUARREN );
comm.c~:	      if( ch->race == RACE_MON_CALAMARI && ( iLang = skill_lookup( "common" ) ) >= 0 )
comm.c~:		ch->pcdata->learned[iLang] = 100;
comm.c~:       * ch->resist           += race_table[ch->race].resist;    drats
comm.c~:       * ch->susceptible     += race_table[ch->race].suscept;    drats
comm.c~:	    ch->skill_level[ability] = 1;
comm.c~:	    ch->experience[ability] = 0;
comm.c~:      ch->top_level = 1;
comm.c~:      ch->hit = ch->max_hit;
comm.c~:      ch->hit += race_table[ch->race].hit;
comm.c~:      ch->move = ch->max_move;
comm.c~:      if( ch->perm_frc > 0 )
comm.c~:	ch->max_mana = 100 + 100 * ch->perm_frc;
comm.c~:	ch->max_mana = 0;
comm.c~:      ch->mana = ch->max_mana;
comm.c~:      sprintf( buf, "%s the %s", ch->name, race_table[ch->race].race_name );
comm.c~:      SET_BIT( ch->act, PLR_AUTOGOLD );
comm.c~:      SET_BIT( ch->act, PLR_AUTOEXIT );
comm.c~:	  ch->pcdata->auth_state = 3;
comm.c~:	  ch->pcdata->auth_state = 1;
comm.c~:	  SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c~:  else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > current_time )
comm.c~:  else if( ch->in_room && !IS_IMMORTAL( ch )
comm.c~:	   && !IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ) && ch->in_room != get_room_index( 6 ) )
comm.c~:      char_to_room( ch, ch->in_room );
comm.c~:  else if( ch->in_room && !IS_IMMORTAL( ch )
comm.c~:	   && IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ) && ch->in_room != get_room_index( 6 ) )
comm.c~:      for( ship = first_ship; ship; ship = ship->next )
comm.c~:	if( ch->in_room->vnum >= ship->firstroom && ch->in_room->vnum <= ship->lastroom )
comm.c~:	  if( ship->ship_class != SHIP_PLATFORM || ship->starsystem )
comm.c~:	    char_to_room( ch, ch->in_room );
comm.c~:  if( ch->plr_home != NULL )
comm.c~:      ROOM_INDEX_DATA *storeroom = ch->plr_home;
comm.c~:      for( obj = storeroom->first_content; obj; obj = obj_next )
comm.c~:	  obj_next = obj->next_content;
comm.c~:      sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
comm.c~:		  bug( ch->name, 0 );
comm.c~:		  bug( ch->name, 0 );
comm.c~:	  for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
comm.c~:	      tobj_next = tobj->next_content;
comm.c~: * Look for link-dead player to reconnect.
comm.c~:   for( ch = first_char; ch; ch = ch->next )
comm.c~:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->name && !str_cmp( name, ch->name ) )
comm.c~:         if( fConn && ch->switched )
comm.c~:            d->connected = CON_GET_NAME;
comm.c~:            if( d->character )
comm.c~:               d->character->desc = NULL;
comm.c~:               free_char( d->character );
comm.c~:               d->character = NULL;
comm.c~:            DISPOSE( d->character->pcdata->pwd );
comm.c~:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c~:            d->character->desc = NULL;
comm.c~:            free_char( d->character );
comm.c~:            d->character = ch;
comm.c~:            ch->desc = d;
comm.c~:            ch->timer = 0;
comm.c~:            sprintf( log_buf, "%s (%s) reconnected.", ch->name, d->host );
comm.c~:            log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c~:            d->connected = CON_PLAYING;
comm.c~:   for( dold = first_descriptor; dold; dold = dold->next )
comm.c~:          && ( dold->character || dold->original )
comm.c~:          && str_cmp( name, dold->original
comm.c~:                      ? dold->original->name : dold->character->name ) && !str_cmp( dold->host, d->host ) )
comm.c~:         if( get_trust( d->character ) >= LEVEL_SUPREME
comm.c~:             || get_trust( dold->original ? dold->original : dold->character ) >= LEVEL_SUPREME )
comm.c~:            if( ok[iloop] != d->host[iloop] )
comm.c~:            if( ok2[iloop] != d->host[iloop] )
comm.c~:         write_to_buffer( d, "Sorry multi-playing is not allowed ... have you other character quit first.\r\n", 0 );
comm.c~:                  dold->original ? dold->original->name : dold->character->name, d->character->name );
comm.c~:         d->character = NULL;
comm.c~:         free_char( d->character );
comm.c~:   for( dold = first_descriptor; dold; dold = dold->next )
comm.c~:          && ( dold->character || dold->original )
comm.c~:          && !str_cmp( name, dold->original ? dold->original->name : dold->character->name ) )
comm.c~:         cstate = dold->connected;
comm.c~:         ch = dold->original ? dold->original : dold->character;
comm.c~:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING ) )
comm.c~:            write_to_buffer( d, "Already connected - try again.\r\n", 0 );
comm.c~:            sprintf( log_buf, "%s already connected.", ch->name );
comm.c~:         d->character->desc = NULL;
comm.c~:         free_char( d->character );
comm.c~:         d->character = ch;
comm.c~:         ch->desc = d;
comm.c~:         ch->timer = 0;
comm.c~:         if( ch->switched )
comm.c~:            do_return( ch->switched, "" );
comm.c~:         ch->switched = NULL;
comm.c~:         sprintf( log_buf, "%s@%s reconnected, kicking off old link.", ch->name, d->host );
comm.c~:         log_string_plus( log_buf, LOG_COMM, UMAX( sysdata.log_level, ch->top_level ) );
comm.c~:         d->connected = cstate;
comm.c~:       || !ch->desc
comm.c~:       || ch->desc->connected != CON_PLAYING || !ch->was_in_room || ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c~:   ch->timer = 0;
comm.c~:   char_to_room( ch, ch->was_in_room );
comm.c~:   ch->was_in_room = NULL;
comm.c~:   if( obj->count > 1 )
comm.c~:      sprintf( buf, "%s (%d)", obj->short_descr, obj->count );
comm.c~:   return obj->short_descr;
comm.c~:/* Major overhaul. -- Alty */
comm.c~:#define NAME(ch)	(IS_NPC(ch) ? ch->short_descr : ch->name)
comm.c~:               if( ch->sex > 2 || ch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c~:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c~:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c~:               if( vch->sex > 2 || vch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c~:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c~:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c~:               if( ch->sex > 2 || ch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c~:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c~:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c~:               if( vch->sex > 2 || vch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c~:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c~:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c~:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c~:               if( ch->sex > 2 || ch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c~:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c~:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c~:               if( vch->sex > 2 || vch->sex < 0 )
comm.c~:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c~:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c~:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c~:    * Discard null and zero-length messages.
comm.c~:   if( !ch->in_room )
comm.c~:      to = ch->in_room->first_person;
comm.c~:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c~:         bug( "%s (%s)", ch->name, format );
comm.c~:      if( !vch->in_room )
comm.c~:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c~:/*	to = vch->in_room->first_person;*/
comm.c~:      if( IS_SET( to->in_room->progtypes, ACT_PROG ) )
comm.c~:         rprog_act_trigger( txt, to->in_room, ch, ( OBJ_DATA * ) arg1, ( void * )arg2 );
comm.c~:      for( to_obj = to->in_room->first_content; to_obj; to_obj = to_obj->next_content )
comm.c~:         if( IS_SET( to_obj->pIndexData->progtypes, ACT_PROG ) )
comm.c~:    * room when we're only sending to one char anyways..? -- Alty 
comm.c~:   for( ; to; to = ( type == TO_CHAR || type == TO_VICT ) ? NULL : to->next_in_room )
comm.c~:      if( ( !to->desc && ( IS_NPC( to ) && !IS_SET( to->pIndexData->progtypes, ACT_PROG ) ) ) || !IS_AWAKE( to ) )
comm.c~:      if( to->desc )
comm.c~:          * Note: use original string, not string with ANSI. -- Alty 
comm.c~:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c~:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c~:   for( tmp = first_char; tmp; tmp = tmp->next )
comm.c~:      if( !str_cmp( ucase_argument, tmp->name ) )
comm.c~:   if( stat( fname, &fst ) != -1 )
comm.c~:   STRFREE( ch->name );
comm.c~:   ch->name = STRALLOC( ucase_argument );
comm.c~:   ch->pcdata->auth_state = 0;
comm.c~:   if( ch->skill_level[FORCE_ABILITY] > 1 || get_trust( ch ) >= LEVEL_IMMORTAL )
comm.c~:   return -1;
comm.c~:   CHAR_DATA *ch = d->character;
comm.c~:   CHAR_DATA *och = ( d->original ? d->original : d->character );
comm.c~:   bool ansi = ( !IS_NPC( och ) && IS_SET( och->act, PLR_ANSI ) );
comm.c~:   if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c~:      prompt = ch->pcdata->subprompt;
comm.c~:   else if( IS_NPC( ch ) || !ch->pcdata->prompt || !*ch->pcdata->prompt )
comm.c~:      prompt = ch->pcdata->prompt;
comm.c~:      d->prevcolor = 0x08;
comm.c~:      if( *prompt == *( prompt - 1 ) )
comm.c~:      switch ( *( prompt - 1 ) )
comm.c~:            bug( "Display_prompt: bad command char '%c'.", *( prompt - 1 ) );
comm.c~:                  if( ch->top_level >= 10 )
comm.c~:                     pstat = ch->alignment;
comm.c~:                  pstat = ch->hit;
comm.c~:                  pstat = ch->max_hit;
comm.c~:                  if( IS_IMMORTAL( ch ) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c~:                     pstat = ch->mana;
comm.c~:                  if( IS_IMMORTAL( ch ) || ch->skill_level[FORCE_ABILITY] > 1 )
comm.c~:                     pstat = ch->max_mana;
comm.c~:                  pstat = ch->move;
comm.c~:                  pstat = ch->max_move;
comm.c~:                  pstat = ch->gold;
comm.c~:                     pstat = ch->in_room->vnum;
comm.c~:                  if( IS_SET( och->act, PLR_ROOMVNUM ) )
comm.c~:                     sprintf( pbuf, "<#%d> ", ch->in_room->vnum );
comm.c~:                  if( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c~:                      ( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c~:                     sprintf( pbuf, "(Invis %d) ", ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c~:                  pstat = ( IS_NPC( ch ) ? ( IS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c~:                            : ( IS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c~:   CHAR_DATA *ch = d->character;
comm.c~:   CHAR_DATA *och = ( d->original ? d->original : d->character );
comm.c~:   bool ansi = ( !IS_NPC( och ) && IS_SET( och->act, PLR_ANSI ) );
comm.c~:   if( !ch->piloting)
comm.c~:   if( IS_NPC( ch ) || !ch->pcdata->pilotprompt || !*ch->pcdata->pilotprompt )
comm.c~:      prompt = ch->pcdata->pilotprompt;
comm.c~:      d->prevcolor = 0x08;
comm.c~:      if( *prompt == *( prompt - 1 ) )
comm.c~:      switch ( *( prompt - 1 ) )
comm.c~:            bug( "Display_pilot_prompt: bad command char '%c'.", *( prompt - 1 ) );
comm.c~:		  sprintf( pbuf, "%0.2f", radianstodegrees(ch->piloting->heading); );
comm.c~:		  sprintf( pbuf, "%0.2f", radianstodegrees(ch->piloting->turnarc); );
comm.c~:                  if( ch->piloting->track0 != NULL)
comm.c~:	                  pstat = radianstodegrees(s2sbearing(ch->piloting,ch->piloting->track0));
comm.c~:		  sprintf( pbuf, "%0.2f", radianstodegrees(ch->piloting->heading); );
comm.c~:                  pstat = ch->piloting->energy;
comm.c~:                  pstat = ch->piloting->maxenergy;
comm.c~:                  pstat = ch->piloting->hull;
comm.c~:                  pstat = ch->piloting->maxhull;
comm.c~:                  if( ch->piloting->statet0 == LASER_DAMAGED)
comm.c~:                  else if( ch->piloting->statet0 >= ch->piloting->lasers && ch->piloting->lasers != 0 )
comm.c~:                  else if( ch->piloting->statet0 <= ch->piloting->lasers && ch->piloting->lasers != 0)
comm.c~:                  if( ch->piloting->missilestate == MISSILE_DAMAGED)
comm.c~:                  else if( ch->piloting->missilestate != MISSILE_READY )
comm.c~:                  else if( ch->piloting->missilestate == MISSILE_READY && ch->piloting->missiles > 0)
comm.c~:                  else if (ch->piloting->missiles <= 0 && ch->piloting->maxmissiles > 0)
comm.c~:                  pstat = ch->piloting->currspeed;
comm.c~:                  pstat = ch->piloting->realspeed;
comm.c~:                  if( ch->piloting->track0 != NULL)
comm.c~:	                  pstat = ship2shipdist(ch->piloting,ch->piloting->track0);
comm.c~:                  pstat = ch->piloting->shield;
comm.c~:                  pstat = ch->piloting->maxshield;
comm.c~:                  if( ch->piloting->track0 != NULL)
comm.c~:	                  strcpy( pbuf, ch->piloting->track0->name );
comm.c~:		     else if (IS_SET(ch->piloting->flightflags,SHIP_TRACKINGRADAR))
comm.c~:   d->pagecmd = *argument;
comm.c~:   if( !d || !d->pagepoint || d->pagecmd == -1 )
comm.c~:   ch = d->original ? d->original : d->character;
comm.c~:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c~:   switch ( LOWER( d->pagecmd ) )
comm.c~:         lines = -1 - ( pclines * 2 );
comm.c~:         lines = -1 - pclines;
comm.c~:         d->pagetop = 0;
comm.c~:         d->pagepoint = NULL;
comm.c~:         DISPOSE( d->pagebuf );
comm.c~:         d->pagesize = MAX_STRING_LENGTH;
comm.c~:   while( lines < 0 && d->pagepoint >= d->pagebuf )
comm.c~:      if( *( --d->pagepoint ) == '\n' )
comm.c~:   if( *d->pagepoint == '\r' && *( ++d->pagepoint ) == '\n' )
comm.c~:      ++d->pagepoint;
comm.c~:   if( d->pagepoint < d->pagebuf )
comm.c~:      d->pagepoint = d->pagebuf;
comm.c~:   for( lines = 0, last = d->pagepoint; lines < pclines; ++last )
comm.c~:   if( last != d->pagepoint )
comm.c~:      if( !write_to_descriptor( d, d->pagepoint, ( last - d->pagepoint ) ) )
comm.c~:      d->pagepoint = last;
comm.c~:      d->pagetop = 0;
comm.c~:      d->pagepoint = NULL;
comm.c~:      DISPOSE( d->pagebuf );
comm.c~:      d->pagesize = MAX_STRING_LENGTH;
comm.c~:   d->pagecmd = -1;
comm.c~:   if( IS_SET( ch->act, PLR_ANSI ) )
comm.c~:   if( IS_SET( ch->act, PLR_ANSI ) )
comm.c~:      sprintf( buf, "%s", color_str( d->pagecolor, ch ) );
comments.c:*--------------------------------------------------------------------------*
comments.c:* -------------------------------------------------------------------------*
comments.c:*--------------------------------------------------------------------------*
comments.c:* ------------------------------------------------------------------------ *
comments.c:* ------------------------------------------------------------------------ *
comments.c:*           and problem players.  -haus 6/25/1995                          * 
comments.c: * save.c:107:     if ( ch->comments )                                              (* saves comments *)
comments.c: * save.c:411:    ch->comments                        = NULL;                   (* nulls ch->comments *)
comments.c:   if( !victim->comments )
comments.c:   if( !pnote->prev )
comments.c:      victim->comments = pnote->next;
comments.c:      pnote->prev->next = pnote->next;
comments.c:   STRFREE( pnote->text );
comments.c:   STRFREE( pnote->subject );
comments.c:   STRFREE( pnote->to_list );
comments.c:   STRFREE( pnote->date );
comments.c:   STRFREE( pnote->sender );
comments.c:   if( !ch->desc )
comments.c:    * from within the editor. -Narn 
comments.c:   if( ch->desc->connected == CON_EDITING )
comments.c:   switch ( ch->substate )
comments.c:         if( !ch->pnote )
comments.c:         if( ch->dest_buf != ch->pnote )
comments.c:            bug( "do_comment: sub_writing_note: ch->dest_buf != ch->pnote", 0 );
comments.c:         STRFREE( ch->pnote->text );
comments.c:         ch->pnote->text = copy_buffer( ch );
comments.c:      if( !victim->comments )
comments.c:      for( pnote = victim->comments; pnote; pnote = pnote->next )
comments.c:         sprintf( buf, "%2d) %-10s [%s] %s\r\n", vnum, pnote->sender, pnote->date, pnote->subject );
comments.c:      if( !victim->comments )
comments.c:      for( pnote = victim->comments; pnote; pnote = pnote->next )
comments.c:                     vnum, pnote->sender, pnote->subject, pnote->date, pnote->to_list );
comments.c:            send_to_char( pnote->text, ch );
comments.c:      ch->substate = SUB_WRITING_NOTE;
comments.c:      ch->dest_buf = ch->pnote;
comments.c:      start_editing( ch, ch->pnote->text );
comments.c:      STRFREE( ch->pnote->subject );
comments.c:      ch->pnote->subject = STRALLOC( argument );
comments.c:      STRFREE( ch->pnote->to_list );
comments.c:      ch->pnote->to_list = STRALLOC( argument );
comments.c:      if( ch->pnote )
comments.c:         STRFREE( ch->pnote->text );
comments.c:         STRFREE( ch->pnote->subject );
comments.c:         STRFREE( ch->pnote->to_list );
comments.c:         STRFREE( ch->pnote->date );
comments.c:         STRFREE( ch->pnote->sender );
comments.c:         DISPOSE( ch->pnote );
comments.c:      ch->pnote = NULL;
comments.c:      if( !ch->pnote )
comments.c:      sprintf( buf, "%s: %s\r\nTo: %s\r\n", ch->pnote->sender, ch->pnote->subject, ch->pnote->to_list );
comments.c:      send_to_char( ch->pnote->text, ch );
comments.c:      if( !ch->pnote )
comments.c:      strtime[strlen( strtime ) - 1] = '\0';
comments.c:      ch->pnote->date = STRALLOC( strtime );
comments.c:      pnote = ch->pnote;
comments.c:      ch->pnote = NULL;
comments.c:      pnote->next = victim->comments;
comments.c:      if( victim->comments )
comments.c:         victim->comments->prev = pnote;
comments.c:      pnote->prev = NULL;
comments.c:      victim->comments = pnote;
comments.c:      sprintf( notefile, "%s/%s", BOARD_DIR, board->note_file );
comments.c:                  pnote->sender, pnote->date, pnote->to_list, pnote->subject, pnote->text );
comments.c:      for( pnote = victim->comments; pnote; pnote = pnote->next )
comments.c:   if( !ch->comments )
comments.c:   for( pnote = ch->comments; pnote; pnote = pnote->next )
comments.c:      fprintf( fp, "sender	%s~\n", pnote->sender );
comments.c:      fprintf( fp, "date  	%s~\n", pnote->date );
comments.c:      fprintf( fp, "to     	%s~\n", pnote->to_list );
comments.c:      fprintf( fp, "subject	%s~\n", pnote->subject );
comments.c:      fprintf( fp, "text\n%s~\n", pnote->text );
comments.c:      pnote->sender = fread_string( fp );
comments.c:      pnote->date = fread_string( fp );
comments.c:      pnote->to_list = fread_string( fp );
comments.c:      pnote->subject = fread_string( fp );
comments.c:      pnote->text = fread_string( fp );
comments.c:      pnote->next = ch->comments;
comments.c:      pnote->prev = NULL;
comments.c:      ch->comments = pnote;
comments.c:-----------------------------------------------------------------------
const.c:*--------------------------------------------------------------------------*
const.c:* -------------------------------------------------------------------------*
const.c:*--------------------------------------------------------------------------*
const.c:* ------------------------------------------------------------------------ *
const.c:* ------------------------------------------------------------------------ *
const.c:    "Wookiee", 0, 8, -1, -3, 0, 2, -2, 0, 0, 3, 0, 0, 0, 0, LANG_WOOKIEE},
const.c:    "Twi'lek", 0, 0, 2, 2, 2, -1, -1, 0, 0, 0, 0, 0, 0, 0, LANG_TWI_LEK},
const.c:    "Rodian", 0, 0, 3, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, LANG_RODIAN},
const.c:    "Hutt", 0, -3, -9, -3, 3, 5, -6, 0, 0, 3, 0, 0, 0, 0, LANG_HUTT},
const.c:    "Mon Calamari", AFF_AQUA_BREATH, 0, -1, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, LANG_MON_CALAMARI},
const.c:    "Noghri", AFF_SNEAK, 0, 8, -2, -1, 0, -3, 0, 0, 0, 0, 0, 0, 0, LANG_NOGHRI},
const.c:    "Gamorrean", 0, 6, 0, -5, -5, 5, -2, 0, 0, 3, 0, 0, 0, 0, LANG_GAMORREAN},
const.c:    "Jawa", 0, -3, 3, 1, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, LANG_JAWA},
const.c:    "Adarian", 0, -2, -1, +2, +2, -1, +2, 0, 0, 0, 0, 0, 0, 0, LANG_ADARIAN},
const.c:    "Ewok", 0, -2, -1, -5, -5, -2, +8, 0, 0, 0, 0, 0, 0, 0, LANG_EWOK},
const.c:    "Verpine", 0, -1, 0, +1, +6, -1, 0, 0, 0, 0, 0, 0, 0, 0, LANG_VERPINE},
const.c:    "Defel", AFF_INVISIBLE, +1, +3, -3, -3, +1, 0, 0, 0, 0, 0, 0, 0, 0, LANG_DEFEL},
const.c:    "Trandoshan", AFF_INFRARED, +2, 0, 0, 0, +6, -1, 0, 0, 0, 0, 0, 0, 0, LANG_TRANDOSHAN},
const.c:    "Chadra-Fan", AFF_INFRARED, -3, +3, 0, +2, -1, 0, 0, 0, 0, 0, 0, 0, 0, LANG_CHADRA_FAN},
const.c:    "Quarren", AFF_AQUA_BREATH + AFF_INFRARED, -1, +1, 0, +1, -1, 0, 0, 0, 0, 0, 0, 0, 0, LANG_MON_CALAMARI},
const.c:    "Duinuogwuin", AFF_FLYING, 0, -1, +3, 0, +8, +1, 0, 0, 0, +10, 0, 0, 0, LANG_DUINUOGWUIN}
const.c:   "Gamorrean", "Jawa", "Adarian", "Ewok", "Verpine", "Defel", "Trandoshan", "Chadra-Fan", "Quarren",
const.c:   {-5, -4, 0, 0},   /* 0  */
const.c:   {-5, -4, 3, 1},   /* 1  */
const.c:   {-3, -2, 3, 2},
const.c:   {-3, -1, 10, 3},  /* 3  */
const.c:   {-2, -1, 25, 4},
const.c:   {-2, -1, 55, 5},  /* 5  */
const.c:   {-1, 0, 80, 6},
const.c:   {-1, 0, 90, 8},
const.c:   {-10},   /* 15 */
const.c:   {-15},
const.c:   {-20},
const.c:   {-30},
const.c:   {-40},
const.c:   {-50},   /* 20 */
const.c:   {-60},
const.c:   {-75},
const.c:   {-90},
const.c:   {-105},
const.c:   {-120}   /* 25 */
const.c:   {-4, 20},   /*  0 */
const.c:   {-3, 25},   /*  1 */
const.c:   {-2, 30},
const.c:   {-2, 35},   /*  3 */
const.c:   {-1, 40},
const.c:   {-1, 45},   /*  5 */
const.c:   {-1, 50},
const.c:   {-60},   /* 0 */
const.c:   {-50},   /* 1 */
const.c:   {-50},
const.c:   {-40},
const.c:   {-30},
const.c:   {-20},   /* 5 */
const.c:   {-10},
const.c:   {-5},
const.c:   {-1},
const.c:/* Have to fix this up - not exactly sure how it works (Scryn) */
const.c:   {-10},   /* 15 */
const.c:   {-15},
const.c:   {-20},
const.c:   {-30},
const.c:   {-40},
const.c:   {-50},   /* 20 */
const.c:   {-60},
const.c:   {-75},
const.c:   {-90},
const.c:   {-105},
const.c:   {-120}   /* 25 */
const.c:   {"slime mold juice", "green", {0, 4, -8}},
const.c:   {"blood", "red", {0, 2, -1}},
const.c:   {"salt water", "clear", {0, 1, -2}},
db.c:*--------------------------------------------------------------------------*
db.c:* -------------------------------------------------------------------------*
db.c:*--------------------------------------------------------------------------*
db.c:* ------------------------------------------------------------------------ *
db.c:* ------------------------------------------------------------------------ *
db.c: * Semi-locals.
db.c:   boot_log( "---------------------[ Boot Log ]--------------------" );
db.c:      if( !gsn_first_spell && skill_table[x]->type == SKILL_SPELL )
db.c:      else if( !gsn_first_skill && skill_table[x]->type == SKILL_SKILL )
db.c:      else if( !gsn_first_weapon && skill_table[x]->type == SKILL_WEAPON )
db.c:      else if( !gsn_first_tongue && skill_table[x]->type == SKILL_TONGUE )
db.c:   auction->item = NULL;
db.c:      lhour = ( current_time - 650336715 ) / ( PULSE_TICK / PULSE_PER_SECOND );
db.c:   log_string( "Loading DNS cache..." ); /* Samson 1-30-02 */
db.c:      ASSIGN_GSN( gsn_vibro_blades, "vibro-blades" );
db.c:      ASSIGN_GSN( gsn_chadra_fan, "chadra-fan" );
db.c:            bug( "%s: EOF encountered reading area list - no $ found at end of file.", __FUNCTION__ );
db.c:   pArea->version = aversion;
db.c:   pArea->first_room = pArea->last_room = NULL;
db.c:   pArea->name = fread_string_nohash( fp );
db.c:   pArea->author = STRALLOC( "unknown" );
db.c:   pArea->filename = str_dup( strArea );
db.c:   pArea->age = 15;
db.c:   pArea->nplayer = 0;
db.c:   pArea->low_r_vnum = 0;
db.c:   pArea->low_o_vnum = 0;
db.c:   pArea->low_m_vnum = 0;
db.c:   pArea->hi_r_vnum = 0;
db.c:   pArea->hi_o_vnum = 0;
db.c:   pArea->hi_m_vnum = 0;
db.c:   pArea->low_soft_range = 0;
db.c:   pArea->hi_soft_range = MAX_LEVEL;
db.c:   pArea->low_hard_range = 0;
db.c:   pArea->hi_hard_range = MAX_LEVEL;
db.c: * the #AREA here.  --Shaddai
db.c:   tarea->version = fread_number( fp );
db.c:   if( tarea->author )
db.c:      STRFREE( tarea->author );
db.c:   tarea->author = fread_string( fp );
db.c:   tarea->high_economy = fread_number( fp );
db.c:   tarea->low_economy = fread_number( fp );
db.c:   if( tarea->resetmsg )
db.c:      DISPOSE( tarea->resetmsg );
db.c:   tarea->resetmsg = fread_string_nohash( fp );
db.c:   tarea->flags = x1;
db.c:   tarea->reset_frequency = x2;
db.c:      tarea->age = x2;
db.c: * Page is insert-sorted by keyword.			-Thoric
db.c:   for( tHelp = first_help; tHelp; tHelp = tHelp->next )
db.c:      if( pHelp->level == tHelp->level && strcmp( pHelp->keyword, tHelp->keyword ) == 0 )
db.c:         bug( "add_help: duplicate: %s.  Deleting.", pHelp->keyword );
db.c:         STRFREE( pHelp->text );
db.c:         STRFREE( pHelp->keyword );
db.c:         if( ( match = strcmp( pHelp->keyword[0] == '\'' ? pHelp->keyword + 1 : pHelp->keyword,
db.c:                               tHelp->keyword[0] == '\'' ? tHelp->keyword + 1 : tHelp->keyword ) ) < 0
db.c:             || ( match == 0 && pHelp->level > tHelp->level ) )
db.c:         if( !tHelp->prev )
db.c:            tHelp->prev->next = pHelp;
db.c:         pHelp->prev = tHelp->prev;
db.c:         pHelp->next = tHelp;
db.c:         tHelp->prev = pHelp;
db.c:      pHelp->level = fread_number( fp );
db.c:      pHelp->keyword = fread_string( fp );
db.c:      if( pHelp->keyword[0] == '$' )
db.c:         STRFREE( pHelp->keyword );
db.c:      pHelp->text = fread_string( fp );
db.c:      if( pHelp->keyword[0] == '\0' )
db.c:         STRFREE( pHelp->text );
db.c:         STRFREE( pHelp->keyword );
db.c:      if( !str_cmp( pHelp->keyword, "greeting" ) )
db.c:         help_greeting = pHelp->text;
db.c: * Add a character to the list of all characters		-Thoric
db.c:      pMobIndex->vnum = vnum;
db.c:         if( !tarea->low_m_vnum )
db.c:            tarea->low_m_vnum = vnum;
db.c:         if( vnum > tarea->hi_m_vnum )
db.c:            tarea->hi_m_vnum = vnum;
db.c:      pMobIndex->player_name = fread_string( fp );
db.c:      pMobIndex->short_descr = fread_string( fp );
db.c:      pMobIndex->long_descr = fread_string( fp );
db.c:      pMobIndex->description = fread_string( fp );
db.c:      ((char*)pMobIndex->long_descr)[0] = UPPER( pMobIndex->long_descr[0] );
db.c:      ((char*)pMobIndex->description)[0] = UPPER( pMobIndex->description[0] );
db.c:      pMobIndex->act = fread_number( fp ) | ACT_IS_NPC;
db.c:      pMobIndex->affected_by = fread_number( fp );
db.c:      pMobIndex->pShop = NULL;
db.c:      pMobIndex->rShop = NULL;
db.c:      pMobIndex->alignment = fread_number( fp );
db.c:      pMobIndex->level = fread_number( fp );
db.c:      pMobIndex->mobthac0 = fread_number( fp );
db.c:      pMobIndex->ac = fread_number( fp );
db.c:      pMobIndex->hitnodice = fread_number( fp );
db.c:      pMobIndex->hitsizedice = fread_number( fp );
db.c:      pMobIndex->hitplus = fread_number( fp );
db.c:      pMobIndex->damnodice = fread_number( fp );
db.c:      pMobIndex->damsizedice = fread_number( fp );
db.c:      pMobIndex->damplus = fread_number( fp );
db.c:      pMobIndex->gold = fread_number( fp );
db.c:      pMobIndex->exp = fread_number( fp );
db.c:      pMobIndex->position = fread_number( fp );
db.c:      pMobIndex->defposition = fread_number( fp );
db.c:      pMobIndex->sex = fread_number( fp );
db.c:      if( letter == 'C' || letter == 'Z' )   /* Realms complex mob    -Thoric  */
db.c:         pMobIndex->perm_str = fread_number( fp );
db.c:         pMobIndex->perm_int = fread_number( fp );
db.c:         pMobIndex->perm_wis = fread_number( fp );
db.c:         pMobIndex->perm_dex = fread_number( fp );
db.c:         pMobIndex->perm_con = fread_number( fp );
db.c:         pMobIndex->perm_cha = fread_number( fp );
db.c:         pMobIndex->perm_lck = fread_number( fp );
db.c:         pMobIndex->saving_poison_death = fread_number( fp );
db.c:         pMobIndex->saving_wand = fread_number( fp );
db.c:         pMobIndex->saving_para_petri = fread_number( fp );
db.c:         pMobIndex->saving_breath = fread_number( fp );
db.c:         pMobIndex->saving_spell_staff = fread_number( fp );
db.c:         pMobIndex->race = x1;
db.c:         pMobIndex->height = x3;
db.c:         pMobIndex->weight = x4;
db.c:         pMobIndex->speaks = x5;
db.c:         pMobIndex->speaking = x6;
db.c:         pMobIndex->numattacks = x7;
db.c:         if( !pMobIndex->speaks )
db.c:            pMobIndex->speaks = race_table[pMobIndex->race].language | LANG_COMMON;
db.c:         if( !pMobIndex->speaking )
db.c:            pMobIndex->speaking = race_table[pMobIndex->race].language;
db.c:         pMobIndex->hitroll = x1;
db.c:         pMobIndex->damroll = x2;
db.c:         pMobIndex->xflags = x3;
db.c:         pMobIndex->resistant = x4;
db.c:         pMobIndex->immune = x5;
db.c:         pMobIndex->susceptible = x6;
db.c:         pMobIndex->attacks = x7;
db.c:         pMobIndex->defenses = x8;
db.c:         pMobIndex->perm_str = 10;
db.c:         pMobIndex->perm_dex = 10;
db.c:         pMobIndex->perm_int = 10;
db.c:         pMobIndex->perm_wis = 10;
db.c:         pMobIndex->perm_cha = 10;
db.c:         pMobIndex->perm_con = 10;
db.c:         pMobIndex->perm_lck = 10;
db.c:         pMobIndex->race = 0;
db.c:         pMobIndex->xflags = 0;
db.c:         pMobIndex->resistant = 0;
db.c:         pMobIndex->immune = 0;
db.c:         pMobIndex->susceptible = 0;
db.c:         pMobIndex->numattacks = 0;
db.c:         pMobIndex->attacks = 0;
db.c:         pMobIndex->defenses = 0;
db.c:         pMobIndex->vip_flags = x1;
db.c:         pMobIndex->next = mob_index_hash[iHash];
db.c:      pObjIndex->vnum = vnum;
db.c:         if( !tarea->low_o_vnum )
db.c:            tarea->low_o_vnum = vnum;
db.c:         if( vnum > tarea->hi_o_vnum )
db.c:            tarea->hi_o_vnum = vnum;
db.c:      pObjIndex->name = fread_string( fp );
db.c:      pObjIndex->short_descr = fread_string( fp );
db.c:      pObjIndex->description = fread_string( fp );
db.c:      pObjIndex->action_desc = fread_string( fp );
db.c:       * pObjIndex->short_descr[0]  = LOWER(pObjIndex->short_descr[0]);
db.c:      ((char*)pObjIndex->description)[0] = UPPER( pObjIndex->description[0] );
db.c:      pObjIndex->item_type = x1;
db.c:      pObjIndex->extra_flags = x2;
db.c:      pObjIndex->wear_flags = x3;
db.c:      pObjIndex->layers = x4;
db.c:      pObjIndex->value[0] = x1;
db.c:      pObjIndex->value[1] = x2;
db.c:      pObjIndex->value[2] = x3;
db.c:      pObjIndex->value[3] = x4;
db.c:      pObjIndex->value[4] = x5;
db.c:      pObjIndex->value[5] = x6;
db.c:      pObjIndex->weight = fread_number( fp );
db.c:      pObjIndex->weight = UMAX( 1, pObjIndex->weight );
db.c:      pObjIndex->cost = fread_number( fp );
db.c:      pObjIndex->rent = fread_number( fp );  /* unused */
db.c:            paf->type = -1;
db.c:            paf->duration = -1;
db.c:            paf->location = fread_number( fp );
db.c:            if( paf->location == APPLY_WEAPONSPELL
db.c:                || paf->location == APPLY_WEARSPELL || paf->location == APPLY_REMOVESPELL || paf->location == APPLY_STRIPSN )
db.c:               paf->modifier = slot_lookup( fread_number( fp ) );
db.c:               paf->modifier = fread_number( fp );
db.c:            paf->bitvector = 0;
db.c:            LINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c:            ed->keyword = fread_string( fp );
db.c:            ed->description = fread_string( fp );
db.c:            LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c:      switch ( pObjIndex->item_type )
db.c:            pObjIndex->value[1] = slot_lookup( pObjIndex->value[1] );
db.c:            pObjIndex->value[2] = slot_lookup( pObjIndex->value[2] );
db.c:            pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
db.c:            pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
db.c:            pObjIndex->value[4] = slot_lookup( pObjIndex->value[4] );
db.c:            pObjIndex->value[5] = slot_lookup( pObjIndex->value[5] );
db.c:         pObjIndex->next = obj_index_hash[iHash];
db.c:   if( !tarea->first_room )
db.c:               boot_log( "%s: %s (%d) bad command '%c'.", __FUNCTION__, tarea->filename, count, letter );
db.c:               boot_log( "%s: %s (%d) 'M': mobile %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c:               boot_log( "%s: %s (%d) 'M': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg3 );
db.c:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c:               boot_log( "%s: %s (%d) '%c': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg3 );
db.c:                  bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c:                  boot_log( "%s: %s (%d) 'P': destination object %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg3 );
db.c:               bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c:               bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c:                  bug( "%s: Unable to add trap reset - room not found.", __FUNCTION__ );
db.c:                  boot_log( "%s: %s (%d) 'D': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c:                || !( pexit = get_exit( pRoomIndex, arg2 ) ) || !IS_SET( pexit->exit_info, EX_ISDOOR ) )
db.c:                  boot_log( "%s: %s (%d) 'D': exit %d not door.", __FUNCTION__, tarea->filename, count, arg2 );
db.c:                  boot_log( "%s: %s (%d) 'D': bad 'locks': %d.", __FUNCTION__, tarea->filename, count, arg3 );
db.c:               boot_log( "%s: %s (%d) 'R': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c:                  boot_log( "%s: %s (%d) 'R': bad exit %d.", __FUNCTION__, tarea->filename, count, arg2 );
db.c:      for( roomlist = tarea->first_room; roomlist; roomlist = roomlist->next_aroom )
db.c:            boot_log( "%s: %s (%d) bad command '%c'.", __FUNCTION__, room->area->filename, count, letter );
db.c:            boot_log( "%s: %s (%d) 'M': mobile %d doesn't exist.", __FUNCTION__, room->area->filename, count, arg1 );
db.c:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c:            boot_log( "%s: %s (%d) 'P': destination object %d doesn't exist.", __FUNCTION__, room->area->filename, count, arg3 );
db.c:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c:             || !( pexit = get_exit( room, arg2 ) ) || !IS_SET( pexit->exit_info, EX_ISDOOR ) )
db.c:               boot_log( "%s: %s (%d) 'D': exit %d not door.", __FUNCTION__, room->area->filename, count, arg2 );
db.c:               boot_log( "%s: %s (%d) 'D': bad 'locks': %d.", __FUNCTION__, room->area->filename, count, arg3 );
db.c:               boot_log( "%s: %s (%d) 'R': bad exit %d.", __FUNCTION__, room->area->filename, count, arg2 );
db.c:   tarea->first_room = tarea->last_room = NULL;
db.c:         pRoomIndex->first_person = NULL;
db.c:         pRoomIndex->last_person = NULL;
db.c:         pRoomIndex->first_content = NULL;
db.c:         pRoomIndex->last_content = NULL;
db.c:      pRoomIndex->area = tarea;
db.c:      pRoomIndex->vnum = vnum;
db.c:      pRoomIndex->first_extradesc = NULL;
db.c:      pRoomIndex->last_extradesc = NULL;
db.c:         if( !tarea->low_r_vnum )
db.c:            tarea->low_r_vnum = vnum;
db.c:         if( vnum > tarea->hi_r_vnum )
db.c:            tarea->hi_r_vnum = vnum;
db.c:      pRoomIndex->name = fread_string( fp );
db.c:      pRoomIndex->description = fread_string( fp );
db.c:      pRoomIndex->room_flags = x2;
db.c:      pRoomIndex->sector_type = x3;
db.c:      pRoomIndex->tele_delay = x4;
db.c:      pRoomIndex->tele_vnum = x5;
db.c:      pRoomIndex->tunnel = x6;
db.c:      if( pRoomIndex->sector_type < 0 || pRoomIndex->sector_type >= SECT_MAX )
db.c:         bug( "Fread_rooms: vnum %d has bad sector_type %d.", vnum, pRoomIndex->sector_type );
db.c:         pRoomIndex->sector_type = 1;
db.c:      pRoomIndex->light = 0;
db.c:      pRoomIndex->first_exit = NULL;
db.c:      pRoomIndex->last_exit = NULL;
db.c:               pexit->description = fread_string( fp );
db.c:               pexit->keyword = fread_string( fp );
db.c:               pexit->exit_info = 0;
db.c:               pexit->key = x2;
db.c:               pexit->vnum = x3;
db.c:               pexit->vdir = door;
db.c:               pexit->distance = x4;
db.c:                     pexit->exit_info = EX_ISDOOR;
db.c:                     pexit->exit_info = EX_ISDOOR | EX_PICKPROOF;
db.c:                     pexit->exit_info = locks;
db.c:            ed->keyword = fread_string( fp );
db.c:            ed->description = fread_string( fp );
db.c:            LINK( ed, pRoomIndex->first_extradesc, pRoomIndex->last_extradesc, next, prev );
db.c:         pRoomIndex->next = room_index_hash[iHash];
db.c:         LINK( pRoomIndex, tarea->first_room, tarea->last_room, next_aroom, prev_aroom );
db.c:      pShop->keeper = fread_number( fp );
db.c:      if( pShop->keeper == 0 )
db.c:         pShop->buy_type[iTrade] = fread_number( fp );
db.c:      pShop->profit_buy = fread_number( fp );
db.c:      pShop->profit_sell = fread_number( fp );
db.c:      pShop->profit_buy = URANGE( pShop->profit_sell + 5, pShop->profit_buy, 1000 );
db.c:      pShop->profit_sell = URANGE( 0, pShop->profit_sell, pShop->profit_buy - 5 );
db.c:      pShop->open_hour = fread_number( fp );
db.c:      pShop->close_hour = fread_number( fp );
db.c:      pMobIndex = get_mob_index( pShop->keeper );
db.c:      pMobIndex->pShop = pShop;
db.c:         last_shop->next = pShop;
db.c:      pShop->next = NULL;
db.c:      pShop->prev = last_shop;
db.c: * Load a repair shop section.					-Thoric
db.c:      rShop->keeper = fread_number( fp );
db.c:      if( rShop->keeper == 0 )
db.c:         rShop->fix_type[iFix] = fread_number( fp );
db.c:      rShop->profit_fix = fread_number( fp );
db.c:      rShop->shop_type = fread_number( fp );
db.c:      rShop->open_hour = fread_number( fp );
db.c:      rShop->close_hour = fread_number( fp );
db.c:      pMobIndex = get_mob_index( rShop->keeper );
db.c:      pMobIndex->rShop = rShop;
db.c:         last_repair->next = rShop;
db.c:      rShop->next = NULL;
db.c:      rShop->prev = last_repair;
db.c:            if( !pMobIndex->spec_fun )
db.c:               pMobIndex->spec_fun = spec_lookup( temp );
db.c:               if( pMobIndex->spec_fun == NULL )
db.c:                  bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
db.c:                  pMobIndex->spec_funname = NULL;
db.c:                  pMobIndex->spec_funname = STRALLOC( temp );
db.c:            else if( !pMobIndex->spec_2 )
db.c:               pMobIndex->spec_2 = spec_lookup( temp );
db.c:               if( pMobIndex->spec_2 == NULL )
db.c:                  bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
db.c:                  pMobIndex->spec_funname2 = NULL;
db.c:                  pMobIndex->spec_funname2 = STRALLOC( temp );
db.c:      tarea->low_soft_range = x1;
db.c:      tarea->hi_soft_range = x2;
db.c:      tarea->low_hard_range = x3;
db.c:      tarea->hi_hard_range = x4;
db.c:   for( tarea = first_area; tarea; tarea = tarea->next )
db.c:      if( tarea->high_economy > 0 || tarea->low_economy > 10000 )
db.c:      rng = tarea->hi_soft_range - tarea->low_soft_range;
db.c:      for( idx = tarea->low_m_vnum; idx < tarea->hi_m_vnum; idx++ )
db.c:            boost_economy( tarea, mob->gold * 10 );
db.c:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c:         for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit_next )
db.c:            pexit_next = pexit->next;
db.c:            pexit->rvnum = pRoomIndex->vnum;
db.c:            if( pexit->vnum <= 0 || ( pexit->to_room = get_room_index( pexit->vnum ) ) == NULL )
db.c:                            pRoomIndex->vnum, dir_name[pexit->vdir], pexit->vnum );
db.c:               bug( "Deleting %s exit in room %d", dir_name[pexit->vdir], pRoomIndex->vnum );
db.c:            SET_BIT( pRoomIndex->room_flags, ROOM_NO_MOB );
db.c:    * Set all the rexit pointers   -Thoric 
db.c:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c:         for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c:            if( pexit->to_room && !pexit->rexit )
db.c:               rev_exit = get_exit_to( pexit->to_room, rev_dir[pexit->vdir], pRoomIndex->vnum );
db.c:                  pexit->rexit = rev_exit;
db.c:                  rev_exit->rexit = pexit;
db.c: * Get diku-compatable exit by number				-Thoric
db.c:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c:   d1 = ( *xit1 )->vdir;
db.c:   d2 = ( *xit2 )->vdir;
db.c:      return -1;
db.c:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c:         exits[x]->prev = exits[x - 1];
db.c:         exits[x]->prev = NULL;
db.c:         room->first_exit = exits[x];
db.c:      if( x >= ( nexits - 1 ) )
db.c:         exits[x]->next = NULL;
db.c:         room->last_exit = exits[x];
db.c:         exits[x]->next = exits[x + 1];
db.c:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c:      vdirs[nexits++] = pexit->vdir;
db.c:      while( vdirs[( d1 = number_range( d0, nexits - 1 ) )] > maxdir || ++count > 5 );
db.c:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c:      pexit->vdir = vdirs[count++];
db.c:   for( pArea = first_area; pArea; pArea = pArea->next )
db.c:      int reset_age = pArea->reset_frequency ? pArea->reset_frequency : 15;
db.c:      if( ( reset_age == -1 && pArea->age == -1 ) || ++pArea->age < ( reset_age - 1 ) )
db.c:      if( pArea->nplayer > 0 && pArea->age == ( reset_age - 1 ) )
db.c:         if( pArea->resetmsg )
db.c:            sprintf( buf, "%s\r\n", pArea->resetmsg );
db.c:         for( pch = first_char; pch; pch = pch->next )
db.c:            if( !IS_NPC( pch ) && IS_AWAKE( pch ) && pch->in_room && pch->in_room->area == pArea )
db.c:      if( pArea->nplayer == 0 || pArea->age >= reset_age )
db.c:         if( reset_age == -1 )
db.c:            pArea->age = -1;
db.c:            pArea->age = number_range( 0, reset_age / 5 );
db.c:         if( pRoomIndex != NULL && pArea == pRoomIndex->area && pArea->reset_frequency == 0 )
db.c:            pArea->age = 15 - 3;
db.c:   mob->pIndexData = pMobIndex;
db.c:   mob->editor = NULL;
db.c:   mob->name = QUICKLINK( pMobIndex->player_name );
db.c:   mob->short_descr = QUICKLINK( pMobIndex->short_descr );
db.c:   mob->long_descr = QUICKLINK( pMobIndex->long_descr );
db.c:   mob->description = QUICKLINK( pMobIndex->description );
db.c:   mob->spec_fun = pMobIndex->spec_fun;
db.c:   mob->spec_2 = pMobIndex->spec_2;
db.c:   if( pMobIndex->spec_funname )
db.c:      mob->spec_funname = QUICKLINK( pMobIndex->spec_funname );
db.c:   if( pMobIndex->spec_funname2 )
db.c:      mob->spec_funname2 = QUICKLINK( pMobIndex->spec_funname2 );
db.c:   mob->mpscriptpos = 0;
db.c:   mob->top_level = number_fuzzy( pMobIndex->level );
db.c:         mob->skill_level[ability] = mob->top_level;
db.c:   mob->act = pMobIndex->act;
db.c:   mob->home_vnum = -1;
db.c:   mob->resetvnum = -1;
db.c:   mob->resetnum = -1;
db.c:   mob->affected_by = pMobIndex->affected_by;
db.c:   mob->alignment = pMobIndex->alignment;
db.c:   mob->sex = pMobIndex->sex;
db.c:   mob->main_ability = 0;
db.c:   mob->mob_clan = STRALLOC( "" );
db.c:   mob->was_sentinel = NULL;
db.c:   mob->plr_home = NULL;
db.c:   mob->guard_data = NULL;
db.c:   if( pMobIndex->ac )
db.c:      mob->armor = pMobIndex->ac;
db.c:     mob->armor = ( short )( LEVEL_HERO - mob->top_level * 2.5 );
db.c:   if( !pMobIndex->hitnodice )
db.c:      mob->max_hit = mob->top_level * 10 + number_range( mob->top_level, mob->top_level * 10 );
db.c:      mob->max_hit = pMobIndex->hitnodice * number_range( 1, pMobIndex->hitsizedice ) + pMobIndex->hitplus;
db.c:   mob->hit = mob->max_hit;
db.c:    * lets put things back the way they used to be! -Thoric 
db.c:   mob->gold = pMobIndex->gold;
db.c:   mob->position = pMobIndex->position;
db.c:   mob->defposition = pMobIndex->defposition;
db.c:   mob->barenumdie = pMobIndex->damnodice;
db.c:   mob->baresizedie = pMobIndex->damsizedice;
db.c:   mob->mobthac0 = pMobIndex->mobthac0;
db.c:   mob->hitplus = pMobIndex->hitplus;
db.c:   mob->damplus = pMobIndex->damplus;
db.c:   mob->perm_str = pMobIndex->perm_str;
db.c:   mob->perm_dex = pMobIndex->perm_dex;
db.c:   mob->perm_wis = pMobIndex->perm_wis;
db.c:   mob->perm_int = pMobIndex->perm_int;
db.c:   mob->perm_con = pMobIndex->perm_con;
db.c:   mob->perm_cha = pMobIndex->perm_cha;
db.c:   mob->perm_lck = pMobIndex->perm_lck;
db.c:   mob->hitroll = pMobIndex->hitroll;
db.c:   mob->damroll = pMobIndex->damroll;
db.c:   mob->race = pMobIndex->race;
db.c:   mob->xflags = pMobIndex->xflags;
db.c:   mob->saving_poison_death = pMobIndex->saving_poison_death;
db.c:   mob->saving_wand = pMobIndex->saving_wand;
db.c:   mob->saving_para_petri = pMobIndex->saving_para_petri;
db.c:   mob->saving_breath = pMobIndex->saving_breath;
db.c:   mob->saving_spell_staff = pMobIndex->saving_spell_staff;
db.c:   mob->height = pMobIndex->height;
db.c:   mob->weight = pMobIndex->weight;
db.c:   mob->resistant = pMobIndex->resistant;
db.c:   mob->immune = pMobIndex->immune;
db.c:   mob->susceptible = pMobIndex->susceptible;
db.c:   mob->attacks = pMobIndex->attacks;
db.c:   mob->defenses = pMobIndex->defenses;
db.c:   mob->numattacks = pMobIndex->numattacks;
db.c:   mob->speaks = pMobIndex->speaks;
db.c:   mob->speaking = pMobIndex->speaking;
db.c:   mob->vip_flags = pMobIndex->vip_flags;
db.c:   pMobIndex->count++;
db.c:   obj->pIndexData = pObjIndex;
db.c:   obj->in_room = NULL;
db.c:   obj->level = level;
db.c:   obj->wear_loc = -1;
db.c:   obj->count = 1;
db.c:   cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
db.c:   obj->serial = obj->pIndexData->serial = cur_obj_serial;
db.c:   obj->armed_by = STRALLOC( "" );
db.c:   obj->name = QUICKLINK( pObjIndex->name );
db.c:   obj->short_descr = QUICKLINK( pObjIndex->short_descr );
db.c:   obj->description = QUICKLINK( pObjIndex->description );
db.c:   obj->action_desc = QUICKLINK( pObjIndex->action_desc );
db.c:   obj->item_type = pObjIndex->item_type;
db.c:   obj->extra_flags = pObjIndex->extra_flags;
db.c:   obj->wear_flags = pObjIndex->wear_flags;
db.c:   obj->value[0] = pObjIndex->value[0];
db.c:   obj->value[1] = pObjIndex->value[1];
db.c:   obj->value[2] = pObjIndex->value[2];
db.c:   obj->value[3] = pObjIndex->value[3];
db.c:   obj->value[4] = pObjIndex->value[4];
db.c:   obj->value[5] = pObjIndex->value[5];
db.c:   obj->weight = pObjIndex->weight;
db.c:   obj->cost = pObjIndex->cost;
db.c:    * obj->cost     = number_fuzzy( 10 )
db.c:   switch ( obj->item_type )
db.c:         bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
db.c:         bug( "------------------------>     ", obj->item_type );
db.c:          * optional food condition (rotting food)    -Thoric
db.c:         if( obj->value[4] )
db.c:            obj->timer = obj->value[4];
db.c:            obj->timer = obj->value[1];
db.c:         obj->value[3] = number_fuzzy( obj->value[3] );
db.c:         obj->value[0] = number_fuzzy( obj->value[0] );
db.c:         obj->value[1] = number_fuzzy( obj->value[1] );
db.c:         obj->value[2] = obj->value[1];
db.c:         if( obj->value[0] <= 0 )
db.c:            obj->value[0] = number_fuzzy( 95 );
db.c:         if( obj->value[0] <= 0 )
db.c:            obj->value[0] = number_fuzzy( 95 );
db.c:         if( obj->value[0] <= 0 )
db.c:            obj->value[0] = number_fuzzy( 495 );
db.c:         if( obj->value[1] && obj->value[2] )
db.c:            obj->value[2] *= obj->value[1];
db.c:            obj->value[1] = number_fuzzy( number_fuzzy( 1 + level / 20 ) );
db.c:            obj->value[2] = number_fuzzy( number_fuzzy( 10 + level / 10 ) );
db.c:         if( obj->value[1] > obj->value[2] )
db.c:            obj->value[1] = obj->value[2] / 3;
db.c:         if( obj->value[0] == 0 )
db.c:            obj->value[0] = INIT_WEAPON_CONDITION;
db.c:         switch ( obj->value[3] )
db.c:               if( obj->value[5] <= 0 )
db.c:                  obj->value[5] = number_fuzzy( 1000 );
db.c:         obj->value[4] = obj->value[5];
db.c:         if( obj->value[0] == 0 )
db.c:            obj->value[0] = obj->value[1];
db.c:         obj->timer = obj->value[3];
db.c:         obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c:         obj->value[0] = obj->cost;
db.c:   ++pObjIndex->count;
db.c:   ch->editor = NULL;
db.c:   ch->hunting = NULL;
db.c:   ch->fearing = NULL;
db.c:   ch->hating = NULL;
db.c:   ch->name = NULL;
db.c:   ch->short_descr = NULL;
db.c:   ch->long_descr = NULL;
db.c:   ch->description = NULL;
db.c:   ch->next = NULL;
db.c:   ch->prev = NULL;
db.c:   ch->first_carrying = NULL;
db.c:   ch->last_carrying = NULL;
db.c:   ch->next_in_room = NULL;
db.c:   ch->prev_in_room = NULL;
db.c:   ch->fighting = NULL;
db.c:   ch->switched = NULL;
db.c:   ch->first_affect = NULL;
db.c:   ch->last_affect = NULL;
db.c:   ch->prev_cmd = NULL; /* maps */
db.c:   ch->last_cmd = NULL;
db.c:   ch->dest_buf = NULL;
db.c:   ch->dest_buf_2 = NULL;
db.c:   ch->spare_ptr = NULL;
db.c:   ch->mount = NULL;
db.c:   ch->affected_by = 0;
db.c:   ch->logon = current_time;
db.c:   ch->armor = 100;
db.c:   ch->position = POS_STANDING;
db.c:   ch->hit = 500;
db.c:   ch->max_hit = 500;
db.c:   ch->mana = 1000;
db.c:   ch->max_mana = 0;
db.c:   ch->move = 1000;
db.c:   ch->max_move = 1000;
db.c:   ch->height = 72;
db.c:   ch->weight = 180;
db.c:   ch->xflags = 0;
db.c:   ch->race = 0;
db.c:   ch->speaking = LANG_COMMON;
db.c:   ch->speaks = LANG_COMMON;
db.c:   ch->barenumdie = 1;
db.c:   ch->baresizedie = 4;
db.c:   ch->substate = 0;
db.c:   ch->tempnum = 0;
db.c:   ch->perm_str = 10;
db.c:   ch->perm_dex = 10;
db.c:   ch->perm_int = 10;
db.c:   ch->perm_wis = 10;
db.c:   ch->perm_cha = 10;
db.c:   ch->perm_con = 10;
db.c:   ch->perm_lck = 10;
db.c:   ch->mod_str = 0;
db.c:   ch->mod_dex = 0;
db.c:   ch->mod_int = 0;
db.c:   ch->mod_wis = 0;
db.c:   ch->mod_cha = 0;
db.c:   ch->mod_con = 0;
db.c:   ch->mod_lck = 0;
db.c:   ch->plr_home = NULL;
db.c:   if( ch->desc )
db.c:   while( ( obj = ch->last_carrying ) != NULL )
db.c:   while( ( paf = ch->last_affect ) != NULL )
db.c:   while( ( timer = ch->first_timer ) != NULL )
db.c:   STRFREE( ch->name );
db.c:   STRFREE( ch->short_descr );
db.c:   STRFREE( ch->long_descr );
db.c:   STRFREE( ch->description );
db.c:   STRFREE( ch->spec_funname );
db.c:   STRFREE( ch->spec_funname2 );
db.c:   if( ch->editor )
db.c:   if( ch->pnote )
db.c:      free_note( ch->pnote );
db.c:   if( ch->pcdata )
db.c:      STRFREE( ch->pcdata->clan_name );
db.c:      DISPOSE( ch->pcdata->pwd );   /* no hash */
db.c:      DISPOSE( ch->pcdata->email ); /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfin );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfout );  /* no hash */
db.c:      DISPOSE( ch->pcdata->rank );
db.c:      STRFREE( ch->pcdata->title );
db.c:      STRFREE( ch->pcdata->bio );
db.c:      DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c:      DISPOSE( ch->pcdata->homepage ); /* no hash */
db.c:      STRFREE( ch->pcdata->authed_by );
db.c:      STRFREE( ch->pcdata->prompt );
db.c:      if( ch->pcdata->subprompt )
db.c:         STRFREE( ch->pcdata->subprompt );
db.c:      DISPOSE( ch->pcdata );
db.c:   for( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:      mpact_next = mpact->next;
db.c:      DISPOSE( mpact->buf );
db.c:   for( comments = ch->comments; comments; comments = comments_next )
db.c:      comments_next = comments->next;
db.c:      STRFREE( comments->text );
db.c:      STRFREE( comments->to_list );
db.c:      STRFREE( comments->subject );
db.c:      STRFREE( comments->sender );
db.c:      STRFREE( comments->date );
db.c:   for( ; ed; ed = ed->next )
db.c:      if( is_name( name, ed->keyword ) )
db.c:         return ed->description;
db.c:   for( pMobIndex = mob_index_hash[vnum % MAX_KEY_HASH]; pMobIndex; pMobIndex = pMobIndex->next )
db.c:      if( pMobIndex->vnum == vnum )
db.c:   for( pObjIndex = obj_index_hash[vnum % MAX_KEY_HASH]; pObjIndex; pObjIndex = pObjIndex->next )
db.c:      if( pObjIndex->vnum == vnum )
db.c:   for( pRoomIndex = room_index_hash[vnum % MAX_KEY_HASH]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c:      if( pRoomIndex->vnum == vnum )
db.c: * should include player files, and in-progress areas that are not loaded
db.c: * -- Altrag
db.c:   else if( c == '-' )
db.c:            number = number * 10 + c - '0';
db.c:            number += pow( 10, ( -1 * place ) ) * ( c - '0' );
db.c:      number = 0 - number;
db.c:   else if( c == '-' )
db.c:      number = number * 10 + c - '0';
db.c:      number = 0 - number;
db.c: * custom str_dup using create					-Thoric
db.c:   if( stat( newfilename, &fst ) != -1 )
db.c:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c: * Read to end of line into static buffer			-Thoric
db.c:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c:      hash = -1;
db.c:      if( hash != -1 )
db.c:         number -= 1;
db.c: * Ooops was (number_mm() % to) + from which doesn't work -Shaddai
db.c:   if( ( to - from ) < 1 )
db.c:   return ( ( number_mm(  ) % ( to - from + 1 ) ) + from );
db.c: * number_mm() % 100 only does 0-99, changed to do 1-100 -Shaddai
db.c:   while( ( door = number_mm(  ) & ( 16 - 1 ) ) > 9 )
db.c:   return number_mm(  ) & ( ( 1 << width ) - 1 );
db.c: * I've gotten too many bad reports on OS-supplied random number generators.
db.c: * This is the Mitchell-Moore algorithm from Knuth Volume II.
db.c: * -- Furey
db.c:   piState[-2] = 55 - 55;
db.c:   piState[-1] = 55 - 24;
db.c:   piState[0] = ( ( int )current_time ) & ( ( 1 << 30 ) - 1 );
db.c:      piState[iState] = ( piState[iState - 1] + piState[iState - 2] ) & ( ( 1 << 30 ) - 1 );
db.c:   iState1 = piState[-2];
db.c:   iState2 = piState[-1];
db.c:   iRand = ( piState[iState1] + piState[iState2] ) & ( ( 1 << 30 ) - 1 );
db.c:   piState[-2] = iState1;
db.c:   piState[-1] = iState2;
db.c: * Roll some dice.						-Thoric
db.c:   return value_00 + level * ( value_32 - value_00 ) / 32;
db.c: * Used for player-entered strings that go into disk files.
db.c:         *str = '-';
db.c: * Encodes the tildes in a string.				-Thoric
db.c: * Used for player-entered strings that go into disk files.
db.c:   for( ichar = 0; ichar <= sstr2 - sstr1; ichar++ )
db.c:   if( sstr1 <= sstr2 && !str_cmp( astr, bstr + sstr2 - sstr1 ) )
db.c: * Returns an initial-capped string.
db.c: * Returns TRUE or FALSE if a letter is a vowel			-Thoric
db.c: * Shove either "a " or "an " onto the beginning of a string	-Thoric
db.c:      fprintf( fp, "[%5d] %s: %s\n", ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:      if( stat( SHUTDOWN_FILE, &fst ) != -1 )   /* file exists */
db.c: * Add a string to the boot-up log				-Thoric
db.c: * Dump a text file to a player, a line at a time		-Thoric
db.c:                && buf[num] != '\n' && buf[num] != '\r' && num < ( MAX_STRING_LENGTH - 2 ) )
db.c: * Show the boot log file					-Thoric
db.c: * Writes a string to the log, extended version			-Thoric
db.c:   strtime[strlen( strtime ) - 1] = '\0';
db.c: * wizlist builder!						-Thoric
db.c:      filler = ( 78 - strlen( line ) );
db.c:   wiz->name = str_dup( name );
db.c:   wiz->level = level;
db.c:      wiz->last = NULL;
db.c:      wiz->next = NULL;
db.c:   for( tmp = first_wiz; tmp; tmp = tmp->next )
db.c:      if( level > tmp->level )
db.c:         if( !tmp->last )
db.c:            tmp->last->next = wiz;
db.c:         wiz->last = tmp->last;
db.c:         wiz->next = tmp;
db.c:         tmp->last = wiz;
db.c:   wiz->last = last_wiz;
db.c:   wiz->next = NULL;
db.c:   last_wiz->next = wiz;
db.c: * Wizlist builder						-Thoric
db.c:      if( dentry->d_name[0] != '.' )
db.c:         sprintf( buf, "%s%s", GOD_DIR, dentry->d_name );
db.c:               ilevel = MAX_LEVEL - 4;
db.c:               ilevel = MAX_LEVEL - 4;
db.c:            add_to_wizlist( dentry->d_name, ilevel );
db.c:   for( wiz = first_wiz; wiz; wiz = wiz->next )
db.c:      if( wiz->level > LEVEL_AVATAR )
db.c:         if( wiz->level < ilevel )
db.c:            ilevel = wiz->level;
db.c:               case MAX_LEVEL - 0:
db.c:               case MAX_LEVEL - 1:
db.c:               case MAX_LEVEL - 2:
db.c:               case MAX_LEVEL - 4:
db.c:         if( strlen( buf ) + strlen( wiz->name ) > 76 )
db.c:         strcat( buf, wiz->name );
db.c:      wiznext = wiz->next;
db.c:      DISPOSE( wiz->name );
db.c:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c:      switch( mprg->type )
db.c:            mprg->arglist = fread_string( progfile );
db.c:            mprg->comlist = fread_string( progfile );
db.c:            mprg->fileprog = TRUE;
db.c:            SET_BIT( mob->progtypes, mprg->type );
db.c:            mprg->next = mob->mudprogs;
db.c:            mob->mudprogs = mprg;
db.c:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, mob->vnum );
db.c:      mprg->next = mob->mudprogs;
db.c:      mob->mudprogs = mprg;
db.c:      mprg->type = mprog_name_to_type( word );
db.c:      switch( mprg->type )
db.c:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, mob->vnum );
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->fileprog = FALSE;
db.c:            mobprog_file_read( mob, mprg->arglist );
db.c:            SET_BIT( mob->progtypes, mprg->type );
db.c:            mprg->fileprog = FALSE;
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->comlist = fread_string( fp );
db.c:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c:      switch( mprg->type )
db.c:            mprg->arglist = fread_string( progfile );
db.c:            mprg->comlist = fread_string( progfile );
db.c:            mprg->fileprog = TRUE;
db.c:            SET_BIT( obj->progtypes, mprg->type );
db.c:            mprg->next = obj->mudprogs;
db.c:            obj->mudprogs = mprg;
db.c:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, obj->vnum );
db.c:      mprg->next = obj->mudprogs;
db.c:      obj->mudprogs = mprg;
db.c:      mprg->type = mprog_name_to_type( word );
db.c:      switch( mprg->type )
db.c:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, obj->vnum );
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->fileprog = FALSE;
db.c:            objprog_file_read( obj, mprg->arglist );
db.c:            SET_BIT( obj->progtypes, mprg->type );
db.c:            mprg->fileprog = FALSE;
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->comlist = fread_string( fp );
db.c:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c:      switch( mprg->type )
db.c:            mprg->arglist = fread_string( progfile );
db.c:            mprg->comlist = fread_string( progfile );
db.c:            mprg->fileprog = TRUE;
db.c:            SET_BIT( room->progtypes, mprg->type );
db.c:            mprg->next = room->mudprogs;
db.c:            room->mudprogs = mprg;
db.c:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, room->vnum );
db.c:      mprg->next = room->mudprogs;
db.c:      room->mudprogs = mprg;
db.c:      mprg->type = mprog_name_to_type( word );
db.c:      switch( mprg->type )
db.c:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, room->vnum );
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->fileprog = FALSE;
db.c:            roomprog_file_read( room, mprg->arglist );
db.c:            SET_BIT( room->progtypes, mprg->type );
db.c:            mprg->fileprog = FALSE;
db.c:            mprg->arglist = fread_string( fp );
db.c:            mprg->comlist = fread_string( fp );
db.c:   Don't ask me why they return bool.. :).. oh well.. -- Alty
db.c:   Don't ask me either, so I changed it to void. - Samson
db.c:   UNLINK( room, room->area->first_room, room->area->last_room, next_aroom, prev_aroom );
db.c:   while( ( ch = room->first_person ) != NULL )
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->was_in_room == room )
db.c:         ch->was_in_room = ch->in_room;
db.c:      if( ch->substate == SUB_ROOM_DESC && ch->dest_buf == room )
db.c:         ch->substate = SUB_NONE;
db.c:         ch->dest_buf = NULL;
db.c:      else if( ch->substate == SUB_ROOM_EXTRA && ch->dest_buf )
db.c:         for( ed = room->first_extradesc; ed; ed = ed->next )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:               ch->dest_buf = NULL;
db.c:   while( ( o = room->first_content ) != NULL )
db.c:   while( ( ed = room->first_extradesc ) != NULL )
db.c:      room->first_extradesc = ed->next;
db.c:      STRFREE( ed->keyword );
db.c:      STRFREE( ed->description );
db.c:      --top_ed;
db.c:   while( ( ex = room->first_exit ) != NULL )
db.c:   while( ( mpact = room->mpact ) != NULL )
db.c:      room->mpact = mpact->next;
db.c:      DISPOSE( mpact->buf );
db.c:   while( ( mp = room->mudprogs ) != NULL )
db.c:      room->mudprogs = mp->next;
db.c:      STRFREE( mp->arglist );
db.c:      STRFREE( mp->comlist );
db.c:   STRFREE( room->name );
db.c:   STRFREE( room->description );
db.c:   hash = room->vnum % MAX_KEY_HASH;
db.c:      room_index_hash[hash] = room->next;
db.c:      for( prev = room_index_hash[hash]; prev; prev = prev->next )
db.c:         if( prev->next == room )
db.c:         prev->next = room->next;
db.c:         bug( "%s: room %d not in hash bucket %d.", __FUNCTION__, room->vnum, hash );
db.c:   --top_room;
db.c:      o_next = o->next;
db.c:      if( o->pIndexData == obj )
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->substate == SUB_OBJ_EXTRA && ch->dest_buf )
db.c:         for( ed = obj->first_extradesc; ed; ed = ed->next )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:         for( mp = obj->mudprogs; mp; mp = mp->next )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
db.c:   while( ( ed = obj->first_extradesc ) != NULL )
db.c:      obj->first_extradesc = ed->next;
db.c:      STRFREE( ed->keyword );
db.c:      STRFREE( ed->description );
db.c:      --top_ed;
db.c:   while( ( af = obj->first_affect ) != NULL )
db.c:      obj->first_affect = af->next;
db.c:      --top_affect;
db.c:   while( ( mp = obj->mudprogs ) != NULL )
db.c:      obj->mudprogs = mp->next;
db.c:      STRFREE( mp->arglist );
db.c:      STRFREE( mp->comlist );
db.c:   STRFREE( obj->name );
db.c:   STRFREE( obj->short_descr );
db.c:   STRFREE( obj->description );
db.c:   STRFREE( obj->action_desc );
db.c:   hash = obj->vnum % MAX_KEY_HASH;
db.c:      obj_index_hash[hash] = obj->next;
db.c:      for( prev = obj_index_hash[hash]; prev; prev = prev->next )
db.c:         if( prev->next == obj )
db.c:         prev->next = obj->next;
db.c:         bug( "%s: object %d not in hash bucket %d.", __FUNCTION__, obj->vnum, hash );
db.c:   --top_obj_index;
db.c:      ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:         for( mp = mob->mudprogs; mp; mp = mp->next )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
db.c:   while( ( mp = mob->mudprogs ) != NULL )
db.c:      mob->mudprogs = mp->next;
db.c:      STRFREE( mp->arglist );
db.c:      STRFREE( mp->comlist );
db.c:   if( mob->pShop )
db.c:      UNLINK( mob->pShop, first_shop, last_shop, next, prev );
db.c:      DISPOSE( mob->pShop );
db.c:      --top_shop;
db.c:   if( mob->rShop )
db.c:      UNLINK( mob->rShop, first_repair, last_repair, next, prev );
db.c:      DISPOSE( mob->rShop );
db.c:      --top_repair;
db.c:   STRFREE( mob->player_name );
db.c:   STRFREE( mob->short_descr );
db.c:   STRFREE( mob->long_descr );
db.c:   STRFREE( mob->description );
db.c:   STRFREE( mob->spec_funname );
db.c:   STRFREE( mob->spec_funname2 );
db.c:   hash = mob->vnum % MAX_KEY_HASH;
db.c:      mob_index_hash[hash] = mob->next;
db.c:      for( prev = mob_index_hash[hash]; prev; prev = prev->next )
db.c:         if( prev->next == mob )
db.c:         prev->next = mob->next;
db.c:         bug( "delete_mob: mobile %d not in hash bucket %d.", mob->vnum, hash );
db.c:   --top_mob_index;
db.c: * Creat a new room (for online building)			-Thoric
db.c:   pRoomIndex->first_person = NULL;
db.c:   pRoomIndex->last_person = NULL;
db.c:   pRoomIndex->first_content = NULL;
db.c:   pRoomIndex->last_content = NULL;
db.c:   pRoomIndex->first_reset = pRoomIndex->last_reset = NULL;
db.c:   pRoomIndex->first_extradesc = NULL;
db.c:   pRoomIndex->last_extradesc = NULL;
db.c:   pRoomIndex->first_ship = NULL;
db.c:   pRoomIndex->last_ship = NULL;
db.c:   pRoomIndex->area = area;
db.c:   pRoomIndex->vnum = vnum;
db.c:   pRoomIndex->name = STRALLOC( "Floating in a void" );
db.c:   pRoomIndex->description = STRALLOC( "" );
db.c:   pRoomIndex->room_flags = ROOM_PROTOTYPE;
db.c:   pRoomIndex->sector_type = 1;
db.c:   pRoomIndex->light = 0;
db.c:   pRoomIndex->first_exit = NULL;
db.c:   pRoomIndex->last_exit = NULL;
db.c:   LINK( pRoomIndex, area->first_room, area->last_room, next_aroom, prev_aroom );
db.c:   pRoomIndex->next = room_index_hash[iHash];
db.c: * Create a new INDEX object (for online building)		-Thoric
db.c:   pObjIndex->vnum = vnum;
db.c:   pObjIndex->name = STRALLOC( name );
db.c:   pObjIndex->first_affect = NULL;
db.c:   pObjIndex->last_affect = NULL;
db.c:   pObjIndex->first_extradesc = NULL;
db.c:   pObjIndex->last_extradesc = NULL;
db.c:      pObjIndex->short_descr = STRALLOC( buf );
db.c:      pObjIndex->description = STRALLOC( buf );
db.c:      pObjIndex->action_desc = STRALLOC( "" );
db.c:      ((char*)pObjIndex->short_descr)[0] = LOWER( pObjIndex->short_descr[0] );
db.c:      ((char*)pObjIndex->description)[0] = UPPER( pObjIndex->description[0] );
db.c:      pObjIndex->item_type = ITEM_TRASH;
db.c:      pObjIndex->extra_flags = ITEM_PROTOTYPE;
db.c:      pObjIndex->wear_flags = 0;
db.c:      pObjIndex->value[0] = 0;
db.c:      pObjIndex->value[1] = 0;
db.c:      pObjIndex->value[2] = 0;
db.c:      pObjIndex->value[3] = 0;
db.c:      pObjIndex->value[4] = 0;
db.c:      pObjIndex->value[5] = 0;
db.c:      pObjIndex->weight = 1;
db.c:      pObjIndex->cost = 0;
db.c:      pObjIndex->short_descr = QUICKLINK( cObjIndex->short_descr );
db.c:      pObjIndex->description = QUICKLINK( cObjIndex->description );
db.c:      pObjIndex->action_desc = QUICKLINK( cObjIndex->action_desc );
db.c:      pObjIndex->item_type = cObjIndex->item_type;
db.c:      pObjIndex->extra_flags = cObjIndex->extra_flags | ITEM_PROTOTYPE;
db.c:      pObjIndex->wear_flags = cObjIndex->wear_flags;
db.c:      pObjIndex->value[0] = cObjIndex->value[0];
db.c:      pObjIndex->value[1] = cObjIndex->value[1];
db.c:      pObjIndex->value[2] = cObjIndex->value[2];
db.c:      pObjIndex->value[3] = cObjIndex->value[3];
db.c:      pObjIndex->value[4] = cObjIndex->value[4];
db.c:      pObjIndex->value[5] = cObjIndex->value[5];
db.c:      pObjIndex->weight = cObjIndex->weight;
db.c:      pObjIndex->cost = cObjIndex->cost;
db.c:      for( ced = cObjIndex->first_extradesc; ced; ced = ced->next )
db.c:         ed->keyword = QUICKLINK( ced->keyword );
db.c:         ed->description = QUICKLINK( ced->description );
db.c:         LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c:      for( cpaf = cObjIndex->first_affect; cpaf; cpaf = cpaf->next )
db.c:         paf->type = cpaf->type;
db.c:         paf->duration = cpaf->duration;
db.c:         paf->location = cpaf->location;
db.c:         paf->modifier = cpaf->modifier;
db.c:         paf->bitvector = cpaf->bitvector;
db.c:         LINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c:   pObjIndex->count = 0;
db.c:   pObjIndex->next = obj_index_hash[iHash];
db.c: * Create a new INDEX mobile (for online building)		-Thoric
db.c:   pMobIndex->vnum = vnum;
db.c:   pMobIndex->count = 0;
db.c:   pMobIndex->killed = 0;
db.c:   pMobIndex->player_name = STRALLOC( name );
db.c:      pMobIndex->short_descr = STRALLOC( buf );
db.c:      pMobIndex->long_descr = STRALLOC( buf );
db.c:      pMobIndex->description = STRALLOC( "" );
db.c:      ((char*)pMobIndex->short_descr)[0] = LOWER( pMobIndex->short_descr[0] );
db.c:      ((char*)pMobIndex->long_descr)[0] = UPPER( pMobIndex->long_descr[0] );
db.c:      ((char*)pMobIndex->description)[0] = UPPER( pMobIndex->description[0] );
db.c:      pMobIndex->act = ACT_IS_NPC | ACT_PROTOTYPE;
db.c:      pMobIndex->affected_by = 0;
db.c:      pMobIndex->pShop = NULL;
db.c:      pMobIndex->rShop = NULL;
db.c:      pMobIndex->spec_fun = NULL;
db.c:      pMobIndex->spec_2 = NULL;
db.c:      pMobIndex->mudprogs = NULL;
db.c:      pMobIndex->progtypes = 0;
db.c:      pMobIndex->alignment = 0;
db.c:      pMobIndex->level = 1;
db.c:      pMobIndex->mobthac0 = 0;
db.c:      pMobIndex->ac = 0;
db.c:      pMobIndex->hitnodice = 0;
db.c:      pMobIndex->hitsizedice = 0;
db.c:      pMobIndex->hitplus = 0;
db.c:      pMobIndex->damnodice = 0;
db.c:      pMobIndex->damsizedice = 0;
db.c:      pMobIndex->damplus = 0;
db.c:      pMobIndex->gold = 0;
db.c:      pMobIndex->exp = 0;
db.c:      pMobIndex->position = 8;
db.c:      pMobIndex->defposition = 8;
db.c:      pMobIndex->sex = 0;
db.c:      pMobIndex->perm_str = 10;
db.c:      pMobIndex->perm_dex = 10;
db.c:      pMobIndex->perm_int = 10;
db.c:      pMobIndex->perm_wis = 10;
db.c:      pMobIndex->perm_cha = 10;
db.c:      pMobIndex->perm_con = 10;
db.c:      pMobIndex->perm_lck = 10;
db.c:      pMobIndex->race = 0;
db.c:      pMobIndex->xflags = 0;
db.c:      pMobIndex->resistant = 0;
db.c:      pMobIndex->immune = 0;
db.c:      pMobIndex->susceptible = 0;
db.c:      pMobIndex->numattacks = 1;
db.c:      pMobIndex->attacks = 0;
db.c:      pMobIndex->defenses = 0;
db.c:      pMobIndex->short_descr = QUICKLINK( cMobIndex->short_descr );
db.c:      pMobIndex->long_descr = QUICKLINK( cMobIndex->long_descr );
db.c:      pMobIndex->description = QUICKLINK( cMobIndex->description );
db.c:      pMobIndex->act = cMobIndex->act | ACT_PROTOTYPE;
db.c:      pMobIndex->affected_by = cMobIndex->affected_by;
db.c:      pMobIndex->pShop = NULL;
db.c:      pMobIndex->rShop = NULL;
db.c:      pMobIndex->spec_fun = cMobIndex->spec_fun;
db.c:      pMobIndex->spec_2 = cMobIndex->spec_2;
db.c:      pMobIndex->mudprogs = NULL;
db.c:      pMobIndex->progtypes = 0;
db.c:      pMobIndex->alignment = cMobIndex->alignment;
db.c:      pMobIndex->level = cMobIndex->level;
db.c:      pMobIndex->mobthac0 = cMobIndex->mobthac0;
db.c:      pMobIndex->ac = cMobIndex->ac;
db.c:      pMobIndex->hitnodice = cMobIndex->hitnodice;
db.c:      pMobIndex->hitsizedice = cMobIndex->hitsizedice;
db.c:      pMobIndex->hitplus = cMobIndex->hitplus;
db.c:      pMobIndex->damnodice = cMobIndex->damnodice;
db.c:      pMobIndex->damsizedice = cMobIndex->damsizedice;
db.c:      pMobIndex->damplus = cMobIndex->damplus;
db.c:      pMobIndex->gold = cMobIndex->gold;
db.c:      pMobIndex->exp = cMobIndex->exp;
db.c:      pMobIndex->position = cMobIndex->position;
db.c:      pMobIndex->defposition = cMobIndex->defposition;
db.c:      pMobIndex->sex = cMobIndex->sex;
db.c:      pMobIndex->perm_str = cMobIndex->perm_str;
db.c:      pMobIndex->perm_dex = cMobIndex->perm_dex;
db.c:      pMobIndex->perm_int = cMobIndex->perm_int;
db.c:      pMobIndex->perm_wis = cMobIndex->perm_wis;
db.c:      pMobIndex->perm_cha = cMobIndex->perm_cha;
db.c:      pMobIndex->perm_con = cMobIndex->perm_con;
db.c:      pMobIndex->perm_lck = cMobIndex->perm_lck;
db.c:      pMobIndex->race = cMobIndex->race;
db.c:      pMobIndex->xflags = cMobIndex->xflags;
db.c:      pMobIndex->resistant = cMobIndex->resistant;
db.c:      pMobIndex->immune = cMobIndex->immune;
db.c:      pMobIndex->susceptible = cMobIndex->susceptible;
db.c:      pMobIndex->numattacks = cMobIndex->numattacks;
db.c:      pMobIndex->attacks = cMobIndex->attacks;
db.c:      pMobIndex->defenses = cMobIndex->defenses;
db.c:   pMobIndex->next = mob_index_hash[iHash];
db.c: * to_room and vnum.						-Thoric
db.c:   pexit->vdir = door;
db.c:   pexit->rvnum = pRoomIndex->vnum;
db.c:   pexit->to_room = to_room;
db.c:   pexit->distance = 1;
db.c:      pexit->vnum = to_room->vnum;
db.c:      texit = get_exit_to( to_room, rev_dir[door], pRoomIndex->vnum );
db.c:         texit->rexit = pexit;
db.c:         pexit->rexit = texit;
db.c:   for( texit = pRoomIndex->first_exit; texit; texit = texit->next )
db.c:      if( door < texit->vdir )
db.c:   if( !pRoomIndex->first_exit )
db.c:      pRoomIndex->first_exit = pexit;
db.c:       * keep exits in incremental order - insert exit into list 
db.c:         if( !texit->prev )
db.c:            pRoomIndex->first_exit = pexit;
db.c:            texit->prev->next = pexit;
db.c:         pexit->prev = texit->prev;
db.c:         pexit->next = texit;
db.c:         texit->prev = pexit;
db.c:      pRoomIndex->last_exit->next = pexit;
db.c:   pexit->next = NULL;
db.c:   pexit->prev = pRoomIndex->last_exit;
db.c:   pRoomIndex->last_exit = pexit;
db.c:   for( rnum = tarea->low_r_vnum; rnum <= tarea->hi_r_vnum; rnum++ )
db.c:      for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c:         pexit->rvnum = pRoomIndex->vnum;
db.c:         if( pexit->vnum <= 0 )
db.c:            pexit->to_room = NULL;
db.c:            pexit->to_room = get_room_index( pexit->vnum );
db.c:         SET_BIT( pRoomIndex->room_flags, ROOM_NO_MOB );
db.c:   for( rnum = tarea->low_r_vnum; rnum <= tarea->hi_r_vnum; rnum++ )
db.c:      for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c:         if( pexit->to_room && !pexit->rexit )
db.c:            rev_exit = get_exit_to( pexit->to_room, rev_dir[pexit->vdir], pRoomIndex->vnum );
db.c:               pexit->rexit = rev_exit;
db.c:               rev_exit->rexit = pexit;
db.c:   fprintf( stderr, "%-14s: Rooms: %5d - %-5d Objs: %5d - %-5d Mobs: %5d - %d\n",
db.c:            tarea->filename,
db.c:            tarea->low_r_vnum, tarea->hi_r_vnum, tarea->low_o_vnum, tarea->hi_o_vnum, tarea->low_m_vnum, tarea->hi_m_vnum );
db.c:   if( !tarea->author )
db.c:      tarea->author = STRALLOC( "" );
db.c:   SET_BIT( tarea->status, AREA_LOADED );
db.c:               if( !ed->keyword )
db.c:                  STRFREE( ed->description );
db.c:               if( !ed->description )
db.c:                  ed->description = STRALLOC( "" );
db.c:            KEY( "ExDescKey", ed->keyword, fread_string( fp ) );
db.c:            KEY( "ExDesc", ed->description, fread_string( fp ) );
db.c:      paf->type = fread_number( fp );
db.c:         paf->type = sn;
db.c:   paf->duration = fread_number( fp );
db.c:   paf->location = fread_number( fp );
db.c:   paf->bitvector = fread_number( fp );
db.c:   if( paf->location == APPLY_WEAPONSPELL
db.c:       || paf->location == APPLY_WEARSPELL
db.c:       || paf->location == APPLY_STRIPSN || paf->location == APPLY_REMOVESPELL )
db.c:      paf->modifier = slot_lookup( pafmod );
db.c:      paf->modifier = pafmod;
db.c:               if( !pexit->description )
db.c:                  pexit->description = STRALLOC( "" );
db.c:               if( !pexit->keyword )
db.c:                  pexit->keyword = STRALLOC( "" );
db.c:            KEY( "Desc", pexit->description, fread_string( fp ) );
db.c:            KEY( "Distance", pexit->distance, fread_number( fp ) );
db.c:                  bug( "%s: vnum %d has bad door number %d.", __FUNCTION__, pRoomIndex->vnum, door );
db.c:                     SET_BIT( pexit->exit_info, 1 << value );
db.c:            KEY( "Key", pexit->key, fread_number( fp ) );
db.c:            KEY( "Keywords", pexit->keyword, fread_string( fp ) );
db.c:            KEY( "ToRoom", pexit->vnum, fread_number( fp ) );
db.c:               mprg->next = prog_target->mudprogs;
db.c:               prog_target->mudprogs = mprg;
db.c:                     mprg->arglist = fread_string( progfile );
db.c:                     mprg->fileprog = true;
db.c:                     switch ( mprg->type )
db.c:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c:               mprg->arglist = fread_string( fp );
db.c:               mprg->fileprog = false;
db.c:               switch ( mprg->type )
db.c:                     rprog_file_read( prog_target, mprg->arglist );
db.c:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c:               SET_BIT( prog_target->progtypes, mprg->type );
db.c:               if( !pRoomIndex->description )
db.c:                  pRoomIndex->description = STRALLOC( "" );
db.c:                  int iHash = pRoomIndex->vnum % MAX_KEY_HASH;
db.c:                  pRoomIndex->next = room_index_hash[iHash];
db.c:                  LINK( pRoomIndex, tarea->first_room, tarea->last_room, next_aroom, prev_aroom );
db.c:                  LINK( ed, pRoomIndex->first_extradesc, pRoomIndex->last_extradesc, next, prev );
db.c:               mprg->next = pRoomIndex->mudprogs;
db.c:               pRoomIndex->mudprogs = mprg;
db.c:                  LINK( af, pRoomIndex->first_permaffect, pRoomIndex->last_permaffect, next, prev );
db.c:            KEY( "Desc", pRoomIndex->description, fread_string( fp ) );
db.c:                     SET_BIT( pRoomIndex->room_flags, 1 << value );
db.c:            KEY( "Name", pRoomIndex->name, fread_string( fp ) );
db.c:                  bug( "%s: Room #%d has bad sector type.", __FUNCTION__, pRoomIndex->vnum );
db.c:               pRoomIndex->sector_type = sector;
db.c:               pRoomIndex->tele_delay = x1;
db.c:               pRoomIndex->tele_vnum = x2;
db.c:               pRoomIndex->tunnel = x3;
db.c:               pRoomIndex->vnum = vnum;
db.c:               pRoomIndex->area = tarea;
db.c:                  if( !tarea->low_r_vnum )
db.c:                     tarea->low_r_vnum = vnum;
db.c:                  if( vnum > tarea->hi_r_vnum )
db.c:                     tarea->hi_r_vnum = vnum;
db.c:               mprg->next = prog_target->mudprogs;
db.c:               prog_target->mudprogs = mprg;
db.c:                     mprg->arglist = fread_string( progfile );
db.c:                     mprg->fileprog = true;
db.c:                     switch ( mprg->type )
db.c:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c:               mprg->arglist = fread_string( fp );
db.c:               mprg->fileprog = false;
db.c:               switch ( mprg->type )
db.c:                     oprog_file_read( prog_target, mprg->arglist );
db.c:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c:               SET_BIT( prog_target->progtypes, 1 << mprg->type );
db.c:               if( !pObjIndex->description )
db.c:                  pObjIndex->description = STRALLOC( "" );
db.c:               if( !pObjIndex->action_desc )
db.c:                  pObjIndex->action_desc = STRALLOC( "" );
db.c:                  int iHash = pObjIndex->vnum % MAX_KEY_HASH;
db.c:                  pObjIndex->next = obj_index_hash[iHash];
db.c:                  LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c:               mprg->next = pObjIndex->mudprogs;
db.c:               pObjIndex->mudprogs = mprg;
db.c:            KEY( "Action", pObjIndex->action_desc, fread_string( fp ) );
db.c:                  LINK( af, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c:                     SET_BIT( pObjIndex->extra_flags, 1 << value );
db.c:            KEY( "Keywords", pObjIndex->name, fread_string( fp ) );
db.c:            KEY( "Long", pObjIndex->description, fread_string( fp ) );
db.c:            KEY( "Short", pObjIndex->short_descr, fread_string( fp ) );
db.c:               switch ( pObjIndex->item_type )
db.c:                     pObjIndex->value[1] = skill_lookup( fread_word( fp ) );
db.c:                     pObjIndex->value[2] = skill_lookup( fread_word( fp ) );
db.c:                     pObjIndex->value[3] = skill_lookup( fread_word( fp ) );
db.c:                     pObjIndex->value[3] = skill_lookup( fread_word( fp ) );
db.c:                     pObjIndex->value[4] = skill_lookup( fread_word( fp ) );
db.c:                     pObjIndex->value[5] = skill_lookup( fread_word( fp ) );
db.c:               pObjIndex->weight = x1;
db.c:               pObjIndex->cost = x2;
db.c:               pObjIndex->rent = x3;
db.c:               pObjIndex->level = x4;
db.c:               pObjIndex->layers = x5;
db.c:                  bug( "%s: vnum %d: Object has invalid type! Defaulting to trash.", __FUNCTION__, pObjIndex->vnum );
db.c:               pObjIndex->item_type = value;
db.c:               pObjIndex->value[0] = x1;
db.c:               pObjIndex->value[1] = x2;
db.c:               pObjIndex->value[2] = x3;
db.c:               pObjIndex->value[3] = x4;
db.c:               pObjIndex->value[4] = x5;
db.c:               pObjIndex->value[5] = x6;
db.c:               pObjIndex->vnum = vnum;
db.c:                  if( !tarea->low_o_vnum )
db.c:                     tarea->low_o_vnum = vnum;
db.c:                  if( vnum > tarea->hi_o_vnum )
db.c:                     tarea->hi_o_vnum = vnum;
db.c:                     SET_BIT( pObjIndex->wear_flags, 1 << value );
db.c:               mprg->next = prog_target->mudprogs;
db.c:               prog_target->mudprogs = mprg;
db.c:                     mprg->arglist = fread_string( progfile );
db.c:                     mprg->fileprog = true;
db.c:                     switch ( mprg->type )
db.c:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c:               mprg->arglist = fread_string( fp );
db.c:               mprg->fileprog = false;
db.c:               switch ( mprg->type )
db.c:                     mprog_file_read( prog_target, mprg->arglist );
db.c:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c:               SET_BIT( prog_target->progtypes, 1 << mprg->type );
db.c:               mprg->next = pMobIndex->mudprogs;
db.c:               pMobIndex->mudprogs = mprg;
db.c:               if( !pMobIndex->long_descr )
db.c:                  pMobIndex->long_descr = STRALLOC( "" );
db.c:               if( !pMobIndex->description )
db.c:                  pMobIndex->description = STRALLOC( "" );
db.c:                  int iHash = pMobIndex->vnum % MAX_KEY_HASH;
db.c:                  pMobIndex->next = mob_index_hash[iHash];
db.c:                     SET_BIT( pMobIndex->act, 1 << value );
db.c:                     SET_BIT( pMobIndex->affected_by, 1 << value );
db.c:                     SET_BIT( pMobIndex->attacks, 1 << value );
db.c:               pMobIndex->perm_str = x1;
db.c:               pMobIndex->perm_int = x2;
db.c:               pMobIndex->perm_wis = x3;
db.c:               pMobIndex->perm_dex = x4;
db.c:               pMobIndex->perm_con = x5;
db.c:               pMobIndex->perm_cha = x6;
db.c:               pMobIndex->perm_lck = x7;
db.c:               pMobIndex->perm_frc = x8;
db.c:                     SET_BIT( pMobIndex->xflags, 1 << value );
db.c:                     SET_BIT( pMobIndex->defenses, 1 << value );
db.c:                       pMobIndex->vnum );
db.c:               pMobIndex->defposition = position;
db.c:            KEY( "Desc", pMobIndex->description, fread_string( fp ) );
db.c:                  bug( "%s: vnum %d: Mobile has invalid sex! Defaulting to neuter.", __FUNCTION__, pMobIndex->vnum );
db.c:               pMobIndex->sex = sex;
db.c:                     SET_BIT( pMobIndex->immune, 1 << value );
db.c:            KEY( "Keywords", pMobIndex->player_name, fread_string( fp ) );
db.c:            KEY( "Long", pMobIndex->long_descr, fread_string( fp ) );
db.c:                  bug( "%s: vnum %d: Mobile in invalid position! Defaulting to standing.", __FUNCTION__, pMobIndex->vnum );
db.c:               pMobIndex->position = position;
db.c:                  bug( "%s: vnum %d: Mob has invalid race! Defaulting to human.", __FUNCTION__, pMobIndex->vnum );
db.c:               pMobIndex->race = race;
db.c:               rShop->keeper = pMobIndex->vnum;
db.c:                  rShop->fix_type[iFix] = fread_number( fp );
db.c:               rShop->profit_fix = fread_number( fp );
db.c:               rShop->shop_type = fread_number( fp );
db.c:               rShop->open_hour = fread_number( fp );
db.c:               rShop->close_hour = fread_number( fp );
db.c:               pMobIndex->rShop = rShop;
db.c:                     SET_BIT( pMobIndex->resistant, 1 << value );
db.c:               pMobIndex->saving_poison_death = x1;
db.c:               pMobIndex->saving_wand = x2;
db.c:               pMobIndex->saving_para_petri = x3;
db.c:               pMobIndex->saving_breath = x4;
db.c:               pMobIndex->saving_spell_staff = x5;
db.c:            KEY( "Short", pMobIndex->short_descr, fread_string( fp ) );
db.c:               pShop->keeper = pMobIndex->vnum;
db.c:                  pShop->buy_type[iTrade] = fread_number( fp );
db.c:               pShop->profit_buy = fread_number( fp );
db.c:               pShop->profit_sell = fread_number( fp );
db.c:               pShop->profit_buy = URANGE( pShop->profit_sell + 5, pShop->profit_buy, 1000 );
db.c:               pShop->profit_sell = URANGE( 0, pShop->profit_sell, pShop->profit_buy - 5 );
db.c:               pShop->open_hour = fread_number( fp );
db.c:               pShop->close_hour = fread_number( fp );
db.c:               pMobIndex->pShop = pShop;
db.c:                     SET_BIT( pMobIndex->speaks, 1 << value );
db.c:               if( !pMobIndex->speaks )
db.c:                  pMobIndex->speaks = LANG_COMMON;
db.c:                     SET_BIT( pMobIndex->speaking, 1 << value );
db.c:               if( !pMobIndex->speaking )
db.c:                  pMobIndex->speaking = LANG_COMMON;
db.c:               if( !( pMobIndex->spec_fun = spec_lookup( temp ) ) )
db.c:                  bug( "%s: Specfun: vnum %d, no spec_fun called %s.", __FUNCTION__, pMobIndex->vnum, temp );
db.c:                  pMobIndex->spec_funname = NULL;
db.c:                  pMobIndex->spec_funname = STRALLOC( temp );
db.c:               if( !( pMobIndex->spec_2 = spec_lookup( temp ) ) )
db.c:                  bug( "%s: Specfun: vnum %d, no spec_fun called %s.", __FUNCTION__, pMobIndex->vnum, temp );
db.c:                  pMobIndex->spec_funname2 = NULL;
db.c:                  pMobIndex->spec_funname2 = STRALLOC( temp );
db.c:               pMobIndex->alignment = x1;
db.c:               pMobIndex->level = x2;
db.c:               pMobIndex->mobthac0 = x3;
db.c:               pMobIndex->ac = x4;
db.c:               pMobIndex->gold = x5;
db.c:               pMobIndex->exp = x6;
db.c:               pMobIndex->hitnodice = x1;
db.c:               pMobIndex->hitsizedice = x2;
db.c:               pMobIndex->hitplus = x3;
db.c:               pMobIndex->damnodice = x1;
db.c:               pMobIndex->damsizedice = x2;
db.c:               pMobIndex->damplus = x3;
db.c:               pMobIndex->height = x1;
db.c:               pMobIndex->weight = x2;
db.c:               pMobIndex->numattacks = x3;
db.c:               pMobIndex->hitroll = x4;
db.c:               pMobIndex->damroll = x5;
db.c:                     SET_BIT( pMobIndex->susceptible, 1 << value );
db.c:                     SET_BIT( pMobIndex->vip_flags, 1 << value );
db.c:               pMobIndex->vnum = vnum;
db.c:                  if( !tarea->low_m_vnum )
db.c:                     tarea->low_m_vnum = vnum;
db.c:                  if( vnum > tarea->hi_m_vnum )
db.c:                     tarea->hi_m_vnum = vnum;
db.c:               tarea->age = tarea->reset_frequency;
db.c:            KEY( "Author", tarea->author, fread_string( fp ) );
db.c:               tarea->high_economy = fread_number( fp );
db.c:               tarea->low_economy = fread_number( fp );
db.c:                     SET_BIT( tarea->flags, 1 << value );
db.c:            KEY( "Name", tarea->name, fread_string_nohash( fp ) );
db.c:               tarea->low_soft_range = x1;
db.c:               tarea->hi_soft_range = x2;
db.c:               tarea->low_hard_range = x3;
db.c:               tarea->hi_hard_range = x4;
db.c:            KEY( "ResetMsg", tarea->resetmsg, fread_string_nohash( fp ) );
db.c:            KEY( "ResetFreq", tarea->reset_frequency, fread_number( fp ) );
db.c:            KEY( "Version", tarea->version, fread_number( fp ) );
db.c:   pArea->first_room = pArea->last_room = NULL;
db.c:   pArea->name = NULL;
db.c:   pArea->author = NULL;
db.c:   pArea->filename = str_dup( strArea );
db.c:   pArea->age = 15;
db.c:   pArea->reset_frequency = 15;
db.c:   pArea->nplayer = 0;
db.c:   pArea->low_r_vnum = 0;
db.c:   pArea->low_o_vnum = 0;
db.c:   pArea->low_m_vnum = 0;
db.c:   pArea->hi_r_vnum = 0;
db.c:   pArea->hi_o_vnum = 0;
db.c:   pArea->hi_m_vnum = 0;
db.c:   pArea->low_soft_range = 0;
db.c:   pArea->hi_soft_range = MAX_LEVEL;
db.c:   pArea->low_hard_range = 0;
db.c:   pArea->hi_hard_range = MAX_LEVEL;
db.c:   pArea->version = 1;
db.c:   // New FUSS area format support -- Samson 7/5/07
db.c:         DISPOSE( tarea->name );
db.c:         tarea->name = fread_string_nohash( fpArea );
db.c: * them out of the area files. -- Altrag */
db.c:      if( dentry->d_name[0] != '.' )
db.c:         sprintf( buf, "%s%s", GOD_DIR, dentry->d_name );
db.c:                  sprintf( buf, "%s: God file with level %d < %d", dentry->d_name, low, LEVEL_AVATAR );
db.c:            sprintf( buf, "%s%s.are", BUILD_DIR, dentry->d_name );
db.c:               sprintf( buf, "Make_buildlist: %s.are: no #AREA found.", dentry->d_name );
db.c:            sprintf( buf, "%s.are", dentry->d_name );
db.c:            pArea->author = STRALLOC( dentry->d_name );
db.c:            pArea->filename = str_dup( buf );
db.c:            pArea->name = fread_string_nohash( fp );
db.c:            sprintf( buf, "{PROTO} %s's area in progress", dentry->d_name );
db.c:            pArea->name = str_dup( buf );
db.c:            pArea->low_r_vnum = rlow;
db.c:            pArea->hi_r_vnum = rhi;
db.c:            pArea->low_m_vnum = mlow;
db.c:            pArea->hi_m_vnum = mhi;
db.c:            pArea->low_o_vnum = olow;
db.c:            pArea->hi_o_vnum = ohi;
db.c:            pArea->low_soft_range = -1;
db.c:            pArea->hi_soft_range = -1;
db.c:            pArea->low_hard_range = -1;
db.c:            pArea->hi_hard_range = -1;
db.c:            pArea->first_room = pArea->last_room = NULL;
db.c:            SET_BIT( pArea->flags, AFLAG_PROTOTYPE );
db.c:            fprintf( stderr, "%-14s: Rooms: %5d - %-5d Objs: %5d - %-5d "
db.c:                     "Mobs: %5d - %-5d\n",
db.c:                     pArea->filename,
db.c:                     pArea->low_r_vnum, pArea->hi_r_vnum,
db.c:                     pArea->low_o_vnum, pArea->hi_o_vnum, pArea->low_m_vnum, pArea->hi_m_vnum );
db.c: *      - 4/27/97, Fireblade
db.c:   for( temp_area = first_area_name; temp_area; temp_area = temp_area->next_sort_name )
db.c:      if( strcmp( pArea->name, temp_area->name ) < 0 )
db.c: * Sort by room vnums					-Altrag & Thoric
db.c:   pArea->next_sort = NULL;
db.c:   pArea->prev_sort = NULL;
db.c:      pArea->prev_sort = NULL;
db.c:      pArea->next_sort = NULL;
db.c:      for( area = first_sort; area; area = area->next_sort )
db.c:         if( pArea->low_r_vnum < area->low_r_vnum )
db.c:            if( !area->prev_sort )
db.c:               area->prev_sort->next_sort = pArea;
db.c:            pArea->prev_sort = area->prev_sort;
db.c:            pArea->next_sort = area;
db.c:            area->prev_sort = pArea;
db.c:      pArea->prev_sort = last_sort;
db.c:      pArea->next_sort = NULL;
db.c:      last_sort->next_sort = pArea;
db.c: * Display vnums currently assigned to areas		-Altrag & Thoric
db.c:   for( pArea = first_sort; pArea; pArea = pArea->next_sort )
db.c:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c:      if( pArea->low_r_vnum < low )
db.c:      if( pArea->hi_r_vnum > high )
db.c:      if( IS_SET( pArea->status, AREA_LOADED ) )
db.c:      pager_printf( ch, "%-15s| Rooms: %5d - %-5d"
db.c:                    " Objs: %5d - %-5d Mobs: %5d - %-5d%s\r\n",
db.c:                    ( pArea->filename ? pArea->filename : "(invalid)" ),
db.c:                    pArea->low_r_vnum, pArea->hi_r_vnum,
db.c:                    pArea->low_o_vnum, pArea->hi_o_vnum,
db.c:                    pArea->low_m_vnum, pArea->hi_m_vnum, IS_SET( pArea->status, AREA_LOADED ) ? loadst : notloadst );
db.c:   sys->time_of_max = NULL;
db.c:            KEY( "Build", sys->build_level, fread_number( fp ) );
db.c:            KEY( "Damplrvsplr", sys->dam_plr_vs_plr, fread_number( fp ) );
db.c:            KEY( "Damplrvsmob", sys->dam_plr_vs_mob, fread_number( fp ) );
db.c:            KEY( "Dammobvsplr", sys->dam_mob_vs_plr, fread_number( fp ) );
db.c:            KEY( "Dammobvsmob", sys->dam_mob_vs_mob, fread_number( fp ) );
db.c:               if( !sys->time_of_max )
db.c:                  sys->time_of_max = str_dup( "(not recorded)" );
db.c:            KEY( "Forcepc", sys->level_forcepc, fread_number( fp ) );
db.c:            KEY( "Guildoverseer", sys->guild_overseer, fread_string_nohash( fp ) );
db.c:            KEY( "Guildadvisor", sys->guild_advisor, fread_string_nohash( fp ) );
db.c:            KEY( "Highplayers", sys->alltimemax, fread_number( fp ) );
db.c:            KEY( "Highplayertime", sys->time_of_max, fread_string_nohash( fp ) );
db.c:            KEY( "Log", sys->log_level, fread_number( fp ) );
db.c:            KEY( "Msetplayer", sys->level_mset_player, fread_number( fp ) );
db.c:            KEY( "Muse", sys->muse_level, fread_number( fp ) );
db.c:            KEY( "Nameresolving", sys->NO_NAME_RESOLVING, fread_number( fp ) );
db.c:            KEY( "Overridepriv", sys->level_override_private, fread_number( fp ) );
db.c:            KEY( "Protoflag", sys->level_modify_proto, fread_number( fp ) );
db.c:            KEY( "Readallmail", sys->read_all_mail, fread_number( fp ) );
db.c:            KEY( "Readmailfree", sys->read_mail_free, fread_number( fp ) );
db.c:            KEY( "Stunplrvsplr", sys->stun_plr_vs_plr, fread_number( fp ) );
db.c:            KEY( "Stunregular", sys->stun_regular, fread_number( fp ) );
db.c:            KEY( "Saveflags", sys->save_flags, fread_number( fp ) );
db.c:            KEY( "Savefreq", sys->save_frequency, fread_number( fp ) );
db.c:            KEY( "Takeothersmail", sys->take_others_mail, fread_number( fp ) );
db.c:            KEY( "Think", sys->think_level, fread_number( fp ) );
db.c:            KEY( "Waitforauth", sys->WAIT_FOR_AUTH, fread_number( fp ) );
db.c:            KEY( "Writemailfree", sys->write_mail_free, fread_number( fp ) );
db.c:         bug( "Load_banlist: no -1 found." );
db.c:      if( number == -1 )
db.c:      pban->level = number;
db.c:      pban->name = fread_string_nohash( fp );
db.c:         pban->ban_time = fread_string_nohash( fp );
db.c:         pban->ban_time = str_dup( "(unrecorded)" );
db.c:/* Check to make sure range of vnums is free - Scryn 2/27/96 */
db.c:   for( pArea = first_asort; pArea; pArea = pArea->next_sort )
db.c:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c:         if( low_range < pArea->low_r_vnum && pArea->low_r_vnum < high_range )
db.c:         if( low_range < pArea->hi_r_vnum && pArea->hi_r_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_r_vnum ) && ( low_range <= pArea->hi_r_vnum ) )
db.c:         if( ( high_range <= pArea->hi_r_vnum ) && ( high_range >= pArea->low_r_vnum ) )
db.c:         if( low_range < pArea->low_m_vnum && pArea->low_m_vnum < high_range )
db.c:         if( low_range < pArea->hi_m_vnum && pArea->hi_m_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_m_vnum ) && ( low_range <= pArea->hi_m_vnum ) )
db.c:         if( ( high_range <= pArea->hi_m_vnum ) && ( high_range >= pArea->low_m_vnum ) )
db.c:         if( low_range < pArea->low_o_vnum && pArea->low_o_vnum < high_range )
db.c:         if( low_range < pArea->hi_o_vnum && pArea->hi_o_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_o_vnum ) && ( low_range <= pArea->hi_o_vnum ) )
db.c:         if( ( high_range <= pArea->hi_o_vnum ) && ( high_range >= pArea->low_o_vnum ) )
db.c:         sprintf( buf, "Conflict:%-15s| ", ( pArea->filename ? pArea->filename : "(invalid)" ) );
db.c:            sprintf( buf2, "Rooms: %5d - %-5d\r\n", pArea->low_r_vnum, pArea->hi_r_vnum );
db.c:            sprintf( buf2, "Mobs: %5d - %-5d\r\n", pArea->low_m_vnum, pArea->hi_m_vnum );
db.c:            sprintf( buf2, "Objects: %5d - %-5d\r\n", pArea->low_o_vnum, pArea->hi_o_vnum );
db.c:   for( pArea = first_bsort; pArea; pArea = pArea->next_sort )
db.c:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c:         if( low_range < pArea->low_r_vnum && pArea->low_r_vnum < high_range )
db.c:         if( low_range < pArea->hi_r_vnum && pArea->hi_r_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_r_vnum ) && ( low_range <= pArea->hi_r_vnum ) )
db.c:         if( ( high_range <= pArea->hi_r_vnum ) && ( high_range >= pArea->low_r_vnum ) )
db.c:         if( low_range < pArea->low_m_vnum && pArea->low_m_vnum < high_range )
db.c:         if( low_range < pArea->hi_m_vnum && pArea->hi_m_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_m_vnum ) && ( low_range <= pArea->hi_m_vnum ) )
db.c:         if( ( high_range <= pArea->hi_m_vnum ) && ( high_range >= pArea->low_m_vnum ) )
db.c:         if( low_range < pArea->low_o_vnum && pArea->low_o_vnum < high_range )
db.c:         if( low_range < pArea->hi_o_vnum && pArea->hi_o_vnum < high_range )
db.c:         if( ( low_range >= pArea->low_o_vnum ) && ( low_range <= pArea->hi_o_vnum ) )
db.c:         if( ( high_range <= pArea->hi_o_vnum ) && ( high_range >= pArea->low_o_vnum ) )
db.c:         sprintf( buf, "Conflict:%-15s| ", ( pArea->filename ? pArea->filename : "(invalid)" ) );
db.c:            sprintf( buf2, "Rooms: %5d - %-5d\r\n", pArea->low_r_vnum, pArea->hi_r_vnum );
db.c:            sprintf( buf2, "Mobs: %5d - %-5d\r\n", pArea->low_m_vnum, pArea->hi_m_vnum );
db.c:            sprintf( buf2, "Objects: %5d - %-5d\r\n", pArea->low_o_vnum, pArea->hi_o_vnum );
db.c:    for ( pArea = first_asort; pArea; pArea = pArea->next_sort )
db.c:	if ( IS_SET( pArea->status, AREA_DELETED ) )
db.c:	  if((pArea->low_r_vnum >= low_range) 
db.c:	  && (pArea->hi_r_vnum <= high_range))
db.c:	  if((pArea->low_m_vnum >= low_range) 
db.c:	  && (pArea->hi_m_vnum <= high_range))
db.c:	  if((pArea->low_o_vnum >= low_range) 
db.c:	  && (pArea->hi_o_vnum <= high_range))
db.c:	  ch_printf(ch, "Conflict:%-15s| Rooms: %5d - %-5d"
db.c:		     " Objs: %5d - %-5d Mobs: %5d - %-5d\r\n",
db.c:		(pArea->filename ? pArea->filename : "(invalid)"),
db.c:		pArea->low_r_vnum, pArea->hi_r_vnum,
db.c:		pArea->low_o_vnum, pArea->hi_o_vnum,
db.c:		pArea->low_m_vnum, pArea->hi_m_vnum );
db.c:    for ( pArea = first_bsort; pArea; pArea = pArea->next_sort )
db.c:	if ( IS_SET( pArea->status, AREA_DELETED ) )
db.c:	  if((pArea->low_r_vnum >= low_range) 
db.c:	  && (pArea->hi_r_vnum <= high_range))
db.c:	  if((pArea->low_m_vnum >= low_range) 
db.c:	  && (pArea->hi_m_vnum <= high_range))
db.c:	  if((pArea->low_o_vnum >= low_range) 
db.c:	  && (pArea->hi_o_vnum <= high_range))
db.c:	  sprintf(ch, "Conflict:%-15s| Rooms: %5d - %-5d"
db.c:		     " Objs: %5d - %-5d Mobs: %5d - %-5d\r\n",
db.c:		(pArea->filename ? pArea->filename : "(invalid)"),
db.c:		pArea->low_r_vnum, pArea->hi_r_vnum,
db.c:		pArea->low_o_vnum, pArea->hi_o_vnum,
db.c:		pArea->low_m_vnum, pArea->hi_m_vnum );
db.c: * -- Furey
db.c:  if( n != 0 && --n != 0 )
db.c:      while( --n != 0 );
db.c:	*d = '\0';  /* NUL-terminate dst */
db.c:  return ( s - src - 1 ); /* count does not include NUL */
db.c:  while( n-- != 0 && *d != '\0' )
db.c:  dlen = d - dst;
db.c:  n = siz - dlen;
db.c:	  n--;
db.c:  return ( dlen + ( s - src ) );   /* count does not include NUL */
db.c:        if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c~:*--------------------------------------------------------------------------*
db.c~:* -------------------------------------------------------------------------*
db.c~:*--------------------------------------------------------------------------*
db.c~:* ------------------------------------------------------------------------ *
db.c~:* ------------------------------------------------------------------------ *
db.c~: * Semi-locals.
db.c~:   boot_log( "---------------------[ Boot Log ]--------------------" );
db.c~:      if( !gsn_first_spell && skill_table[x]->type == SKILL_SPELL )
db.c~:      else if( !gsn_first_skill && skill_table[x]->type == SKILL_SKILL )
db.c~:      else if( !gsn_first_weapon && skill_table[x]->type == SKILL_WEAPON )
db.c~:      else if( !gsn_first_tongue && skill_table[x]->type == SKILL_TONGUE )
db.c~:   auction->item = NULL;
db.c~:      lhour = ( current_time - 650336715 ) / ( PULSE_TICK / PULSE_PER_SECOND );
db.c~:   log_string( "Loading DNS cache..." ); /* Samson 1-30-02 */
db.c~:      ASSIGN_GSN( gsn_vibro_blades, "vibro-blades" );
db.c~:      ASSIGN_GSN( gsn_chadra_fan, "chadra-fan" );
db.c~:            bug( "%s: EOF encountered reading area list - no $ found at end of file.", __FUNCTION__ );
db.c~:   pArea->version = aversion;
db.c~:   pArea->first_room = pArea->last_room = NULL;
db.c~:   pArea->name = fread_string_nohash( fp );
db.c~:   pArea->author = STRALLOC( "unknown" );
db.c~:   pArea->filename = str_dup( strArea );
db.c~:   pArea->age = 15;
db.c~:   pArea->nplayer = 0;
db.c~:   pArea->low_r_vnum = 0;
db.c~:   pArea->low_o_vnum = 0;
db.c~:   pArea->low_m_vnum = 0;
db.c~:   pArea->hi_r_vnum = 0;
db.c~:   pArea->hi_o_vnum = 0;
db.c~:   pArea->hi_m_vnum = 0;
db.c~:   pArea->low_soft_range = 0;
db.c~:   pArea->hi_soft_range = MAX_LEVEL;
db.c~:   pArea->low_hard_range = 0;
db.c~:   pArea->hi_hard_range = MAX_LEVEL;
db.c~: * the #AREA here.  --Shaddai
db.c~:   tarea->version = fread_number( fp );
db.c~:   if( tarea->author )
db.c~:      STRFREE( tarea->author );
db.c~:   tarea->author = fread_string( fp );
db.c~:   tarea->high_economy = fread_number( fp );
db.c~:   tarea->low_economy = fread_number( fp );
db.c~:   if( tarea->resetmsg )
db.c~:      DISPOSE( tarea->resetmsg );
db.c~:   tarea->resetmsg = fread_string_nohash( fp );
db.c~:   tarea->flags = x1;
db.c~:   tarea->reset_frequency = x2;
db.c~:      tarea->age = x2;
db.c~: * Page is insert-sorted by keyword.			-Thoric
db.c~:   for( tHelp = first_help; tHelp; tHelp = tHelp->next )
db.c~:      if( pHelp->level == tHelp->level && strcmp( pHelp->keyword, tHelp->keyword ) == 0 )
db.c~:         bug( "add_help: duplicate: %s.  Deleting.", pHelp->keyword );
db.c~:         STRFREE( pHelp->text );
db.c~:         STRFREE( pHelp->keyword );
db.c~:         if( ( match = strcmp( pHelp->keyword[0] == '\'' ? pHelp->keyword + 1 : pHelp->keyword,
db.c~:                               tHelp->keyword[0] == '\'' ? tHelp->keyword + 1 : tHelp->keyword ) ) < 0
db.c~:             || ( match == 0 && pHelp->level > tHelp->level ) )
db.c~:         if( !tHelp->prev )
db.c~:            tHelp->prev->next = pHelp;
db.c~:         pHelp->prev = tHelp->prev;
db.c~:         pHelp->next = tHelp;
db.c~:         tHelp->prev = pHelp;
db.c~:      pHelp->level = fread_number( fp );
db.c~:      pHelp->keyword = fread_string( fp );
db.c~:      if( pHelp->keyword[0] == '$' )
db.c~:         STRFREE( pHelp->keyword );
db.c~:      pHelp->text = fread_string( fp );
db.c~:      if( pHelp->keyword[0] == '\0' )
db.c~:         STRFREE( pHelp->text );
db.c~:         STRFREE( pHelp->keyword );
db.c~:      if( !str_cmp( pHelp->keyword, "greeting" ) )
db.c~:         help_greeting = pHelp->text;
db.c~: * Add a character to the list of all characters		-Thoric
db.c~:      pMobIndex->vnum = vnum;
db.c~:         if( !tarea->low_m_vnum )
db.c~:            tarea->low_m_vnum = vnum;
db.c~:         if( vnum > tarea->hi_m_vnum )
db.c~:            tarea->hi_m_vnum = vnum;
db.c~:      pMobIndex->player_name = fread_string( fp );
db.c~:      pMobIndex->short_descr = fread_string( fp );
db.c~:      pMobIndex->long_descr = fread_string( fp );
db.c~:      pMobIndex->description = fread_string( fp );
db.c~:      ((char*)pMobIndex->long_descr)[0] = UPPER( pMobIndex->long_descr[0] );
db.c~:      ((char*)pMobIndex->description)[0] = UPPER( pMobIndex->description[0] );
db.c~:      pMobIndex->act = fread_number( fp ) | ACT_IS_NPC;
db.c~:      pMobIndex->affected_by = fread_number( fp );
db.c~:      pMobIndex->pShop = NULL;
db.c~:      pMobIndex->rShop = NULL;
db.c~:      pMobIndex->alignment = fread_number( fp );
db.c~:      pMobIndex->level = fread_number( fp );
db.c~:      pMobIndex->mobthac0 = fread_number( fp );
db.c~:      pMobIndex->ac = fread_number( fp );
db.c~:      pMobIndex->hitnodice = fread_number( fp );
db.c~:      pMobIndex->hitsizedice = fread_number( fp );
db.c~:      pMobIndex->hitplus = fread_number( fp );
db.c~:      pMobIndex->damnodice = fread_number( fp );
db.c~:      pMobIndex->damsizedice = fread_number( fp );
db.c~:      pMobIndex->damplus = fread_number( fp );
db.c~:      pMobIndex->gold = fread_number( fp );
db.c~:      pMobIndex->exp = fread_number( fp );
db.c~:      pMobIndex->position = fread_number( fp );
db.c~:      pMobIndex->defposition = fread_number( fp );
db.c~:      pMobIndex->sex = fread_number( fp );
db.c~:      if( letter == 'C' || letter == 'Z' )   /* Realms complex mob    -Thoric  */
db.c~:         pMobIndex->perm_str = fread_number( fp );
db.c~:         pMobIndex->perm_int = fread_number( fp );
db.c~:         pMobIndex->perm_wis = fread_number( fp );
db.c~:         pMobIndex->perm_dex = fread_number( fp );
db.c~:         pMobIndex->perm_con = fread_number( fp );
db.c~:         pMobIndex->perm_cha = fread_number( fp );
db.c~:         pMobIndex->perm_lck = fread_number( fp );
db.c~:         pMobIndex->saving_poison_death = fread_number( fp );
db.c~:         pMobIndex->saving_wand = fread_number( fp );
db.c~:         pMobIndex->saving_para_petri = fread_number( fp );
db.c~:         pMobIndex->saving_breath = fread_number( fp );
db.c~:         pMobIndex->saving_spell_staff = fread_number( fp );
db.c~:         pMobIndex->race = x1;
db.c~:         pMobIndex->height = x3;
db.c~:         pMobIndex->weight = x4;
db.c~:         pMobIndex->speaks = x5;
db.c~:         pMobIndex->speaking = x6;
db.c~:         pMobIndex->numattacks = x7;
db.c~:         if( !pMobIndex->speaks )
db.c~:            pMobIndex->speaks = race_table[pMobIndex->race].language | LANG_COMMON;
db.c~:         if( !pMobIndex->speaking )
db.c~:            pMobIndex->speaking = race_table[pMobIndex->race].language;
db.c~:         pMobIndex->hitroll = x1;
db.c~:         pMobIndex->damroll = x2;
db.c~:         pMobIndex->xflags = x3;
db.c~:         pMobIndex->resistant = x4;
db.c~:         pMobIndex->immune = x5;
db.c~:         pMobIndex->susceptible = x6;
db.c~:         pMobIndex->attacks = x7;
db.c~:         pMobIndex->defenses = x8;
db.c~:         pMobIndex->perm_str = 10;
db.c~:         pMobIndex->perm_dex = 10;
db.c~:         pMobIndex->perm_int = 10;
db.c~:         pMobIndex->perm_wis = 10;
db.c~:         pMobIndex->perm_cha = 10;
db.c~:         pMobIndex->perm_con = 10;
db.c~:         pMobIndex->perm_lck = 10;
db.c~:         pMobIndex->race = 0;
db.c~:         pMobIndex->xflags = 0;
db.c~:         pMobIndex->resistant = 0;
db.c~:         pMobIndex->immune = 0;
db.c~:         pMobIndex->susceptible = 0;
db.c~:         pMobIndex->numattacks = 0;
db.c~:         pMobIndex->attacks = 0;
db.c~:         pMobIndex->defenses = 0;
db.c~:         pMobIndex->vip_flags = x1;
db.c~:         pMobIndex->next = mob_index_hash[iHash];
db.c~:      pObjIndex->vnum = vnum;
db.c~:         if( !tarea->low_o_vnum )
db.c~:            tarea->low_o_vnum = vnum;
db.c~:         if( vnum > tarea->hi_o_vnum )
db.c~:            tarea->hi_o_vnum = vnum;
db.c~:      pObjIndex->name = fread_string( fp );
db.c~:      pObjIndex->short_descr = fread_string( fp );
db.c~:      pObjIndex->description = fread_string( fp );
db.c~:      pObjIndex->action_desc = fread_string( fp );
db.c~:       * pObjIndex->short_descr[0]  = LOWER(pObjIndex->short_descr[0]);
db.c~:      ((char*)pObjIndex->description)[0] = UPPER( pObjIndex->description[0] );
db.c~:      pObjIndex->item_type = x1;
db.c~:      pObjIndex->extra_flags = x2;
db.c~:      pObjIndex->wear_flags = x3;
db.c~:      pObjIndex->layers = x4;
db.c~:      pObjIndex->value[0] = x1;
db.c~:      pObjIndex->value[1] = x2;
db.c~:      pObjIndex->value[2] = x3;
db.c~:      pObjIndex->value[3] = x4;
db.c~:      pObjIndex->value[4] = x5;
db.c~:      pObjIndex->value[5] = x6;
db.c~:      pObjIndex->weight = fread_number( fp );
db.c~:      pObjIndex->weight = UMAX( 1, pObjIndex->weight );
db.c~:      pObjIndex->cost = fread_number( fp );
db.c~:      pObjIndex->rent = fread_number( fp );  /* unused */
db.c~:            paf->type = -1;
db.c~:            paf->duration = -1;
db.c~:            paf->location = fread_number( fp );
db.c~:            if( paf->location == APPLY_WEAPONSPELL
db.c~:                || paf->location == APPLY_WEARSPELL || paf->location == APPLY_REMOVESPELL || paf->location == APPLY_STRIPSN )
db.c~:               paf->modifier = slot_lookup( fread_number( fp ) );
db.c~:               paf->modifier = fread_number( fp );
db.c~:            paf->bitvector = 0;
db.c~:            LINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c~:            ed->keyword = fread_string( fp );
db.c~:            ed->description = fread_string( fp );
db.c~:            LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c~:      switch ( pObjIndex->item_type )
db.c~:            pObjIndex->value[1] = slot_lookup( pObjIndex->value[1] );
db.c~:            pObjIndex->value[2] = slot_lookup( pObjIndex->value[2] );
db.c~:            pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
db.c~:            pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
db.c~:            pObjIndex->value[4] = slot_lookup( pObjIndex->value[4] );
db.c~:            pObjIndex->value[5] = slot_lookup( pObjIndex->value[5] );
db.c~:         pObjIndex->next = obj_index_hash[iHash];
db.c~:   if( !tarea->first_room )
db.c~:               boot_log( "%s: %s (%d) bad command '%c'.", __FUNCTION__, tarea->filename, count, letter );
db.c~:               boot_log( "%s: %s (%d) 'M': mobile %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c~:               boot_log( "%s: %s (%d) 'M': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg3 );
db.c~:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c~:               boot_log( "%s: %s (%d) '%c': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg3 );
db.c~:                  bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c~:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c~:                  boot_log( "%s: %s (%d) 'P': destination object %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg3 );
db.c~:               bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c~:               boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, tarea->filename, count, letter, arg1 );
db.c~:               bug( "%s: Unable to add room reset - room not found.", __FUNCTION__ );
db.c~:                  bug( "%s: Unable to add trap reset - room not found.", __FUNCTION__ );
db.c~:                  boot_log( "%s: %s (%d) 'D': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c~:                || !( pexit = get_exit( pRoomIndex, arg2 ) ) || !IS_SET( pexit->exit_info, EX_ISDOOR ) )
db.c~:                  boot_log( "%s: %s (%d) 'D': exit %d not door.", __FUNCTION__, tarea->filename, count, arg2 );
db.c~:                  boot_log( "%s: %s (%d) 'D': bad 'locks': %d.", __FUNCTION__, tarea->filename, count, arg3 );
db.c~:               boot_log( "%s: %s (%d) 'R': room %d doesn't exist.", __FUNCTION__, tarea->filename, count, arg1 );
db.c~:                  boot_log( "%s: %s (%d) 'R': bad exit %d.", __FUNCTION__, tarea->filename, count, arg2 );
db.c~:      for( roomlist = tarea->first_room; roomlist; roomlist = roomlist->next_aroom )
db.c~:            boot_log( "%s: %s (%d) bad command '%c'.", __FUNCTION__, room->area->filename, count, letter );
db.c~:            boot_log( "%s: %s (%d) 'M': mobile %d doesn't exist.", __FUNCTION__, room->area->filename, count, arg1 );
db.c~:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c~:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c~:            boot_log( "%s: %s (%d) 'P': destination object %d doesn't exist.", __FUNCTION__, room->area->filename, count, arg3 );
db.c~:            boot_log( "%s: %s (%d) '%c': object %d doesn't exist.", __FUNCTION__, room->area->filename, count, letter, arg1 );
db.c~:             || !( pexit = get_exit( room, arg2 ) ) || !IS_SET( pexit->exit_info, EX_ISDOOR ) )
db.c~:               boot_log( "%s: %s (%d) 'D': exit %d not door.", __FUNCTION__, room->area->filename, count, arg2 );
db.c~:               boot_log( "%s: %s (%d) 'D': bad 'locks': %d.", __FUNCTION__, room->area->filename, count, arg3 );
db.c~:               boot_log( "%s: %s (%d) 'R': bad exit %d.", __FUNCTION__, room->area->filename, count, arg2 );
db.c~:   tarea->first_room = tarea->last_room = NULL;
db.c~:         pRoomIndex->first_person = NULL;
db.c~:         pRoomIndex->last_person = NULL;
db.c~:         pRoomIndex->first_content = NULL;
db.c~:         pRoomIndex->last_content = NULL;
db.c~:      pRoomIndex->area = tarea;
db.c~:      pRoomIndex->vnum = vnum;
db.c~:      pRoomIndex->first_extradesc = NULL;
db.c~:      pRoomIndex->last_extradesc = NULL;
db.c~:         if( !tarea->low_r_vnum )
db.c~:            tarea->low_r_vnum = vnum;
db.c~:         if( vnum > tarea->hi_r_vnum )
db.c~:            tarea->hi_r_vnum = vnum;
db.c~:      pRoomIndex->name = fread_string( fp );
db.c~:      pRoomIndex->description = fread_string( fp );
db.c~:      pRoomIndex->room_flags = x2;
db.c~:      pRoomIndex->sector_type = x3;
db.c~:      pRoomIndex->tele_delay = x4;
db.c~:      pRoomIndex->tele_vnum = x5;
db.c~:      pRoomIndex->tunnel = x6;
db.c~:      if( pRoomIndex->sector_type < 0 || pRoomIndex->sector_type >= SECT_MAX )
db.c~:         bug( "Fread_rooms: vnum %d has bad sector_type %d.", vnum, pRoomIndex->sector_type );
db.c~:         pRoomIndex->sector_type = 1;
db.c~:      pRoomIndex->light = 0;
db.c~:      pRoomIndex->first_exit = NULL;
db.c~:      pRoomIndex->last_exit = NULL;
db.c~:               pexit->description = fread_string( fp );
db.c~:               pexit->keyword = fread_string( fp );
db.c~:               pexit->exit_info = 0;
db.c~:               pexit->key = x2;
db.c~:               pexit->vnum = x3;
db.c~:               pexit->vdir = door;
db.c~:               pexit->distance = x4;
db.c~:                     pexit->exit_info = EX_ISDOOR;
db.c~:                     pexit->exit_info = EX_ISDOOR | EX_PICKPROOF;
db.c~:                     pexit->exit_info = locks;
db.c~:            ed->keyword = fread_string( fp );
db.c~:            ed->description = fread_string( fp );
db.c~:            LINK( ed, pRoomIndex->first_extradesc, pRoomIndex->last_extradesc, next, prev );
db.c~:         pRoomIndex->next = room_index_hash[iHash];
db.c~:         LINK( pRoomIndex, tarea->first_room, tarea->last_room, next_aroom, prev_aroom );
db.c~:      pShop->keeper = fread_number( fp );
db.c~:      if( pShop->keeper == 0 )
db.c~:         pShop->buy_type[iTrade] = fread_number( fp );
db.c~:      pShop->profit_buy = fread_number( fp );
db.c~:      pShop->profit_sell = fread_number( fp );
db.c~:      pShop->profit_buy = URANGE( pShop->profit_sell + 5, pShop->profit_buy, 1000 );
db.c~:      pShop->profit_sell = URANGE( 0, pShop->profit_sell, pShop->profit_buy - 5 );
db.c~:      pShop->open_hour = fread_number( fp );
db.c~:      pShop->close_hour = fread_number( fp );
db.c~:      pMobIndex = get_mob_index( pShop->keeper );
db.c~:      pMobIndex->pShop = pShop;
db.c~:         last_shop->next = pShop;
db.c~:      pShop->next = NULL;
db.c~:      pShop->prev = last_shop;
db.c~: * Load a repair shop section.					-Thoric
db.c~:      rShop->keeper = fread_number( fp );
db.c~:      if( rShop->keeper == 0 )
db.c~:         rShop->fix_type[iFix] = fread_number( fp );
db.c~:      rShop->profit_fix = fread_number( fp );
db.c~:      rShop->shop_type = fread_number( fp );
db.c~:      rShop->open_hour = fread_number( fp );
db.c~:      rShop->close_hour = fread_number( fp );
db.c~:      pMobIndex = get_mob_index( rShop->keeper );
db.c~:      pMobIndex->rShop = rShop;
db.c~:         last_repair->next = rShop;
db.c~:      rShop->next = NULL;
db.c~:      rShop->prev = last_repair;
db.c~:            if( !pMobIndex->spec_fun )
db.c~:               pMobIndex->spec_fun = spec_lookup( temp );
db.c~:               if( pMobIndex->spec_fun == NULL )
db.c~:                  bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
db.c~:                  pMobIndex->spec_funname = NULL;
db.c~:                  pMobIndex->spec_funname = STRALLOC( temp );
db.c~:            else if( !pMobIndex->spec_2 )
db.c~:               pMobIndex->spec_2 = spec_lookup( temp );
db.c~:               if( pMobIndex->spec_2 == NULL )
db.c~:                  bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
db.c~:                  pMobIndex->spec_funname2 = NULL;
db.c~:                  pMobIndex->spec_funname2 = STRALLOC( temp );
db.c~:      tarea->low_soft_range = x1;
db.c~:      tarea->hi_soft_range = x2;
db.c~:      tarea->low_hard_range = x3;
db.c~:      tarea->hi_hard_range = x4;
db.c~:   for( tarea = first_area; tarea; tarea = tarea->next )
db.c~:      if( tarea->high_economy > 0 || tarea->low_economy > 10000 )
db.c~:      rng = tarea->hi_soft_range - tarea->low_soft_range;
db.c~:      for( idx = tarea->low_m_vnum; idx < tarea->hi_m_vnum; idx++ )
db.c~:            boost_economy( tarea, mob->gold * 10 );
db.c~:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c~:         for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit_next )
db.c~:            pexit_next = pexit->next;
db.c~:            pexit->rvnum = pRoomIndex->vnum;
db.c~:            if( pexit->vnum <= 0 || ( pexit->to_room = get_room_index( pexit->vnum ) ) == NULL )
db.c~:                            pRoomIndex->vnum, dir_name[pexit->vdir], pexit->vnum );
db.c~:               bug( "Deleting %s exit in room %d", dir_name[pexit->vdir], pRoomIndex->vnum );
db.c~:            SET_BIT( pRoomIndex->room_flags, ROOM_NO_MOB );
db.c~:    * Set all the rexit pointers   -Thoric 
db.c~:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c~:         for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c~:            if( pexit->to_room && !pexit->rexit )
db.c~:               rev_exit = get_exit_to( pexit->to_room, rev_dir[pexit->vdir], pRoomIndex->vnum );
db.c~:                  pexit->rexit = rev_exit;
db.c~:                  rev_exit->rexit = pexit;
db.c~: * Get diku-compatable exit by number				-Thoric
db.c~:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c~:   d1 = ( *xit1 )->vdir;
db.c~:   d2 = ( *xit2 )->vdir;
db.c~:      return -1;
db.c~:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c~:         exits[x]->prev = exits[x - 1];
db.c~:         exits[x]->prev = NULL;
db.c~:         room->first_exit = exits[x];
db.c~:      if( x >= ( nexits - 1 ) )
db.c~:         exits[x]->next = NULL;
db.c~:         room->last_exit = exits[x];
db.c~:         exits[x]->next = exits[x + 1];
db.c~:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c~:      vdirs[nexits++] = pexit->vdir;
db.c~:      while( vdirs[( d1 = number_range( d0, nexits - 1 ) )] > maxdir || ++count > 5 );
db.c~:   for( pexit = room->first_exit; pexit; pexit = pexit->next )
db.c~:      pexit->vdir = vdirs[count++];
db.c~:   for( pArea = first_area; pArea; pArea = pArea->next )
db.c~:      int reset_age = pArea->reset_frequency ? pArea->reset_frequency : 15;
db.c~:      if( ( reset_age == -1 && pArea->age == -1 ) || ++pArea->age < ( reset_age - 1 ) )
db.c~:      if( pArea->nplayer > 0 && pArea->age == ( reset_age - 1 ) )
db.c~:         if( pArea->resetmsg )
db.c~:            sprintf( buf, "%s\r\n", pArea->resetmsg );
db.c~:         for( pch = first_char; pch; pch = pch->next )
db.c~:            if( !IS_NPC( pch ) && IS_AWAKE( pch ) && pch->in_room && pch->in_room->area == pArea )
db.c~:      if( pArea->nplayer == 0 || pArea->age >= reset_age )
db.c~:         if( reset_age == -1 )
db.c~:            pArea->age = -1;
db.c~:            pArea->age = number_range( 0, reset_age / 5 );
db.c~:         if( pRoomIndex != NULL && pArea == pRoomIndex->area && pArea->reset_frequency == 0 )
db.c~:            pArea->age = 15 - 3;
db.c~:   mob->pIndexData = pMobIndex;
db.c~:   mob->editor = NULL;
db.c~:   mob->name = QUICKLINK( pMobIndex->player_name );
db.c~:   mob->short_descr = QUICKLINK( pMobIndex->short_descr );
db.c~:   mob->long_descr = QUICKLINK( pMobIndex->long_descr );
db.c~:   mob->description = QUICKLINK( pMobIndex->description );
db.c~:   mob->spec_fun = pMobIndex->spec_fun;
db.c~:   mob->spec_2 = pMobIndex->spec_2;
db.c~:   if( pMobIndex->spec_funname )
db.c~:      mob->spec_funname = QUICKLINK( pMobIndex->spec_funname );
db.c~:   if( pMobIndex->spec_funname2 )
db.c~:      mob->spec_funname2 = QUICKLINK( pMobIndex->spec_funname2 );
db.c~:   mob->mpscriptpos = 0;
db.c~:   mob->top_level = number_fuzzy( pMobIndex->level );
db.c~:         mob->skill_level[ability] = mob->top_level;
db.c~:   mob->act = pMobIndex->act;
db.c~:   mob->home_vnum = -1;
db.c~:   mob->resetvnum = -1;
db.c~:   mob->resetnum = -1;
db.c~:   mob->affected_by = pMobIndex->affected_by;
db.c~:   mob->alignment = pMobIndex->alignment;
db.c~:   mob->sex = pMobIndex->sex;
db.c~:   mob->main_ability = 0;
db.c~:   mob->mob_clan = STRALLOC( "" );
db.c~:   mob->was_sentinel = NULL;
db.c~:   mob->plr_home = NULL;
db.c~:   mob->guard_data = NULL;
db.c~:   if( pMobIndex->ac )
db.c~:      mob->armor = pMobIndex->ac;
db.c~:     mob->armor = ( short )( LEVEL_HERO - mob->top_level * 2.5 );
db.c~:   if( !pMobIndex->hitnodice )
db.c~:      mob->max_hit = mob->top_level * 10 + number_range( mob->top_level, mob->top_level * 10 );
db.c~:      mob->max_hit = pMobIndex->hitnodice * number_range( 1, pMobIndex->hitsizedice ) + pMobIndex->hitplus;
db.c~:   mob->hit = mob->max_hit;
db.c~:    * lets put things back the way they used to be! -Thoric 
db.c~:   mob->gold = pMobIndex->gold;
db.c~:   mob->position = pMobIndex->position;
db.c~:   mob->defposition = pMobIndex->defposition;
db.c~:   mob->barenumdie = pMobIndex->damnodice;
db.c~:   mob->baresizedie = pMobIndex->damsizedice;
db.c~:   mob->mobthac0 = pMobIndex->mobthac0;
db.c~:   mob->hitplus = pMobIndex->hitplus;
db.c~:   mob->damplus = pMobIndex->damplus;
db.c~:   mob->perm_str = pMobIndex->perm_str;
db.c~:   mob->perm_dex = pMobIndex->perm_dex;
db.c~:   mob->perm_wis = pMobIndex->perm_wis;
db.c~:   mob->perm_int = pMobIndex->perm_int;
db.c~:   mob->perm_con = pMobIndex->perm_con;
db.c~:   mob->perm_cha = pMobIndex->perm_cha;
db.c~:   mob->perm_lck = pMobIndex->perm_lck;
db.c~:   mob->hitroll = pMobIndex->hitroll;
db.c~:   mob->damroll = pMobIndex->damroll;
db.c~:   mob->race = pMobIndex->race;
db.c~:   mob->xflags = pMobIndex->xflags;
db.c~:   mob->saving_poison_death = pMobIndex->saving_poison_death;
db.c~:   mob->saving_wand = pMobIndex->saving_wand;
db.c~:   mob->saving_para_petri = pMobIndex->saving_para_petri;
db.c~:   mob->saving_breath = pMobIndex->saving_breath;
db.c~:   mob->saving_spell_staff = pMobIndex->saving_spell_staff;
db.c~:   mob->height = pMobIndex->height;
db.c~:   mob->weight = pMobIndex->weight;
db.c~:   mob->resistant = pMobIndex->resistant;
db.c~:   mob->immune = pMobIndex->immune;
db.c~:   mob->susceptible = pMobIndex->susceptible;
db.c~:   mob->attacks = pMobIndex->attacks;
db.c~:   mob->defenses = pMobIndex->defenses;
db.c~:   mob->numattacks = pMobIndex->numattacks;
db.c~:   mob->speaks = pMobIndex->speaks;
db.c~:   mob->speaking = pMobIndex->speaking;
db.c~:   mob->vip_flags = pMobIndex->vip_flags;
db.c~:   pMobIndex->count++;
db.c~:   obj->pIndexData = pObjIndex;
db.c~:   obj->in_room = NULL;
db.c~:   obj->level = level;
db.c~:   obj->wear_loc = -1;
db.c~:   obj->count = 1;
db.c~:   cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
db.c~:   obj->serial = obj->pIndexData->serial = cur_obj_serial;
db.c~:   obj->armed_by = STRALLOC( "" );
db.c~:   obj->name = QUICKLINK( pObjIndex->name );
db.c~:   obj->short_descr = QUICKLINK( pObjIndex->short_descr );
db.c~:   obj->description = QUICKLINK( pObjIndex->description );
db.c~:   obj->action_desc = QUICKLINK( pObjIndex->action_desc );
db.c~:   obj->item_type = pObjIndex->item_type;
db.c~:   obj->extra_flags = pObjIndex->extra_flags;
db.c~:   obj->wear_flags = pObjIndex->wear_flags;
db.c~:   obj->value[0] = pObjIndex->value[0];
db.c~:   obj->value[1] = pObjIndex->value[1];
db.c~:   obj->value[2] = pObjIndex->value[2];
db.c~:   obj->value[3] = pObjIndex->value[3];
db.c~:   obj->value[4] = pObjIndex->value[4];
db.c~:   obj->value[5] = pObjIndex->value[5];
db.c~:   obj->weight = pObjIndex->weight;
db.c~:   obj->cost = pObjIndex->cost;
db.c~:    * obj->cost     = number_fuzzy( 10 )
db.c~:   switch ( obj->item_type )
db.c~:         bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
db.c~:         bug( "------------------------>     ", obj->item_type );
db.c~:          * optional food condition (rotting food)    -Thoric
db.c~:         if( obj->value[4] )
db.c~:            obj->timer = obj->value[4];
db.c~:            obj->timer = obj->value[1];
db.c~:         obj->value[3] = number_fuzzy( obj->value[3] );
db.c~:         obj->value[0] = number_fuzzy( obj->value[0] );
db.c~:         obj->value[1] = number_fuzzy( obj->value[1] );
db.c~:         obj->value[2] = obj->value[1];
db.c~:         if( obj->value[0] <= 0 )
db.c~:            obj->value[0] = number_fuzzy( 95 );
db.c~:         if( obj->value[0] <= 0 )
db.c~:            obj->value[0] = number_fuzzy( 95 );
db.c~:         if( obj->value[0] <= 0 )
db.c~:            obj->value[0] = number_fuzzy( 495 );
db.c~:         if( obj->value[1] && obj->value[2] )
db.c~:            obj->value[2] *= obj->value[1];
db.c~:            obj->value[1] = number_fuzzy( number_fuzzy( 1 + level / 20 ) );
db.c~:            obj->value[2] = number_fuzzy( number_fuzzy( 10 + level / 10 ) );
db.c~:         if( obj->value[1] > obj->value[2] )
db.c~:            obj->value[1] = obj->value[2] / 3;
db.c~:         if( obj->value[0] == 0 )
db.c~:            obj->value[0] = INIT_WEAPON_CONDITION;
db.c~:         switch ( obj->value[3] )
db.c~:               if( obj->value[5] <= 0 )
db.c~:                  obj->value[5] = number_fuzzy( 1000 );
db.c~:         obj->value[4] = obj->value[5];
db.c~:         if( obj->value[0] == 0 )
db.c~:            obj->value[0] = obj->value[1];
db.c~:         obj->timer = obj->value[3];
db.c~:         obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c~:         obj->value[0] = obj->cost;
db.c~:   ++pObjIndex->count;
db.c~:   ch->editor = NULL;
db.c~:   ch->hunting = NULL;
db.c~:   ch->fearing = NULL;
db.c~:   ch->hating = NULL;
db.c~:   ch->name = NULL;
db.c~:   ch->short_descr = NULL;
db.c~:   ch->long_descr = NULL;
db.c~:   ch->description = NULL;
db.c~:   ch->next = NULL;
db.c~:   ch->prev = NULL;
db.c~:   ch->first_carrying = NULL;
db.c~:   ch->last_carrying = NULL;
db.c~:   ch->next_in_room = NULL;
db.c~:   ch->prev_in_room = NULL;
db.c~:   ch->fighting = NULL;
db.c~:   ch->switched = NULL;
db.c~:   ch->first_affect = NULL;
db.c~:   ch->last_affect = NULL;
db.c~:   ch->prev_cmd = NULL; /* maps */
db.c~:   ch->last_cmd = NULL;
db.c~:   ch->dest_buf = NULL;
db.c~:   ch->dest_buf_2 = NULL;
db.c~:   ch->spare_ptr = NULL;
db.c~:   ch->mount = NULL;
db.c~:   ch->affected_by = 0;
db.c~:   ch->logon = current_time;
db.c~:   ch->armor = 100;
db.c~:   ch->position = POS_STANDING;
db.c~:   ch->hit = 500;
db.c~:   ch->max_hit = 500;
db.c~:   ch->mana = 1000;
db.c~:   ch->max_mana = 0;
db.c~:   ch->move = 1000;
db.c~:   ch->max_move = 1000;
db.c~:   ch->height = 72;
db.c~:   ch->weight = 180;
db.c~:   ch->xflags = 0;
db.c~:   ch->race = 0;
db.c~:   ch->speaking = LANG_COMMON;
db.c~:   ch->speaks = LANG_COMMON;
db.c~:   ch->barenumdie = 1;
db.c~:   ch->baresizedie = 4;
db.c~:   ch->substate = 0;
db.c~:   ch->tempnum = 0;
db.c~:   ch->perm_str = 10;
db.c~:   ch->perm_dex = 10;
db.c~:   ch->perm_int = 10;
db.c~:   ch->perm_wis = 10;
db.c~:   ch->perm_cha = 10;
db.c~:   ch->perm_con = 10;
db.c~:   ch->perm_lck = 10;
db.c~:   ch->mod_str = 0;
db.c~:   ch->mod_dex = 0;
db.c~:   ch->mod_int = 0;
db.c~:   ch->mod_wis = 0;
db.c~:   ch->mod_cha = 0;
db.c~:   ch->mod_con = 0;
db.c~:   ch->mod_lck = 0;
db.c~:   ch->plr_home = NULL;
db.c~:   if( ch->desc )
db.c~:   while( ( obj = ch->last_carrying ) != NULL )
db.c~:   while( ( paf = ch->last_affect ) != NULL )
db.c~:   while( ( timer = ch->first_timer ) != NULL )
db.c~:   STRFREE( ch->name );
db.c~:   STRFREE( ch->short_descr );
db.c~:   STRFREE( ch->long_descr );
db.c~:   STRFREE( ch->description );
db.c~:   STRFREE( ch->spec_funname );
db.c~:   STRFREE( ch->spec_funname2 );
db.c~:   if( ch->editor )
db.c~:   if( ch->pnote )
db.c~:      free_note( ch->pnote );
db.c~:   if( ch->pcdata )
db.c~:      STRFREE( ch->pcdata->clan_name );
db.c~:      DISPOSE( ch->pcdata->pwd );   /* no hash */
db.c~:      DISPOSE( ch->pcdata->email ); /* no hash */
db.c~:      DISPOSE( ch->pcdata->bamfin );   /* no hash */
db.c~:      DISPOSE( ch->pcdata->bamfout );  /* no hash */
db.c~:      DISPOSE( ch->pcdata->rank );
db.c~:      STRFREE( ch->pcdata->title );
db.c~:      STRFREE( ch->pcdata->bio );
db.c~:      DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c~:      DISPOSE( ch->pcdata->homepage ); /* no hash */
db.c~:      STRFREE( ch->pcdata->authed_by );
db.c~:      STRFREE( ch->pcdata->prompt );
db.c~:      if( ch->pcdata->subprompt )
db.c~:         STRFREE( ch->pcdata->subprompt );
db.c~:      DISPOSE( ch->pcdata );
db.c~:   for( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c~:      mpact_next = mpact->next;
db.c~:      DISPOSE( mpact->buf );
db.c~:   for( comments = ch->comments; comments; comments = comments_next )
db.c~:      comments_next = comments->next;
db.c~:      STRFREE( comments->text );
db.c~:      STRFREE( comments->to_list );
db.c~:      STRFREE( comments->subject );
db.c~:      STRFREE( comments->sender );
db.c~:      STRFREE( comments->date );
db.c~:   for( ; ed; ed = ed->next )
db.c~:      if( is_name( name, ed->keyword ) )
db.c~:         return ed->description;
db.c~:   for( pMobIndex = mob_index_hash[vnum % MAX_KEY_HASH]; pMobIndex; pMobIndex = pMobIndex->next )
db.c~:      if( pMobIndex->vnum == vnum )
db.c~:   for( pObjIndex = obj_index_hash[vnum % MAX_KEY_HASH]; pObjIndex; pObjIndex = pObjIndex->next )
db.c~:      if( pObjIndex->vnum == vnum )
db.c~:   for( pRoomIndex = room_index_hash[vnum % MAX_KEY_HASH]; pRoomIndex; pRoomIndex = pRoomIndex->next )
db.c~:      if( pRoomIndex->vnum == vnum )
db.c~: * should include player files, and in-progress areas that are not loaded
db.c~: * -- Altrag
db.c~:   else if( c == '-' )
db.c~:            number = number * 10 + c - '0';
db.c~:            number += pow( 10, ( -1 * place ) ) * ( c - '0' );
db.c~:      number = 0 - number;
db.c~:   else if( c == '-' )
db.c~:      number = number * 10 + c - '0';
db.c~:      number = 0 - number;
db.c~: * custom str_dup using create					-Thoric
db.c~:   if( stat( newfilename, &fst ) != -1 )
db.c~:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c~:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c~: * Read to end of line into static buffer			-Thoric
db.c~:      if( ln >= ( MAX_STRING_LENGTH - 1 ) )
db.c~:      hash = -1;
db.c~:      if( hash != -1 )
db.c~:         number -= 1;
db.c~: * Ooops was (number_mm() % to) + from which doesn't work -Shaddai
db.c~:   if( ( to - from ) < 1 )
db.c~:   return ( ( number_mm(  ) % ( to - from + 1 ) ) + from );
db.c~: * number_mm() % 100 only does 0-99, changed to do 1-100 -Shaddai
db.c~:   while( ( door = number_mm(  ) & ( 16 - 1 ) ) > 9 )
db.c~:   return number_mm(  ) & ( ( 1 << width ) - 1 );
db.c~: * I've gotten too many bad reports on OS-supplied random number generators.
db.c~: * This is the Mitchell-Moore algorithm from Knuth Volume II.
db.c~: * -- Furey
db.c~:   piState[-2] = 55 - 55;
db.c~:   piState[-1] = 55 - 24;
db.c~:   piState[0] = ( ( int )current_time ) & ( ( 1 << 30 ) - 1 );
db.c~:      piState[iState] = ( piState[iState - 1] + piState[iState - 2] ) & ( ( 1 << 30 ) - 1 );
db.c~:   iState1 = piState[-2];
db.c~:   iState2 = piState[-1];
db.c~:   iRand = ( piState[iState1] + piState[iState2] ) & ( ( 1 << 30 ) - 1 );
db.c~:   piState[-2] = iState1;
db.c~:   piState[-1] = iState2;
db.c~: * Roll some dice.						-Thoric
db.c~:   return value_00 + level * ( value_32 - value_00 ) / 32;
db.c~: * Used for player-entered strings that go into disk files.
db.c~:         *str = '-';
db.c~: * Encodes the tildes in a string.				-Thoric
db.c~: * Used for player-entered strings that go into disk files.
db.c~:   for( ichar = 0; ichar <= sstr2 - sstr1; ichar++ )
db.c~:   if( sstr1 <= sstr2 && !str_cmp( astr, bstr + sstr2 - sstr1 ) )
db.c~: * Returns an initial-capped string.
db.c~: * Returns TRUE or FALSE if a letter is a vowel			-Thoric
db.c~: * Shove either "a " or "an " onto the beginning of a string	-Thoric
db.c~:      fprintf( fp, "[%5d] %s: %s\n", ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c~:      if( stat( SHUTDOWN_FILE, &fst ) != -1 )   /* file exists */
db.c~: * Add a string to the boot-up log				-Thoric
db.c~: * Dump a text file to a player, a line at a time		-Thoric
db.c~:                && buf[num] != '\n' && buf[num] != '\r' && num < ( MAX_STRING_LENGTH - 2 ) )
db.c~: * Show the boot log file					-Thoric
db.c~: * Writes a string to the log, extended version			-Thoric
db.c~:   strtime[strlen( strtime ) - 1] = '\0';
db.c~: * wizlist builder!						-Thoric
db.c~:      filler = ( 78 - strlen( line ) );
db.c~:   wiz->name = str_dup( name );
db.c~:   wiz->level = level;
db.c~:      wiz->last = NULL;
db.c~:      wiz->next = NULL;
db.c~:   for( tmp = first_wiz; tmp; tmp = tmp->next )
db.c~:      if( level > tmp->level )
db.c~:         if( !tmp->last )
db.c~:            tmp->last->next = wiz;
db.c~:         wiz->last = tmp->last;
db.c~:         wiz->next = tmp;
db.c~:         tmp->last = wiz;
db.c~:   wiz->last = last_wiz;
db.c~:   wiz->next = NULL;
db.c~:   last_wiz->next = wiz;
db.c~: * Wizlist builder						-Thoric
db.c~:      if( dentry->d_name[0] != '.' )
db.c~:         sprintf( buf, "%s%s", GOD_DIR, dentry->d_name );
db.c~:               ilevel = MAX_LEVEL - 4;
db.c~:               ilevel = MAX_LEVEL - 4;
db.c~:            add_to_wizlist( dentry->d_name, ilevel );
db.c~:   for( wiz = first_wiz; wiz; wiz = wiz->next )
db.c~:      if( wiz->level > LEVEL_AVATAR )
db.c~:         if( wiz->level < ilevel )
db.c~:            ilevel = wiz->level;
db.c~:               case MAX_LEVEL - 0:
db.c~:               case MAX_LEVEL - 1:
db.c~:               case MAX_LEVEL - 2:
db.c~:               case MAX_LEVEL - 4:
db.c~:         if( strlen( buf ) + strlen( wiz->name ) > 76 )
db.c~:         strcat( buf, wiz->name );
db.c~:      wiznext = wiz->next;
db.c~:      DISPOSE( wiz->name );
db.c~:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c~:      switch( mprg->type )
db.c~:            mprg->arglist = fread_string( progfile );
db.c~:            mprg->comlist = fread_string( progfile );
db.c~:            mprg->fileprog = TRUE;
db.c~:            SET_BIT( mob->progtypes, mprg->type );
db.c~:            mprg->next = mob->mudprogs;
db.c~:            mob->mudprogs = mprg;
db.c~:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, mob->vnum );
db.c~:      mprg->next = mob->mudprogs;
db.c~:      mob->mudprogs = mprg;
db.c~:      mprg->type = mprog_name_to_type( word );
db.c~:      switch( mprg->type )
db.c~:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, mob->vnum );
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->fileprog = FALSE;
db.c~:            mobprog_file_read( mob, mprg->arglist );
db.c~:            SET_BIT( mob->progtypes, mprg->type );
db.c~:            mprg->fileprog = FALSE;
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->comlist = fread_string( fp );
db.c~:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c~:      switch( mprg->type )
db.c~:            mprg->arglist = fread_string( progfile );
db.c~:            mprg->comlist = fread_string( progfile );
db.c~:            mprg->fileprog = TRUE;
db.c~:            SET_BIT( obj->progtypes, mprg->type );
db.c~:            mprg->next = obj->mudprogs;
db.c~:            obj->mudprogs = mprg;
db.c~:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, obj->vnum );
db.c~:      mprg->next = obj->mudprogs;
db.c~:      obj->mudprogs = mprg;
db.c~:      mprg->type = mprog_name_to_type( word );
db.c~:      switch( mprg->type )
db.c~:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, obj->vnum );
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->fileprog = FALSE;
db.c~:            objprog_file_read( obj, mprg->arglist );
db.c~:            SET_BIT( obj->progtypes, mprg->type );
db.c~:            mprg->fileprog = FALSE;
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->comlist = fread_string( fp );
db.c~:      mprg->type = mprog_name_to_type( fread_word( progfile ) );
db.c~:      switch( mprg->type )
db.c~:            mprg->arglist = fread_string( progfile );
db.c~:            mprg->comlist = fread_string( progfile );
db.c~:            mprg->fileprog = TRUE;
db.c~:            SET_BIT( room->progtypes, mprg->type );
db.c~:            mprg->next = room->mudprogs;
db.c~:            room->mudprogs = mprg;
db.c~:         bug( "%s: vnum %d MUDPROG char", __FUNCTION__, room->vnum );
db.c~:      mprg->next = room->mudprogs;
db.c~:      room->mudprogs = mprg;
db.c~:      mprg->type = mprog_name_to_type( word );
db.c~:      switch( mprg->type )
db.c~:            bug( "%s: vnum %d MUDPROG type.", __FUNCTION__, room->vnum );
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->fileprog = FALSE;
db.c~:            roomprog_file_read( room, mprg->arglist );
db.c~:            SET_BIT( room->progtypes, mprg->type );
db.c~:            mprg->fileprog = FALSE;
db.c~:            mprg->arglist = fread_string( fp );
db.c~:            mprg->comlist = fread_string( fp );
db.c~:   Don't ask me why they return bool.. :).. oh well.. -- Alty
db.c~:   Don't ask me either, so I changed it to void. - Samson
db.c~:   UNLINK( room, room->area->first_room, room->area->last_room, next_aroom, prev_aroom );
db.c~:   while( ( ch = room->first_person ) != NULL )
db.c~:   for( ch = first_char; ch; ch = ch->next )
db.c~:      if( ch->was_in_room == room )
db.c~:         ch->was_in_room = ch->in_room;
db.c~:      if( ch->substate == SUB_ROOM_DESC && ch->dest_buf == room )
db.c~:         ch->substate = SUB_NONE;
db.c~:         ch->dest_buf = NULL;
db.c~:      else if( ch->substate == SUB_ROOM_EXTRA && ch->dest_buf )
db.c~:         for( ed = room->first_extradesc; ed; ed = ed->next )
db.c~:            if( ed == ch->dest_buf )
db.c~:               ch->substate = SUB_NONE;
db.c~:               ch->dest_buf = NULL;
db.c~:   while( ( o = room->first_content ) != NULL )
db.c~:   while( ( ed = room->first_extradesc ) != NULL )
db.c~:      room->first_extradesc = ed->next;
db.c~:      STRFREE( ed->keyword );
db.c~:      STRFREE( ed->description );
db.c~:      --top_ed;
db.c~:   while( ( ex = room->first_exit ) != NULL )
db.c~:   while( ( mpact = room->mpact ) != NULL )
db.c~:      room->mpact = mpact->next;
db.c~:      DISPOSE( mpact->buf );
db.c~:   while( ( mp = room->mudprogs ) != NULL )
db.c~:      room->mudprogs = mp->next;
db.c~:      STRFREE( mp->arglist );
db.c~:      STRFREE( mp->comlist );
db.c~:   STRFREE( room->name );
db.c~:   STRFREE( room->description );
db.c~:   hash = room->vnum % MAX_KEY_HASH;
db.c~:      room_index_hash[hash] = room->next;
db.c~:      for( prev = room_index_hash[hash]; prev; prev = prev->next )
db.c~:         if( prev->next == room )
db.c~:         prev->next = room->next;
db.c~:         bug( "%s: room %d not in hash bucket %d.", __FUNCTION__, room->vnum, hash );
db.c~:   --top_room;
db.c~:      o_next = o->next;
db.c~:      if( o->pIndexData == obj )
db.c~:   for( ch = first_char; ch; ch = ch->next )
db.c~:      if( ch->substate == SUB_OBJ_EXTRA && ch->dest_buf )
db.c~:         for( ed = obj->first_extradesc; ed; ed = ed->next )
db.c~:            if( ed == ch->dest_buf )
db.c~:               ch->substate = SUB_NONE;
db.c~:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c~:         for( mp = obj->mudprogs; mp; mp = mp->next )
db.c~:            if( mp == ch->dest_buf )
db.c~:               ch->dest_buf = NULL;
db.c~:               ch->substate = SUB_NONE;
db.c~:   while( ( ed = obj->first_extradesc ) != NULL )
db.c~:      obj->first_extradesc = ed->next;
db.c~:      STRFREE( ed->keyword );
db.c~:      STRFREE( ed->description );
db.c~:      --top_ed;
db.c~:   while( ( af = obj->first_affect ) != NULL )
db.c~:      obj->first_affect = af->next;
db.c~:      --top_affect;
db.c~:   while( ( mp = obj->mudprogs ) != NULL )
db.c~:      obj->mudprogs = mp->next;
db.c~:      STRFREE( mp->arglist );
db.c~:      STRFREE( mp->comlist );
db.c~:   STRFREE( obj->name );
db.c~:   STRFREE( obj->short_descr );
db.c~:   STRFREE( obj->description );
db.c~:   STRFREE( obj->action_desc );
db.c~:   hash = obj->vnum % MAX_KEY_HASH;
db.c~:      obj_index_hash[hash] = obj->next;
db.c~:      for( prev = obj_index_hash[hash]; prev; prev = prev->next )
db.c~:         if( prev->next == obj )
db.c~:         prev->next = obj->next;
db.c~:         bug( "%s: object %d not in hash bucket %d.", __FUNCTION__, obj->vnum, hash );
db.c~:   --top_obj_index;
db.c~:      ch_next = ch->next;
db.c~:      if( ch->pIndexData == mob )
db.c~:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c~:         for( mp = mob->mudprogs; mp; mp = mp->next )
db.c~:            if( mp == ch->dest_buf )
db.c~:               ch->dest_buf = NULL;
db.c~:               ch->substate = SUB_NONE;
db.c~:   while( ( mp = mob->mudprogs ) != NULL )
db.c~:      mob->mudprogs = mp->next;
db.c~:      STRFREE( mp->arglist );
db.c~:      STRFREE( mp->comlist );
db.c~:   if( mob->pShop )
db.c~:      UNLINK( mob->pShop, first_shop, last_shop, next, prev );
db.c~:      DISPOSE( mob->pShop );
db.c~:      --top_shop;
db.c~:   if( mob->rShop )
db.c~:      UNLINK( mob->rShop, first_repair, last_repair, next, prev );
db.c~:      DISPOSE( mob->rShop );
db.c~:      --top_repair;
db.c~:   STRFREE( mob->player_name );
db.c~:   STRFREE( mob->short_descr );
db.c~:   STRFREE( mob->long_descr );
db.c~:   STRFREE( mob->description );
db.c~:   STRFREE( mob->spec_funname );
db.c~:   STRFREE( mob->spec_funname2 );
db.c~:   hash = mob->vnum % MAX_KEY_HASH;
db.c~:      mob_index_hash[hash] = mob->next;
db.c~:      for( prev = mob_index_hash[hash]; prev; prev = prev->next )
db.c~:         if( prev->next == mob )
db.c~:         prev->next = mob->next;
db.c~:         bug( "delete_mob: mobile %d not in hash bucket %d.", mob->vnum, hash );
db.c~:   --top_mob_index;
db.c~: * Creat a new room (for online building)			-Thoric
db.c~:   pRoomIndex->first_person = NULL;
db.c~:   pRoomIndex->last_person = NULL;
db.c~:   pRoomIndex->first_content = NULL;
db.c~:   pRoomIndex->last_content = NULL;
db.c~:   pRoomIndex->first_reset = pRoomIndex->last_reset = NULL;
db.c~:   pRoomIndex->first_extradesc = NULL;
db.c~:   pRoomIndex->last_extradesc = NULL;
db.c~:   pRoomIndex->first_ship = NULL;
db.c~:   pRoomIndex->last_ship = NULL;
db.c~:   pRoomIndex->area = area;
db.c~:   pRoomIndex->vnum = vnum;
db.c~:   pRoomIndex->name = STRALLOC( "Floating in a void" );
db.c~:   pRoomIndex->description = STRALLOC( "" );
db.c~:   pRoomIndex->room_flags = ROOM_PROTOTYPE;
db.c~:   pRoomIndex->sector_type = 1;
db.c~:   pRoomIndex->light = 0;
db.c~:   pRoomIndex->first_exit = NULL;
db.c~:   pRoomIndex->last_exit = NULL;
db.c~:   LINK( pRoomIndex, area->first_room, area->last_room, next_aroom, prev_aroom );
db.c~:   pRoomIndex->next = room_index_hash[iHash];
db.c~: * Create a new INDEX object (for online building)		-Thoric
db.c~:   pObjIndex->vnum = vnum;
db.c~:   pObjIndex->name = STRALLOC( name );
db.c~:   pObjIndex->first_affect = NULL;
db.c~:   pObjIndex->last_affect = NULL;
db.c~:   pObjIndex->first_extradesc = NULL;
db.c~:   pObjIndex->last_extradesc = NULL;
db.c~:      pObjIndex->short_descr = STRALLOC( buf );
db.c~:      pObjIndex->description = STRALLOC( buf );
db.c~:      pObjIndex->action_desc = STRALLOC( "" );
db.c~:      ((char*)pObjIndex->short_descr)[0] = LOWER( pObjIndex->short_descr[0] );
db.c~:      ((char*)pObjIndex->description)[0] = UPPER( pObjIndex->description[0] );
db.c~:      pObjIndex->item_type = ITEM_TRASH;
db.c~:      pObjIndex->extra_flags = ITEM_PROTOTYPE;
db.c~:      pObjIndex->wear_flags = 0;
db.c~:      pObjIndex->value[0] = 0;
db.c~:      pObjIndex->value[1] = 0;
db.c~:      pObjIndex->value[2] = 0;
db.c~:      pObjIndex->value[3] = 0;
db.c~:      pObjIndex->value[4] = 0;
db.c~:      pObjIndex->value[5] = 0;
db.c~:      pObjIndex->weight = 1;
db.c~:      pObjIndex->cost = 0;
db.c~:      pObjIndex->short_descr = QUICKLINK( cObjIndex->short_descr );
db.c~:      pObjIndex->description = QUICKLINK( cObjIndex->description );
db.c~:      pObjIndex->action_desc = QUICKLINK( cObjIndex->action_desc );
db.c~:      pObjIndex->item_type = cObjIndex->item_type;
db.c~:      pObjIndex->extra_flags = cObjIndex->extra_flags | ITEM_PROTOTYPE;
db.c~:      pObjIndex->wear_flags = cObjIndex->wear_flags;
db.c~:      pObjIndex->value[0] = cObjIndex->value[0];
db.c~:      pObjIndex->value[1] = cObjIndex->value[1];
db.c~:      pObjIndex->value[2] = cObjIndex->value[2];
db.c~:      pObjIndex->value[3] = cObjIndex->value[3];
db.c~:      pObjIndex->value[4] = cObjIndex->value[4];
db.c~:      pObjIndex->value[5] = cObjIndex->value[5];
db.c~:      pObjIndex->weight = cObjIndex->weight;
db.c~:      pObjIndex->cost = cObjIndex->cost;
db.c~:      for( ced = cObjIndex->first_extradesc; ced; ced = ced->next )
db.c~:         ed->keyword = QUICKLINK( ced->keyword );
db.c~:         ed->description = QUICKLINK( ced->description );
db.c~:         LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c~:      for( cpaf = cObjIndex->first_affect; cpaf; cpaf = cpaf->next )
db.c~:         paf->type = cpaf->type;
db.c~:         paf->duration = cpaf->duration;
db.c~:         paf->location = cpaf->location;
db.c~:         paf->modifier = cpaf->modifier;
db.c~:         paf->bitvector = cpaf->bitvector;
db.c~:         LINK( paf, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c~:   pObjIndex->count = 0;
db.c~:   pObjIndex->next = obj_index_hash[iHash];
db.c~: * Create a new INDEX mobile (for online building)		-Thoric
db.c~:   pMobIndex->vnum = vnum;
db.c~:   pMobIndex->count = 0;
db.c~:   pMobIndex->killed = 0;
db.c~:   pMobIndex->player_name = STRALLOC( name );
db.c~:      pMobIndex->short_descr = STRALLOC( buf );
db.c~:      pMobIndex->long_descr = STRALLOC( buf );
db.c~:      pMobIndex->description = STRALLOC( "" );
db.c~:      ((char*)pMobIndex->short_descr)[0] = LOWER( pMobIndex->short_descr[0] );
db.c~:      ((char*)pMobIndex->long_descr)[0] = UPPER( pMobIndex->long_descr[0] );
db.c~:      ((char*)pMobIndex->description)[0] = UPPER( pMobIndex->description[0] );
db.c~:      pMobIndex->act = ACT_IS_NPC | ACT_PROTOTYPE;
db.c~:      pMobIndex->affected_by = 0;
db.c~:      pMobIndex->pShop = NULL;
db.c~:      pMobIndex->rShop = NULL;
db.c~:      pMobIndex->spec_fun = NULL;
db.c~:      pMobIndex->spec_2 = NULL;
db.c~:      pMobIndex->mudprogs = NULL;
db.c~:      pMobIndex->progtypes = 0;
db.c~:      pMobIndex->alignment = 0;
db.c~:      pMobIndex->level = 1;
db.c~:      pMobIndex->mobthac0 = 0;
db.c~:      pMobIndex->ac = 0;
db.c~:      pMobIndex->hitnodice = 0;
db.c~:      pMobIndex->hitsizedice = 0;
db.c~:      pMobIndex->hitplus = 0;
db.c~:      pMobIndex->damnodice = 0;
db.c~:      pMobIndex->damsizedice = 0;
db.c~:      pMobIndex->damplus = 0;
db.c~:      pMobIndex->gold = 0;
db.c~:      pMobIndex->exp = 0;
db.c~:      pMobIndex->position = 8;
db.c~:      pMobIndex->defposition = 8;
db.c~:      pMobIndex->sex = 0;
db.c~:      pMobIndex->perm_str = 10;
db.c~:      pMobIndex->perm_dex = 10;
db.c~:      pMobIndex->perm_int = 10;
db.c~:      pMobIndex->perm_wis = 10;
db.c~:      pMobIndex->perm_cha = 10;
db.c~:      pMobIndex->perm_con = 10;
db.c~:      pMobIndex->perm_lck = 10;
db.c~:      pMobIndex->race = 0;
db.c~:      pMobIndex->xflags = 0;
db.c~:      pMobIndex->resistant = 0;
db.c~:      pMobIndex->immune = 0;
db.c~:      pMobIndex->susceptible = 0;
db.c~:      pMobIndex->numattacks = 1;
db.c~:      pMobIndex->attacks = 0;
db.c~:      pMobIndex->defenses = 0;
db.c~:      pMobIndex->short_descr = QUICKLINK( cMobIndex->short_descr );
db.c~:      pMobIndex->long_descr = QUICKLINK( cMobIndex->long_descr );
db.c~:      pMobIndex->description = QUICKLINK( cMobIndex->description );
db.c~:      pMobIndex->act = cMobIndex->act | ACT_PROTOTYPE;
db.c~:      pMobIndex->affected_by = cMobIndex->affected_by;
db.c~:      pMobIndex->pShop = NULL;
db.c~:      pMobIndex->rShop = NULL;
db.c~:      pMobIndex->spec_fun = cMobIndex->spec_fun;
db.c~:      pMobIndex->spec_2 = cMobIndex->spec_2;
db.c~:      pMobIndex->mudprogs = NULL;
db.c~:      pMobIndex->progtypes = 0;
db.c~:      pMobIndex->alignment = cMobIndex->alignment;
db.c~:      pMobIndex->level = cMobIndex->level;
db.c~:      pMobIndex->mobthac0 = cMobIndex->mobthac0;
db.c~:      pMobIndex->ac = cMobIndex->ac;
db.c~:      pMobIndex->hitnodice = cMobIndex->hitnodice;
db.c~:      pMobIndex->hitsizedice = cMobIndex->hitsizedice;
db.c~:      pMobIndex->hitplus = cMobIndex->hitplus;
db.c~:      pMobIndex->damnodice = cMobIndex->damnodice;
db.c~:      pMobIndex->damsizedice = cMobIndex->damsizedice;
db.c~:      pMobIndex->damplus = cMobIndex->damplus;
db.c~:      pMobIndex->gold = cMobIndex->gold;
db.c~:      pMobIndex->exp = cMobIndex->exp;
db.c~:      pMobIndex->position = cMobIndex->position;
db.c~:      pMobIndex->defposition = cMobIndex->defposition;
db.c~:      pMobIndex->sex = cMobIndex->sex;
db.c~:      pMobIndex->perm_str = cMobIndex->perm_str;
db.c~:      pMobIndex->perm_dex = cMobIndex->perm_dex;
db.c~:      pMobIndex->perm_int = cMobIndex->perm_int;
db.c~:      pMobIndex->perm_wis = cMobIndex->perm_wis;
db.c~:      pMobIndex->perm_cha = cMobIndex->perm_cha;
db.c~:      pMobIndex->perm_con = cMobIndex->perm_con;
db.c~:      pMobIndex->perm_lck = cMobIndex->perm_lck;
db.c~:      pMobIndex->race = cMobIndex->race;
db.c~:      pMobIndex->xflags = cMobIndex->xflags;
db.c~:      pMobIndex->resistant = cMobIndex->resistant;
db.c~:      pMobIndex->immune = cMobIndex->immune;
db.c~:      pMobIndex->susceptible = cMobIndex->susceptible;
db.c~:      pMobIndex->numattacks = cMobIndex->numattacks;
db.c~:      pMobIndex->attacks = cMobIndex->attacks;
db.c~:      pMobIndex->defenses = cMobIndex->defenses;
db.c~:   pMobIndex->next = mob_index_hash[iHash];
db.c~: * to_room and vnum.						-Thoric
db.c~:   pexit->vdir = door;
db.c~:   pexit->rvnum = pRoomIndex->vnum;
db.c~:   pexit->to_room = to_room;
db.c~:   pexit->distance = 1;
db.c~:      pexit->vnum = to_room->vnum;
db.c~:      texit = get_exit_to( to_room, rev_dir[door], pRoomIndex->vnum );
db.c~:         texit->rexit = pexit;
db.c~:         pexit->rexit = texit;
db.c~:   for( texit = pRoomIndex->first_exit; texit; texit = texit->next )
db.c~:      if( door < texit->vdir )
db.c~:   if( !pRoomIndex->first_exit )
db.c~:      pRoomIndex->first_exit = pexit;
db.c~:       * keep exits in incremental order - insert exit into list 
db.c~:         if( !texit->prev )
db.c~:            pRoomIndex->first_exit = pexit;
db.c~:            texit->prev->next = pexit;
db.c~:         pexit->prev = texit->prev;
db.c~:         pexit->next = texit;
db.c~:         texit->prev = pexit;
db.c~:      pRoomIndex->last_exit->next = pexit;
db.c~:   pexit->next = NULL;
db.c~:   pexit->prev = pRoomIndex->last_exit;
db.c~:   pRoomIndex->last_exit = pexit;
db.c~:   for( rnum = tarea->low_r_vnum; rnum <= tarea->hi_r_vnum; rnum++ )
db.c~:      for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c~:         pexit->rvnum = pRoomIndex->vnum;
db.c~:         if( pexit->vnum <= 0 )
db.c~:            pexit->to_room = NULL;
db.c~:            pexit->to_room = get_room_index( pexit->vnum );
db.c~:         SET_BIT( pRoomIndex->room_flags, ROOM_NO_MOB );
db.c~:   for( rnum = tarea->low_r_vnum; rnum <= tarea->hi_r_vnum; rnum++ )
db.c~:      for( pexit = pRoomIndex->first_exit; pexit; pexit = pexit->next )
db.c~:         if( pexit->to_room && !pexit->rexit )
db.c~:            rev_exit = get_exit_to( pexit->to_room, rev_dir[pexit->vdir], pRoomIndex->vnum );
db.c~:               pexit->rexit = rev_exit;
db.c~:               rev_exit->rexit = pexit;
db.c~:   fprintf( stderr, "%-14s: Rooms: %5d - %-5d Objs: %5d - %-5d Mobs: %5d - %d\n",
db.c~:            tarea->filename,
db.c~:            tarea->low_r_vnum, tarea->hi_r_vnum, tarea->low_o_vnum, tarea->hi_o_vnum, tarea->low_m_vnum, tarea->hi_m_vnum );
db.c~:   if( !tarea->author )
db.c~:      tarea->author = STRALLOC( "" );
db.c~:   SET_BIT( tarea->status, AREA_LOADED );
db.c~:               if( !ed->keyword )
db.c~:                  STRFREE( ed->description );
db.c~:               if( !ed->description )
db.c~:                  ed->description = STRALLOC( "" );
db.c~:            KEY( "ExDescKey", ed->keyword, fread_string( fp ) );
db.c~:            KEY( "ExDesc", ed->description, fread_string( fp ) );
db.c~:      paf->type = fread_number( fp );
db.c~:         paf->type = sn;
db.c~:   paf->duration = fread_number( fp );
db.c~:   paf->location = fread_number( fp );
db.c~:   paf->bitvector = fread_number( fp );
db.c~:   if( paf->location == APPLY_WEAPONSPELL
db.c~:       || paf->location == APPLY_WEARSPELL
db.c~:       || paf->location == APPLY_STRIPSN || paf->location == APPLY_REMOVESPELL )
db.c~:      paf->modifier = slot_lookup( pafmod );
db.c~:      paf->modifier = pafmod;
db.c~:               if( !pexit->description )
db.c~:                  pexit->description = STRALLOC( "" );
db.c~:               if( !pexit->keyword )
db.c~:                  pexit->keyword = STRALLOC( "" );
db.c~:            KEY( "Desc", pexit->description, fread_string( fp ) );
db.c~:            KEY( "Distance", pexit->distance, fread_number( fp ) );
db.c~:                  bug( "%s: vnum %d has bad door number %d.", __FUNCTION__, pRoomIndex->vnum, door );
db.c~:                     SET_BIT( pexit->exit_info, 1 << value );
db.c~:            KEY( "Key", pexit->key, fread_number( fp ) );
db.c~:            KEY( "Keywords", pexit->keyword, fread_string( fp ) );
db.c~:            KEY( "ToRoom", pexit->vnum, fread_number( fp ) );
db.c~:               mprg->next = prog_target->mudprogs;
db.c~:               prog_target->mudprogs = mprg;
db.c~:                     mprg->arglist = fread_string( progfile );
db.c~:                     mprg->fileprog = true;
db.c~:                     switch ( mprg->type )
db.c~:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c~:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c~:               mprg->arglist = fread_string( fp );
db.c~:               mprg->fileprog = false;
db.c~:               switch ( mprg->type )
db.c~:                     rprog_file_read( prog_target, mprg->arglist );
db.c~:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c~:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c~:               SET_BIT( prog_target->progtypes, mprg->type );
db.c~:               if( !pRoomIndex->description )
db.c~:                  pRoomIndex->description = STRALLOC( "" );
db.c~:                  int iHash = pRoomIndex->vnum % MAX_KEY_HASH;
db.c~:                  pRoomIndex->next = room_index_hash[iHash];
db.c~:                  LINK( pRoomIndex, tarea->first_room, tarea->last_room, next_aroom, prev_aroom );
db.c~:                  LINK( ed, pRoomIndex->first_extradesc, pRoomIndex->last_extradesc, next, prev );
db.c~:               mprg->next = pRoomIndex->mudprogs;
db.c~:               pRoomIndex->mudprogs = mprg;
db.c~:                  LINK( af, pRoomIndex->first_permaffect, pRoomIndex->last_permaffect, next, prev );
db.c~:            KEY( "Desc", pRoomIndex->description, fread_string( fp ) );
db.c~:                     SET_BIT( pRoomIndex->room_flags, 1 << value );
db.c~:            KEY( "Name", pRoomIndex->name, fread_string( fp ) );
db.c~:                  bug( "%s: Room #%d has bad sector type.", __FUNCTION__, pRoomIndex->vnum );
db.c~:               pRoomIndex->sector_type = sector;
db.c~:               pRoomIndex->tele_delay = x1;
db.c~:               pRoomIndex->tele_vnum = x2;
db.c~:               pRoomIndex->tunnel = x3;
db.c~:               pRoomIndex->vnum = vnum;
db.c~:               pRoomIndex->area = tarea;
db.c~:                  if( !tarea->low_r_vnum )
db.c~:                     tarea->low_r_vnum = vnum;
db.c~:                  if( vnum > tarea->hi_r_vnum )
db.c~:                     tarea->hi_r_vnum = vnum;
db.c~:               mprg->next = prog_target->mudprogs;
db.c~:               prog_target->mudprogs = mprg;
db.c~:                     mprg->arglist = fread_string( progfile );
db.c~:                     mprg->fileprog = true;
db.c~:                     switch ( mprg->type )
db.c~:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c~:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c~:               mprg->arglist = fread_string( fp );
db.c~:               mprg->fileprog = false;
db.c~:               switch ( mprg->type )
db.c~:                     oprog_file_read( prog_target, mprg->arglist );
db.c~:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c~:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c~:               SET_BIT( prog_target->progtypes, 1 << mprg->type );
db.c~:               if( !pObjIndex->description )
db.c~:                  pObjIndex->description = STRALLOC( "" );
db.c~:               if( !pObjIndex->action_desc )
db.c~:                  pObjIndex->action_desc = STRALLOC( "" );
db.c~:                  int iHash = pObjIndex->vnum % MAX_KEY_HASH;
db.c~:                  pObjIndex->next = obj_index_hash[iHash];
db.c~:                  LINK( ed, pObjIndex->first_extradesc, pObjIndex->last_extradesc, next, prev );
db.c~:               mprg->next = pObjIndex->mudprogs;
db.c~:               pObjIndex->mudprogs = mprg;
db.c~:            KEY( "Action", pObjIndex->action_desc, fread_string( fp ) );
db.c~:                  LINK( af, pObjIndex->first_affect, pObjIndex->last_affect, next, prev );
db.c~:                     SET_BIT( pObjIndex->extra_flags, 1 << value );
db.c~:            KEY( "Keywords", pObjIndex->name, fread_string( fp ) );
db.c~:            KEY( "Long", pObjIndex->description, fread_string( fp ) );
db.c~:            KEY( "Short", pObjIndex->short_descr, fread_string( fp ) );
db.c~:               switch ( pObjIndex->item_type )
db.c~:                     pObjIndex->value[1] = skill_lookup( fread_word( fp ) );
db.c~:                     pObjIndex->value[2] = skill_lookup( fread_word( fp ) );
db.c~:                     pObjIndex->value[3] = skill_lookup( fread_word( fp ) );
db.c~:                     pObjIndex->value[3] = skill_lookup( fread_word( fp ) );
db.c~:                     pObjIndex->value[4] = skill_lookup( fread_word( fp ) );
db.c~:                     pObjIndex->value[5] = skill_lookup( fread_word( fp ) );
db.c~:               pObjIndex->weight = x1;
db.c~:               pObjIndex->cost = x2;
db.c~:               pObjIndex->rent = x3;
db.c~:               pObjIndex->level = x4;
db.c~:               pObjIndex->layers = x5;
db.c~:                  bug( "%s: vnum %d: Object has invalid type! Defaulting to trash.", __FUNCTION__, pObjIndex->vnum );
db.c~:               pObjIndex->item_type = value;
db.c~:               pObjIndex->value[0] = x1;
db.c~:               pObjIndex->value[1] = x2;
db.c~:               pObjIndex->value[2] = x3;
db.c~:               pObjIndex->value[3] = x4;
db.c~:               pObjIndex->value[4] = x5;
db.c~:               pObjIndex->value[5] = x6;
db.c~:               pObjIndex->vnum = vnum;
db.c~:                  if( !tarea->low_o_vnum )
db.c~:                     tarea->low_o_vnum = vnum;
db.c~:                  if( vnum > tarea->hi_o_vnum )
db.c~:                     tarea->hi_o_vnum = vnum;
db.c~:                     SET_BIT( pObjIndex->wear_flags, 1 << value );
db.c~:               mprg->next = prog_target->mudprogs;
db.c~:               prog_target->mudprogs = mprg;
db.c~:                     mprg->arglist = fread_string( progfile );
db.c~:                     mprg->fileprog = true;
db.c~:                     switch ( mprg->type )
db.c~:                  KEY( "Comlist", mprg->comlist, fread_string( progfile ) );
db.c~:                     mprg->type = mprog_name_to_type( fread_flagstring( progfile ) );
db.c~:               mprg->arglist = fread_string( fp );
db.c~:               mprg->fileprog = false;
db.c~:               switch ( mprg->type )
db.c~:                     mprog_file_read( prog_target, mprg->arglist );
db.c~:            KEY( "Comlist", mprg->comlist, fread_string( fp ) );
db.c~:               mprg->type = mprog_name_to_type( fread_flagstring( fp ) );
db.c~:               SET_BIT( prog_target->progtypes, 1 << mprg->type );
db.c~:               mprg->next = pMobIndex->mudprogs;
db.c~:               pMobIndex->mudprogs = mprg;
db.c~:               if( !pMobIndex->long_descr )
db.c~:                  pMobIndex->long_descr = STRALLOC( "" );
db.c~:               if( !pMobIndex->description )
db.c~:                  pMobIndex->description = STRALLOC( "" );
db.c~:                  int iHash = pMobIndex->vnum % MAX_KEY_HASH;
db.c~:                  pMobIndex->next = mob_index_hash[iHash];
db.c~:                     SET_BIT( pMobIndex->act, 1 << value );
db.c~:                     SET_BIT( pMobIndex->affected_by, 1 << value );
db.c~:                     SET_BIT( pMobIndex->attacks, 1 << value );
db.c~:               pMobIndex->perm_str = x1;
db.c~:               pMobIndex->perm_int = x2;
db.c~:               pMobIndex->perm_wis = x3;
db.c~:               pMobIndex->perm_dex = x4;
db.c~:               pMobIndex->perm_con = x5;
db.c~:               pMobIndex->perm_cha = x6;
db.c~:               pMobIndex->perm_lck = x7;
db.c~:               pMobIndex->perm_frc = x8;
db.c~:                     SET_BIT( pMobIndex->xflags, 1 << value );
db.c~:                     SET_BIT( pMobIndex->defenses, 1 << value );
db.c~:                       pMobIndex->vnum );
db.c~:               pMobIndex->defposition = position;
db.c~:            KEY( "Desc", pMobIndex->description, fread_string( fp ) );
db.c~:                  bug( "%s: vnum %d: Mobile has invalid sex! Defaulting to neuter.", __FUNCTION__, pMobIndex->vnum );
db.c~:               pMobIndex->sex = sex;
db.c~:                     SET_BIT( pMobIndex->immune, 1 << value );
db.c~:            KEY( "Keywords", pMobIndex->player_name, fread_string( fp ) );
db.c~:            KEY( "Long", pMobIndex->long_descr, fread_string( fp ) );
db.c~:                  bug( "%s: vnum %d: Mobile in invalid position! Defaulting to standing.", __FUNCTION__, pMobIndex->vnum );
db.c~:               pMobIndex->position = position;
db.c~:                  bug( "%s: vnum %d: Mob has invalid race! Defaulting to human.", __FUNCTION__, pMobIndex->vnum );
db.c~:               pMobIndex->race = race;
db.c~:               rShop->keeper = pMobIndex->vnum;
db.c~:                  rShop->fix_type[iFix] = fread_number( fp );
db.c~:               rShop->profit_fix = fread_number( fp );
db.c~:               rShop->shop_type = fread_number( fp );
db.c~:               rShop->open_hour = fread_number( fp );
db.c~:               rShop->close_hour = fread_number( fp );
db.c~:               pMobIndex->rShop = rShop;
db.c~:                     SET_BIT( pMobIndex->resistant, 1 << value );
db.c~:               pMobIndex->saving_poison_death = x1;
db.c~:               pMobIndex->saving_wand = x2;
db.c~:               pMobIndex->saving_para_petri = x3;
db.c~:               pMobIndex->saving_breath = x4;
db.c~:               pMobIndex->saving_spell_staff = x5;
db.c~:            KEY( "Short", pMobIndex->short_descr, fread_string( fp ) );
db.c~:               pShop->keeper = pMobIndex->vnum;
db.c~:                  pShop->buy_type[iTrade] = fread_number( fp );
db.c~:               pShop->profit_buy = fread_number( fp );
db.c~:               pShop->profit_sell = fread_number( fp );
db.c~:               pShop->profit_buy = URANGE( pShop->profit_sell + 5, pShop->profit_buy, 1000 );
db.c~:               pShop->profit_sell = URANGE( 0, pShop->profit_sell, pShop->profit_buy - 5 );
db.c~:               pShop->open_hour = fread_number( fp );
db.c~:               pShop->close_hour = fread_number( fp );
db.c~:               pMobIndex->pShop = pShop;
db.c~:                     SET_BIT( pMobIndex->speaks, 1 << value );
db.c~:               if( !pMobIndex->speaks )
db.c~:                  pMobIndex->speaks = LANG_COMMON;
db.c~:                     SET_BIT( pMobIndex->speaking, 1 << value );
db.c~:               if( !pMobIndex->speaking )
db.c~:                  pMobIndex->speaking = LANG_COMMON;
db.c~:               if( !( pMobIndex->spec_fun = spec_lookup( temp ) ) )
db.c~:                  bug( "%s: Specfun: vnum %d, no spec_fun called %s.", __FUNCTION__, pMobIndex->vnum, temp );
db.c~:                  pMobIndex->spec_funname = NULL;
db.c~:                  pMobIndex->spec_funname = STRALLOC( temp );
db.c~:               if( !( pMobIndex->spec_2 = spec_lookup( temp ) ) )
db.c~:                  bug( "%s: Specfun: vnum %d, no spec_fun called %s.", __FUNCTION__, pMobIndex->vnum, temp );
db.c~:                  pMobIndex->spec_funname2 = NULL;
db.c~:                  pMobIndex->spec_funname2 = STRALLOC( temp );
db.c~:               pMobIndex->alignment = x1;
db.c~:               pMobIndex->level = x2;
db.c~:               pMobIndex->mobthac0 = x3;
db.c~:               pMobIndex->ac = x4;
db.c~:               pMobIndex->gold = x5;
db.c~:               pMobIndex->exp = x6;
db.c~:               pMobIndex->hitnodice = x1;
db.c~:               pMobIndex->hitsizedice = x2;
db.c~:               pMobIndex->hitplus = x3;
db.c~:               pMobIndex->damnodice = x1;
db.c~:               pMobIndex->damsizedice = x2;
db.c~:               pMobIndex->damplus = x3;
db.c~:               pMobIndex->height = x1;
db.c~:               pMobIndex->weight = x2;
db.c~:               pMobIndex->numattacks = x3;
db.c~:               pMobIndex->hitroll = x4;
db.c~:               pMobIndex->damroll = x5;
db.c~:                     SET_BIT( pMobIndex->susceptible, 1 << value );
db.c~:                     SET_BIT( pMobIndex->vip_flags, 1 << value );
db.c~:               pMobIndex->vnum = vnum;
db.c~:                  if( !tarea->low_m_vnum )
db.c~:                     tarea->low_m_vnum = vnum;
db.c~:                  if( vnum > tarea->hi_m_vnum )
db.c~:                     tarea->hi_m_vnum = vnum;
db.c~:               tarea->age = tarea->reset_frequency;
db.c~:            KEY( "Author", tarea->author, fread_string( fp ) );
db.c~:               tarea->high_economy = fread_number( fp );
db.c~:               tarea->low_economy = fread_number( fp );
db.c~:                     SET_BIT( tarea->flags, 1 << value );
db.c~:            KEY( "Name", tarea->name, fread_string_nohash( fp ) );
db.c~:               tarea->low_soft_range = x1;
db.c~:               tarea->hi_soft_range = x2;
db.c~:               tarea->low_hard_range = x3;
db.c~:               tarea->hi_hard_range = x4;
db.c~:            KEY( "ResetMsg", tarea->resetmsg, fread_string_nohash( fp ) );
db.c~:            KEY( "ResetFreq", tarea->reset_frequency, fread_number( fp ) );
db.c~:            KEY( "Version", tarea->version, fread_number( fp ) );
db.c~:   pArea->first_room = pArea->last_room = NULL;
db.c~:   pArea->name = NULL;
db.c~:   pArea->author = NULL;
db.c~:   pArea->filename = str_dup( strArea );
db.c~:   pArea->age = 15;
db.c~:   pArea->reset_frequency = 15;
db.c~:   pArea->nplayer = 0;
db.c~:   pArea->low_r_vnum = 0;
db.c~:   pArea->low_o_vnum = 0;
db.c~:   pArea->low_m_vnum = 0;
db.c~:   pArea->hi_r_vnum = 0;
db.c~:   pArea->hi_o_vnum = 0;
db.c~:   pArea->hi_m_vnum = 0;
db.c~:   pArea->low_soft_range = 0;
db.c~:   pArea->hi_soft_range = MAX_LEVEL;
db.c~:   pArea->low_hard_range = 0;
db.c~:   pArea->hi_hard_range = MAX_LEVEL;
db.c~:   pArea->version = 1;
db.c~:   // New FUSS area format support -- Samson 7/5/07
db.c~:         DISPOSE( tarea->name );
db.c~:         tarea->name = fread_string_nohash( fpArea );
db.c~: * them out of the area files. -- Altrag */
db.c~:      if( dentry->d_name[0] != '.' )
db.c~:         sprintf( buf, "%s%s", GOD_DIR, dentry->d_name );
db.c~:                  sprintf( buf, "%s: God file with level %d < %d", dentry->d_name, low, LEVEL_AVATAR );
db.c~:            sprintf( buf, "%s%s.are", BUILD_DIR, dentry->d_name );
db.c~:               sprintf( buf, "Make_buildlist: %s.are: no #AREA found.", dentry->d_name );
db.c~:            sprintf( buf, "%s.are", dentry->d_name );
db.c~:            pArea->author = STRALLOC( dentry->d_name );
db.c~:            pArea->filename = str_dup( buf );
db.c~:            pArea->name = fread_string_nohash( fp );
db.c~:            sprintf( buf, "{PROTO} %s's area in progress", dentry->d_name );
db.c~:            pArea->name = str_dup( buf );
db.c~:            pArea->low_r_vnum = rlow;
db.c~:            pArea->hi_r_vnum = rhi;
db.c~:            pArea->low_m_vnum = mlow;
db.c~:            pArea->hi_m_vnum = mhi;
db.c~:            pArea->low_o_vnum = olow;
db.c~:            pArea->hi_o_vnum = ohi;
db.c~:            pArea->low_soft_range = -1;
db.c~:            pArea->hi_soft_range = -1;
db.c~:            pArea->low_hard_range = -1;
db.c~:            pArea->hi_hard_range = -1;
db.c~:            pArea->first_room = pArea->last_room = NULL;
db.c~:            SET_BIT( pArea->flags, AFLAG_PROTOTYPE );
db.c~:            fprintf( stderr, "%-14s: Rooms: %5d - %-5d Objs: %5d - %-5d "
db.c~:                     "Mobs: %5d - %-5d\n",
db.c~:                     pArea->filename,
db.c~:                     pArea->low_r_vnum, pArea->hi_r_vnum,
db.c~:                     pArea->low_o_vnum, pArea->hi_o_vnum, pArea->low_m_vnum, pArea->hi_m_vnum );
db.c~: *      - 4/27/97, Fireblade
db.c~:   for( temp_area = first_area_name; temp_area; temp_area = temp_area->next_sort_name )
db.c~:      if( strcmp( pArea->name, temp_area->name ) < 0 )
db.c~: * Sort by room vnums					-Altrag & Thoric
db.c~:   pArea->next_sort = NULL;
db.c~:   pArea->prev_sort = NULL;
db.c~:      pArea->prev_sort = NULL;
db.c~:      pArea->next_sort = NULL;
db.c~:      for( area = first_sort; area; area = area->next_sort )
db.c~:         if( pArea->low_r_vnum < area->low_r_vnum )
db.c~:            if( !area->prev_sort )
db.c~:               area->prev_sort->next_sort = pArea;
db.c~:            pArea->prev_sort = area->prev_sort;
db.c~:            pArea->next_sort = area;
db.c~:            area->prev_sort = pArea;
db.c~:      pArea->prev_sort = last_sort;
db.c~:      pArea->next_sort = NULL;
db.c~:      last_sort->next_sort = pArea;
db.c~: * Display vnums currently assigned to areas		-Altrag & Thoric
db.c~:   for( pArea = first_sort; pArea; pArea = pArea->next_sort )
db.c~:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c~:      if( pArea->low_r_vnum < low )
db.c~:      if( pArea->hi_r_vnum > high )
db.c~:      if( IS_SET( pArea->status, AREA_LOADED ) )
db.c~:      pager_printf( ch, "%-15s| Rooms: %5d - %-5d"
db.c~:                    " Objs: %5d - %-5d Mobs: %5d - %-5d%s\r\n",
db.c~:                    ( pArea->filename ? pArea->filename : "(invalid)" ),
db.c~:                    pArea->low_r_vnum, pArea->hi_r_vnum,
db.c~:                    pArea->low_o_vnum, pArea->hi_o_vnum,
db.c~:                    pArea->low_m_vnum, pArea->hi_m_vnum, IS_SET( pArea->status, AREA_LOADED ) ? loadst : notloadst );
db.c~:   sys->time_of_max = NULL;
db.c~:            KEY( "Build", sys->build_level, fread_number( fp ) );
db.c~:            KEY( "Damplrvsplr", sys->dam_plr_vs_plr, fread_number( fp ) );
db.c~:            KEY( "Damplrvsmob", sys->dam_plr_vs_mob, fread_number( fp ) );
db.c~:            KEY( "Dammobvsplr", sys->dam_mob_vs_plr, fread_number( fp ) );
db.c~:            KEY( "Dammobvsmob", sys->dam_mob_vs_mob, fread_number( fp ) );
db.c~:               if( !sys->time_of_max )
db.c~:                  sys->time_of_max = str_dup( "(not recorded)" );
db.c~:            KEY( "Forcepc", sys->level_forcepc, fread_number( fp ) );
db.c~:            KEY( "Guildoverseer", sys->guild_overseer, fread_string_nohash( fp ) );
db.c~:            KEY( "Guildadvisor", sys->guild_advisor, fread_string_nohash( fp ) );
db.c~:            KEY( "Highplayers", sys->alltimemax, fread_number( fp ) );
db.c~:            KEY( "Highplayertime", sys->time_of_max, fread_string_nohash( fp ) );
db.c~:            KEY( "Log", sys->log_level, fread_number( fp ) );
db.c~:            KEY( "Msetplayer", sys->level_mset_player, fread_number( fp ) );
db.c~:            KEY( "Muse", sys->muse_level, fread_number( fp ) );
db.c~:            KEY( "Nameresolving", sys->NO_NAME_RESOLVING, fread_number( fp ) );
db.c~:            KEY( "Overridepriv", sys->level_override_private, fread_number( fp ) );
db.c~:            KEY( "Protoflag", sys->level_modify_proto, fread_number( fp ) );
db.c~:            KEY( "Readallmail", sys->read_all_mail, fread_number( fp ) );
db.c~:            KEY( "Readmailfree", sys->read_mail_free, fread_number( fp ) );
db.c~:            KEY( "Stunplrvsplr", sys->stun_plr_vs_plr, fread_number( fp ) );
db.c~:            KEY( "Stunregular", sys->stun_regular, fread_number( fp ) );
db.c~:            KEY( "Saveflags", sys->save_flags, fread_number( fp ) );
db.c~:            KEY( "Savefreq", sys->save_frequency, fread_number( fp ) );
db.c~:            KEY( "Takeothersmail", sys->take_others_mail, fread_number( fp ) );
db.c~:            KEY( "Think", sys->think_level, fread_number( fp ) );
db.c~:            KEY( "Waitforauth", sys->WAIT_FOR_AUTH, fread_number( fp ) );
db.c~:            KEY( "Writemailfree", sys->write_mail_free, fread_number( fp ) );
db.c~:         bug( "Load_banlist: no -1 found." );
db.c~:      if( number == -1 )
db.c~:      pban->level = number;
db.c~:      pban->name = fread_string_nohash( fp );
db.c~:         pban->ban_time = fread_string_nohash( fp );
db.c~:         pban->ban_time = str_dup( "(unrecorded)" );
db.c~:/* Check to make sure range of vnums is free - Scryn 2/27/96 */
db.c~:   for( pArea = first_asort; pArea; pArea = pArea->next_sort )
db.c~:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c~:         if( low_range < pArea->low_r_vnum && pArea->low_r_vnum < high_range )
db.c~:         if( low_range < pArea->hi_r_vnum && pArea->hi_r_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_r_vnum ) && ( low_range <= pArea->hi_r_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_r_vnum ) && ( high_range >= pArea->low_r_vnum ) )
db.c~:         if( low_range < pArea->low_m_vnum && pArea->low_m_vnum < high_range )
db.c~:         if( low_range < pArea->hi_m_vnum && pArea->hi_m_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_m_vnum ) && ( low_range <= pArea->hi_m_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_m_vnum ) && ( high_range >= pArea->low_m_vnum ) )
db.c~:         if( low_range < pArea->low_o_vnum && pArea->low_o_vnum < high_range )
db.c~:         if( low_range < pArea->hi_o_vnum && pArea->hi_o_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_o_vnum ) && ( low_range <= pArea->hi_o_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_o_vnum ) && ( high_range >= pArea->low_o_vnum ) )
db.c~:         sprintf( buf, "Conflict:%-15s| ", ( pArea->filename ? pArea->filename : "(invalid)" ) );
db.c~:            sprintf( buf2, "Rooms: %5d - %-5d\r\n", pArea->low_r_vnum, pArea->hi_r_vnum );
db.c~:            sprintf( buf2, "Mobs: %5d - %-5d\r\n", pArea->low_m_vnum, pArea->hi_m_vnum );
db.c~:            sprintf( buf2, "Objects: %5d - %-5d\r\n", pArea->low_o_vnum, pArea->hi_o_vnum );
db.c~:   for( pArea = first_bsort; pArea; pArea = pArea->next_sort )
db.c~:      if( IS_SET( pArea->status, AREA_DELETED ) )
db.c~:         if( low_range < pArea->low_r_vnum && pArea->low_r_vnum < high_range )
db.c~:         if( low_range < pArea->hi_r_vnum && pArea->hi_r_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_r_vnum ) && ( low_range <= pArea->hi_r_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_r_vnum ) && ( high_range >= pArea->low_r_vnum ) )
db.c~:         if( low_range < pArea->low_m_vnum && pArea->low_m_vnum < high_range )
db.c~:         if( low_range < pArea->hi_m_vnum && pArea->hi_m_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_m_vnum ) && ( low_range <= pArea->hi_m_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_m_vnum ) && ( high_range >= pArea->low_m_vnum ) )
db.c~:         if( low_range < pArea->low_o_vnum && pArea->low_o_vnum < high_range )
db.c~:         if( low_range < pArea->hi_o_vnum && pArea->hi_o_vnum < high_range )
db.c~:         if( ( low_range >= pArea->low_o_vnum ) && ( low_range <= pArea->hi_o_vnum ) )
db.c~:         if( ( high_range <= pArea->hi_o_vnum ) && ( high_range >= pArea->low_o_vnum ) )
db.c~:         sprintf( buf, "Conflict:%-15s| ", ( pArea->filename ? pArea->filename : "(invalid)" ) );
db.c~:            sprintf( buf2, "Rooms: %5d - %-5d\r\n", pArea->low_r_vnum, pArea->hi_r_vnum );
db.c~:            sprintf( buf2, "Mobs: %5d - %-5d\r\n", pArea->low_m_vnum, pArea->hi_m_vnum );
db.c~:            sprintf( buf2, "Objects: %5d - %-5d\r\n", pArea->low_o_vnum, pArea->hi_o_vnum );
db.c~:    for ( pArea = first_asort; pArea; pArea = pArea->next_sort )
db.c~:	if ( IS_SET( pArea->status, AREA_DELETED ) )
db.c~:	  if((pArea->low_r_vnum >= low_range) 
db.c~:	  && (pArea->hi_r_vnum <= high_range))
db.c~:	  if((pArea->low_m_vnum >= low_range) 
db.c~:	  && (pArea->hi_m_vnum <= high_range))
db.c~:	  if((pArea->low_o_vnum >= low_range) 
db.c~:	  && (pArea->hi_o_vnum <= high_range))
db.c~:	  ch_printf(ch, "Conflict:%-15s| Rooms: %5d - %-5d"
db.c~:		     " Objs: %5d - %-5d Mobs: %5d - %-5d\r\n",
db.c~:		(pArea->filename ? pArea->filename : "(invalid)"),
db.c~:		pArea->low_r_vnum, pArea->hi_r_vnum,
db.c~:		pArea->low_o_vnum, pArea->hi_o_vnum,
db.c~:		pArea->low_m_vnum, pArea->hi_m_vnum );
db.c~:    for ( pArea = first_bsort; pArea; pArea = pArea->next_sort )
db.c~:	if ( IS_SET( pArea->status, AREA_DELETED ) )
db.c~:	  if((pArea->low_r_vnum >= low_range) 
db.c~:	  && (pArea->hi_r_vnum <= high_range))
db.c~:	  if((pArea->low_m_vnum >= low_range) 
db.c~:	  && (pArea->hi_m_vnum <= high_range))
db.c~:	  if((pArea->low_o_vnum >= low_range) 
db.c~:	  && (pArea->hi_o_vnum <= high_range))
db.c~:	  sprintf(ch, "Conflict:%-15s| Rooms: %5d - %-5d"
db.c~:		     " Objs: %5d - %-5d Mobs: %5d - %-5d\r\n",
db.c~:		(pArea->filename ? pArea->filename : "(invalid)"),
db.c~:		pArea->low_r_vnum, pArea->hi_r_vnum,
db.c~:		pArea->low_o_vnum, pArea->hi_o_vnum,
db.c~:		pArea->low_m_vnum, pArea->hi_m_vnum );
db.c~: * -- Furey
db.c~:  if( n != 0 && --n != 0 )
db.c~:      while( --n != 0 );
db.c~:	*d = '\0';  /* NUL-terminate dst */
db.c~:  return ( s - src - 1 ); /* count does not include NUL */
db.c~:  while( n-- != 0 && *d != '\0' )
db.c~:  dlen = d - dst;
db.c~:  n = siz - dlen;
db.c~:	  n--;
db.c~:  return ( dlen + ( s - src ) );   /* count does not include NUL */
db.c~:        if( ln >= ( MAX_STRING_LENGTH - 1 ) )
dns.c: *                   ^     +----- |  / ^     ^ |     | +-\                  *
dns.c: *                 /   \   +---   |<   | \ / | |     | |  |                 *
dns.c: *                /-----\  |      | \  |  v  | |     | |  /                 *
dns.c: *               /       \ |      |  \ |     | +-----+ +-/                  *
dns.c: * AFKMud Copyright 1997-2002 Alsherok. Contributors: Samson, Dwip, Whir,   *
dns.c:      cache_next = cache->next;
dns.c:      if( current_time - cache->time >= 1209600 || !str_cmp( cache->ip, "Unknown??" )
dns.c:          || !str_cmp( cache->name, "Unknown??" ) )
dns.c:         STRFREE( cache->ip );
dns.c:         STRFREE( cache->name );
dns.c:   cache->ip = STRALLOC( dhost );
dns.c:   cache->name = STRALLOC( address );
dns.c:   cache->time = current_time;
dns.c:   for( cache = first_cache; cache; cache = cache->next )
dns.c:      if( !str_cmp( ip, cache->ip ) )
dns.c:         strncpy( dnsbuf, cache->name, MAX_STRING_LENGTH );
dns.c:               if( !cache->ip )
dns.c:                  cache->ip = STRALLOC( "Unknown??" );
dns.c:               if( !cache->name )
dns.c:                  cache->name = STRALLOC( "Unknown??" );
dns.c:            KEY( "IP", cache->ip, fread_string( fp ) );
dns.c:            KEY( "Name", cache->name, fread_string( fp ) );
dns.c:            KEY( "Time", cache->time, fread_number( fp ) );
dns.c:      for( cache = first_cache; cache; cache = cache->next )
dns.c:         fprintf( fp, "IP		%s~\n", cache->ip );
dns.c:         fprintf( fp, "Name		%s~\n", cache->name );
dns.c:         fprintf( fp, "Time		%ld\n", cache->time );
dns.c:   if( iStart >= sizeof( inbuf ) - 10 )
dns.c:      nRead = read( fd, inbuf + iStart, sizeof( inbuf ) - 10 - iStart );
dns.c:         if( inbuf[iStart - 2] == '\n' || inbuf[iStart - 2] == '\r' )
dns.c:         --k;
dns.c:   if( !read_from_dns( d->ifd, address ) || address[0] == '\0' )
dns.c:      add_dns( d->host, address );  /* Add entry to DNS cache */
dns.c:      STRFREE( d->host );
dns.c:      d->host = STRALLOC( address );
dns.c:   if( d->ifd != -1 )
dns.c:      close( d->ifd );
dns.c:      d->ifd = -1;
dns.c:   if( d->ipid != -1 )
dns.c:      waitpid( d->ipid, &status, 0 );
dns.c:      d->ipid = -1;
dns.c:      d->ifd = fds[0];
dns.c:      d->ipid = pid;
dns.c:      d->ifd = fds[0];
dns.c:      d->ipid = pid;
dns.c:       * Still here --> hmm. An error. 
dns.c:      d->ifd = -1;
dns.c:      d->ipid = -1;
dns.c:   send_to_pager( "------------------------------------------------------------------------------\r\n", ch );
dns.c:   for( cache = first_cache; cache; cache = cache->next )
dns.c:      pager_printf( ch, "&W%16.16s  &Y%s\r\n", cache->ip, cache->name );
dns.h: *                   ^     +----- |  / ^     ^ |     | +-\                  *
dns.h: *                 /   \   +---   |<   | \ / | |     | |  |                 *
dns.h: *                /-----\  |      | \  |  v  | |     | |  /                 *
dns.h: *               /       \ |      |  \ |     | +-----+ +-/                  *
dns.h: * AFKMud Copyright 1997-2002 Alsherok. Contributors: Samson, Dwip, Whir,   *
fight.c:*--------------------------------------------------------------------------*
fight.c:* -------------------------------------------------------------------------*
fight.c:*--------------------------------------------------------------------------*
fight.c:* ------------------------------------------------------------------------ *
fight.c:* ------------------------------------------------------------------------ *
fight.c:   int oldgold = ch->gold;
fight.c:   for( content = corpse->first_content; content; content = content_next )
fight.c:      content_next = content->next_content;
fight.c:      if( content->item_type != ITEM_MONEY )
fight.c:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->top_level < sysdata.level_getobjnotake )
fight.c:      ch->gold += content->value[0] * content->count;
fight.c:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c:   if( ( obj = get_eq_char( ch, WEAR_WIELD ) ) && ( IS_SET( obj->extra_flags, ITEM_POISONED ) ) )
fight.c: * hunting, hating and fearing code				-Thoric
fight.c:   if( !ch->hunting || ch->hunting->who != victim )
fight.c:   if( !ch->hating || ch->hating->who != victim )
fight.c:   if( !ch->fearing || ch->fearing->who != victim )
fight.c:   if( ch->hunting )
fight.c:      STRFREE( ch->hunting->name );
fight.c:      DISPOSE( ch->hunting );
fight.c:      ch->hunting = NULL;
fight.c:   if( ch->hating )
fight.c:      STRFREE( ch->hating->name );
fight.c:      DISPOSE( ch->hating );
fight.c:      ch->hating = NULL;
fight.c:   if( ch->fearing )
fight.c:      STRFREE( ch->fearing->name );
fight.c:      DISPOSE( ch->fearing );
fight.c:      ch->fearing = NULL;
fight.c:   if( ch->hunting )
fight.c:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:   ch->hunting->name = QUICKLINK( victim->name );
fight.c:   ch->hunting->who = victim;
fight.c:   if( ch->hating )
fight.c:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c:   ch->hating->name = QUICKLINK( victim->name );
fight.c:   ch->hating->who = victim;
fight.c:   if( ch->fearing )
fight.c:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:   ch->fearing->name = QUICKLINK( victim->name );
fight.c:   ch->fearing->who = victim;
fight.c:      if( ch == first_char && ch->prev )
fight.c:         bug( "ERROR: first_char->prev != NULL, fixing...", 0 );
fight.c:         ch->prev = NULL;
fight.c:      gch_prev = ch->prev;
fight.c:      if( gch_prev && gch_prev->next != ch )
fight.c:         sprintf( buf, "FATAL: violence_update: %s->prev->next doesn't point to ch.", ch->name );
fight.c:         bug( "Short-cutting here", 0 );
fight.c:         ch->prev = NULL;
fight.c:      if( !ch->in_room || !ch->name )
fight.c:         sprintf( buf, "ch: %ld  ch->in_room: %ld  ch->prev: %ld  ch->next: %ld",
fight.c:                  ( long )ch, ( long )ch->in_room, ( long )ch->prev, ( long )ch->next );
fight.c:            sprintf( buf, "lst_ch: %ld  lst_ch->prev: %ld  lst_ch->next: %ld",
fight.c:                     ( long )lst_ch, ( long )lst_ch->prev, ( long )lst_ch->next );
fight.c:      if( ch->fighting )
fight.c:         if( ( ++ch->fighting->duration % 24 ) == 0 )
fight.c:            ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c:         timer_next = timer->next;
fight.c:         if( --timer->count <= 0 )
fight.c:            if( timer->type == TIMER_DO_FUN )
fight.c:               tempsub = ch->substate;
fight.c:               ch->substate = timer->value;
fight.c:               ( timer->do_fun ) ( ch, "" );
fight.c:               ch->substate = tempsub;
fight.c:       * So a melee round sounds good to me... -Thoric
fight.c:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c:         paf_next = paf->next;
fight.c:         if( paf->duration > 0 )
fight.c:            paf->duration--;
fight.c:         else if( paf->duration < 0 )
fight.c:            if( !paf_next || paf_next->type != paf->type || paf_next->duration > 0 )
fight.c:               skill = get_skilltype( paf->type );
fight.c:               if( paf->type > 0 && skill && skill->msg_off )
fight.c:                  send_to_char( skill->msg_off, ch );
fight.c:            if( paf->type == gsn_possess )
fight.c:               ch->desc->character = ch->desc->original;
fight.c:               ch->desc->original = NULL;
fight.c:               ch->desc->character->desc = ch->desc;
fight.c:               ch->desc->character->switched = NULL;
fight.c:               ch->desc = NULL;
fight.c:      if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:         sprintf( buf, "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:      for( rch = ch->in_room->first_person; rch; rch = rch_next )
fight.c:         rch_next = rch->next_in_room;
fight.c:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c:             * PC's auto-assist others in their group.
fight.c:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !IS_SET( rch->act, ACT_NOASSIST ) )
fight.c:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c:                  for( vch = ch->in_room->first_person; vch; vch = vch->next )
fight.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NICE ) && !IS_NPC( victim ) )
fight.c:    * -- Altrag 
fight.c:   schance = IS_NPC( ch ) ? 100 : ( ch->pcdata->learned[gsn_berserk] * 5 / 2 );
fight.c:      dual_bonus = IS_NPC( ch ) ? ( ch->skill_level[COMBAT_ABILITY] / 10 ) : ( ch->pcdata->learned[gsn_dual_wield] / 10 );
fight.c:      schance = IS_NPC( ch ) ? ch->top_level : ch->pcdata->learned[gsn_dual_wield];
fight.c:   if( ch->move < 10 )
fight.c:      dual_bonus = -20;
fight.c:    * NPC predetermined number of attacks         -Thoric
fight.c:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ( ch->pcdata->learned[gsn_second_attack] + dual_bonus ) / 1.5 );
fight.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ( ch->pcdata->learned[gsn_third_attack] + ( dual_bonus * 1.5 ) ) / 2 );
fight.c:   schance = IS_NPC( ch ) ? ( int )( ch->top_level / 4 ) : 0;
fight.c:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c:      if( ch->move )
fight.c:         ch->move = UMAX( 0, ch->move - move );
fight.c:   *gsn_ptr = -1;
fight.c:      switch ( wield->value[3] )
fight.c:            *gsn_ptr = -1;
fight.c:      if( *gsn_ptr != -1 )
fight.c:         bonus = ( int )( ch->pcdata->learned[*gsn_ptr] );
fight.c: * -- Altrag
fight.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
fight.c:      if( paf->location == APPLY_HITROLL )
fight.c:         tohit += paf->modifier;
fight.c:   for( paf = obj->first_affect; paf; paf = paf->next )
fight.c:      if( paf->location == APPLY_HITROLL )
fight.c:         tohit += paf->modifier;
fight.c:      lvl = UMAX( 1, ( ch->skill_level[FORCE_ABILITY] ) );
fight.c:      if( number_percent(  ) + ( victim->skill_level[COMBAT_ABILITY] - lvl ) < 35 )
fight.c:      lvl = ch->top_level;
fight.c:      if( number_percent(  ) + ( victim->skill_level[COMBAT_ABILITY] - lvl ) < 70 )
fight.c:    * Guard against weird room-leavings.
fight.c:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    * Figure out the weapon doing the damage         -Thoric
fight.c:   if( ch->fighting  /* make sure fight is already started */
fight.c:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && ch->attacks != 0 )
fight.c:         if( IS_SET( ch->attacks, attacktype ) )
fight.c:      if( wield && wield->item_type == ITEM_WEAPON )
fight.c:         dt += wield->value[3];
fight.c:    * Calculate to-hit-armor-class-0 versus armor.
fight.c:   thac0 = interpolate( ch->skill_level[COMBAT_ABILITY], thac0_00, thac0_32 ) - GET_HITROLL( ch );
fight.c:      victim_ac -= 4;
fight.c:   if( ch->race == RACE_DEFEL )
fight.c:   if( diceroll == 1 || ( diceroll < 20 && diceroll < thac0 - victim_ac ) )
fight.c:      if( prof_gsn != -1 )
fight.c:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c:      dam = number_range( wield->value[1], wield->value[2] );
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:      dam += ( int )( dam * ch->pcdata->learned[gsn_enhanced_damage] / 120 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->skill_level[HUNTING_ABILITY] - ( victim->skill_level[COMBAT_ABILITY] / 4 ), 30 ) / 8 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->skill_level[HUNTING_ABILITY] - ( victim->skill_level[COMBAT_ABILITY] / 4 ), 30 ) / 16 );
fight.c:      if( IS_SET( wield->extra_flags, ITEM_MAGIC ) )
fight.c:       * Handle PLUS1 - PLUS6 ris bits vs. weapon hitroll   -Thoric
fight.c:    * check for RIS_PLUSx                -Thoric 
fight.c:      imm = res = -1;
fight.c:         if( IS_SET( victim->immune, xx ) )
fight.c:         if( IS_SET( victim->resistant, xx ) )
fight.c:         if( IS_SET( victim->susceptible, xx ) )
fight.c:         mod -= 10;
fight.c:         mod -= 2;
fight.c:         dam = -1;
fight.c:   if( victim->race == RACE_DUINUOGWUIN )
fight.c:   if( dt == ( TYPE_HIT + WEAPON_BLASTER ) && wield && wield->item_type == ITEM_WEAPON )
fight.c:      if( wield->value[4] < 1 )
fight.c:            do_remove( ch, wield->name );
fight.c:      else if( wield->blaster_setting == BLASTER_FULL && wield->value[4] >= 5 )
fight.c:	wield->value[4] -= 5;
fight.c:      else if( wield->blaster_setting == BLASTER_HIGH && wield->value[4] >= 4 )
fight.c:	wield->value[4] -= 4;
fight.c:      else if( wield->blaster_setting == BLASTER_NORMAL && wield->value[4] >= 3 )
fight.c:         wield->value[4] -= 3;
fight.c:      else if( wield->blaster_setting == BLASTER_STUN && wield->value[4] >= 5 )
fight.c:         wield->value[4] -= 3;
fight.c:         schance = ris_save( victim, ch->skill_level[COMBAT_ABILITY], RIS_PARALYSIS );
fight.c:         if( victim->was_stunned > 0 )
fight.c:            victim->was_stunned--;
fight.c:         schance = 100 - get_curr_con( victim ) - victim->skill_level[COMBAT_ABILITY] / 2;
fight.c:            schance -= sysdata.stun_plr_vs_plr;
fight.c:            schance -= sysdata.stun_regular;
fight.c:                  victim->was_stunned = 10;
fight.c:      else if( wield->blaster_setting == BLASTER_HALF && wield->value[4] >= 2 )
fight.c:	wield->value[4] -= 2;
fight.c:	wield->value[4] -= 1;
fight.c:   else if( dt == ( TYPE_HIT + WEAPON_VIBRO_BLADE ) && wield && wield->item_type == ITEM_WEAPON )
fight.c:      if( wield->value[4] < 1 )
fight.c:         act( AT_YELLOW, "Your vibro-blade needs recharging ...", ch, NULL, victim, TO_CHAR );
fight.c:   else if( dt == ( TYPE_HIT + WEAPON_FORCE_PIKE ) && wield && wield->item_type == ITEM_WEAPON )
fight.c:      if( wield->value[4] < 1 )
fight.c:         act( AT_YELLOW, "Your force-pike needs recharging ...", ch, NULL, victim, TO_CHAR );
fight.c:         wield->value[4]--;
fight.c:   else if( dt == ( TYPE_HIT + WEAPON_LIGHTSABER ) && wield && wield->item_type == ITEM_WEAPON )
fight.c:      if( wield->value[4] < 1 )
fight.c:            do_remove( ch, wield->name );
fight.c:   else if( dt == ( TYPE_HIT + WEAPON_BOWCASTER ) && wield && wield->item_type == ITEM_WEAPON )
fight.c:      if( wield->value[4] < 1 )
fight.c:            do_remove( ch, wield->name );
fight.c:         wield->value[4]--;
fight.c:   if( prof_gsn != -1 )
fight.c:   if( dam == -1 )
fight.c:         if( skill->imm_char && skill->imm_char[0] != '\0' )
fight.c:            act( AT_HIT, skill->imm_char, ch, NULL, victim, TO_CHAR );
fight.c:         if( skill->imm_vict && skill->imm_vict[0] != '\0' )
fight.c:            act( AT_HITME, skill->imm_vict, ch, NULL, victim, TO_VICT );
fight.c:         if( skill->imm_room && skill->imm_room[0] != '\0' )
fight.c:            act( AT_ACTION, skill->imm_room, ch, NULL, victim, TO_NOTVICT );
fight.c:   /* weapon spells -Thoric */
fight.c:   if( wield && !IS_SET( victim->immune, RIS_MAGIC ) && !IS_SET( victim->in_room->room_flags, ROOM_NO_MAGIC ) )
fight.c:      for( aff = wield->pIndexData->first_affect; aff; aff = aff->next )
fight.c:         if( aff->location == APPLY_WEAPONSPELL && IS_VALID_SN( aff->modifier ) && skill_table[aff->modifier]->spell_fun )
fight.c:            retcode = ( *skill_table[aff->modifier]->spell_fun ) ( aff->modifier, ( wield->level + 3 ) / 3, ch, victim );
fight.c:      for( aff = wield->first_affect; aff; aff = aff->next )
fight.c:         if( aff->location == APPLY_WEAPONSPELL && IS_VALID_SN( aff->modifier ) && skill_table[aff->modifier]->spell_fun )
fight.c:            retcode = ( *skill_table[aff->modifier]->spell_fun ) ( aff->modifier, ( wield->level + 3 ) / 3, ch, victim );
fight.c:    * magic shields that retaliate          -Thoric
fight.c:      if( owield != NULL && owield->value[3] == WEAPON_BLASTER && get_cover( victim ) == TRUE )
fight.c: *					-Thoric
fight.c:   if( IS_SET( ch->immune, ris ) )
fight.c:      modifier -= 10;
fight.c:   if( IS_SET( ch->resistant, ris ) )
fight.c:      modifier -= 2;
fight.c:   if( IS_SET( ch->susceptible, ris ) )
fight.c:      return -1;
fight.c:   if( victim->position == POS_DEAD )
fight.c:    * Check damage types for RIS            -Thoric
fight.c:      if( dam == -1 )
fight.c:            if( skill->imm_char && skill->imm_char[0] != '\0' )
fight.c:               act( AT_HIT, skill->imm_char, ch, NULL, victim, TO_CHAR );
fight.c:            if( skill->imm_vict && skill->imm_vict[0] != '\0' )
fight.c:               act( AT_HITME, skill->imm_vict, ch, NULL, victim, TO_VICT );
fight.c:            if( skill->imm_room && skill->imm_room[0] != '\0' )
fight.c:               act( AT_ACTION, skill->imm_room, ch, NULL, victim, TO_NOTVICT );
fight.c:      if( !IS_SET( victim->act, ACT_SENTINEL ) )
fight.c:         if( victim->hunting )
fight.c:            if( victim->hunting->who != ch )
fight.c:               STRFREE( victim->hunting->name );
fight.c:               victim->hunting->name = QUICKLINK( ch->name );
fight.c:               victim->hunting->who = ch;
fight.c:      if( victim->hating )
fight.c:         if( victim->hating->who != ch )
fight.c:            STRFREE( victim->hating->name );
fight.c:            victim->hating->name = QUICKLINK( ch->name );
fight.c:            victim->hating->who = ch;
fight.c:      if( victim->position > POS_STUNNED )
fight.c:         if( !victim->fighting )
fight.c:         if( victim->fighting )
fight.c:            victim->position = POS_FIGHTING;
fight.c:      if( victim->position > POS_STUNNED )
fight.c:         if( !ch->fighting )
fight.c:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c:            retcode = multi_hit( ch, victim->master, TYPE_UNDEFINED );
fight.c:      if( victim->master == ch )
fight.c:      if( IS_AFFECTED( ch, AFF_INVISIBLE ) && ch->race != RACE_DEFEL )
fight.c:         REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:         REMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c:         dam -= ( int )( dam / 4 );
fight.c:         if( IS_NPC( ch ) && IS_SET( ch->attacks, DFND_DISARM ) && number_percent(  ) < ch->skill_level[COMBAT_ABILITY] / 2 )
fight.c:         if( IS_NPC( ch ) && IS_SET( ch->attacks, ATCK_TRIP ) && number_percent(  ) < ch->skill_level[COMBAT_ABILITY] )
fight.c:    * Code to handle equipment getting damaged, and also support  -Thoric
fight.c:         dam -= 5;   /* add a bonus for having something to block the blow */
fight.c:   victim->hit -= dam;
fight.c:    * Get experience based on % of damage done       -Thoric
fight.c:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c:      xp_gain = ( int )( xp_compute( ch, victim ) * 0.1 * dam ) / victim->max_hit;
fight.c:   if( !IS_NPC( victim ) && victim->top_level >= LEVEL_IMMORTAL && victim->hit < 1 )
fight.c:      victim->hit = 1;
fight.c:   if( !IS_NPC( victim ) && NOT_AUTHED( victim ) && victim->hit < 1 )
fight.c:      victim->hit = 1;
fight.c:       && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->skill_level[COMBAT_ABILITY], victim ) )
fight.c:      af.modifier = -2;
fight.c:      victim->mental_state = URANGE( 20, victim->mental_state + 2, 100 );
fight.c:   if( !npcvict && get_trust( victim ) >= LEVEL_IMMORTAL && get_trust( ch ) >= LEVEL_IMMORTAL && victim->hit < 1 )
fight.c:      victim->hit = 1;
fight.c:   switch ( victim->position )
fight.c:            if( skill->die_char && skill->die_char[0] != '\0' )
fight.c:               act( AT_DEAD, skill->die_char, ch, NULL, victim, TO_CHAR );
fight.c:            if( skill->die_vict && skill->die_vict[0] != '\0' )
fight.c:               act( AT_DEAD, skill->die_vict, ch, NULL, victim, TO_VICT );
fight.c:            if( skill->die_room && skill->die_room[0] != '\0' )
fight.c:               act( AT_DEAD, skill->die_room, ch, NULL, victim, TO_NOTVICT );
fight.c:         if( IS_NPC( victim ) && IS_SET( victim->act, ACT_NOKILL ) )
fight.c:         else if( IS_NPC( victim ) && IS_SET( victim->act, ACT_DROID ) )
fight.c:         if( dam > victim->max_hit / 4 )
fight.c:         if( victim->hit < victim->max_hit / 4 )
fight.c:      if( victim->fighting && victim->fighting->who->hunting && victim->fighting->who->hunting->who == victim )
fight.c:         stop_hunting( victim->fighting->who );
fight.c:      if( victim->fighting && victim->fighting->who->hating && victim->fighting->who->hating->who == victim )
fight.c:         stop_hating( victim->fighting->who );
fight.c:   if( victim->hit <= 0 && !IS_NPC( victim ) )
fight.c:      REMOVE_BIT( victim->act, PLR_ATTACKER );
fight.c:      for( obj = victim->first_carrying; obj; obj = obj_next )
fight.c:         obj_next = obj->next_content;
fight.c:         if( obj->wear_loc == WEAR_NONE )
fight.c:            if( obj->pIndexData->progtypes & DROP_PROG && obj->count > 1 )
fight.c:                  obj_next = victim->first_carrying;
fight.c:               cnt += obj->count;
fight.c:            obj = obj_to_room( obj, victim->in_room );
fight.c:         lose_exp = UMAX( ( victim->experience[COMBAT_ABILITY] - exp_level( victim->skill_level[COMBAT_ABILITY] ) ), 0 );
fight.c:         victim->experience[COMBAT_ABILITY] -= lose_exp;
fight.c:   if( victim->position == POS_DEAD )
fight.c:                  victim->name, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c:          * Add to kill tracker for grouped chars, as well. -Halcyon
fight.c:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      if( !IS_NPC( victim ) || !IS_SET( victim->act, ACT_NOKILL ) )
fight.c:      if( !IS_NPC( ch ) && loot && new_corpse && new_corpse->item_type == ITEM_CORPSE_NPC
fight.c:       && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c:         if( IS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c:         if( new_corpse && !obj_extracted(new_corpse) && new_corpse->in_room == ch->in_room
fight.c:          && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:            if( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c:            if( !char_died(ch) && IS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted(new_corpse)
fight.c:             && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING
fight.c:   if( !npcvict && !victim->desc && !victim->switched )
fight.c:      if( number_range( 0, victim->wait ) == 0 )
fight.c:      if( ( IS_SET( victim->act, ACT_WIMPY ) && number_bits( 1 ) == 0
fight.c:            && victim->hit < victim->max_hit / 2 )
fight.c:          || ( IS_AFFECTED( victim, AFF_CHARM ) && victim->master && victim->master->in_room != victim->in_room ) )
fight.c:   if( !npcvict && victim->hit > 0 && victim->hit <= victim->wimpy && victim->wait == 0 )
fight.c:   else if( !npcvict && IS_SET( victim->act, PLR_FLEE ) )
fight.c:   if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) )
fight.c:    * non-charmed mobs can loot anything 
fight.c:   if( IS_NPC( ch ) && !ch->master )
fight.c:see if an attack justifies a KILLER flag --- edited so that none do but can't 
fight.c:murder a no pk person. --- edited again for planetary wanted flags -- well will be soon :p
fight.c:    * Charm-o-rama.
fight.c:   if( IS_SET( ch->affected_by, AFF_CHARM ) )
fight.c:      if( !ch->master )
fight.c:         sprintf( buf, "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         REMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:      if( ch->master )
fight.c:         check_killer( ch->master, victim );
fight.c:            if( IS_SET( victim->vip_flags, 1 << x ) )
fight.c:               SET_BIT( ch->pcdata->wanted_flags, 1 << x );
fight.c:               ch_printf( ch, "&YYou are now wanted on %s.&w\r\n", planet_flags[x], victim->short_descr );
fight.c:         if( ch->pcdata->clan )
fight.c:            ch->pcdata->clan->mkills++;
fight.c:         ch->pcdata->mkills++;
fight.c:         ch->in_room->area->mkills++;
fight.c:      if( ch->pcdata->clan )
fight.c:         ch->pcdata->clan->pkills++;
fight.c:      ch->pcdata->pkills++;
fight.c:      if( victim->pcdata->clan )
fight.c:         victim->pcdata->clan->pdeaths++;
fight.c:         victim->in_room->area->mdeaths++;
fight.c:   if( victim->hit > 0 )
fight.c:      if( victim->position <= POS_STUNNED )
fight.c:         victim->position = POS_STANDING;
fight.c:         victim->position = POS_STUNNED;
fight.c:   if( IS_NPC( victim ) || victim->hit <= -500 )
fight.c:      if( victim->mount )
fight.c:         act( AT_ACTION, "$n falls from $N.", victim, NULL, victim->mount, TO_ROOM );
fight.c:         REMOVE_BIT( victim->mount->act, ACT_MOUNTED );
fight.c:         victim->mount = NULL;
fight.c:      victim->position = POS_DEAD;
fight.c:   if( victim->hit <= -400 )
fight.c:      victim->position = POS_MORTAL;
fight.c:   else if( victim->hit <= -200 )
fight.c:      victim->position = POS_INCAP;
fight.c:      victim->position = POS_STUNNED;
fight.c:   if( victim->position > POS_STUNNED && IS_AFFECTED( victim, AFF_PARALYSIS ) )
fight.c:      victim->position = POS_STUNNED;
fight.c:   if( victim->mount )
fight.c:      act( AT_ACTION, "$n falls unconscious from $N.", victim, NULL, victim->mount, TO_ROOM );
fight.c:      REMOVE_BIT( victim->mount->act, ACT_MOUNTED );
fight.c:      victim->mount = NULL;
fight.c:   if( ch->fighting )
fight.c:      sprintf( buf, "Set_fighting: %s -> %s (already fighting %s)", ch->name, victim->name, ch->fighting->who->name );
fight.c:    * Limit attackers -Thoric 
fight.c:   if( victim->num_fighting > max_fight( victim ) )
fight.c:   fight->who = victim;
fight.c:   fight->xp = ( int )xp_compute( ch, victim );
fight.c:   fight->align = align_compute( ch, victim );
fight.c:      fight->timeskilled = times_killed( ch, victim );
fight.c:   ch->num_fighting = 1;
fight.c:   ch->fighting = fight;
fight.c:   ch->position = POS_FIGHTING;
fight.c:   victim->num_fighting++;
fight.c:   if( victim->switched && IS_AFFECTED( victim->switched, AFF_POSSESS ) )
fight.c:      send_to_char( "You are disturbed!\r\n", victim->switched );
fight.c:      do_return( victim->switched, "" );
fight.c:   if( !ch->fighting )
fight.c:   return ch->fighting->who;
fight.c:   if( ch->fighting )
fight.c:      if( !char_died( ch->fighting->who ) )
fight.c:         --ch->fighting->who->num_fighting;
fight.c:      DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if( ch->mount )
fight.c:      ch->position = POS_MOUNTED;
fight.c:      ch->position = POS_STANDING;
fight.c:    * Berserk wears off after combat. -- Altrag 
fight.c:      send_to_char( skill_table[gsn_berserk]->msg_off, ch );
fight.c:   for( fch = first_char; fch; fch = fch->next )
fight.c:   strcpy( arg, victim->name );
fight.c:   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_POLYMORPHED ) )
fight.c:      char_from_room( victim->desc->original );
fight.c:      char_to_room( victim->desc->original, victim->in_room );
fight.c:      victmp = victim->desc->original;
fight.c:   if( victim->in_room && IS_NPC( victim ) && victim->vip_flags != 0 && victim->in_room->area
fight.c:       && victim->in_room->area->planet )
fight.c:      victim->in_room->area->planet->population--;
fight.c:      victim->in_room->area->planet->population = UMAX( victim->in_room->area->planet->population, 0 );
fight.c:      victim->in_room->area->planet->pop_support -= ( float )( 1 + 1 / ( victim->in_room->area->planet->population + 1 ) );
fight.c:      if( victim->in_room->area->planet->pop_support < -100 )
fight.c:         victim->in_room->area->planet->pop_support = -100;
fight.c:   if( !IS_NPC( victim ) || !IS_SET( victim->act, ACT_NOKILL ) )
fight.c:   if( !IS_NPC( victim ) || !IS_SET( victim->act, ACT_NOKILL ) )
fight.c:   if( !IS_NPC( victim ) || ( !IS_SET( victim->act, ACT_NOKILL ) && !IS_SET( victim->act, ACT_NOCORPSE ) ) )
fight.c:      for( obj = victim->last_carrying; obj; obj = obj_next )
fight.c:         obj_next = obj->prev_content;
fight.c:      victim->pIndexData->killed++;
fight.c:   for( ship = first_ship; ship; ship = ship->next )
fight.c:      if( !str_cmp( ship->owner, victim->name ) )
fight.c:         STRFREE( ship->owner );
fight.c:         ship->owner = STRALLOC( "" );
fight.c:         STRFREE( ship->pilot );
fight.c:         ship->pilot = STRALLOC( "" );
fight.c:         STRFREE( ship->copilot );
fight.c:         ship->copilot = STRALLOC( "" );
fight.c:   if( victim->plr_home )
fight.c:      ROOM_INDEX_DATA *room = victim->plr_home;
fight.c:      STRFREE( room->name );
fight.c:      room->name = STRALLOC( "An Empty Apartment" );
fight.c:      REMOVE_BIT( room->room_flags, ROOM_PLR_HOME );
fight.c:      SET_BIT( room->room_flags, ROOM_EMPTY_HOME );
fight.c:      fold_area( room->area, room->area->filename, FALSE );
fight.c:   if( victim->pcdata && victim->pcdata->clan )
fight.c:      if( !str_cmp( victim->name, victim->pcdata->clan->leader ) )
fight.c:         STRFREE( victim->pcdata->clan->leader );
fight.c:         if( victim->pcdata->clan->number1 )
fight.c:            victim->pcdata->clan->leader = STRALLOC( victim->pcdata->clan->number1 );
fight.c:            STRFREE( victim->pcdata->clan->number1 );
fight.c:            victim->pcdata->clan->number1 = STRALLOC( "" );
fight.c:         else if( victim->pcdata->clan->number2 )
fight.c:            victim->pcdata->clan->leader = STRALLOC( victim->pcdata->clan->number2 );
fight.c:            STRFREE( victim->pcdata->clan->number2 );
fight.c:            victim->pcdata->clan->number2 = STRALLOC( "" );
fight.c:            victim->pcdata->clan->leader = STRALLOC( "" );
fight.c:      if( !str_cmp( victim->name, victim->pcdata->clan->number1 ) )
fight.c:         STRFREE( victim->pcdata->clan->number1 );
fight.c:         if( victim->pcdata->clan->number2 )
fight.c:            victim->pcdata->clan->number1 = STRALLOC( victim->pcdata->clan->number2 );
fight.c:            STRFREE( victim->pcdata->clan->number2 );
fight.c:            victim->pcdata->clan->number2 = STRALLOC( "" );
fight.c:            victim->pcdata->clan->number1 = STRALLOC( "" );
fight.c:      if( !str_cmp( victim->name, victim->pcdata->clan->number2 ) )
fight.c:         STRFREE( victim->pcdata->clan->number2 );
fight.c:         victim->pcdata->clan->number1 = STRALLOC( "" );
fight.c:      victim->pcdata->clan->members--;
fight.c:      for( d = first_descriptor; d; d = d->next )
fight.c:         if( ( victim = d->character ) && !IS_NPC( victim ) )
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:   lch = ch->leader ? ch->leader : ch;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      gch_next = gch->next_in_room;
fight.c:      gch->alignment = align_compute( gch, victim );
fight.c:      if( !IS_NPC( gch ) && IS_NPC( victim ) && gch->pcdata && gch->pcdata->clan
fight.c:          && !str_cmp( gch->pcdata->clan->name, victim->mob_clan ) )
fight.c:                    ( exp_level( gch->skill_level[LEADERSHIP_ABILITY] + 1 ) -
fight.c:                      exp_level( gch->skill_level[LEADERSHIP_ABILITY] ) / 10 ) );
fight.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
fight.c:         obj_next = obj->next_content;
fight.c:         if( obj->wear_loc == WEAR_NONE )
fight.c:            obj = obj_to_room( obj, gch->in_room );
fight.c:    align = gch->alignment - victim->alignment;
fight.c:	newalign  = UMIN( gch->alignment + (align-500)/4,  1000 );
fight.c:    if ( align < -500 )
fight.c:	newalign  = UMAX( gch->alignment + (align+500)/4, -1000 );
fight.c:	newalign  = gch->alignment - (int) (gch->alignment / 4);
fight.c:   return URANGE( -1000, ( int )( gch->alignment - victim->alignment / 5 ), 1000 );
fight.c:          * URANGE( 1, ( victim->skill_level[COMBAT_ABILITY] - gch->skill_level[COMBAT_ABILITY] ) + 10, 20 ) ) / 10;
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( align > 990 || align < -990 )
fight.c:   if( gch->alignment > 300 && align < 250 )
fight.c:    * reduce exp for killing the same mob repeatedly    -Thoric 
fight.c:         xp = ( xp * ( 5 - times ) ) / 5;
fight.c:                  ( exp_level( gch->skill_level[COMBAT_ABILITY] + 1 ) - exp_level( gch->skill_level[COMBAT_ABILITY] ) ) );
fight.c:      dampc = ( ( dam * 1000 ) / victim->max_hit ) + ( 50 - ( ( victim->hit * 50 ) / victim->max_hit ) );
fight.c:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c:   if( dam == 0 && ( !IS_NPC( victim ) && ( IS_SET( victim->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c:      sound_to_room( ch->in_room, sound );
fight.c:         attack = attack_table[dt - TYPE_HIT];
fight.c:         attack = skill->noun_damage;
fight.c:            if( skill->miss_char && skill->miss_char[0] != '\0' )
fight.c:               act( AT_HIT, skill->miss_char, ch, NULL, victim, TO_CHAR );
fight.c:            if( skill->miss_vict && skill->miss_vict[0] != '\0' )
fight.c:               act( AT_HITME, skill->miss_vict, ch, NULL, victim, TO_VICT );
fight.c:            if( skill->miss_room && skill->miss_room[0] != '\0' )
fight.c:               act( AT_ACTION, skill->miss_room, ch, NULL, victim, TO_NOTVICT );
fight.c:            if( skill->hit_char && skill->hit_char[0] != '\0' )
fight.c:               act( AT_HIT, skill->hit_char, ch, NULL, victim, TO_CHAR );
fight.c:            if( skill->hit_vict && skill->hit_vict[0] != '\0' )
fight.c:               act( AT_HITME, skill->hit_vict, ch, NULL, victim, TO_VICT );
fight.c:            if( skill->hit_room && skill->hit_room[0] != '\0' )
fight.c:               act( AT_ACTION, skill->hit_room, ch, NULL, victim, TO_NOTVICT );
fight.c:         attack = attack_table[dt - TYPE_HIT];
fight.c:   if( ch->skill_level[COMBAT_ABILITY] >= 100 )
fight.c:    if ( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL )
fight.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:   if( ch->position == POS_FIGHTING )
fight.c:   if( victim->vip_flags != 0 )
fight.c:      ch->alignment -= 10;
fight.c:      if( ch->master == victim )
fight.c:   if( ch->position == POS_FIGHTING )
fight.c:   if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
fight.c:   ch->alignment = URANGE( -1000, ch->alignment - 10, 1000 );
fight.c:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c:   if( ch->in_room->vnum < 29 || ch->in_room->vnum > 43 )
fight.c:      if( ch->position == POS_FIGHTING )
fight.c:         if( ch->mount )
fight.c:            ch->position = POS_MOUNTED;
fight.c:            ch->position = POS_STANDING;
fight.c:   if( ch->move <= 0 )
fight.c:    * No fleeing while stunned. - Narn 
fight.c:   if( ch->position < POS_FIGHTING )
fight.c:   was_in = ch->in_room;
fight.c:          || !pexit->to_room
fight.c:          || ( IS_SET( pexit->exit_info, EX_CLOSED )
fight.c:          || ( IS_NPC( ch ) && IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB ) ) )
fight.c:      REMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c:      if( ch->mount && ch->mount->fighting )
fight.c:         stop_fighting( ch->mount, TRUE );
fight.c:      if( ( now_in = ch->in_room ) == was_in )
fight.c:      ch->in_room = was_in;
fight.c:      ch->in_room = now_in;
fight.c:   if( ch->position < POS_FIGHTING )
fight.c:   was_in = ch->in_room;
fight.c:          || !pexit->to_room
fight.c:          || ( IS_SET( pexit->exit_info, EX_CLOSED )
fight.c:          || ( IS_NPC( ch ) && IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB ) ) )
fight.c:      REMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c:      if( ch->mount && ch->mount->fighting )
fight.c:         stop_fighting( ch->mount, TRUE );
fight.c:      if( ( now_in = ch->in_room ) == was_in )
fight.c:      ch->in_room = was_in;
fight.c:      ch->in_room = now_in;
grind:valgrind -v --tool=memcheck --leak-check=yes --show-reachable=yes --db-attach=yes --num-callers=10 --track-fds=yes ../src/swreality 9500
handler.c:*--------------------------------------------------------------------------*
handler.c:* -------------------------------------------------------------------------*
handler.c:*--------------------------------------------------------------------------*
handler.c:* ------------------------------------------------------------------------ *
handler.c:* ------------------------------------------------------------------------ *
handler.c:   if( IS_SET( room->room_flags, BFS_MARK ) )
handler.c:   SET_BIT( room->room_flags, BFS_MARK );
handler.c:   for( rch = room->first_person; rch; rch = rnext )
handler.c:      rnext = rch->next_in_room;
handler.c:      dam = number_range( obj->value[0], obj->value[1] );
handler.c:            if( IS_SET( rch->act, ACT_SENTINEL ) )
handler.c:               rch->was_sentinel = rch->in_room;
handler.c:               REMOVE_BIT( rch->act, ACT_SENTINEL );
handler.c:   for( robj = room->first_content; robj; robj = robj_next )
handler.c:      robj_next = robj->next_content;
handler.c:      if( robj != obj && robj->item_type != ITEM_SPACECRAFT && robj->item_type != ITEM_SCRAPS
handler.c:          && robj->item_type != ITEM_CORPSE_NPC && robj->item_type != ITEM_CORPSE_PC
handler.c:          && robj->item_type != ITEM_DROID_CORPSE )
handler.c:      for( pexit = room->first_exit; pexit; pexit = pexit->next )
handler.c:         if( pexit->to_room && pexit->to_room != room )
handler.c:               roomblast = blast - 1;
handler.c:               room_explode_1( obj, xch, pexit->to_room, roomblast );
handler.c:               echo_to_room( AT_WHITE, pexit->to_room, "You hear a loud EXPLOSION not to far from here." );
handler.c:   if( !IS_SET( room->room_flags, BFS_MARK ) )
handler.c:   REMOVE_BIT( room->room_flags, BFS_MARK );
handler.c:      for( pexit = room->first_exit; pexit; pexit = pexit->next )
handler.c:         if( pexit->to_room && pexit->to_room != room )
handler.c:            roomblast = blast - 1;
handler.c:            room_explode_2( pexit->to_room, roomblast );
handler.c:   blast = ( int )( obj->value[1] / 500 );
handler.c:   if( obj->armed_by )
handler.c:      for( xch = first_char; xch; xch = xch->next )
handler.c:         if( !IS_NPC( xch ) && nifty_is_name( obj->armed_by, xch->name ) )
handler.c:            if( obj->carried_by )
handler.c:               act( AT_WHITE, "$p EXPLODES in $n's hands!", obj->carried_by, obj, NULL, TO_ROOM );
handler.c:               act( AT_WHITE, "$p EXPLODES in your hands!", obj->carried_by, obj, NULL, TO_CHAR );
handler.c:               room = obj->carried_by->in_room;
handler.c:            else if( obj->in_room )
handler.c:               room = obj->in_room;
handler.c:               if( !held && room->first_person )
handler.c:                  act( AT_WHITE, "$p EXPLODES!", room->first_person, obj, NULL, TO_ROOM );
handler.c:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) && get_trust( ch ) < victim->pcdata->wizinvis )
handler.c:   return ch->experience[ability];
handler.c:   wexp = ch->skill_level[COMBAT_ABILITY] * ch->top_level * 50;
handler.c:   wexp += ch->max_hit * 2;
handler.c:   wexp -= ( ch->armor - 50 ) * 2;
handler.c:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c:   wexp += GET_HITROLL( ch ) * ch->top_level * 10;
handler.c:/*								-Thoric
handler.c:   lvl = UMAX( 0, level - 1 );
handler.c:   if( ch->desc )
handler.c:      if( ch->desc->original )
handler.c:         ch = ch->desc->original;
handler.c:   if( ch->trust != 0 )
handler.c:      return ch->trust;
handler.c:   if( IS_NPC( ch ) && ch->top_level >= LEVEL_AVATAR )
handler.c:   if( ch->top_level >= LEVEL_NEOPHYTE && IS_RETIRED( ch ) )
handler.c:   return ch->top_level;
handler.c:   return 17 + ( ch->played + ( current_time - ch->logon ) ) / 14400;
handler.c:   max = 20 + race_table[ch->race].str_plus;
handler.c:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:   max = 20 + race_table[ch->race].int_plus;
handler.c:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:   max = 20 + race_table[ch->race].wis_plus;
handler.c:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:   max = 20 + race_table[ch->race].dex_plus;
handler.c:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:   max = 20 + race_table[ch->race].con_plus;
handler.c:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:   max = 20 + race_table[ch->race].cha_plus;
handler.c:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c:   max = 20 + race_table[ch->race].lck_plus;
handler.c:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c:   max = 20 + race_table[ch->race].frc_plus;
handler.c:   return URANGE( 0, ch->perm_frc + ch->mod_frc, max );
handler.c: * Vastly reduced (finally) due to containers		-Thoric
handler.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c:   return URANGE( 5, ( ch->top_level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c: * See if a player/mob can take a piece of prototype eq		-Thoric
handler.c:   else if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c: * See if a string is one of the names of an object.		-Thoric
handler.c:/*								-Thoric
handler.c:   mod = paf->modifier;
handler.c:      SET_BIT( ch->affected_by, paf->bitvector );
handler.c:      REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c:       * the removed spell's information somewhere...    -Thoric
handler.c:      switch ( paf->location % REVERSE_APPLY )
handler.c:            REMOVE_BIT( ch->affected_by, mod );
handler.c:            REMOVE_BIT( ch->resistant, mod );
handler.c:            REMOVE_BIT( ch->immune, mod );
handler.c:            REMOVE_BIT( ch->susceptible, mod );
handler.c:            SET_BIT( ch->affected_by, mod );
handler.c:      mod = 0 - mod;
handler.c:   switch ( paf->location % REVERSE_APPLY )
handler.c:         bug( "Affect_modify: unknown location %d.", paf->location );
handler.c:         ch->mod_str += mod;
handler.c:         ch->mod_dex += mod;
handler.c:         ch->mod_int += mod;
handler.c:         ch->mod_wis += mod;
handler.c:         ch->mod_con += mod;
handler.c:         ch->mod_cha += mod;
handler.c:         ch->mod_lck += mod;
handler.c:         ch->sex = ( ch->sex + mod ) % 3;
handler.c:         if( ch->sex < 0 )
handler.c:            ch->sex += 2;
handler.c:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:         ch->height += mod;
handler.c:         ch->weight += mod;
handler.c:         ch->max_mana += mod;
handler.c:         ch->max_hit += mod;
handler.c:         ch->max_move += mod;
handler.c:         ch->armor += mod;
handler.c:         ch->hitroll += mod;
handler.c:         ch->damroll += mod;
handler.c:         ch->saving_poison_death += mod;
handler.c:         ch->saving_wand += mod;
handler.c:         ch->saving_para_petri += mod;
handler.c:         ch->saving_breath += mod;
handler.c:         ch->saving_spell_staff += mod;
handler.c:         SET_BIT( ch->affected_by, mod );
handler.c:         SET_BIT( ch->resistant, mod );
handler.c:         SET_BIT( ch->immune, mod );
handler.c:         SET_BIT( ch->susceptible, mod );
handler.c:         REMOVE_BIT( ch->affected_by, mod );
handler.c:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c:/* spell cast upon wear/removal of an object	-Thoric */
handler.c:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_WEARSPELL && !fAdd ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_REMOVESPELL && !fAdd ) || saving_char == ch /* so save/quit doesn't trigger */
handler.c:         if( IS_VALID_SN( mod ) && ( skill = skill_table[mod] ) != NULL && skill->type == SKILL_SPELL )
handler.c:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->skill_level[FORCE_ABILITY], ch, ch ) ) == rCHAR_DIED
handler.c:/* skill apply types	-Thoric */
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] > 0 )
handler.c:            ch->pcdata->learned[gsn_track] = UMAX( 1, ch->pcdata->learned[gsn_track] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_hide] > 0 )
handler.c:            ch->pcdata->learned[gsn_hide] = UMAX( 1, ch->pcdata->learned[gsn_hide] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_steal] > 0 )
handler.c:            ch->pcdata->learned[gsn_steal] = UMAX( 1, ch->pcdata->learned[gsn_steal] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_sneak] > 0 )
handler.c:            ch->pcdata->learned[gsn_sneak] = UMAX( 1, ch->pcdata->learned[gsn_sneak] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_pick_lock] > 0 )
handler.c:            ch->pcdata->learned[gsn_pick_lock] = UMAX( 1, ch->pcdata->learned[gsn_pick_lock] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_backstab] > 0 )
handler.c:            ch->pcdata->learned[gsn_backstab] = UMAX( 1, ch->pcdata->learned[gsn_backstab] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_detrap] > 0 )
handler.c:            ch->pcdata->learned[gsn_detrap] = UMAX( 1, ch->pcdata->learned[gsn_detrap] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_dodge] > 0 )
handler.c:            ch->pcdata->learned[gsn_dodge] = UMAX( 1, ch->pcdata->learned[gsn_dodge] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_peek] > 0 )
handler.c:            ch->pcdata->learned[gsn_peek] = UMAX( 1, ch->pcdata->learned[gsn_peek] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_scan] > 0 )
handler.c:            ch->pcdata->learned[gsn_scan] = UMAX( 1, ch->pcdata->learned[gsn_scan] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_gouge] > 0 )
handler.c:            ch->pcdata->learned[gsn_gouge] = UMAX( 1, ch->pcdata->learned[gsn_gouge] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_search] > 0 )
handler.c:            ch->pcdata->learned[gsn_search] = UMAX( 1, ch->pcdata->learned[gsn_search] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_dig] > 0 )
handler.c:            ch->pcdata->learned[gsn_dig] = UMAX( 1, ch->pcdata->learned[gsn_dig] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_mount] > 0 )
handler.c:            ch->pcdata->learned[gsn_mount] = UMAX( 1, ch->pcdata->learned[gsn_mount] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_disarm] > 0 )
handler.c:            ch->pcdata->learned[gsn_disarm] = UMAX( 1, ch->pcdata->learned[gsn_disarm] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_kick] > 0 )
handler.c:            ch->pcdata->learned[gsn_kick] = UMAX( 1, ch->pcdata->learned[gsn_kick] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_parry] > 0 )
handler.c:            ch->pcdata->learned[gsn_parry] = UMAX( 1, ch->pcdata->learned[gsn_parry] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_bash] > 0 )
handler.c:            ch->pcdata->learned[gsn_bash] = UMAX( 1, ch->pcdata->learned[gsn_bash] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_stun] > 0 )
handler.c:            ch->pcdata->learned[gsn_stun] = UMAX( 1, ch->pcdata->learned[gsn_stun] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_punch] > 0 )
handler.c:            ch->pcdata->learned[gsn_punch] = UMAX( 1, ch->pcdata->learned[gsn_punch] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_climb] > 0 )
handler.c:            ch->pcdata->learned[gsn_climb] = UMAX( 1, ch->pcdata->learned[gsn_climb] + mod );
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_grip] > 0 )
handler.c:            ch->pcdata->learned[gsn_grip] = UMAX( 1, ch->pcdata->learned[gsn_grip] + mod );
handler.c:         depth--;
handler.c:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:   paf_new->type = paf->type;
handler.c:   paf_new->duration = paf->duration;
handler.c:   paf_new->location = paf->location;
handler.c:   paf_new->modifier = paf->modifier;
handler.c:   paf_new->bitvector = paf->bitvector;
handler.c:   if( !ch->first_affect )
handler.c:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c:      paf_next = paf->next;
handler.c:      if( paf->type == sn )
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:      if( paf->type == sn )
handler.c:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:      if( paf_old->type == paf->type )
handler.c:         paf->duration = UMIN( 1000000, paf->duration + paf_old->duration );
handler.c:         if( paf->modifier )
handler.c:            paf->modifier = UMIN( 5000, paf->modifier + paf_old->modifier );
handler.c:            paf->modifier = paf_old->modifier;
handler.c:   if( !ch->in_room )
handler.c:      bug( "Char_from_room: NULL room: %s", ch->name );
handler.c:   if(ch->piloting != NULL)
handler.c:      --ch->in_room->area->nplayer;
handler.c:       && obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c:   ch->in_room = NULL;
handler.c:   ch->next_in_room = NULL;
handler.c:   ch->prev_in_room = NULL;
handler.c:   if( !pRoomIndex || !get_room_index( pRoomIndex->vnum ) )
handler.c:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __FUNCTION__, ch->name, ROOM_VNUM_LIMBO );
handler.c:       * and I saw no reason not to just put the char in limbo.  -Narn
handler.c:   ch->in_room = pRoomIndex;
handler.c:   if( ch->home_vnum < 1 )
handler.c:      ch->home_vnum = ch->in_room->vnum;
handler.c:   LINK( ch, pRoomIndex->first_person, pRoomIndex->last_person, next_in_room, prev_in_room );
handler.c:      if( ++ch->in_room->area->nplayer > ch->in_room->area->max_players )
handler.c:         ch->in_room->area->max_players = ch->in_room->area->nplayer;
handler.c:   if( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL && obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:      ++ch->in_room->light;
handler.c:   if( !IS_NPC( ch ) && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
handler.c:      add_timer( ch, TIMER_SHOVEDRAG, 10, NULL, 0 );   /*-30 Seconds-*/
handler.c:    * Delayed Teleport rooms             -Thoric
handler.c:   if( IS_SET( ch->in_room->room_flags, ROOM_TELEPORT ) && ch->in_room->tele_delay > 0 )
handler.c:      for( tele = first_teleport; tele; tele = tele->next )
handler.c:         if( tele->room == pRoomIndex )
handler.c:      tele->room = pRoomIndex;
handler.c:      tele->timer = pRoomIndex->tele_delay;
handler.c:   int wear_loc = obj->wear_loc;
handler.c:   int extra_flags = obj->extra_flags;
handler.c:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) && !IS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c:         return obj_to_room( obj, ch->in_room );
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:      LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:      obj->carried_by = ch;
handler.c:      obj->in_room = NULL;
handler.c:      obj->in_obj = NULL;
handler.c:      ch->carry_number += onum;
handler.c:      ch->carry_weight += oweight;
handler.c:      ch->carry_weight += oweight;
handler.c:   if( ( ch = obj->carried_by ) == NULL )
handler.c:   if( obj->wear_loc != WEAR_NONE )
handler.c:   if( !obj->carried_by )
handler.c:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:   ch->carry_weight -= get_obj_weight( obj );
handler.c:   if( obj->item_type != ITEM_ARMOR )
handler.c:         return 3 * obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c: * Will pick the top layer if clothing is layered.		-Thoric
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->wear_loc == iWear )
handler.c:         if( !obj->pIndexData->layers )
handler.c:         else if( !maxobj || obj->pIndexData->layers > maxobj->pIndexData->layers )
handler.c:   if( ( otmp = get_eq_char( ch, iWear ) ) != NULL && ( !otmp->pIndexData->layers || !obj->pIndexData->layers ) )
handler.c:   if( obj->carried_by != ch )
handler.c:      if( obj->carried_by )
handler.c:      obj_to_room( obj, ch->in_room );
handler.c:   ch->armor -= apply_ac( obj, iWear );
handler.c:   obj->wear_loc = iWear;
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:   if( IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c:      ch->carry_weight -= get_obj_weight( obj );
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room )
handler.c:      ++ch->in_room->light;
handler.c:   if( obj->wear_loc == WEAR_NONE )
handler.c:   ch->carry_number += get_obj_number( obj );
handler.c:   if( IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c:      ch->carry_weight += get_obj_weight( obj );
handler.c:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c:   obj->wear_loc = -1;
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   if( obj->carried_by )
handler.c:      for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:   if( !obj->carried_by )
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   if( ( in_room = obj->in_room ) == NULL )
handler.c:   UNLINK( obj, in_room->first_content, in_room->last_content, next_content, prev_content );
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:      empty_obj( obj, NULL, obj->in_room );
handler.c:   if( obj->item_type == ITEM_FIRE )
handler.c:      obj->in_room->light -= obj->count;
handler.c:   obj->carried_by = NULL;
handler.c:   obj->in_obj = NULL;
handler.c:   obj->in_room = NULL;
handler.c:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling == 0 )
handler.c:      write_corpses( NULL, obj->short_descr + 14 );
handler.c:   short count = obj->count;
handler.c:   short item_type = obj->item_type;
handler.c:   for( otmp = pRoomIndex->first_content; otmp; otmp = otmp->next_content )
handler.c:            pRoomIndex->light += count;
handler.c:   LINK( obj, pRoomIndex->first_content, pRoomIndex->last_content, next_content, prev_content );
handler.c:   obj->in_room = pRoomIndex;
handler.c:   obj->carried_by = NULL;
handler.c:   obj->in_obj = NULL;
handler.c:   obj->room_vnum = pRoomIndex->vnum;  /* hotboot tracker */
handler.c:      pRoomIndex->light += count;
handler.c:   falling--;
handler.c:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling == 0 )
handler.c:      write_corpses( NULL, obj->short_descr + 14 );
handler.c:      bug( "Obj_to_obj: trying to put object inside itself: vnum %d", obj->pIndexData->vnum );
handler.c:   if( obj->carried_by != obj_to->carried_by )
handler.c:      if( obj->carried_by )
handler.c:         obj->carried_by->carry_weight -= get_obj_weight( obj );
handler.c:      if( obj_to->carried_by )
handler.c:         obj_to->carried_by->carry_weight += get_obj_weight( obj );
handler.c:   for( otmp = obj_to->first_content; otmp; otmp = otmp->next_content )
handler.c:   LINK( obj, obj_to->first_content, obj_to->last_content, next_content, prev_content );
handler.c:   obj->in_obj = obj_to;
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:   if( ( obj_from = obj->in_obj ) == NULL )
handler.c:   UNLINK( obj, obj_from->first_content, obj_from->last_content, next_content, prev_content );
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:      empty_obj( obj, obj->in_obj, NULL );
handler.c:   obj->in_obj = NULL;
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:   for( ; obj_from; obj_from = obj_from->in_obj )
handler.c:      if( obj_from->carried_by )
handler.c:         obj_from->carried_by->carry_weight -= get_obj_weight( obj );
handler.c:      bug( "extract_obj: obj %d already extracted!", obj->pIndexData->vnum );
handler.c:   if( obj->item_type == ITEM_PORTAL )
handler.c:   if( obj->carried_by )
handler.c:   else if( obj->in_room )
handler.c:   else if( obj->in_obj )
handler.c:   while( ( obj_content = obj->last_content ) != NULL )
handler.c:      for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:         paf_next = paf->next;
handler.c:      obj->first_affect = obj->last_affect = NULL;
handler.c:      for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:         ed_next = ed->next;
handler.c:         STRFREE( ed->description );
handler.c:         STRFREE( ed->keyword );
handler.c:      obj->first_extradesc = obj->last_extradesc = NULL;
handler.c:      gobj_prev = obj->prev;
handler.c:      rq_next = RQueue->next;
handler.c:      if( RQueue->Type == relOSET_ON )
handler.c:         if( obj == RQueue->Subject )
handler.c:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c:   obj->pIndexData->count -= obj->count;
handler.c:   numobjsloaded -= obj->count;
handler.c:   --physicalobjects;
handler.c:   if( obj->serial == cur_obj )
handler.c:   if( !ch->in_room )
handler.c:      bug( "%s: %s already died!", __FUNCTION__, ch->name );
handler.c:      rq_next = RQueue->next;
handler.c:      if( fPull && RQueue->Type == relMSET_ON )
handler.c:         if( ch == RQueue->Subject )
handler.c:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c:         else if( ch != RQueue->Actor )
handler.c:      gch_prev = ch->prev;
handler.c:   if( ch->mount )
handler.c:      REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:      ch->mount = NULL;
handler.c:      ch->position = POS_STANDING;
handler.c:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOUNTED ) )
handler.c:      for( wch = first_char; wch; wch = wch->next )
handler.c:         if( wch->mount == ch )
handler.c:            wch->mount = NULL;
handler.c:            wch->position = POS_STANDING;
handler.c:      REMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:   while( ( obj = ch->last_carrying ) != NULL )
handler.c:      ch->position = POS_RESTING;
handler.c:      --ch->pIndexData->count;
handler.c:      --nummobsloaded;
handler.c:   if( ch->desc && ch->desc->original && IS_SET( ch->act, ACT_POLYMORPHED ) )
handler.c:   if( ch->desc && ch->desc->original )
handler.c:   if( ch->switched && ch->switched->desc )
handler.c:      do_return( ch->switched, "" );
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( wch->reply == ch )
handler.c:         wch->reply = NULL;
handler.c:   if( ch->desc )
handler.c:      if( ch->desc->character != ch )
handler.c:         ch->desc->character = NULL;
handler.c:         close_socket( ch->desc, FALSE );
handler.c:         ch->desc = NULL;
handler.c:      vnum = -1;
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c:   if( vnum != -1 )
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c:    * Allow reference by vnum for saints+         -Thoric
handler.c:      vnum = -1;
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) && is_wizvis( ch, wch ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) && is_wizvis( ch, wch ) )
handler.c:   if( vnum != -1 )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( obj = list; obj; obj = obj->next_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = list; obj; obj = obj->next_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c: * Find an obj in a list...going the other way			-Thoric
handler.c:   for( obj = list; obj; obj = obj->prev_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = list; obj; obj = obj->prev_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:      vnum = -1;
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc == WEAR_NONE
handler.c:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   if( vnum != -1 )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:      vnum = -1;
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc != WEAR_NONE
handler.c:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c:   if( vnum != -1 )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:   if( !ch || !ch->in_room )
handler.c:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:    * Allow reference by vnum for saints+         -Thoric
handler.c:      vnum = -1;
handler.c:   for( obj = first_object; obj; obj = obj->next )
handler.c:      if( can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || vnum == obj->pIndexData->vnum ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   if( vnum != -1 )
handler.c:   for( obj = first_object; obj; obj = obj->next )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c: * How mental state could affect finding an object		-Thoric
handler.c:   int ms = ch->mental_state;
handler.c:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:      switch ( number_range( UMAX( 1, ( ms / 5 - 15 ) ), ( ms + 4 ) / 5 ) )
handler.c:            t = "What about the millions of burrow-maggots feasting on your arm?!?!\r\n";
handler.c: * Generic get obj function that supports optional containers.	-Thoric
handler.c:      if( !IS_OBJ_STAT( container, ITEM_COVERING ) && IS_SET( container->value[1], CONT_CLOSED ) )
handler.c:         act( AT_PLAIN, "The $d is closed.", ch, NULL, container->name, TO_CHAR );
handler.c:      obj = get_obj_list( ch, arg1, container->first_content );
handler.c:   return obj->count;
handler.c:   weight = obj->count * obj->weight;
handler.c:   for( obj = obj->first_content; obj; obj = obj->next_content )
handler.c:   if( pRoomIndex->light > 0 )
handler.c:   if( IS_SET( pRoomIndex->room_flags, ROOM_DARK ) )
handler.c:   if( pRoomIndex->sector_type == SECT_INSIDE || pRoomIndex->sector_type == SECT_CITY )
handler.c:   if( IS_SET( pRoomIndex->room_flags, ROOM_PLR_HOME ) && ch->plr_home != pRoomIndex )
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:   if( IS_SET( pRoomIndex->room_flags, ROOM_PRIVATE ) && count >= 2 )
handler.c:   if( IS_SET( pRoomIndex->room_flags, ROOM_SOLITARY ) && count >= 1 )
handler.c:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c:      if( IS_AFFECTED( victim, AFF_INVISIBLE ) || IS_AFFECTED( victim, AFF_HIDE ) || IS_SET( victim->act, PLR_WIZINVIS ) )
handler.c:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) && get_trust( ch ) < victim->pcdata->wizinvis )
handler.c:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c:   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_MOBINVIS ) && get_trust( ch ) < victim->mobinvis )
handler.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( victim ) && !victim->desc
handler.c:       && ( !victim->switched || !IS_AFFECTED( victim->switched, AFF_POSSESS ) ) )
handler.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:    * The miracle cure for blindness? -- Altrag 
handler.c:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:      if( IS_AFFECTED( victim, AFF_HIDE ) && !IS_AFFECTED( ch, AFF_DETECT_HIDDEN ) && !victim->fighting )
handler.c:      if( ch->race == RACE_DEFEL && victim->race == RACE_DEFEL )
handler.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:   if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:   if( obj->item_type < 1 || obj->item_type > MAX_ITEM_TYPE )
handler.c:      bug( "Item_type_name: unknown type %d.", obj->item_type );
handler.c:   return o_types[obj->item_type];
handler.c:      strcat( buf, " anti-good" );
handler.c:      strcat( buf, " anti-evil" );
handler.c:      strcat( buf, " anti-neutral" );
handler.c:      strcat( buf, " anti-soldier" );
handler.c:      strcat( buf, " anti-thief" );
handler.c:      strcat( buf, " anti-hunter" );
handler.c:      strcat( buf, " anti-jedi" );
handler.c:      strcat( buf, " anti-sith" );
handler.c:      strcat( buf, " anti-pilot" );
handler.c:      strcat( buf, " anti-citizen" );
handler.c: * Return ascii name of magic flags vector. - Scryn
handler.c: * Set off a trap (obj) upon character (ch)			-Thoric
handler.c:   typ = obj->value[1];
handler.c:   lev = obj->value[2];
handler.c:   dam = number_range( obj->value[2], obj->value[2] * 2 );
handler.c:   --obj->value[0];
handler.c:   if( obj->value[0] <= 0 )
handler.c: * Check an object for a trap					-Thoric
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:      if( check->item_type == ITEM_TRAP && IS_SET( check->value[3], flag ) )
handler.c: * Check the room for a trap					-Thoric
handler.c:   if( !ch->in_room || !ch->in_room->first_content )
handler.c:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:      if( check->item_type == ITEM_LANDMINE && flag == TRAP_ENTER_ROOM )
handler.c:      else if( check->item_type == ITEM_TRAP && IS_SET( check->value[3], flag ) )
handler.c: * return TRUE if an object contains a trap			-Thoric
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:      if( check->item_type == ITEM_TRAP )
handler.c: * If an object contains a trap, return the pointer to the trap	-Thoric
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:      if( check->item_type == ITEM_TRAP )
handler.c: * Remove an exit from a room					-Thoric
handler.c:   UNLINK( pexit, room->first_exit, room->last_exit, next, prev );
handler.c:   if( pexit->rexit )
handler.c:      pexit->rexit->rexit = NULL;
handler.c:   STRFREE( pexit->keyword );
handler.c:   STRFREE( pexit->description );
handler.c: * clean out a room (leave list pointers intact )		-Thoric
handler.c:   STRFREE( room->description );
handler.c:   STRFREE( room->name );
handler.c:   for( ed = room->first_extradesc; ed; ed = ed_next )
handler.c:      ed_next = ed->next;
handler.c:      STRFREE( ed->description );
handler.c:      STRFREE( ed->keyword );
handler.c:      top_ed--;
handler.c:   room->first_extradesc = NULL;
handler.c:   room->last_extradesc = NULL;
handler.c:   for( pexit = room->first_exit; pexit; pexit = pexit_next )
handler.c:      pexit_next = pexit->next;
handler.c:      STRFREE( pexit->keyword );
handler.c:      STRFREE( pexit->description );
handler.c:      top_exit--;
handler.c:   room->first_exit = NULL;
handler.c:   room->last_exit = NULL;
handler.c:   room->room_flags = 0;
handler.c:   room->sector_type = 0;
handler.c:   room->light = 0;
handler.c: * clean out an object (index) (leave list pointers intact )	-Thoric
handler.c:   STRFREE( obj->name );
handler.c:   STRFREE( obj->short_descr );
handler.c:   STRFREE( obj->description );
handler.c:   STRFREE( obj->action_desc );
handler.c:   obj->item_type = 0;
handler.c:   obj->extra_flags = 0;
handler.c:   obj->wear_flags = 0;
handler.c:   obj->count = 0;
handler.c:   obj->weight = 0;
handler.c:   obj->cost = 0;
handler.c:   obj->value[0] = 0;
handler.c:   obj->value[1] = 0;
handler.c:   obj->value[2] = 0;
handler.c:   obj->value[3] = 0;
handler.c:   obj->value[4] = 0;
handler.c:   obj->value[5] = 0;
handler.c:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:      paf_next = paf->next;
handler.c:      top_affect--;
handler.c:   obj->first_affect = NULL;
handler.c:   obj->last_affect = NULL;
handler.c:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:      ed_next = ed->next;
handler.c:      STRFREE( ed->description );
handler.c:      STRFREE( ed->keyword );
handler.c:      top_ed--;
handler.c:   obj->first_extradesc = NULL;
handler.c:   obj->last_extradesc = NULL;
handler.c: * clean out a mobile (index) (leave list pointers intact )	-Thoric
handler.c:   STRFREE( mob->player_name );
handler.c:   STRFREE( mob->short_descr );
handler.c:   STRFREE( mob->long_descr );
handler.c:   STRFREE( mob->description );
handler.c:   mob->spec_fun = NULL;
handler.c:   mob->spec_2 = NULL;
handler.c:   mob->pShop = NULL;
handler.c:   mob->rShop = NULL;
handler.c:   mob->progtypes = 0;
handler.c:   for( mprog = mob->mudprogs; mprog; mprog = mprog_next )
handler.c:      mprog_next = mprog->next;
handler.c:      STRFREE( mprog->arglist );
handler.c:      STRFREE( mprog->comlist );
handler.c:   mob->count = 0;
handler.c:   mob->killed = 0;
handler.c:   mob->sex = 0;
handler.c:   mob->level = 0;
handler.c:   mob->act = 0;
handler.c:   mob->affected_by = 0;
handler.c:   mob->alignment = 0;
handler.c:   mob->mobthac0 = 0;
handler.c:   mob->ac = 0;
handler.c:   mob->hitnodice = 0;
handler.c:   mob->hitsizedice = 0;
handler.c:   mob->hitplus = 0;
handler.c:   mob->damnodice = 0;
handler.c:   mob->damsizedice = 0;
handler.c:   mob->damplus = 0;
handler.c:   mob->gold = 0;
handler.c:   mob->position = 0;
handler.c:   mob->defposition = 0;
handler.c:   mob->height = 0;
handler.c:   mob->weight = 0;
handler.c: * Remove all resets from a room -Thoric
handler.c:    for( pReset = room->first_reset; pReset; pReset = pReset_next )
handler.c:	pReset_next = pReset->next;
handler.c:	--top_reset;
handler.c:    room->first_reset	= NULL;
handler.c:    room->last_reset	= NULL;
handler.c: * "Fix" a character's stats					-Thoric
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   ch->affected_by = race_table[ch->race].affected;
handler.c:   ch->mental_state = -10;
handler.c:   ch->hit = UMAX( 1, ch->hit );
handler.c:   ch->mana = UMAX( 1, ch->mana );
handler.c:   ch->move = UMAX( 1, ch->move );
handler.c:   ch->armor = 100;
handler.c:   ch->mod_str = 0;
handler.c:   ch->mod_dex = 0;
handler.c:   ch->mod_wis = 0;
handler.c:   ch->mod_int = 0;
handler.c:   ch->mod_con = 0;
handler.c:   ch->mod_cha = 0;
handler.c:   ch->mod_lck = 0;
handler.c:   ch->damroll = 0;
handler.c:   ch->hitroll = 0;
handler.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c:   ch->saving_breath = 0;
handler.c:   ch->saving_wand = 0;
handler.c:   ch->saving_para_petri = 0;
handler.c:   ch->saving_spell_staff = 0;
handler.c:   ch->saving_poison_death = 0;
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   ch->carry_weight = 0;
handler.c:   ch->carry_number = 0;
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->wear_loc == WEAR_NONE )
handler.c:         ch->carry_number += get_obj_number( obj );
handler.c:      if( !IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c:         ch->carry_weight += get_obj_weight( obj );
handler.c: * Show an affect verbosely to a character			-Thoric
handler.c:   if( paf->location != APPLY_NONE && paf->modifier != 0 )
handler.c:      switch ( paf->location )
handler.c:            sprintf( buf, "Affects %s by %d.\r\n", affect_loc_name( paf->location ), paf->modifier );
handler.c:            sprintf( buf, "Affects %s by", affect_loc_name( paf->location ) );
handler.c:               if( IS_SET( paf->modifier, 1 << x ) )
handler.c:                     IS_VALID_SN( paf->modifier ) ? skill_table[paf->modifier]->name : "unknown" );
handler.c:            sprintf( buf, "Affects %s by", affect_loc_name( paf->location ) );
handler.c:               if( IS_SET( paf->modifier, 1 << x ) )
handler.c: * Set the current global object to obj				-Thoric
handler.c:   cur_obj = obj->serial;
handler.c: * Check the recently extracted object queue for obj		-Thoric
handler.c:   if( obj->serial == cur_obj && cur_obj_extracted )
handler.c:   for( cod = extracted_obj_queue; cod; cod = cod->next )
handler.c:   obj->next = extracted_obj_queue;
handler.c:   for( mpact = obj->mpact; mpact; mpact = mpact_next )
handler.c:      mpact_next = mpact->next;
handler.c:      DISPOSE( mpact->buf );
handler.c:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:      paf_next = paf->next;
handler.c:   obj->first_affect = obj->last_affect = NULL;
handler.c:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:      ed_next = ed->next;
handler.c:      STRFREE( ed->description );
handler.c:      STRFREE( ed->keyword );
handler.c:   obj->first_extradesc = obj->last_extradesc = NULL;
handler.c:      rq_next = RQueue->next;
handler.c:      if( RQueue->Type == relOSET_ON )
handler.c:         if( obj == RQueue->Subject )
handler.c:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c:   STRFREE( obj->name );
handler.c:   STRFREE( obj->description );
handler.c:   STRFREE( obj->short_descr );
handler.c:   STRFREE( obj->action_desc );
handler.c:      extracted_obj_queue = extracted_obj_queue->next;
handler.c:      --cur_qobjs;
handler.c: * Set the current global character to ch			-Thoric
handler.c:   cur_room = ch->in_room;
handler.c: * Check to see if ch died recently				-Thoric
handler.c:   for( ccd = extracted_char_queue; ccd; ccd = ccd->next )
handler.c:      if( ccd->ch == ch )
handler.c: * Add ch to the queue of recently extracted characters		-Thoric
handler.c:   ccd->ch = ch;
handler.c:   ccd->room = ch->in_room;
handler.c:   ccd->extract = extract;
handler.c:      ccd->retcode = global_retcode;
handler.c:      ccd->retcode = rCHAR_DIED;
handler.c:   ccd->next = extracted_char_queue;
handler.c:      extracted_char_queue = ccd->next;
handler.c:      if( ccd->extract )
handler.c:         free_char( ccd->ch );
handler.c:      --cur_qchars;
handler.c: * Add a timer to ch						-Thoric
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      if( timer->type == type )
handler.c:         timer->count = count;
handler.c:         timer->do_fun = fun;
handler.c:         timer->value = value;
handler.c:      timer->count = count;
handler.c:      timer->type = type;
handler.c:      timer->do_fun = fun;
handler.c:      timer->value = value;
handler.c:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      if( timer->type == type )
handler.c:      return timer->count;
handler.c:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      if( timer->type == type )
handler.c:   else if( ch->top_level >= tarea->low_soft_range || ch->top_level <= tarea->hi_soft_range )
handler.c:   else if( ch->top_level >= tarea->low_hard_range && ch->top_level <= tarea->hi_hard_range )
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:   ms = 10 - abs( ch->mental_state );
handler.c:   if( ( number_percent(  ) - get_curr_lck( ch ) + 13 - ms ) )
handler.c:   if( number_percent(  ) - get_curr_lck( ch ) + 13 - attrib + 13 )
handler.c: * Make a simple clone of an object (no extras...yet)		-Thoric
handler.c:   clone->pIndexData = obj->pIndexData;
handler.c:   clone->name = QUICKLINK( obj->name );
handler.c:   clone->short_descr = QUICKLINK( obj->short_descr );
handler.c:   clone->description = QUICKLINK( obj->description );
handler.c:   clone->action_desc = QUICKLINK( obj->action_desc );
handler.c:   clone->item_type = obj->item_type;
handler.c:   clone->extra_flags = obj->extra_flags;
handler.c:   clone->magic_flags = obj->magic_flags;
handler.c:   clone->wear_flags = obj->wear_flags;
handler.c:   clone->wear_loc = obj->wear_loc;
handler.c:   clone->weight = obj->weight;
handler.c:   clone->cost = obj->cost;
handler.c:   clone->level = obj->level;
handler.c:   clone->timer = obj->timer;
handler.c:   clone->value[0] = obj->value[0];
handler.c:   clone->value[1] = obj->value[1];
handler.c:   clone->value[2] = obj->value[2];
handler.c:   clone->value[3] = obj->value[3];
handler.c:   clone->value[4] = obj->value[4];
handler.c:   clone->value[5] = obj->value[5];
handler.c:   clone->count = 1;
handler.c:   ++obj->pIndexData->count;
handler.c:   cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
handler.c:   clone->serial = clone->pIndexData->serial = cur_obj_serial;
handler.c: * If possible group obj2 into obj1				-Thoric
handler.c: * This code, along with clone_object, obj->count, and special support
handler.c:   if( obj1->pIndexData == obj2->pIndexData
handler.c:    &&	!obj1->pIndexData->mudprogs
handler.c:    &&  !obj2->pIndexData->mudprogs
handler.c:       && !str_cmp( obj1->name, obj2->name )
handler.c:       && !str_cmp( obj1->short_descr, obj2->short_descr )
handler.c:       && !str_cmp( obj1->description, obj2->description )
handler.c:       && !str_cmp( obj1->action_desc, obj2->action_desc )
handler.c:       && obj1->item_type == obj2->item_type
handler.c:       && obj1->extra_flags == obj2->extra_flags
handler.c:       && obj1->magic_flags == obj2->magic_flags
handler.c:       && obj1->wear_flags == obj2->wear_flags
handler.c:       && obj1->wear_loc == obj2->wear_loc
handler.c:       && obj1->weight == obj2->weight
handler.c:       && obj1->cost == obj2->cost
handler.c:       && obj1->level == obj2->level
handler.c:       && obj1->timer == obj2->timer
handler.c:       && obj1->value[0] == obj2->value[0]
handler.c:       && obj1->value[1] == obj2->value[1]
handler.c:       && obj1->value[2] == obj2->value[2]
handler.c:       && obj1->value[3] == obj2->value[3]
handler.c:       && obj1->value[4] == obj2->value[4]
handler.c:       && obj1->value[5] == obj2->value[5]
handler.c:       && !obj1->first_extradesc && !obj2->first_extradesc
handler.c:       && !obj1->first_affect && !obj2->first_affect && !obj1->first_content && !obj2->first_content )
handler.c:      obj1->count += obj2->count;
handler.c:      obj1->pIndexData->count += obj2->count;   /* to be decremented in */
handler.c:      numobjsloaded += obj2->count; /* extract_obj */
handler.c: * Split off a grouped object					-Thoric
handler.c:   count = obj->count;
handler.c:   --obj->pIndexData->count;  /* since clone_object() ups this value */
handler.c:   --numobjsloaded;
handler.c:   rest->count = obj->count - num;
handler.c:   obj->count = num;
handler.c:   if( obj->carried_by )
handler.c:      LINK( rest, obj->carried_by->first_carrying, obj->carried_by->last_carrying, next_content, prev_content );
handler.c:      rest->carried_by = obj->carried_by;
handler.c:      rest->in_room = NULL;
handler.c:      rest->in_obj = NULL;
handler.c:   else if( obj->in_room )
handler.c:      LINK( rest, obj->in_room->first_content, obj->in_room->last_content, next_content, prev_content );
handler.c:      rest->carried_by = NULL;
handler.c:      rest->in_room = obj->in_room;
handler.c:      rest->in_obj = NULL;
handler.c:   else if( obj->in_obj )
handler.c:      LINK( rest, obj->in_obj->first_content, obj->in_obj->last_content, next_content, prev_content );
handler.c:      rest->in_obj = obj->in_obj;
handler.c:      rest->in_room = NULL;
handler.c:      rest->carried_by = NULL;
handler.c:   CHAR_DATA *ch = obj->carried_by;
handler.c:   if( destobj || ( !destroom && !ch && ( destobj = obj->in_obj ) != NULL ) )
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:         otmp_next = otmp->next_content;
handler.c:         if( destobj->item_type == ITEM_CONTAINER && get_obj_weight( otmp ) + get_obj_weight( destobj ) > destobj->value[0] )
handler.c:   if( destroom || ( !ch && ( destroom = obj->in_room ) != NULL ) )
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:         otmp_next = otmp->next_content;
handler.c:         if( ch && ( otmp->pIndexData->progtypes & DROP_PROG ) && otmp->count > 1 )
handler.c:               otmp_next = obj->first_content;
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:         otmp_next = otmp->next_content;
handler.c:   bug( "empty_obj: could not determine a destination for vnum %d", obj->pIndexData->vnum );
handler.c: * Improve mental state						-Thoric
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c: * Deteriorate mental state					-Thoric
handler.c:   c -= number_percent(  ) < con ? 1 : 0;
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:      ch->mental_state -= c;
handler.c: * Add gold to an area's economy				-Thoric
handler.c:      ++tarea->high_economy;
handler.c:      gold -= 1000000000;
handler.c:   tarea->low_economy += gold;
handler.c:   while( tarea->low_economy >= 1000000000 )
handler.c:      ++tarea->high_economy;
handler.c:      tarea->low_economy -= 1000000000;
handler.c: * Take gold from an area's economy				-Thoric
handler.c:      tarea->high_economy -= 1;
handler.c:      gold -= 1000000000;
handler.c:   tarea->low_economy -= gold;
handler.c:   while( tarea->low_economy < 0 )
handler.c:      tarea->high_economy -= 1;
handler.c:      tarea->low_economy += 1000000000;
handler.c: * Check to see if economy has at least this much gold		   -Thoric
handler.c:   int hasgold = ( ( tarea->high_economy > 0 ) ? 1 : 0 ) * 1000000000 + tarea->low_economy;
handler.c: * Used in db.c when resetting a mob into an area		    -Thoric
handler.c:   mob->gold = UMIN( mob->gold, mob->top_level * mob->top_level * 400 );
handler.c:   if( !mob->in_room )
handler.c:   tarea = mob->in_room->area;
handler.c:   gold = ( ( tarea->high_economy > 0 ) ? 1 : 0 ) * 1000000000 + tarea->low_economy;
handler.c:   mob->gold = URANGE( 0, mob->gold, gold / 10 );
handler.c:   if( mob->gold )
handler.c:      lower_economy( tarea, mob->gold );
handler.c: * Keep track of the last so many kills by vnum			-Thoric
handler.c:   vnum = mob->pIndexData->vnum;
handler.c:   track = URANGE( 2, ( ( ch->skill_level[COMBAT_ABILITY] + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         if( ch->pcdata->killed[x].count < 50 )
handler.c:            ++ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c:   ch->pcdata->killed[0].vnum = vnum;
handler.c:   ch->pcdata->killed[0].count = 1;
handler.c:      ch->pcdata->killed[track].vnum = 0;
handler.c: * Return how many times this player has killed this mob	-Thoric
handler.c:   vnum = mob->pIndexData->vnum;
handler.c:   track = URANGE( 2, ( ( ch->skill_level[COMBAT_ABILITY] + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         return ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   for( ch = first_char; ch; ch = ch->next )
handler.c:   if( !ch->switched )
handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c:         if( paf->duration == -1 )
handler.c:         if( paf->type != -1 && skill_table[paf->type]->spell_fun == spell_possess )
handler.c:      for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
handler.c:         if( cmd->do_fun != do_switch )
handler.c:         if( cmd->level <= trust )
handler.c:         if( !IS_NPC(ch) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c:          && cmd->level <= trust )
handler.c:      set_char_color( AT_BLUE, ch->switched );
handler.c:      send_to_char( "You suddenly forfeit the power to switch!\r\n", ch->switched );
handler.c:   do_return( ch->switched, "" );
handler.c~:*--------------------------------------------------------------------------*
handler.c~:* -------------------------------------------------------------------------*
handler.c~:*--------------------------------------------------------------------------*
handler.c~:* ------------------------------------------------------------------------ *
handler.c~:* ------------------------------------------------------------------------ *
handler.c~:   if( IS_SET( room->room_flags, BFS_MARK ) )
handler.c~:   SET_BIT( room->room_flags, BFS_MARK );
handler.c~:   for( rch = room->first_person; rch; rch = rnext )
handler.c~:      rnext = rch->next_in_room;
handler.c~:      dam = number_range( obj->value[0], obj->value[1] );
handler.c~:            if( IS_SET( rch->act, ACT_SENTINEL ) )
handler.c~:               rch->was_sentinel = rch->in_room;
handler.c~:               REMOVE_BIT( rch->act, ACT_SENTINEL );
handler.c~:   for( robj = room->first_content; robj; robj = robj_next )
handler.c~:      robj_next = robj->next_content;
handler.c~:      if( robj != obj && robj->item_type != ITEM_SPACECRAFT && robj->item_type != ITEM_SCRAPS
handler.c~:          && robj->item_type != ITEM_CORPSE_NPC && robj->item_type != ITEM_CORPSE_PC
handler.c~:          && robj->item_type != ITEM_DROID_CORPSE )
handler.c~:      for( pexit = room->first_exit; pexit; pexit = pexit->next )
handler.c~:         if( pexit->to_room && pexit->to_room != room )
handler.c~:               roomblast = blast - 1;
handler.c~:               room_explode_1( obj, xch, pexit->to_room, roomblast );
handler.c~:               echo_to_room( AT_WHITE, pexit->to_room, "You hear a loud EXPLOSION not to far from here." );
handler.c~:   if( !IS_SET( room->room_flags, BFS_MARK ) )
handler.c~:   REMOVE_BIT( room->room_flags, BFS_MARK );
handler.c~:      for( pexit = room->first_exit; pexit; pexit = pexit->next )
handler.c~:         if( pexit->to_room && pexit->to_room != room )
handler.c~:            roomblast = blast - 1;
handler.c~:            room_explode_2( pexit->to_room, roomblast );
handler.c~:   blast = ( int )( obj->value[1] / 500 );
handler.c~:   if( obj->armed_by )
handler.c~:      for( xch = first_char; xch; xch = xch->next )
handler.c~:         if( !IS_NPC( xch ) && nifty_is_name( obj->armed_by, xch->name ) )
handler.c~:            if( obj->carried_by )
handler.c~:               act( AT_WHITE, "$p EXPLODES in $n's hands!", obj->carried_by, obj, NULL, TO_ROOM );
handler.c~:               act( AT_WHITE, "$p EXPLODES in your hands!", obj->carried_by, obj, NULL, TO_CHAR );
handler.c~:               room = obj->carried_by->in_room;
handler.c~:            else if( obj->in_room )
handler.c~:               room = obj->in_room;
handler.c~:               if( !held && room->first_person )
handler.c~:                  act( AT_WHITE, "$p EXPLODES!", room->first_person, obj, NULL, TO_ROOM );
handler.c~:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) && get_trust( ch ) < victim->pcdata->wizinvis )
handler.c~:   return ch->experience[ability];
handler.c~:   wexp = ch->skill_level[COMBAT_ABILITY] * ch->top_level * 50;
handler.c~:   wexp += ch->max_hit * 2;
handler.c~:   wexp -= ( ch->armor - 50 ) * 2;
handler.c~:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c~:   wexp += GET_HITROLL( ch ) * ch->top_level * 10;
handler.c~:/*								-Thoric
handler.c~:   lvl = UMAX( 0, level - 1 );
handler.c~:   if( ch->desc )
handler.c~:      if( ch->desc->original )
handler.c~:         ch = ch->desc->original;
handler.c~:   if( ch->trust != 0 )
handler.c~:      return ch->trust;
handler.c~:   if( IS_NPC( ch ) && ch->top_level >= LEVEL_AVATAR )
handler.c~:   if( ch->top_level >= LEVEL_NEOPHYTE && IS_RETIRED( ch ) )
handler.c~:   return ch->top_level;
handler.c~:   return 17 + ( ch->played + ( current_time - ch->logon ) ) / 14400;
handler.c~:   max = 20 + race_table[ch->race].str_plus;
handler.c~:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c~:   max = 20 + race_table[ch->race].int_plus;
handler.c~:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c~:   max = 20 + race_table[ch->race].wis_plus;
handler.c~:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c~:   max = 20 + race_table[ch->race].dex_plus;
handler.c~:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c~:   max = 20 + race_table[ch->race].con_plus;
handler.c~:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c~:   max = 20 + race_table[ch->race].cha_plus;
handler.c~:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c~:   max = 20 + race_table[ch->race].lck_plus;
handler.c~:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c~:   max = 20 + race_table[ch->race].frc_plus;
handler.c~:   return URANGE( 0, ch->perm_frc + ch->mod_frc, max );
handler.c~: * Vastly reduced (finally) due to containers		-Thoric
handler.c~:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c~:   return URANGE( 5, ( ch->top_level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c~:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PET ) )
handler.c~: * See if a player/mob can take a piece of prototype eq		-Thoric
handler.c~:   else if( IS_NPC( ch ) && IS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c~: * See if a string is one of the names of an object.		-Thoric
handler.c~:/*								-Thoric
handler.c~:   mod = paf->modifier;
handler.c~:      SET_BIT( ch->affected_by, paf->bitvector );
handler.c~:      REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c~:       * the removed spell's information somewhere...    -Thoric
handler.c~:      switch ( paf->location % REVERSE_APPLY )
handler.c~:            REMOVE_BIT( ch->affected_by, mod );
handler.c~:            REMOVE_BIT( ch->resistant, mod );
handler.c~:            REMOVE_BIT( ch->immune, mod );
handler.c~:            REMOVE_BIT( ch->susceptible, mod );
handler.c~:            SET_BIT( ch->affected_by, mod );
handler.c~:      mod = 0 - mod;
handler.c~:   switch ( paf->location % REVERSE_APPLY )
handler.c~:         bug( "Affect_modify: unknown location %d.", paf->location );
handler.c~:         ch->mod_str += mod;
handler.c~:         ch->mod_dex += mod;
handler.c~:         ch->mod_int += mod;
handler.c~:         ch->mod_wis += mod;
handler.c~:         ch->mod_con += mod;
handler.c~:         ch->mod_cha += mod;
handler.c~:         ch->mod_lck += mod;
handler.c~:         ch->sex = ( ch->sex + mod ) % 3;
handler.c~:         if( ch->sex < 0 )
handler.c~:            ch->sex += 2;
handler.c~:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c~:         ch->height += mod;
handler.c~:         ch->weight += mod;
handler.c~:         ch->max_mana += mod;
handler.c~:         ch->max_hit += mod;
handler.c~:         ch->max_move += mod;
handler.c~:         ch->armor += mod;
handler.c~:         ch->hitroll += mod;
handler.c~:         ch->damroll += mod;
handler.c~:         ch->saving_poison_death += mod;
handler.c~:         ch->saving_wand += mod;
handler.c~:         ch->saving_para_petri += mod;
handler.c~:         ch->saving_breath += mod;
handler.c~:         ch->saving_spell_staff += mod;
handler.c~:         SET_BIT( ch->affected_by, mod );
handler.c~:         SET_BIT( ch->resistant, mod );
handler.c~:         SET_BIT( ch->immune, mod );
handler.c~:         SET_BIT( ch->susceptible, mod );
handler.c~:         REMOVE_BIT( ch->affected_by, mod );
handler.c~:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c~:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c~:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c~:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c~:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c~:/* spell cast upon wear/removal of an object	-Thoric */
handler.c~:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_WEARSPELL && !fAdd ) || ( ( paf->location % REVERSE_APPLY ) == APPLY_REMOVESPELL && !fAdd ) || saving_char == ch /* so save/quit doesn't trigger */
handler.c~:         if( IS_VALID_SN( mod ) && ( skill = skill_table[mod] ) != NULL && skill->type == SKILL_SPELL )
handler.c~:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->skill_level[FORCE_ABILITY], ch, ch ) ) == rCHAR_DIED
handler.c~:/* skill apply types	-Thoric */
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] > 0 )
handler.c~:            ch->pcdata->learned[gsn_track] = UMAX( 1, ch->pcdata->learned[gsn_track] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_hide] > 0 )
handler.c~:            ch->pcdata->learned[gsn_hide] = UMAX( 1, ch->pcdata->learned[gsn_hide] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_steal] > 0 )
handler.c~:            ch->pcdata->learned[gsn_steal] = UMAX( 1, ch->pcdata->learned[gsn_steal] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_sneak] > 0 )
handler.c~:            ch->pcdata->learned[gsn_sneak] = UMAX( 1, ch->pcdata->learned[gsn_sneak] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_pick_lock] > 0 )
handler.c~:            ch->pcdata->learned[gsn_pick_lock] = UMAX( 1, ch->pcdata->learned[gsn_pick_lock] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_backstab] > 0 )
handler.c~:            ch->pcdata->learned[gsn_backstab] = UMAX( 1, ch->pcdata->learned[gsn_backstab] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_detrap] > 0 )
handler.c~:            ch->pcdata->learned[gsn_detrap] = UMAX( 1, ch->pcdata->learned[gsn_detrap] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_dodge] > 0 )
handler.c~:            ch->pcdata->learned[gsn_dodge] = UMAX( 1, ch->pcdata->learned[gsn_dodge] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_peek] > 0 )
handler.c~:            ch->pcdata->learned[gsn_peek] = UMAX( 1, ch->pcdata->learned[gsn_peek] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_scan] > 0 )
handler.c~:            ch->pcdata->learned[gsn_scan] = UMAX( 1, ch->pcdata->learned[gsn_scan] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_gouge] > 0 )
handler.c~:            ch->pcdata->learned[gsn_gouge] = UMAX( 1, ch->pcdata->learned[gsn_gouge] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_search] > 0 )
handler.c~:            ch->pcdata->learned[gsn_search] = UMAX( 1, ch->pcdata->learned[gsn_search] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_dig] > 0 )
handler.c~:            ch->pcdata->learned[gsn_dig] = UMAX( 1, ch->pcdata->learned[gsn_dig] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_mount] > 0 )
handler.c~:            ch->pcdata->learned[gsn_mount] = UMAX( 1, ch->pcdata->learned[gsn_mount] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_disarm] > 0 )
handler.c~:            ch->pcdata->learned[gsn_disarm] = UMAX( 1, ch->pcdata->learned[gsn_disarm] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_kick] > 0 )
handler.c~:            ch->pcdata->learned[gsn_kick] = UMAX( 1, ch->pcdata->learned[gsn_kick] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_parry] > 0 )
handler.c~:            ch->pcdata->learned[gsn_parry] = UMAX( 1, ch->pcdata->learned[gsn_parry] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_bash] > 0 )
handler.c~:            ch->pcdata->learned[gsn_bash] = UMAX( 1, ch->pcdata->learned[gsn_bash] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_stun] > 0 )
handler.c~:            ch->pcdata->learned[gsn_stun] = UMAX( 1, ch->pcdata->learned[gsn_stun] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_punch] > 0 )
handler.c~:            ch->pcdata->learned[gsn_punch] = UMAX( 1, ch->pcdata->learned[gsn_punch] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_climb] > 0 )
handler.c~:            ch->pcdata->learned[gsn_climb] = UMAX( 1, ch->pcdata->learned[gsn_climb] + mod );
handler.c~:         if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_grip] > 0 )
handler.c~:            ch->pcdata->learned[gsn_grip] = UMAX( 1, ch->pcdata->learned[gsn_grip] + mod );
handler.c~:         depth--;
handler.c~:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c~:   paf_new->type = paf->type;
handler.c~:   paf_new->duration = paf->duration;
handler.c~:   paf_new->location = paf->location;
handler.c~:   paf_new->modifier = paf->modifier;
handler.c~:   paf_new->bitvector = paf->bitvector;
handler.c~:   if( !ch->first_affect )
handler.c~:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c~:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c~:      paf_next = paf->next;
handler.c~:      if( paf->type == sn )
handler.c~:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c~:      if( paf->type == sn )
handler.c~:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c~:      if( paf_old->type == paf->type )
handler.c~:         paf->duration = UMIN( 1000000, paf->duration + paf_old->duration );
handler.c~:         if( paf->modifier )
handler.c~:            paf->modifier = UMIN( 5000, paf->modifier + paf_old->modifier );
handler.c~:            paf->modifier = paf_old->modifier;
handler.c~:   if( !ch->in_room )
handler.c~:      bug( "Char_from_room: NULL room: %s", ch->name );
handler.c~:   if(ch->piloting != NULL)
handler.c~:      --ch->in_room->area->nplayer;
handler.c~:       && obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room->light > 0 )
handler.c~:      --ch->in_room->light;
handler.c~:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c~:   ch->in_room = NULL;
handler.c~:   ch->next_in_room = NULL;
handler.c~:   ch->prev_in_room = NULL;
handler.c~:   if( !pRoomIndex || !get_room_index( pRoomIndex->vnum ) )
handler.c~:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __FUNCTION__, ch->name, ROOM_VNUM_LIMBO );
handler.c~:       * and I saw no reason not to just put the char in limbo.  -Narn
handler.c~:   ch->in_room = pRoomIndex;
handler.c~:   if( ch->home_vnum < 1 )
handler.c~:      ch->home_vnum = ch->in_room->vnum;
handler.c~:   LINK( ch, pRoomIndex->first_person, pRoomIndex->last_person, next_in_room, prev_in_room );
handler.c~:      if( ++ch->in_room->area->nplayer > ch->in_room->area->max_players )
handler.c~:         ch->in_room->area->max_players = ch->in_room->area->nplayer;
handler.c~:   if( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL && obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c~:      ++ch->in_room->light;
handler.c~:   if( !IS_NPC( ch ) && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
handler.c~:      add_timer( ch, TIMER_SHOVEDRAG, 10, NULL, 0 );   /*-30 Seconds-*/
handler.c~:    * Delayed Teleport rooms             -Thoric
handler.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_TELEPORT ) && ch->in_room->tele_delay > 0 )
handler.c~:      for( tele = first_teleport; tele; tele = tele->next )
handler.c~:         if( tele->room == pRoomIndex )
handler.c~:      tele->room = pRoomIndex;
handler.c~:      tele->timer = pRoomIndex->tele_delay;
handler.c~:   int wear_loc = obj->wear_loc;
handler.c~:   int extra_flags = obj->extra_flags;
handler.c~:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) && !IS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c~:         return obj_to_room( obj, ch->in_room );
handler.c~:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c~:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c~:      LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c~:      obj->carried_by = ch;
handler.c~:      obj->in_room = NULL;
handler.c~:      obj->in_obj = NULL;
handler.c~:      ch->carry_number += onum;
handler.c~:      ch->carry_weight += oweight;
handler.c~:      ch->carry_weight += oweight;
handler.c~:   if( ( ch = obj->carried_by ) == NULL )
handler.c~:   if( obj->wear_loc != WEAR_NONE )
handler.c~:   if( !obj->carried_by )
handler.c~:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c~:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c~:   obj->in_room = NULL;
handler.c~:   obj->carried_by = NULL;
handler.c~:   ch->carry_number -= get_obj_number( obj );
handler.c~:   ch->carry_weight -= get_obj_weight( obj );
handler.c~:   if( obj->item_type != ITEM_ARMOR )
handler.c~:         return 3 * obj->value[0];
handler.c~:         return 2 * obj->value[0];
handler.c~:         return 2 * obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return 2 * obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~:         return obj->value[0];
handler.c~: * Will pick the top layer if clothing is layered.		-Thoric
handler.c~:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c~:      if( obj->wear_loc == iWear )
handler.c~:         if( !obj->pIndexData->layers )
handler.c~:         else if( !maxobj || obj->pIndexData->layers > maxobj->pIndexData->layers )
handler.c~:   if( ( otmp = get_eq_char( ch, iWear ) ) != NULL && ( !otmp->pIndexData->layers || !obj->pIndexData->layers ) )
handler.c~:   if( obj->carried_by != ch )
handler.c~:      if( obj->carried_by )
handler.c~:      obj_to_room( obj, ch->in_room );
handler.c~:   ch->armor -= apply_ac( obj, iWear );
handler.c~:   obj->wear_loc = iWear;
handler.c~:   ch->carry_number -= get_obj_number( obj );
handler.c~:   if( IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c~:      ch->carry_weight -= get_obj_weight( obj );
handler.c~:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c~:   for( paf = obj->first_affect; paf; paf = paf->next )
handler.c~:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room )
handler.c~:      ++ch->in_room->light;
handler.c~:   if( obj->wear_loc == WEAR_NONE )
handler.c~:   ch->carry_number += get_obj_number( obj );
handler.c~:   if( IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c~:      ch->carry_weight += get_obj_weight( obj );
handler.c~:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c~:   obj->wear_loc = -1;
handler.c~:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c~:   if( obj->carried_by )
handler.c~:      for( paf = obj->first_affect; paf; paf = paf->next )
handler.c~:   if( !obj->carried_by )
handler.c~:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 && ch->in_room && ch->in_room->light > 0 )
handler.c~:      --ch->in_room->light;
handler.c~:   if( ( in_room = obj->in_room ) == NULL )
handler.c~:   UNLINK( obj, in_room->first_content, in_room->last_content, next_content, prev_content );
handler.c~:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c~:      empty_obj( obj, NULL, obj->in_room );
handler.c~:   if( obj->item_type == ITEM_FIRE )
handler.c~:      obj->in_room->light -= obj->count;
handler.c~:   obj->carried_by = NULL;
handler.c~:   obj->in_obj = NULL;
handler.c~:   obj->in_room = NULL;
handler.c~:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling == 0 )
handler.c~:      write_corpses( NULL, obj->short_descr + 14 );
handler.c~:   short count = obj->count;
handler.c~:   short item_type = obj->item_type;
handler.c~:   for( otmp = pRoomIndex->first_content; otmp; otmp = otmp->next_content )
handler.c~:            pRoomIndex->light += count;
handler.c~:   LINK( obj, pRoomIndex->first_content, pRoomIndex->last_content, next_content, prev_content );
handler.c~:   obj->in_room = pRoomIndex;
handler.c~:   obj->carried_by = NULL;
handler.c~:   obj->in_obj = NULL;
handler.c~:   obj->room_vnum = pRoomIndex->vnum;  /* hotboot tracker */
handler.c~:      pRoomIndex->light += count;
handler.c~:   falling--;
handler.c~:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling == 0 )
handler.c~:      write_corpses( NULL, obj->short_descr + 14 );
handler.c~:      bug( "Obj_to_obj: trying to put object inside itself: vnum %d", obj->pIndexData->vnum );
handler.c~:   if( obj->carried_by != obj_to->carried_by )
handler.c~:      if( obj->carried_by )
handler.c~:         obj->carried_by->carry_weight -= get_obj_weight( obj );
handler.c~:      if( obj_to->carried_by )
handler.c~:         obj_to->carried_by->carry_weight += get_obj_weight( obj );
handler.c~:   for( otmp = obj_to->first_content; otmp; otmp = otmp->next_content )
handler.c~:   LINK( obj, obj_to->first_content, obj_to->last_content, next_content, prev_content );
handler.c~:   obj->in_obj = obj_to;
handler.c~:   obj->in_room = NULL;
handler.c~:   obj->carried_by = NULL;
handler.c~:   if( ( obj_from = obj->in_obj ) == NULL )
handler.c~:   UNLINK( obj, obj_from->first_content, obj_from->last_content, next_content, prev_content );
handler.c~:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c~:      empty_obj( obj, obj->in_obj, NULL );
handler.c~:   obj->in_obj = NULL;
handler.c~:   obj->in_room = NULL;
handler.c~:   obj->carried_by = NULL;
handler.c~:   for( ; obj_from; obj_from = obj_from->in_obj )
handler.c~:      if( obj_from->carried_by )
handler.c~:         obj_from->carried_by->carry_weight -= get_obj_weight( obj );
handler.c~:      bug( "extract_obj: obj %d already extracted!", obj->pIndexData->vnum );
handler.c~:   if( obj->item_type == ITEM_PORTAL )
handler.c~:   if( obj->carried_by )
handler.c~:   else if( obj->in_room )
handler.c~:   else if( obj->in_obj )
handler.c~:   while( ( obj_content = obj->last_content ) != NULL )
handler.c~:      for( paf = obj->first_affect; paf; paf = paf_next )
handler.c~:         paf_next = paf->next;
handler.c~:      obj->first_affect = obj->last_affect = NULL;
handler.c~:      for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c~:         ed_next = ed->next;
handler.c~:         STRFREE( ed->description );
handler.c~:         STRFREE( ed->keyword );
handler.c~:      obj->first_extradesc = obj->last_extradesc = NULL;
handler.c~:      gobj_prev = obj->prev;
handler.c~:      rq_next = RQueue->next;
handler.c~:      if( RQueue->Type == relOSET_ON )
handler.c~:         if( obj == RQueue->Subject )
handler.c~:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c~:   obj->pIndexData->count -= obj->count;
handler.c~:   numobjsloaded -= obj->count;
handler.c~:   --physicalobjects;
handler.c~:   if( obj->serial == cur_obj )
handler.c~:   if( !ch->in_room )
handler.c~:      bug( "%s: %s already died!", __FUNCTION__, ch->name );
handler.c~:      rq_next = RQueue->next;
handler.c~:      if( fPull && RQueue->Type == relMSET_ON )
handler.c~:         if( ch == RQueue->Subject )
handler.c~:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c~:         else if( ch != RQueue->Actor )
handler.c~:      gch_prev = ch->prev;
handler.c~:   if( ch->mount )
handler.c~:      REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c~:      ch->mount = NULL;
handler.c~:      ch->position = POS_STANDING;
handler.c~:   if( IS_NPC( ch ) && IS_SET( ch->act, ACT_MOUNTED ) )
handler.c~:      for( wch = first_char; wch; wch = wch->next )
handler.c~:         if( wch->mount == ch )
handler.c~:            wch->mount = NULL;
handler.c~:            wch->position = POS_STANDING;
handler.c~:      REMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c~:   while( ( obj = ch->last_carrying ) != NULL )
handler.c~:      ch->position = POS_RESTING;
handler.c~:      --ch->pIndexData->count;
handler.c~:      --nummobsloaded;
handler.c~:   if( ch->desc && ch->desc->original && IS_SET( ch->act, ACT_POLYMORPHED ) )
handler.c~:   if( ch->desc && ch->desc->original )
handler.c~:   if( ch->switched && ch->switched->desc )
handler.c~:      do_return( ch->switched, "" );
handler.c~:   for( wch = first_char; wch; wch = wch->next )
handler.c~:      if( wch->reply == ch )
handler.c~:         wch->reply = NULL;
handler.c~:   if( ch->desc )
handler.c~:      if( ch->desc->character != ch )
handler.c~:         ch->desc->character = NULL;
handler.c~:         close_socket( ch->desc, FALSE );
handler.c~:         ch->desc = NULL;
handler.c~:      vnum = -1;
handler.c~:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c~:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c~:   if( vnum != -1 )
handler.c~:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c~:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c~:    * Allow reference by vnum for saints+         -Thoric
handler.c~:      vnum = -1;
handler.c~:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c~:      if( ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) && is_wizvis( ch, wch ) )
handler.c~:   for( wch = first_char; wch; wch = wch->next )
handler.c~:      if( ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) && is_wizvis( ch, wch ) )
handler.c~:   if( vnum != -1 )
handler.c~:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c~:      if( !nifty_is_name_prefix( arg, wch->name ) )
handler.c~:   for( wch = first_char; wch; wch = wch->next )
handler.c~:      if( !nifty_is_name_prefix( arg, wch->name ) )
handler.c~:   for( obj = list; obj; obj = obj->next_content )
handler.c~:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:   for( obj = list; obj; obj = obj->next_content )
handler.c~:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~: * Find an obj in a list...going the other way			-Thoric
handler.c~:   for( obj = list; obj; obj = obj->prev_content )
handler.c~:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:   for( obj = list; obj; obj = obj->prev_content )
handler.c~:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:      vnum = -1;
handler.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c~:      if( obj->wear_loc == WEAR_NONE
handler.c~:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:   if( vnum != -1 )
handler.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c~:      if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:      vnum = -1;
handler.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c~:      if( obj->wear_loc != WEAR_NONE
handler.c~:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c~:   if( vnum != -1 )
handler.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c~:      if( obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c~:   if( !ch || !ch->in_room )
handler.c~:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c~:    * Allow reference by vnum for saints+         -Thoric
handler.c~:      vnum = -1;
handler.c~:   for( obj = first_object; obj; obj = obj->next )
handler.c~:      if( can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || vnum == obj->pIndexData->vnum ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~:   if( vnum != -1 )
handler.c~:   for( obj = first_object; obj; obj = obj->next )
handler.c~:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c~:         if( ( count += obj->count ) >= number )
handler.c~: * How mental state could affect finding an object		-Thoric
handler.c~:   int ms = ch->mental_state;
handler.c~:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c~:      switch ( number_range( UMAX( 1, ( ms / 5 - 15 ) ), ( ms + 4 ) / 5 ) )
handler.c~:            t = "What about the millions of burrow-maggots feasting on your arm?!?!\r\n";
handler.c~: * Generic get obj function that supports optional containers.	-Thoric
handler.c~:      if( !IS_OBJ_STAT( container, ITEM_COVERING ) && IS_SET( container->value[1], CONT_CLOSED ) )
handler.c~:         act( AT_PLAIN, "The $d is closed.", ch, NULL, container->name, TO_CHAR );
handler.c~:      obj = get_obj_list( ch, arg1, container->first_content );
handler.c~:   return obj->count;
handler.c~:   weight = obj->count * obj->weight;
handler.c~:   for( obj = obj->first_content; obj; obj = obj->next_content )
handler.c~:   if( pRoomIndex->light > 0 )
handler.c~:   if( IS_SET( pRoomIndex->room_flags, ROOM_DARK ) )
handler.c~:   if( pRoomIndex->sector_type == SECT_INSIDE || pRoomIndex->sector_type == SECT_CITY )
handler.c~:   if( IS_SET( pRoomIndex->room_flags, ROOM_PLR_HOME ) && ch->plr_home != pRoomIndex )
handler.c~:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c~:   if( IS_SET( pRoomIndex->room_flags, ROOM_PRIVATE ) && count >= 2 )
handler.c~:   if( IS_SET( pRoomIndex->room_flags, ROOM_SOLITARY ) && count >= 1 )
handler.c~:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c~:      if( IS_AFFECTED( victim, AFF_INVISIBLE ) || IS_AFFECTED( victim, AFF_HIDE ) || IS_SET( victim->act, PLR_WIZINVIS ) )
handler.c~:   if( !IS_NPC( victim ) && IS_SET( victim->act, PLR_WIZINVIS ) && get_trust( ch ) < victim->pcdata->wizinvis )
handler.c~:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c~:   if( victim->position == POS_FIGHTING || victim->position < POS_SLEEPING )
handler.c~:   if( IS_NPC( victim ) && IS_SET( victim->act, ACT_MOBINVIS ) && get_trust( ch ) < victim->mobinvis )
handler.c~:   if( !IS_IMMORTAL( ch ) && !IS_NPC( victim ) && !victim->desc
handler.c~:       && ( !victim->switched || !IS_AFFECTED( victim->switched, AFF_POSSESS ) ) )
handler.c~:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c~:    * The miracle cure for blindness? -- Altrag 
handler.c~:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c~:      if( IS_AFFECTED( victim, AFF_HIDE ) && !IS_AFFECTED( ch, AFF_DETECT_HIDDEN ) && !victim->fighting )
handler.c~:      if( ch->race == RACE_DEFEL && victim->race == RACE_DEFEL )
handler.c~:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c~:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c~:   if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c~:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c~:   if( obj->item_type < 1 || obj->item_type > MAX_ITEM_TYPE )
handler.c~:      bug( "Item_type_name: unknown type %d.", obj->item_type );
handler.c~:   return o_types[obj->item_type];
handler.c~:      strcat( buf, " anti-good" );
handler.c~:      strcat( buf, " anti-evil" );
handler.c~:      strcat( buf, " anti-neutral" );
handler.c~:      strcat( buf, " anti-soldier" );
handler.c~:      strcat( buf, " anti-thief" );
handler.c~:      strcat( buf, " anti-hunter" );
handler.c~:      strcat( buf, " anti-jedi" );
handler.c~:      strcat( buf, " anti-sith" );
handler.c~:      strcat( buf, " anti-pilot" );
handler.c~:      strcat( buf, " anti-citizen" );
handler.c~: * Return ascii name of magic flags vector. - Scryn
handler.c~: * Set off a trap (obj) upon character (ch)			-Thoric
handler.c~:   typ = obj->value[1];
handler.c~:   lev = obj->value[2];
handler.c~:   dam = number_range( obj->value[2], obj->value[2] * 2 );
handler.c~:   --obj->value[0];
handler.c~:   if( obj->value[0] <= 0 )
handler.c~: * Check an object for a trap					-Thoric
handler.c~:   if( !obj->first_content )
handler.c~:   for( check = obj->first_content; check; check = check->next_content )
handler.c~:      if( check->item_type == ITEM_TRAP && IS_SET( check->value[3], flag ) )
handler.c~: * Check the room for a trap					-Thoric
handler.c~:   if( !ch->in_room || !ch->in_room->first_content )
handler.c~:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c~:      if( check->item_type == ITEM_LANDMINE && flag == TRAP_ENTER_ROOM )
handler.c~:      else if( check->item_type == ITEM_TRAP && IS_SET( check->value[3], flag ) )
handler.c~: * return TRUE if an object contains a trap			-Thoric
handler.c~:   if( !obj->first_content )
handler.c~:   for( check = obj->first_content; check; check = check->next_content )
handler.c~:      if( check->item_type == ITEM_TRAP )
handler.c~: * If an object contains a trap, return the pointer to the trap	-Thoric
handler.c~:   if( !obj->first_content )
handler.c~:   for( check = obj->first_content; check; check = check->next_content )
handler.c~:      if( check->item_type == ITEM_TRAP )
handler.c~: * Remove an exit from a room					-Thoric
handler.c~:   UNLINK( pexit, room->first_exit, room->last_exit, next, prev );
handler.c~:   if( pexit->rexit )
handler.c~:      pexit->rexit->rexit = NULL;
handler.c~:   STRFREE( pexit->keyword );
handler.c~:   STRFREE( pexit->description );
handler.c~: * clean out a room (leave list pointers intact )		-Thoric
handler.c~:   STRFREE( room->description );
handler.c~:   STRFREE( room->name );
handler.c~:   for( ed = room->first_extradesc; ed; ed = ed_next )
handler.c~:      ed_next = ed->next;
handler.c~:      STRFREE( ed->description );
handler.c~:      STRFREE( ed->keyword );
handler.c~:      top_ed--;
handler.c~:   room->first_extradesc = NULL;
handler.c~:   room->last_extradesc = NULL;
handler.c~:   for( pexit = room->first_exit; pexit; pexit = pexit_next )
handler.c~:      pexit_next = pexit->next;
handler.c~:      STRFREE( pexit->keyword );
handler.c~:      STRFREE( pexit->description );
handler.c~:      top_exit--;
handler.c~:   room->first_exit = NULL;
handler.c~:   room->last_exit = NULL;
handler.c~:   room->room_flags = 0;
handler.c~:   room->sector_type = 0;
handler.c~:   room->light = 0;
handler.c~: * clean out an object (index) (leave list pointers intact )	-Thoric
handler.c~:   STRFREE( obj->name );
handler.c~:   STRFREE( obj->short_descr );
handler.c~:   STRFREE( obj->description );
handler.c~:   STRFREE( obj->action_desc );
handler.c~:   obj->item_type = 0;
handler.c~:   obj->extra_flags = 0;
handler.c~:   obj->wear_flags = 0;
handler.c~:   obj->count = 0;
handler.c~:   obj->weight = 0;
handler.c~:   obj->cost = 0;
handler.c~:   obj->value[0] = 0;
handler.c~:   obj->value[1] = 0;
handler.c~:   obj->value[2] = 0;
handler.c~:   obj->value[3] = 0;
handler.c~:   obj->value[4] = 0;
handler.c~:   obj->value[5] = 0;
handler.c~:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c~:      paf_next = paf->next;
handler.c~:      top_affect--;
handler.c~:   obj->first_affect = NULL;
handler.c~:   obj->last_affect = NULL;
handler.c~:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c~:      ed_next = ed->next;
handler.c~:      STRFREE( ed->description );
handler.c~:      STRFREE( ed->keyword );
handler.c~:      top_ed--;
handler.c~:   obj->first_extradesc = NULL;
handler.c~:   obj->last_extradesc = NULL;
handler.c~: * clean out a mobile (index) (leave list pointers intact )	-Thoric
handler.c~:   STRFREE( mob->player_name );
handler.c~:   STRFREE( mob->short_descr );
handler.c~:   STRFREE( mob->long_descr );
handler.c~:   STRFREE( mob->description );
handler.c~:   mob->spec_fun = NULL;
handler.c~:   mob->spec_2 = NULL;
handler.c~:   mob->pShop = NULL;
handler.c~:   mob->rShop = NULL;
handler.c~:   mob->progtypes = 0;
handler.c~:   for( mprog = mob->mudprogs; mprog; mprog = mprog_next )
handler.c~:      mprog_next = mprog->next;
handler.c~:      STRFREE( mprog->arglist );
handler.c~:      STRFREE( mprog->comlist );
handler.c~:   mob->count = 0;
handler.c~:   mob->killed = 0;
handler.c~:   mob->sex = 0;
handler.c~:   mob->level = 0;
handler.c~:   mob->act = 0;
handler.c~:   mob->affected_by = 0;
handler.c~:   mob->alignment = 0;
handler.c~:   mob->mobthac0 = 0;
handler.c~:   mob->ac = 0;
handler.c~:   mob->hitnodice = 0;
handler.c~:   mob->hitsizedice = 0;
handler.c~:   mob->hitplus = 0;
handler.c~:   mob->damnodice = 0;
handler.c~:   mob->damsizedice = 0;
handler.c~:   mob->damplus = 0;
handler.c~:   mob->gold = 0;
handler.c~:   mob->position = 0;
handler.c~:   mob->defposition = 0;
handler.c~:   mob->height = 0;
handler.c~:   mob->weight = 0;
handler.c~: * Remove all resets from a room -Thoric
handler.c~:    for( pReset = room->first_reset; pReset; pReset = pReset_next )
handler.c~:	pReset_next = pReset->next;
handler.c~:	--top_reset;
handler.c~:    room->first_reset	= NULL;
handler.c~:    room->last_reset	= NULL;
handler.c~: * "Fix" a character's stats					-Thoric
handler.c~:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c~:   ch->affected_by = race_table[ch->race].affected;
handler.c~:   ch->mental_state = -10;
handler.c~:   ch->hit = UMAX( 1, ch->hit );
handler.c~:   ch->mana = UMAX( 1, ch->mana );
handler.c~:   ch->move = UMAX( 1, ch->move );
handler.c~:   ch->armor = 100;
handler.c~:   ch->mod_str = 0;
handler.c~:   ch->mod_dex = 0;
handler.c~:   ch->mod_wis = 0;
handler.c~:   ch->mod_int = 0;
handler.c~:   ch->mod_con = 0;
handler.c~:   ch->mod_cha = 0;
handler.c~:   ch->mod_lck = 0;
handler.c~:   ch->damroll = 0;
handler.c~:   ch->hitroll = 0;
handler.c~:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c~:   ch->saving_breath = 0;
handler.c~:   ch->saving_wand = 0;
handler.c~:   ch->saving_para_petri = 0;
handler.c~:   ch->saving_spell_staff = 0;
handler.c~:   ch->saving_poison_death = 0;
handler.c~:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c~:   ch->carry_weight = 0;
handler.c~:   ch->carry_number = 0;
handler.c~:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c~:      if( obj->wear_loc == WEAR_NONE )
handler.c~:         ch->carry_number += get_obj_number( obj );
handler.c~:      if( !IS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c~:         ch->carry_weight += get_obj_weight( obj );
handler.c~: * Show an affect verbosely to a character			-Thoric
handler.c~:   if( paf->location != APPLY_NONE && paf->modifier != 0 )
handler.c~:      switch ( paf->location )
handler.c~:            sprintf( buf, "Affects %s by %d.\r\n", affect_loc_name( paf->location ), paf->modifier );
handler.c~:            sprintf( buf, "Affects %s by", affect_loc_name( paf->location ) );
handler.c~:               if( IS_SET( paf->modifier, 1 << x ) )
handler.c~:                     IS_VALID_SN( paf->modifier ) ? skill_table[paf->modifier]->name : "unknown" );
handler.c~:            sprintf( buf, "Affects %s by", affect_loc_name( paf->location ) );
handler.c~:               if( IS_SET( paf->modifier, 1 << x ) )
handler.c~: * Set the current global object to obj				-Thoric
handler.c~:   cur_obj = obj->serial;
handler.c~: * Check the recently extracted object queue for obj		-Thoric
handler.c~:   if( obj->serial == cur_obj && cur_obj_extracted )
handler.c~:   for( cod = extracted_obj_queue; cod; cod = cod->next )
handler.c~:   obj->next = extracted_obj_queue;
handler.c~:   for( mpact = obj->mpact; mpact; mpact = mpact_next )
handler.c~:      mpact_next = mpact->next;
handler.c~:      DISPOSE( mpact->buf );
handler.c~:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c~:      paf_next = paf->next;
handler.c~:   obj->first_affect = obj->last_affect = NULL;
handler.c~:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c~:      ed_next = ed->next;
handler.c~:      STRFREE( ed->description );
handler.c~:      STRFREE( ed->keyword );
handler.c~:   obj->first_extradesc = obj->last_extradesc = NULL;
handler.c~:      rq_next = RQueue->next;
handler.c~:      if( RQueue->Type == relOSET_ON )
handler.c~:         if( obj == RQueue->Subject )
handler.c~:            ( ( CHAR_DATA * ) RQueue->Actor )->dest_buf = NULL;
handler.c~:   STRFREE( obj->name );
handler.c~:   STRFREE( obj->description );
handler.c~:   STRFREE( obj->short_descr );
handler.c~:   STRFREE( obj->action_desc );
handler.c~:      extracted_obj_queue = extracted_obj_queue->next;
handler.c~:      --cur_qobjs;
handler.c~: * Set the current global character to ch			-Thoric
handler.c~:   cur_room = ch->in_room;
handler.c~: * Check to see if ch died recently				-Thoric
handler.c~:   for( ccd = extracted_char_queue; ccd; ccd = ccd->next )
handler.c~:      if( ccd->ch == ch )
handler.c~: * Add ch to the queue of recently extracted characters		-Thoric
handler.c~:   ccd->ch = ch;
handler.c~:   ccd->room = ch->in_room;
handler.c~:   ccd->extract = extract;
handler.c~:      ccd->retcode = global_retcode;
handler.c~:      ccd->retcode = rCHAR_DIED;
handler.c~:   ccd->next = extracted_char_queue;
handler.c~:      extracted_char_queue = ccd->next;
handler.c~:      if( ccd->extract )
handler.c~:         free_char( ccd->ch );
handler.c~:      --cur_qchars;
handler.c~: * Add a timer to ch						-Thoric
handler.c~:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c~:      if( timer->type == type )
handler.c~:         timer->count = count;
handler.c~:         timer->do_fun = fun;
handler.c~:         timer->value = value;
handler.c~:      timer->count = count;
handler.c~:      timer->type = type;
handler.c~:      timer->do_fun = fun;
handler.c~:      timer->value = value;
handler.c~:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c~:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c~:      if( timer->type == type )
handler.c~:      return timer->count;
handler.c~:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c~:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c~:      if( timer->type == type )
handler.c~:   else if( ch->top_level >= tarea->low_soft_range || ch->top_level <= tarea->hi_soft_range )
handler.c~:   else if( ch->top_level >= tarea->low_hard_range && ch->top_level <= tarea->hi_hard_range )
handler.c~:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c~:   ms = 10 - abs( ch->mental_state );
handler.c~:   if( ( number_percent(  ) - get_curr_lck( ch ) + 13 - ms ) )
handler.c~:   if( number_percent(  ) - get_curr_lck( ch ) + 13 - attrib + 13 )
handler.c~: * Make a simple clone of an object (no extras...yet)		-Thoric
handler.c~:   clone->pIndexData = obj->pIndexData;
handler.c~:   clone->name = QUICKLINK( obj->name );
handler.c~:   clone->short_descr = QUICKLINK( obj->short_descr );
handler.c~:   clone->description = QUICKLINK( obj->description );
handler.c~:   clone->action_desc = QUICKLINK( obj->action_desc );
handler.c~:   clone->item_type = obj->item_type;
handler.c~:   clone->extra_flags = obj->extra_flags;
handler.c~:   clone->magic_flags = obj->magic_flags;
handler.c~:   clone->wear_flags = obj->wear_flags;
handler.c~:   clone->wear_loc = obj->wear_loc;
handler.c~:   clone->weight = obj->weight;
handler.c~:   clone->cost = obj->cost;
handler.c~:   clone->level = obj->level;
handler.c~:   clone->timer = obj->timer;
handler.c~:   clone->value[0] = obj->value[0];
handler.c~:   clone->value[1] = obj->value[1];
handler.c~:   clone->value[2] = obj->value[2];
handler.c~:   clone->value[3] = obj->value[3];
handler.c~:   clone->value[4] = obj->value[4];
handler.c~:   clone->value[5] = obj->value[5];
handler.c~:   clone->count = 1;
handler.c~:   ++obj->pIndexData->count;
handler.c~:   cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
handler.c~:   clone->serial = clone->pIndexData->serial = cur_obj_serial;
handler.c~: * If possible group obj2 into obj1				-Thoric
handler.c~: * This code, along with clone_object, obj->count, and special support
handler.c~:   if( obj1->pIndexData == obj2->pIndexData
handler.c~:    &&	!obj1->pIndexData->mudprogs
handler.c~:    &&  !obj2->pIndexData->mudprogs
handler.c~:       && !str_cmp( obj1->name, obj2->name )
handler.c~:       && !str_cmp( obj1->short_descr, obj2->short_descr )
handler.c~:       && !str_cmp( obj1->description, obj2->description )
handler.c~:       && !str_cmp( obj1->action_desc, obj2->action_desc )
handler.c~:       && obj1->item_type == obj2->item_type
handler.c~:       && obj1->extra_flags == obj2->extra_flags
handler.c~:       && obj1->magic_flags == obj2->magic_flags
handler.c~:       && obj1->wear_flags == obj2->wear_flags
handler.c~:       && obj1->wear_loc == obj2->wear_loc
handler.c~:       && obj1->weight == obj2->weight
handler.c~:       && obj1->cost == obj2->cost
handler.c~:       && obj1->level == obj2->level
handler.c~:       && obj1->timer == obj2->timer
handler.c~:       && obj1->value[0] == obj2->value[0]
handler.c~:       && obj1->value[1] == obj2->value[1]
handler.c~:       && obj1->value[2] == obj2->value[2]
handler.c~:       && obj1->value[3] == obj2->value[3]
handler.c~:       && obj1->value[4] == obj2->value[4]
handler.c~:       && obj1->value[5] == obj2->value[5]
handler.c~:       && !obj1->first_extradesc && !obj2->first_extradesc
handler.c~:       && !obj1->first_affect && !obj2->first_affect && !obj1->first_content && !obj2->first_content )
handler.c~:      obj1->count += obj2->count;
handler.c~:      obj1->pIndexData->count += obj2->count;   /* to be decremented in */
handler.c~:      numobjsloaded += obj2->count; /* extract_obj */
handler.c~: * Split off a grouped object					-Thoric
handler.c~:   count = obj->count;
handler.c~:   --obj->pIndexData->count;  /* since clone_object() ups this value */
handler.c~:   --numobjsloaded;
handler.c~:   rest->count = obj->count - num;
handler.c~:   obj->count = num;
handler.c~:   if( obj->carried_by )
handler.c~:      LINK( rest, obj->carried_by->first_carrying, obj->carried_by->last_carrying, next_content, prev_content );
handler.c~:      rest->carried_by = obj->carried_by;
handler.c~:      rest->in_room = NULL;
handler.c~:      rest->in_obj = NULL;
handler.c~:   else if( obj->in_room )
handler.c~:      LINK( rest, obj->in_room->first_content, obj->in_room->last_content, next_content, prev_content );
handler.c~:      rest->carried_by = NULL;
handler.c~:      rest->in_room = obj->in_room;
handler.c~:      rest->in_obj = NULL;
handler.c~:   else if( obj->in_obj )
handler.c~:      LINK( rest, obj->in_obj->first_content, obj->in_obj->last_content, next_content, prev_content );
handler.c~:      rest->in_obj = obj->in_obj;
handler.c~:      rest->in_room = NULL;
handler.c~:      rest->carried_by = NULL;
handler.c~:   CHAR_DATA *ch = obj->carried_by;
handler.c~:   if( destobj || ( !destroom && !ch && ( destobj = obj->in_obj ) != NULL ) )
handler.c~:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c~:         otmp_next = otmp->next_content;
handler.c~:         if( destobj->item_type == ITEM_CONTAINER && get_obj_weight( otmp ) + get_obj_weight( destobj ) > destobj->value[0] )
handler.c~:   if( destroom || ( !ch && ( destroom = obj->in_room ) != NULL ) )
handler.c~:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c~:         otmp_next = otmp->next_content;
handler.c~:         if( ch && ( otmp->pIndexData->progtypes & DROP_PROG ) && otmp->count > 1 )
handler.c~:               otmp_next = obj->first_content;
handler.c~:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c~:         otmp_next = otmp->next_content;
handler.c~:   bug( "empty_obj: could not determine a destination for vnum %d", obj->pIndexData->vnum );
handler.c~: * Improve mental state						-Thoric
handler.c~:   if( ch->mental_state < 0 )
handler.c~:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c~:   else if( ch->mental_state > 0 )
handler.c~:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c~: * Deteriorate mental state					-Thoric
handler.c~:   c -= number_percent(  ) < con ? 1 : 0;
handler.c~:   if( ch->mental_state < 0 )
handler.c~:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c~:   else if( ch->mental_state > 0 )
handler.c~:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c~:      ch->mental_state -= c;
handler.c~: * Add gold to an area's economy				-Thoric
handler.c~:      ++tarea->high_economy;
handler.c~:      gold -= 1000000000;
handler.c~:   tarea->low_economy += gold;
handler.c~:   while( tarea->low_economy >= 1000000000 )
handler.c~:      ++tarea->high_economy;
handler.c~:      tarea->low_economy -= 1000000000;
handler.c~: * Take gold from an area's economy				-Thoric
handler.c~:      tarea->high_economy -= 1;
handler.c~:      gold -= 1000000000;
handler.c~:   tarea->low_economy -= gold;
handler.c~:   while( tarea->low_economy < 0 )
handler.c~:      tarea->high_economy -= 1;
handler.c~:      tarea->low_economy += 1000000000;
handler.c~: * Check to see if economy has at least this much gold		   -Thoric
handler.c~:   int hasgold = ( ( tarea->high_economy > 0 ) ? 1 : 0 ) * 1000000000 + tarea->low_economy;
handler.c~: * Used in db.c when resetting a mob into an area		    -Thoric
handler.c~:   mob->gold = UMIN( mob->gold, mob->top_level * mob->top_level * 400 );
handler.c~:   if( !mob->in_room )
handler.c~:   tarea = mob->in_room->area;
handler.c~:   gold = ( ( tarea->high_economy > 0 ) ? 1 : 0 ) * 1000000000 + tarea->low_economy;
handler.c~:   mob->gold = URANGE( 0, mob->gold, gold / 10 );
handler.c~:   if( mob->gold )
handler.c~:      lower_economy( tarea, mob->gold );
handler.c~: * Keep track of the last so many kills by vnum			-Thoric
handler.c~:   vnum = mob->pIndexData->vnum;
handler.c~:   track = URANGE( 2, ( ( ch->skill_level[COMBAT_ABILITY] + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c~:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c~:         if( ch->pcdata->killed[x].count < 50 )
handler.c~:            ++ch->pcdata->killed[x].count;
handler.c~:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c~:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c~:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c~:   ch->pcdata->killed[0].vnum = vnum;
handler.c~:   ch->pcdata->killed[0].count = 1;
handler.c~:      ch->pcdata->killed[track].vnum = 0;
handler.c~: * Return how many times this player has killed this mob	-Thoric
handler.c~:   vnum = mob->pIndexData->vnum;
handler.c~:   track = URANGE( 2, ( ( ch->skill_level[COMBAT_ABILITY] + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c~:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c~:         return ch->pcdata->killed[x].count;
handler.c~:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c~:   for( ch = first_char; ch; ch = ch->next )
handler.c~:   if( !ch->switched )
handler.c~:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c~:         if( paf->duration == -1 )
handler.c~:         if( paf->type != -1 && skill_table[paf->type]->spell_fun == spell_possess )
handler.c~:      for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
handler.c~:         if( cmd->do_fun != do_switch )
handler.c~:         if( cmd->level <= trust )
handler.c~:         if( !IS_NPC(ch) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c~:          && cmd->level <= trust )
handler.c~:      set_char_color( AT_BLUE, ch->switched );
handler.c~:      send_to_char( "You suddenly forfeit the power to switch!\r\n", ch->switched );
handler.c~:   do_return( ch->switched, "" );
hashstr.c:*--------------------------------------------------------------------------*
hashstr.c:* -------------------------------------------------------------------------*
hashstr.c:*--------------------------------------------------------------------------*
hashstr.c:* ------------------------------------------------------------------------ *
hashstr.c:* ------------------------------------------------------------------------ *
hashstr.c:* this as you still save lots of space on duplicate strings.	-Thoric	   *
hashstr.c:   for( ptr = string_hash[hash]; ptr; ptr = ptr->next )
hashstr.c:      if( len == ptr->length && !strcmp( str, ( char * )ptr + psize ) )
hashstr.c:         if( ptr->links < 65535 )
hashstr.c:            ++ptr->links;
hashstr.c:   ptr->links = 1;
hashstr.c:   ptr->length = len;
hashstr.c:   ptr->next = string_hash[hash];
hashstr.c:   ptr = ( struct hashstr_data * )( str - sizeof( struct hashstr_data ) );
hashstr.c:   if( ptr->links == 0 )
hashstr.c:   if( ptr->links < 65535 )
hashstr.c:      ++ptr->links;
hashstr.c: * returns how many links are left, or -1 if an error occurred.
hashstr.c:   ptr = ( struct hashstr_data * )( str - sizeof( struct hashstr_data ) );
hashstr.c:   if( ptr->links == 65535 )  /* permanent */
hashstr.c:      return ptr->links;
hashstr.c:   if( ptr->links == 0 )
hashstr.c:      return -1;
hashstr.c:   if( --ptr->links == 0 )
hashstr.c:         string_hash[hash] = ptr->next;
hashstr.c:         ptr2_next = ptr2->next;
hashstr.c:            ptr2->next = ptr->next;
hashstr.c:      return -1;
hashstr.c:   return ptr->links;
hashstr.c:      for( c = 0, ptr = string_hash[x]; ptr; ptr = ptr->next, c++ );
hashstr.c:   for( c = 0, ptr = string_hash[hash]; ptr; ptr = ptr->next, c++ )
hashstr.c:      fprintf( stderr, "Len:%4d Lnks:%5d Str: %s\r\n", ptr->length, ptr->links, str );
hashstr.c:   for( fnd = NULL, ptr = string_hash[hash], c = 0; ptr; ptr = ptr->next, c++ )
hashstr.c:      if( len == ptr->length && !strcmp( str, ( char * )ptr + psize ) )
hashstr.c:               str, fnd->links, p, c, hash, fnd->length );
hashstr.c:      for( c = 0, ptr = string_hash[x]; ptr; ptr = ptr->next, c++ )
hashstr.c:         if( ptr->links == 1 )
hashstr.c:         if( ptr->links > hilink )
hashstr.c:            hilink = ptr->links;
hashstr.c:         totlinks += ptr->links;
hashstr.c:         bytesused += ( ptr->length + 1 + sizeof( struct hashstr_data ) );
hashstr.c:         wouldhave += ( ( ptr->links * sizeof(struct hashstr_data) ) + ( ptr->links * ( ptr->length + 1 ) ) );
hashstr.c:            "Hash strings allocated:%8d  Total links  : %d\r\nString bytes allocated:%8d  Bytes saved  : %d\r\nUnique (wasted) links :%8d  Hi-Link count: %d\r\n",
hashstr.c:            total, totlinks, bytesused, wouldhave - bytesused, unique, hilink );
hashstr.c:      for( ptr = string_hash[x]; ptr; ptr = ptr->next )
hashstr.c:         if( ptr->links >= top )
hashstr.c:            fprintf( stderr, "Links: %5d  String: >%s<\r\n", ptr->links, str );
hashstr.c:   for( ptr = string_hash[hash]; ptr; ptr = ptr->next )
hashstr.c:      if( len == ptr->length && str == ( (char *)ptr + psize ) )
hotboot.c: *                           ^     +----- |  / ^     ^ |     | +-\                       *
hotboot.c: *                         /   \   +---   |<   | \ / | |     | |  |                      *
hotboot.c: *                        /-----\  |      | \  |  v  | |     | |  /                      *
hotboot.c: *                       /       \ |      |  \ |     | +-----+ +-/                       *
hotboot.c: * AFKMud Copyright 1997-2003 by Roger Libiez (Samson), Levi Beckerson (Whir),           *
hotboot.c:   if( ship->shipstate == SHIP_DOCKED )
hotboot.c:   if( ship->ship_class > SHIP_PLATFORM )
hotboot.c:   fprintf( fp, "Shipfname	%s~\n", ship->filename );
hotboot.c:   if( ship->currspeed != 0 )
hotboot.c:      fprintf( fp, "Currspeed %d\n", ship->currspeed );
hotboot.c:   if( ship->chaff != ship->maxchaff )
hotboot.c:      fprintf( fp, "Chaff %d\n", ship->chaff );
hotboot.c:   if( ship->shield != ship->maxshield )
hotboot.c:      fprintf( fp, "Shield %d\n", ship->shield );
hotboot.c:   if( ship->missiles != ship->maxmissiles )
hotboot.c:      fprintf( fp, "Missiles %d\n", ship->missiles );
hotboot.c:   if( ship->torpedos != ship->maxtorpedos )
hotboot.c:      fprintf( fp, "Torpedos %d\n", ship->torpedos );
hotboot.c:   if( ship->rockets != ship->maxrockets )
hotboot.c:      fprintf( fp, "Rockets %d\n", ship->rockets );
hotboot.c:   fprintf( fp, "Autorecharge %d\n", ship->autorecharge );
hotboot.c:   fprintf( fp, "Autotrack %d\n", ship->autotrack );
hotboot.c:   fprintf( fp, "Autospeed %d\n", ship->autospeed );
hotboot.c:   fprintf( fp, "Autopilot %d\n", ship->autopilot );
hotboot.c:   fprintf( fp, "VX %d\n", ( int )ship->vx );
hotboot.c:   fprintf( fp, "VY %d\n", ( int )ship->vy );
hotboot.c:   fprintf( fp, "VZ %d\n", ( int )ship->vz );
hotboot.c:   fprintf( fp, "HX %d\n", ( int )ship->hx );
hotboot.c:   fprintf( fp, "HY %d\n", ( int )ship->hy );
hotboot.c:   fprintf( fp, "HZ %d\n", ( int )ship->hz );
hotboot.c:   fprintf( fp, "JX %d\n", ( int )ship->jx );
hotboot.c:   fprintf( fp, "JY %d\n", ( int )ship->jy );
hotboot.c:   fprintf( fp, "JZ %d\n", ( int )ship->jz );
hotboot.c:   if( ship->target0 )
hotboot.c:      fprintf( fp, "Target0 %s~\n", ship->target0->name );
hotboot.c:   if( ship->target1 )
hotboot.c:      fprintf( fp, "Target1 %s~\n", ship->target1->name );
hotboot.c:   if( ship->target2 )
hotboot.c:      fprintf( fp, "Target2 %s~\n", ship->target2->name );
hotboot.c:   fprintf( fp, "Shipstate %d\n", ship->shipstate );
hotboot.c:   if( ship->dest != NULL && ship->dest[0] != '\0' )
hotboot.c:      fprintf( fp, "LandDest %s~\n", ship->dest );
hotboot.c:   if( ship->shipstate == SHIP_HYPERSPACE )
hotboot.c:      fprintf( fp, "Hyperdistance %d\n", ship->hyperdistance );
hotboot.c:      fprintf( fp, "Currjump %s~\n", ship->currjump->name );
hotboot.c:   if( ship->energy != ship->maxenergy )
hotboot.c:      fprintf( fp, "Energy %d\n", ship->energy );
hotboot.c:   if( ship->hull != ship->maxhull )
hotboot.c:      fprintf( fp, "Hull %d\n", ship->hull );
hotboot.c:   if( ship->starsystem )
hotboot.c:      fprintf( fp, "Starsystem %s~\n", ship->starsystem->name );
hotboot.c:     const char *name = fread_string_nohash( fp ); /* is this right? - Gavin */
hotboot.c:      for( temp_ship = first_ship; temp_ship; temp_ship = temp_ship->next )
hotboot.c:         if( !str_cmp( name, temp_ship->filename ) )
hotboot.c:             * mob->tempnum = -9999; 
hotboot.c:            KEY( "Autorecharge", ship->autorecharge, ( bool ) fread_number( fp ) );
hotboot.c:            KEY( "Autotrack", ship->autotrack, ( bool ) fread_number( fp ) );
hotboot.c:            KEY( "Autospeed", ship->autospeed, ( bool ) fread_number( fp ) );
hotboot.c:            KEY( "Autopilot", ship->autopilot, ( bool ) fread_number( fp ) );
hotboot.c:            KEY( "Currspeed", ship->currspeed, fread_number( fp ) );
hotboot.c:               ship->location = 0;
hotboot.c:               ship->currjump = starsystem_from_name( temp );
hotboot.c:            KEY( "Chaff", ship->chaff, fread_number( fp ) );
hotboot.c:            KEY( "Energy", ship->energy, fread_number( fp ) );
hotboot.c:            if( !str_cmp( word, "End" ) ) /* End of object, need to ignore this. sometimes they creep in there somehow -- Scion */
hotboot.c:            KEY( "Hull", ship->hull, fread_number( fp ) );
hotboot.c:            KEY( "HX", ship->hx, ( float )fread_number( fp ) );
hotboot.c:            KEY( "HY", ship->hy, ( float )fread_number( fp ) );
hotboot.c:            KEY( "HZ", ship->hz, ( float )fread_number( fp ) );
hotboot.c:            KEY( "Hyperdistance", ship->hyperdistance, fread_number( fp ) );
hotboot.c:            KEY( "JX", ship->jx, ( float )fread_number( fp ) );
hotboot.c:            KEY( "JY", ship->jy, ( float )fread_number( fp ) );
hotboot.c:            KEY( "JZ", ship->jz, ( float )fread_number( fp ) );
hotboot.c:               STRFREE( ship->dest );
hotboot.c:               ship->dest = fread_string( fp );
hotboot.c:            KEY( "Missiles", ship->missiles, fread_number( fp ) );
hotboot.c:            KEY( "Rockets", ship->rockets, fread_number( fp ) );
hotboot.c:            KEY( "Shield", ship->shield, fread_number( fp ) );
hotboot.c:            KEY( "Shipstate", ship->shipstate, fread_number( fp ) );
hotboot.c:               ship->location = 0;
hotboot.c:               if( ship->starsystem )
hotboot.c:            KEY( "Torpedos", ship->torpedos, fread_number( fp ) );
hotboot.c:               ship->target0 = target;
hotboot.c:               ship->target1 = target;
hotboot.c:               ship->target2 = target;
hotboot.c:            KEY( "VX", ship->vx, ( float )fread_number( fp ) );
hotboot.c:            KEY( "VY", ship->vy, ( float )fread_number( fp ) );
hotboot.c:            KEY( "VZ", ship->vz, ( float )fread_number( fp ) );
hotboot.c: * Save the world's objects and mobs in their current positions -- Scion
hotboot.c:   fprintf( fp, "Vnum	%d\n", mob->pIndexData->vnum );
hotboot.c:   fprintf( fp, "Level   %d\n", mob->top_level );
hotboot.c:   fprintf( fp, "Gold	%d\n", mob->gold );
hotboot.c:   fprintf( fp, "Resetvnum %d\n", mob->resetvnum );
hotboot.c:   fprintf( fp, "Resetnum  %d\n", mob->resetnum );
hotboot.c:   if( mob->in_room )
hotboot.c:      if( IS_SET( mob->act, ACT_SENTINEL ) )
hotboot.c:          * enter the game from a reboot or copyover -- Scion 
hotboot.c:         fprintf( fp, "Room	%d\n", mob->home_vnum );
hotboot.c:         fprintf( fp, "Room	%d\n", mob->in_room->vnum );
hotboot.c:   fprintf( fp, "Coordinates  %d %d %d\n", mob->x, mob->y, mob->map );
hotboot.c:   if( mob->name && mob->pIndexData->player_name && str_cmp( mob->name, mob->pIndexData->player_name ) )
hotboot.c:      fprintf( fp, "Name     %s~\n", mob->name );
hotboot.c:   if( mob->short_descr && mob->pIndexData->short_descr && str_cmp( mob->short_descr, mob->pIndexData->short_descr ) )
hotboot.c:      fprintf( fp, "Short	%s~\n", mob->short_descr );
hotboot.c:   if( mob->long_descr && mob->pIndexData->long_descr && str_cmp( mob->long_descr, mob->pIndexData->long_descr ) )
hotboot.c:      fprintf( fp, "Long	%s~\n", mob->long_descr );
hotboot.c:   if( mob->description && mob->pIndexData->description && str_cmp( mob->description, mob->pIndexData->description ) )
hotboot.c:      fprintf( fp, "Description %s~\n", mob->description );
hotboot.c:            mob->hit, mob->max_hit, mob->mana, mob->max_mana, mob->move, mob->max_move );
hotboot.c:   fprintf( fp, "Position %d\n", mob->position );
hotboot.c:   fprintf( fp, "Flags %d\n", mob->act );
hotboot.c:   fprintf( fp, "AffectedBy   %d\n", mob->affected_by );
hotboot.c:   for( paf = mob->first_affect; paf; paf = paf->next )
hotboot.c:      if( paf->type >= 0 && ( skill = get_skilltype( paf->type ) ) == NULL )
hotboot.c:      if( paf->type >= 0 && paf->type < TYPE_PERSONAL )
hotboot.c:                  skill->name, paf->duration, paf->modifier, paf->location, paf->bitvector );
hotboot.c:                  paf->type, paf->duration, paf->modifier, paf->location, paf->bitvector );
hotboot.c:   if( mob->first_carrying )
hotboot.c:      fwrite_obj( mob, mob->last_carrying, fp, 0, OS_CARRY, TRUE );
hotboot.c:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
hotboot.c:            if( !pRoomIndex->first_content   /* Skip room if nothing in it */
hotboot.c:                || IS_SET( pRoomIndex->room_flags, ROOM_CLANSTOREROOM ) /* These rooms save on their own */
hotboot.c:            snprintf( filename, 256, "%s%d", HOTBOOT_DIR, pRoomIndex->vnum );
hotboot.c:               bug( "save_world: fopen %d", pRoomIndex->vnum );
hotboot.c:            fwrite_obj( NULL, pRoomIndex->last_content, objfp, 0, OS_CARRY, TRUE );
hotboot.c:      for( rch = first_char; rch; rch = rch->next )
hotboot.c:         if( !IS_NPC( rch ) || rch == supermob || IS_SET( rch->act, ACT_PROTOTYPE ) || IS_SET( rch->act, ACT_PET ) )
hotboot.c:      for( ship = first_ship; ship; ship = ship->next )
hotboot.c:             * * --Shaddai 
hotboot.c:          * * --Shaddai 
hotboot.c:               mob->tempnum = -9999;   /* Hackish, yes. Works though doesn't it? */
hotboot.c:                  paf->type = fread_number( fp );
hotboot.c:                  paf->type = sn;
hotboot.c:               paf->duration = fread_number( fp );
hotboot.c:               paf->modifier = fread_number( fp );
hotboot.c:               paf->location = fread_number( fp );
hotboot.c:               if( paf->location == APPLY_WEAPONSPELL
hotboot.c:                   || paf->location == APPLY_WEARSPELL
hotboot.c:                   || paf->location == APPLY_REMOVESPELL || paf->location == APPLY_STRIPSN )
hotboot.c:                  paf->modifier = slot_lookup( paf->modifier );
hotboot.c:               paf->bitvector = fread_number( fp );
hotboot.c:               LINK( paf, mob->first_affect, mob->last_affect, next, prev );
hotboot.c:            KEY( "AffectedBy", mob->affected_by, fread_number( fp ) );
hotboot.c:               mob->x = fread_number( fp );
hotboot.c:               mob->y = fread_number( fp );
hotboot.c:               mob->map = fread_number( fp );
hotboot.c:               STRFREE( mob->description );
hotboot.c:               mob->description = fread_string( fp );
hotboot.c:               mob->tempnum = -9998;   /* Yet another hackish fix! */
hotboot.c:            if( !str_cmp( word, "End" ) ) /* End of object, need to ignore this. sometimes they creep in there somehow -- Scion */
hotboot.c:            KEY( "Flags", mob->act, fread_number( fp ) );
hotboot.c:            KEY( "Gold", mob->gold, fread_number( fp ) );
hotboot.c:               mob->hit = fread_number( fp );
hotboot.c:               mob->max_hit = fread_number( fp );
hotboot.c:               mob->mana = fread_number( fp );
hotboot.c:               mob->max_mana = fread_number( fp );
hotboot.c:               mob->move = fread_number( fp );
hotboot.c:               mob->max_move = fread_number( fp );
hotboot.c:               if( mob->max_move <= 0 )
hotboot.c:                  mob->max_move = 150;
hotboot.c:               STRFREE( mob->long_descr );
hotboot.c:               mob->long_descr = fread_string( fp );
hotboot.c:            KEY( "Level", mob->top_level, fread_number( fp ) );
hotboot.c:               STRFREE( mob->mob_clan );
hotboot.c:               mob->mob_clan = fread_string( fp );
hotboot.c:               STRFREE( mob->name );
hotboot.c:               mob->name = fread_string( fp );
hotboot.c:            KEY( "Position", mob->position, fread_number( fp ) );
hotboot.c:            KEY( "Resetvnum", mob->resetvnum, fread_number( fp ) );
hotboot.c:            KEY( "Resetnum", mob->resetnum, fread_number( fp ) );
hotboot.c:               STRFREE( mob->short_descr );
hotboot.c:               mob->short_descr = fread_string( fp );
hotboot.c:      for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
hotboot.c:         tobj_next = tobj->next_content;
hotboot.c:            supermob->map = tobj->map;
hotboot.c:            supermob->x = tobj->x;
hotboot.c:            supermob->y = tobj->y;
hotboot.c:         supermob->map = -1;
hotboot.c:         supermob->x = -1;
hotboot.c:         supermob->y = -1;
hotboot.c:      if( !str_cmp( dentry->d_name, "CVS" ) )
hotboot.c:      if( dentry->d_name[0] != '.' )
hotboot.c:         read_obj_file( directory_name, dentry->d_name );
hotboot.c:   for( d = first_descriptor; d; d = d->next )
hotboot.c:      if( ( d->connected == CON_PLAYING
hotboot.c:            || d->connected == CON_EDITING )
hotboot.c:          && ( victim = d->character ) != NULL && !IS_NPC( victim )
hotboot.c:          && victim->in_room && victim->fighting && victim->top_level >= 1 && victim->top_level <= MAX_LEVEL )
hotboot.c:   for( d = first_descriptor; d; d = d->next )
hotboot.c:      if( d->connected == CON_EDITING && d->character )
hotboot.c:   sprintf( log_buf, "Hotboot initiated by %s.", ch->name );
hotboot.c:      for( tshuttle = first_shuttle; tshuttle; tshuttle = tshuttle->next )
hotboot.c:   if( ch && ch->desc )
hotboot.c:      write_to_descriptor( ch->desc, "\033[0m", 0 );
hotboot.c:      de_next = d->next;   /* We delete from the list , so need to save this */
hotboot.c:      if( !d->character || d->connected < CON_PLAYING )  /* drop those logging on */
hotboot.c:         fprintf( fp, "%d %d %d %d %d %s %s\n", d->can_compress, d->descriptor, och->in_room->vnum, d->port, d->idle, och->name, d->host );
hotboot.c:         och->pcdata->hotboot = TRUE;
hotboot.c:   fprintf( fp, "%s", "-1" );
hotboot.c:      log_string( "Hotboot debug - Aborting before execl" );
hotboot.c:    * exec - descriptors are inherited 
hotboot.c:      snprintf( buf3, 100, "%d", this_imcmud->desc );
hotboot.c:      strncpy( buf3, "-1", 100 );
hotboot.c:   strncpy( buf3, "-1", 100 );
hotboot.c:    * Failed - sucessful exec will not return 
hotboot.c:/* Recover from a hotboot - load players */
hotboot.c:   unlink( HOTBOOT_FILE ); /* In case something crashes - doesn't prevent reading */
hotboot.c:      if( desc == -1 || feof( fp ) )
hotboot.c:       * Write something, and check if it goes error-free 
hotboot.c:      CREATE( d->mccp, MCCP, 1 );
hotboot.c:      d->next = NULL;
hotboot.c:      d->descriptor = desc;
hotboot.c:      d->connected = CON_GET_NAME;
hotboot.c:      d->outsize = 2000;
hotboot.c:      d->idle = 0;
hotboot.c:      d->lines = 0;
hotboot.c:      d->scrlen = 24;
hotboot.c:      d->newstate = 0;
hotboot.c:      d->prevcolor = 0x08;
hotboot.c:      d->ifd = -1;
hotboot.c:      d->ipid = -1;
hotboot.c:      CREATE( d->outbuf, char, d->outsize );
hotboot.c:      d->host = STRALLOC( host );
hotboot.c:      d->port = dport;
hotboot.c:      d->idle = idle;
hotboot.c:      d->connected = CON_COPYOVER_RECOVER;   /* negative so close_socket will cut them off */
hotboot.c:      d->can_compress = dcompress;
hotboot.c:      if( d->can_compress )
hotboot.c:         d->character->in_room = get_room_index( room );
hotboot.c:         if( !d->character->in_room )
hotboot.c:            d->character->in_room = get_room_index( ROOM_VNUM_TEMPLE );
hotboot.c:         LINK( d->character, first_char, last_char, next, prev );
hotboot.c:         char_to_room( d->character, d->character->in_room );
hotboot.c:         act( AT_MAGIC, "You appear in a swirl of the Force!", d->character, NULL, NULL, TO_CHAR );
hotboot.c:         act( AT_MAGIC, "$n appears in a swrrl of the Force!", d->character, NULL, NULL, TO_ROOM );
hotboot.c:         d->connected = CON_PLAYING;
hotboot.c:         check_auth_state( d->character );   /* new auth */
hotboot.c~: *                           ^     +----- |  / ^     ^ |     | +-\                       *
hotboot.c~: *                         /   \   +---   |<   | \ / | |     | |  |                      *
hotboot.c~: *                        /-----\  |      | \  |  v  | |     | |  /                      *
hotboot.c~: *                       /       \ |      |  \ |     | +-----+ +-/                       *
hotboot.c~: * AFKMud Copyright 1997-2003 by Roger Libiez (Samson), Levi Beckerson (Whir),           *
hotboot.c~:   if( ship->shipstate == SHIP_DOCKED )
hotboot.c~:   if( ship->ship_class > SHIP_PLATFORM )
hotboot.c~:   fprintf( fp, "Shipfname	%s~\n", ship->filename );
hotboot.c~:   if( ship->currspeed != 0 )
hotboot.c~:      fprintf( fp, "Currspeed %d\n", ship->currspeed );
hotboot.c~:   if( ship->chaff != ship->maxchaff )
hotboot.c~:      fprintf( fp, "Chaff %d\n", ship->chaff );
hotboot.c~:   if( ship->shield != ship->maxshield )
hotboot.c~:      fprintf( fp, "Shield %d\n", ship->shield );
hotboot.c~:   if( ship->missiles != ship->maxmissiles )
hotboot.c~:      fprintf( fp, "Missiles %d\n", ship->missiles );
hotboot.c~:   if( ship->torpedos != ship->maxtorpedos )
hotboot.c~:      fprintf( fp, "Torpedos %d\n", ship->torpedos );
hotboot.c~:   if( ship->rockets != ship->maxrockets )
hotboot.c~:      fprintf( fp, "Rockets %d\n", ship->rockets );
hotboot.c~:   fprintf( fp, "Autorecharge %d\n", ship->autorecharge );
hotboot.c~:   fprintf( fp, "Autotrack %d\n", ship->autotrack );
hotboot.c~:   fprintf( fp, "Autospeed %d\n", ship->autospeed );
hotboot.c~:   fprintf( fp, "Autopilot %d\n", ship->autopilot );
hotboot.c~:   fprintf( fp, "VX %d\n", ( int )ship->vx );
hotboot.c~:   fprintf( fp, "VY %d\n", ( int )ship->vy );
hotboot.c~:   fprintf( fp, "VZ %d\n", ( int )ship->vz );
hotboot.c~:   fprintf( fp, "HX %d\n", ( int )ship->hx );
hotboot.c~:   fprintf( fp, "HY %d\n", ( int )ship->hy );
hotboot.c~:   fprintf( fp, "HZ %d\n", ( int )ship->hz );
hotboot.c~:   fprintf( fp, "JX %d\n", ( int )ship->jx );
hotboot.c~:   fprintf( fp, "JY %d\n", ( int )ship->jy );
hotboot.c~:   fprintf( fp, "JZ %d\n", ( int )ship->jz );
hotboot.c~:   if( ship->target0 )
hotboot.c~:      fprintf( fp, "Target0 %s~\n", ship->target0->name );
hotboot.c~:   if( ship->target1 )
hotboot.c~:      fprintf( fp, "Target1 %s~\n", ship->target1->name );
hotboot.c~:   if( ship->target2 )
hotboot.c~:      fprintf( fp, "Target2 %s~\n", ship->target2->name );
hotboot.c~:   if( ship->target0 )
hotboot.c~:      fprintf( fp, "Track0 %s~\n", ship->track0->name );
hotboot.c~:   fprintf( fp, "Shipstate %d\n", ship->shipstate );
hotboot.c~:   if( ship->dest != NULL && ship->dest[0] != '\0' )
hotboot.c~:      fprintf( fp, "LandDest %s~\n", ship->dest );
hotboot.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
hotboot.c~:      fprintf( fp, "Hyperdistance %d\n", ship->hyperdistance );
hotboot.c~:      fprintf( fp, "Currjump %s~\n", ship->currjump->name );
hotboot.c~:   if( ship->energy != ship->maxenergy )
hotboot.c~:      fprintf( fp, "Energy %d\n", ship->energy );
hotboot.c~:   if( ship->hull != ship->maxhull )
hotboot.c~:      fprintf( fp, "Hull %d\n", ship->hull );
hotboot.c~:   if( ship->starsystem )
hotboot.c~:      fprintf( fp, "Starsystem %s~\n", ship->starsystem->name );
hotboot.c~:     const char *name = fread_string_nohash( fp ); /* is this right? - Gavin */
hotboot.c~:      for( temp_ship = first_ship; temp_ship; temp_ship = temp_ship->next )
hotboot.c~:         if( !str_cmp( name, temp_ship->filename ) )
hotboot.c~:             * mob->tempnum = -9999; 
hotboot.c~:            KEY( "Autorecharge", ship->autorecharge, ( bool ) fread_number( fp ) );
hotboot.c~:            KEY( "Autotrack", ship->autotrack, ( bool ) fread_number( fp ) );
hotboot.c~:            KEY( "Autospeed", ship->autospeed, ( bool ) fread_number( fp ) );
hotboot.c~:            KEY( "Autopilot", ship->autopilot, ( bool ) fread_number( fp ) );
hotboot.c~:            KEY( "Currspeed", ship->currspeed, fread_number( fp ) );
hotboot.c~:               ship->location = 0;
hotboot.c~:               ship->currjump = starsystem_from_name( temp );
hotboot.c~:            KEY( "Chaff", ship->chaff, fread_number( fp ) );
hotboot.c~:            KEY( "Energy", ship->energy, fread_number( fp ) );
hotboot.c~:            if( !str_cmp( word, "End" ) ) /* End of object, need to ignore this. sometimes they creep in there somehow -- Scion */
hotboot.c~:            KEY( "Hull", ship->hull, fread_number( fp ) );
hotboot.c~:            KEY( "HX", ship->hx, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "HY", ship->hy, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "HZ", ship->hz, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "Hyperdistance", ship->hyperdistance, fread_number( fp ) );
hotboot.c~:            KEY( "JX", ship->jx, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "JY", ship->jy, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "JZ", ship->jz, ( float )fread_number( fp ) );
hotboot.c~:               STRFREE( ship->dest );
hotboot.c~:               ship->dest = fread_string( fp );
hotboot.c~:            KEY( "Missiles", ship->missiles, fread_number( fp ) );
hotboot.c~:            KEY( "Rockets", ship->rockets, fread_number( fp ) );
hotboot.c~:            KEY( "Shield", ship->shield, fread_number( fp ) );
hotboot.c~:            KEY( "Shipstate", ship->shipstate, fread_number( fp ) );
hotboot.c~:               ship->location = 0;
hotboot.c~:               if( ship->starsystem )
hotboot.c~:            KEY( "Torpedos", ship->torpedos, fread_number( fp ) );
hotboot.c~:               ship->target0 = target;
hotboot.c~:               ship->target1 = target;
hotboot.c~:               ship->target2 = target;
hotboot.c~:            KEY( "VX", ship->vx, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "VY", ship->vy, ( float )fread_number( fp ) );
hotboot.c~:            KEY( "VZ", ship->vz, ( float )fread_number( fp ) );
hotboot.c~: * Save the world's objects and mobs in their current positions -- Scion
hotboot.c~:   fprintf( fp, "Vnum	%d\n", mob->pIndexData->vnum );
hotboot.c~:   fprintf( fp, "Level   %d\n", mob->top_level );
hotboot.c~:   fprintf( fp, "Gold	%d\n", mob->gold );
hotboot.c~:   fprintf( fp, "Resetvnum %d\n", mob->resetvnum );
hotboot.c~:   fprintf( fp, "Resetnum  %d\n", mob->resetnum );
hotboot.c~:   if( mob->in_room )
hotboot.c~:      if( IS_SET( mob->act, ACT_SENTINEL ) )
hotboot.c~:          * enter the game from a reboot or copyover -- Scion 
hotboot.c~:         fprintf( fp, "Room	%d\n", mob->home_vnum );
hotboot.c~:         fprintf( fp, "Room	%d\n", mob->in_room->vnum );
hotboot.c~:   fprintf( fp, "Coordinates  %d %d %d\n", mob->x, mob->y, mob->map );
hotboot.c~:   if( mob->name && mob->pIndexData->player_name && str_cmp( mob->name, mob->pIndexData->player_name ) )
hotboot.c~:      fprintf( fp, "Name     %s~\n", mob->name );
hotboot.c~:   if( mob->short_descr && mob->pIndexData->short_descr && str_cmp( mob->short_descr, mob->pIndexData->short_descr ) )
hotboot.c~:      fprintf( fp, "Short	%s~\n", mob->short_descr );
hotboot.c~:   if( mob->long_descr && mob->pIndexData->long_descr && str_cmp( mob->long_descr, mob->pIndexData->long_descr ) )
hotboot.c~:      fprintf( fp, "Long	%s~\n", mob->long_descr );
hotboot.c~:   if( mob->description && mob->pIndexData->description && str_cmp( mob->description, mob->pIndexData->description ) )
hotboot.c~:      fprintf( fp, "Description %s~\n", mob->description );
hotboot.c~:            mob->hit, mob->max_hit, mob->mana, mob->max_mana, mob->move, mob->max_move );
hotboot.c~:   fprintf( fp, "Position %d\n", mob->position );
hotboot.c~:   fprintf( fp, "Flags %d\n", mob->act );
hotboot.c~:   fprintf( fp, "AffectedBy   %d\n", mob->affected_by );
hotboot.c~:   for( paf = mob->first_affect; paf; paf = paf->next )
hotboot.c~:      if( paf->type >= 0 && ( skill = get_skilltype( paf->type ) ) == NULL )
hotboot.c~:      if( paf->type >= 0 && paf->type < TYPE_PERSONAL )
hotboot.c~:                  skill->name, paf->duration, paf->modifier, paf->location, paf->bitvector );
hotboot.c~:                  paf->type, paf->duration, paf->modifier, paf->location, paf->bitvector );
hotboot.c~:   if( mob->first_carrying )
hotboot.c~:      fwrite_obj( mob, mob->last_carrying, fp, 0, OS_CARRY, TRUE );
hotboot.c~:      for( pRoomIndex = room_index_hash[iHash]; pRoomIndex; pRoomIndex = pRoomIndex->next )
hotboot.c~:            if( !pRoomIndex->first_content   /* Skip room if nothing in it */
hotboot.c~:                || IS_SET( pRoomIndex->room_flags, ROOM_CLANSTOREROOM ) /* These rooms save on their own */
hotboot.c~:            snprintf( filename, 256, "%s%d", HOTBOOT_DIR, pRoomIndex->vnum );
hotboot.c~:               bug( "save_world: fopen %d", pRoomIndex->vnum );
hotboot.c~:            fwrite_obj( NULL, pRoomIndex->last_content, objfp, 0, OS_CARRY, TRUE );
hotboot.c~:      for( rch = first_char; rch; rch = rch->next )
hotboot.c~:         if( !IS_NPC( rch ) || rch == supermob || IS_SET( rch->act, ACT_PROTOTYPE ) || IS_SET( rch->act, ACT_PET ) )
hotboot.c~:      for( ship = first_ship; ship; ship = ship->next )
hotboot.c~:             * * --Shaddai 
hotboot.c~:          * * --Shaddai 
hotboot.c~:               mob->tempnum = -9999;   /* Hackish, yes. Works though doesn't it? */
hotboot.c~:                  paf->type = fread_number( fp );
hotboot.c~:                  paf->type = sn;
hotboot.c~:               paf->duration = fread_number( fp );
hotboot.c~:               paf->modifier = fread_number( fp );
hotboot.c~:               paf->location = fread_number( fp );
hotboot.c~:               if( paf->location == APPLY_WEAPONSPELL
hotboot.c~:                   || paf->location == APPLY_WEARSPELL
hotboot.c~:                   || paf->location == APPLY_REMOVESPELL || paf->location == APPLY_STRIPSN )
hotboot.c~:                  paf->modifier = slot_lookup( paf->modifier );
hotboot.c~:               paf->bitvector = fread_number( fp );
hotboot.c~:               LINK( paf, mob->first_affect, mob->last_affect, next, prev );
hotboot.c~:            KEY( "AffectedBy", mob->affected_by, fread_number( fp ) );
hotboot.c~:               mob->x = fread_number( fp );
hotboot.c~:               mob->y = fread_number( fp );
hotboot.c~:               mob->map = fread_number( fp );
hotboot.c~:               STRFREE( mob->description );
hotboot.c~:               mob->description = fread_string( fp );
hotboot.c~:               mob->tempnum = -9998;   /* Yet another hackish fix! */
hotboot.c~:            if( !str_cmp( word, "End" ) ) /* End of object, need to ignore this. sometimes they creep in there somehow -- Scion */
hotboot.c~:            KEY( "Flags", mob->act, fread_number( fp ) );
hotboot.c~:            KEY( "Gold", mob->gold, fread_number( fp ) );
hotboot.c~:               mob->hit = fread_number( fp );
hotboot.c~:               mob->max_hit = fread_number( fp );
hotboot.c~:               mob->mana = fread_number( fp );
hotboot.c~:               mob->max_mana = fread_number( fp );
hotboot.c~:               mob->move = fread_number( fp );
hotboot.c~:               mob->max_move = fread_number( fp );
hotboot.c~:               if( mob->max_move <= 0 )
hotboot.c~:                  mob->max_move = 150;
hotboot.c~:               STRFREE( mob->long_descr );
hotboot.c~:               mob->long_descr = fread_string( fp );
hotboot.c~:            KEY( "Level", mob->top_level, fread_number( fp ) );
hotboot.c~:               STRFREE( mob->mob_clan );
hotboot.c~:               mob->mob_clan = fread_string( fp );
hotboot.c~:               STRFREE( mob->name );
hotboot.c~:               mob->name = fread_string( fp );
hotboot.c~:            KEY( "Position", mob->position, fread_number( fp ) );
hotboot.c~:            KEY( "Resetvnum", mob->resetvnum, fread_number( fp ) );
hotboot.c~:            KEY( "Resetnum", mob->resetnum, fread_number( fp ) );
hotboot.c~:               STRFREE( mob->short_descr );
hotboot.c~:               mob->short_descr = fread_string( fp );
hotboot.c~:      for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
hotboot.c~:         tobj_next = tobj->next_content;
hotboot.c~:            supermob->map = tobj->map;
hotboot.c~:            supermob->x = tobj->x;
hotboot.c~:            supermob->y = tobj->y;
hotboot.c~:         supermob->map = -1;
hotboot.c~:         supermob->x = -1;
hotboot.c~:         supermob->y = -1;
hotboot.c~:      if( !str_cmp( dentry->d_name, "CVS" ) )
hotboot.c~:      if( dentry->d_name[0] != '.' )
hotboot.c~:         read_obj_file( directory_name, dentry->d_name );
hotboot.c~:   for( d = first_descriptor; d; d = d->next )
hotboot.c~:      if( ( d->connected == CON_PLAYING
hotboot.c~:            || d->connected == CON_EDITING )
hotboot.c~:          && ( victim = d->character ) != NULL && !IS_NPC( victim )
hotboot.c~:          && victim->in_room && victim->fighting && victim->top_level >= 1 && victim->top_level <= MAX_LEVEL )
hotboot.c~:   for( d = first_descriptor; d; d = d->next )
hotboot.c~:      if( d->connected == CON_EDITING && d->character )
hotboot.c~:   sprintf( log_buf, "Hotboot initiated by %s.", ch->name );
hotboot.c~:      for( tshuttle = first_shuttle; tshuttle; tshuttle = tshuttle->next )
hotboot.c~:   if( ch && ch->desc )
hotboot.c~:      write_to_descriptor( ch->desc, "\033[0m", 0 );
hotboot.c~:      de_next = d->next;   /* We delete from the list , so need to save this */
hotboot.c~:      if( !d->character || d->connected < CON_PLAYING )  /* drop those logging on */
hotboot.c~:         fprintf( fp, "%d %d %d %d %d %s %s\n", d->can_compress, d->descriptor, och->in_room->vnum, d->port, d->idle, och->name, d->host );
hotboot.c~:         och->pcdata->hotboot = TRUE;
hotboot.c~:   fprintf( fp, "%s", "-1" );
hotboot.c~:      log_string( "Hotboot debug - Aborting before execl" );
hotboot.c~:    * exec - descriptors are inherited 
hotboot.c~:      snprintf( buf3, 100, "%d", this_imcmud->desc );
hotboot.c~:      strncpy( buf3, "-1", 100 );
hotboot.c~:   strncpy( buf3, "-1", 100 );
hotboot.c~:    * Failed - sucessful exec will not return 
hotboot.c~:/* Recover from a hotboot - load players */
hotboot.c~:   unlink( HOTBOOT_FILE ); /* In case something crashes - doesn't prevent reading */
hotboot.c~:      if( desc == -1 || feof( fp ) )
hotboot.c~:       * Write something, and check if it goes error-free 
hotboot.c~:      CREATE( d->mccp, MCCP, 1 );
hotboot.c~:      d->next = NULL;
hotboot.c~:      d->descriptor = desc;
hotboot.c~:      d->connected = CON_GET_NAME;
hotboot.c~:      d->outsize = 2000;
hotboot.c~:      d->idle = 0;
hotboot.c~:      d->lines = 0;
hotboot.c~:      d->scrlen = 24;
hotboot.c~:      d->newstate = 0;
hotboot.c~:      d->prevcolor = 0x08;
hotboot.c~:      d->ifd = -1;
hotboot.c~:      d->ipid = -1;
hotboot.c~:      CREATE( d->outbuf, char, d->outsize );
hotboot.c~:      d->host = STRALLOC( host );
hotboot.c~:      d->port = dport;
hotboot.c~:      d->idle = idle;
hotboot.c~:      d->connected = CON_COPYOVER_RECOVER;   /* negative so close_socket will cut them off */
hotboot.c~:      d->can_compress = dcompress;
hotboot.c~:      if( d->can_compress )
hotboot.c~:         d->character->in_room = get_room_index( room );
hotboot.c~:         if( !d->character->in_room )
hotboot.c~:            d->character->in_room = get_room_index( ROOM_VNUM_TEMPLE );
hotboot.c~:         LINK( d->character, first_char, last_char, next, prev );
hotboot.c~:         char_to_room( d->character, d->character->in_room );
hotboot.c~:         act( AT_MAGIC, "You appear in a swirl of the Force!", d->character, NULL, NULL, TO_CHAR );
hotboot.c~:         act( AT_MAGIC, "$n appears in a swrrl of the Force!", d->character, NULL, NULL, TO_ROOM );
hotboot.c~:         d->connected = CON_PLAYING;
hotboot.c~:         check_auth_state( d->character );   /* new auth */
hotboot.h: *                           ^     +----- |  / ^     ^ |     | +-\                       *
hotboot.h: *                         /   \   +---   |<   | \ / | |     | |  |                      *
hotboot.h: *                        /-----\  |      | \  |  v  | |     | |  /                      *
hotboot.h: *                       /       \ |      |  \ |     | +-----+ +-/                       *
hotboot.h: * AFKMud Copyright 1997-2003 by Roger Libiez (Samson), Levi Beckerson (Whir),           *
hotboot.h:#define CH(d)			((d)->original ? (d)->original : (d)->character)
hotboot.h:DECLARE_DO_FUN( do_hotboot ); /* Hotboot command - Samson 3-31-01 */
imc.c:/* IMC2 Freedom Client - Developed by Mud Domain.
imc.c: * Copyright 2004-2008 by Roger Libiez ( Samson )
imc.c: * Comments and suggestions welcome: http://www.mudbytes.net/imc2-support-forum
imc.c: * Copy src to string dst of size siz.  At most siz-1 characters
imc.c: * Samson 10-12-03
imc.c:   if( n != 0 && --n != 0 )
imc.c:      while( --n != 0 );
imc.c:         *d = '\0';  /* NUL-terminate dst */
imc.c:   return ( s - src - 1 ); /* count does not include NUL */
imc.c: * full size of dst, not space left).  At most siz-1 characters
imc.c: * Samson 10-12-03
imc.c:   while( n-- != 0 && *d != '\0' )
imc.c:   dlen = d - dst;
imc.c:   n = siz - dlen;
imc.c:         n--;
imc.c:   return ( dlen + ( s - src ) );   /* count does not include NUL */
imc.c:   strtime[strlen( strtime ) - 1] = '\0';
imc.c:   strtime[strlen( strtime ) - 1] = '\0';
imc.c:   -- Xorith
imc.c:               if( in_p == ( LGST - 1 ) )
imc.c:               if( src[x - 1] == sch[0] )
imc.c:                           newsrc[in_p - 1] = sch[y];
imc.c:                        newsrc[in_p - 1] = rep[y];
imc.c:            x += lensch - 1;
imc.c:            in_p--;
imc.c:      if( in_p == ( LGST - 1 ) )
imc.c:   for( color = first_imc_color; color; color = color->next )
imc.c:      imcstrlcpy( tbuf, imcstrrep( tbuf, color->imctag, "" ), LGST );
imc.c:   for( color = first_imc_color; color; color = color->next )
imc.c:      imcstrlcpy( tbuf, imcstrrep( tbuf, color->mudtag, "" ), LGST );
imc.c:/* Now tell me this isn't cleaner than the mess that was here before. -- Xorith */
imc.c:/* Yes, Xorith it is. Now, how about this update? Much less hassle with no hardcoded table! -- Samson */
imc.c:/* convert from imc color -> mud color */
imc.c:      for( color = first_imc_color; color; color = color->next )
imc.c:         imcstrlcpy( tbuf, imcstrrep( tbuf, color->imctag, color->mudtag ), LGST );
imc.c:/* convert from mud color -> imc color */
imc.c:   for( color = first_imc_color; color; color = color->next )
imc.c:      imcstrlcpy( tbuf, imcstrrep( tbuf, color->mudtag, color->imctag ), LGST );
imc.c: * Returns an initial-capped string.
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      if( ( vch = d->character ? d->character : d->original ) != NULL && !strcasecmp( CH_IMCNAME( vch ), name )
imc.c:          && d->connected == CON_PLAYING )
imc.c:   if( !strcasecmp( mud, this_imcmud->localname ) )
imc.c:   for( mud = first_imc_ban; mud; mud = mud->next )
imc.c:      if( !strcasecmp( mud->name, imc_mudof( who ) ) )
imc.c:   for( temp = FIRST_IMCIGNORE( ch ); temp; temp = temp->next )
imc.c:      if( !strcasecmp( imc_nameof( temp->name ), "*" ) )
imc.c:         if( !strcasecmp( imc_mudof( temp->name ), imc_mudof( ignore ) ) )
imc.c:      if( !strcasecmp( imc_mudof( temp->name ), "*" ) )
imc.c:         if( !strcasecmp( imc_nameof( temp->name ), imc_nameof( ignore ) ) )
imc.c:      if( !str_prefix( ignore, temp->name ) )
imc.c:   IMCSTRFREE( this_imcmud->servername );
imc.c:   IMCSTRFREE( this_imcmud->rhost );
imc.c:   IMCSTRFREE( this_imcmud->network );
imc.c:   IMCSTRFREE( this_imcmud->clientpw );
imc.c:   IMCSTRFREE( this_imcmud->serverpw );
imc.c:   IMCDISPOSE( this_imcmud->outbuf );
imc.c:   IMCSTRFREE( this_imcmud->localname );
imc.c:   IMCSTRFREE( this_imcmud->fullname );
imc.c:   IMCSTRFREE( this_imcmud->ihost );
imc.c:   IMCSTRFREE( this_imcmud->email );
imc.c:   IMCSTRFREE( this_imcmud->www );
imc.c:   IMCSTRFREE( this_imcmud->details );
imc.c:   IMCSTRFREE( this_imcmud->versionid );
imc.c:   IMCSTRFREE( this_imcmud->base );
imc.c:   IMCSTRFREE( p->name );
imc.c:   IMCSTRFREE( p->version );
imc.c:   IMCSTRFREE( p->network );
imc.c:   IMCSTRFREE( p->path );
imc.c:   IMCSTRFREE( p->url );
imc.c:   IMCSTRFREE( p->port );
imc.c:   IMCSTRFREE( p->host );
imc.c:   p->name = IMCSTRALLOC( mud );
imc.c:      p->url = IMCSTRALLOC( "Unknown" );
imc.c:      p->url = IMCSTRALLOC( url );
imc.c:      p->version = IMCSTRALLOC( "Unknown" );
imc.c:      p->version = IMCSTRALLOC( version );
imc.c:      p->network = IMCSTRALLOC( this_imcmud->network );
imc.c:      p->network = IMCSTRALLOC( netname );
imc.c:      p->path = IMCSTRALLOC( "UNKNOWN" );
imc.c:      p->path = IMCSTRALLOC( path );
imc.c:   p->expired = FALSE;
imc.c:   for( mud_prev = first_rinfo; mud_prev; mud_prev = mud_prev->next )
imc.c:      if( strcasecmp( mud_prev->name, mud ) >= 0 )
imc.c:   for( p = first_rinfo; p; p = p->next )
imc.c:      if( !strcasecmp( name, p->name ) )
imc.c:   if( r->expired )
imc.c:      imc_printf( ch, "~W%s ~cis not connected right now.\r\n", r->name );
imc.c:   return -1;
imc.c:   ban->name = NULL;
imc.c:   ban->name = IMCSTRALLOC( what );
imc.c:   IMCSTRFREE( ban->name );
imc.c:      ban_next = ban->next;
imc.c:      if( !strcasecmp( what, ban->name ) )
imc.c:   for( c = first_imc_channel; c; c = c->next )
imc.c:      if( ( c->name && !strcasecmp( c->name, name ) ) || ( c->local_name && !strcasecmp( c->local_name, name ) ) )
imc.c:   IMCSTRFREE( c->name );
imc.c:   IMCSTRFREE( c->owner );
imc.c:   IMCSTRFREE( c->operators );
imc.c:   IMCSTRFREE( c->invited );
imc.c:   IMCSTRFREE( c->excluded );
imc.c:   IMCSTRFREE( c->local_name );
imc.c:   IMCSTRFREE( c->regformat );
imc.c:   IMCSTRFREE( c->emoteformat );
imc.c:   IMCSTRFREE( c->socformat );
imc.c:      IMCSTRFREE( c->history[x] );
imc.c:      for( c = first_imc_channel; c; c = c->next )
imc.c:         if( !c->local_name || c->local_name[0] == '\0' )
imc.c:            snprintf( buf, LGST, "~R[~Y%s~R] ~C%%s: ~c%%s", c->local_name );
imc.c:            IMCSTRFREE( c->regformat );
imc.c:            c->regformat = IMCSTRALLOC( buf );
imc.c:            snprintf( buf, LGST, "~R[~Y%s~R] ~c%%s %%s", c->local_name );
imc.c:            IMCSTRFREE( c->emoteformat );
imc.c:            c->emoteformat = IMCSTRALLOC( buf );
imc.c:            snprintf( buf, LGST, "~R[~Y%s~R] ~c%%s", c->local_name );
imc.c:            IMCSTRFREE( c->socformat );
imc.c:            c->socformat = IMCSTRALLOC( buf );
imc.c:      if( ch && ( !d->local_name || d->local_name[0] == '\0' ) )
imc.c:         snprintf( buf, LGST, "~R[~Y%s~R] ~C%%s: ~c%%s", d->local_name );
imc.c:         IMCSTRFREE( d->regformat );
imc.c:         d->regformat = IMCSTRALLOC( buf );
imc.c:         snprintf( buf, LGST, "~R[~Y%s~R] ~c%%s %%s", d->local_name );
imc.c:         IMCSTRFREE( d->emoteformat );
imc.c:         d->emoteformat = IMCSTRALLOC( buf );
imc.c:         snprintf( buf, LGST, "~R[~Y%s~R] ~c%%s", d->local_name );
imc.c:         IMCSTRFREE( d->socformat );
imc.c:         d->socformat = IMCSTRALLOC( buf );
imc.c:   c->name = IMCSTRALLOC( chan );
imc.c:   c->owner = IMCSTRALLOC( owner );
imc.c:   c->operators = IMCSTRALLOC( ops );
imc.c:   c->invited = IMCSTRALLOC( invite );
imc.c:   c->excluded = IMCSTRALLOC( exclude );
imc.c:      c->local_name = IMCSTRALLOC( lname );
imc.c:      c->local_name = imc_channel_nameof( c->name );
imc.c:   c->level = perm;
imc.c:   c->refreshed = TRUE;
imc.c:   c->open = copen;
imc.c:   else if( c == '-' )
imc.c:      number = number * 10 + c - '0';
imc.c:      number = 0 - number;
imc.c:      if( ln >= ( LGST - 1 ) )
imc.c:   pline--;
imc.c:   if( line[strlen( line ) - 1] == '~' )
imc.c:      line[strlen( line ) - 1] = '\0';
imc.c:   for( ph = first_phandler; ph; ph = ph->next )
imc.c:      if( !strcasecmp( ph->name, name ) )
imc.c:   ph->name = IMCSTRALLOC( name );
imc.c:   ph->func = func;
imc.c:   for( data = p->first_data; data; data = data_next )
imc.c:      data_next = data->next;
imc.c:      IMCUNLINK( data, p->first_data, p->last_data, next, prev );
imc.c:      return -1;
imc.c:      i = current - strlen( key );
imc.c:   if( !this_imcmud || this_imcmud->desc < 1 )
imc.c:   if( !this_imcmud->outbuf )
imc.c:   while( this_imcmud->outtop + length >= this_imcmud->outsize )
imc.c:      if( this_imcmud->outsize > 64000 )
imc.c:         this_imcmud->outtop = 0;
imc.c:         imcbug( "Buffer overflow: %ld. Purging.", this_imcmud->outsize );
imc.c:      this_imcmud->outsize *= 2;
imc.c:      IMCRECREATE( this_imcmud->outbuf, char, this_imcmud->outsize );
imc.c:   strncpy( this_imcmud->outbuf + this_imcmud->outtop, output, length );   /* Leave this one alone! BAD THINGS(TM) will happen if you don't! */
imc.c:   this_imcmud->outtop += length;
imc.c:   this_imcmud->outbuf[this_imcmud->outtop] = '\0';
imc.c:   snprintf( txt, IMC_BUFF_SIZE, "%s %lu %s %s %s", p->from, ++imc_sequencenumber, this_imcmud->localname, p->type, p->to );
imc.c:   for( data = p->first_data; data; data = data->next )
imc.c:      snprintf( txt + strlen( txt ), IMC_BUFF_SIZE - strlen( txt ), "%s", data->field );
imc.c:   snprintf( data->field, IMC_BUFF_SIZE, " %s", escape_string( pkt ) );
imc.c:   IMCLINK( data, p->first_data, p->last_data, next, prev );
imc.c:   snprintf( p->from, SMST, "%s@%s", from, this_imcmud->localname );
imc.c:   imcstrlcpy( p->type, type, SMST );
imc.c:   imcstrlcpy( p->to, to, SMST );
imc.c:   p->first_data = p->last_data = NULL;
imc.c:   snprintf( new_msg, LGST, "~R[%-2.2d:%-2.2d] %s", local->tm_hour, local->tm_min, msg );
imc.c:      if( x == MAX_IMCTELLHISTORY - 1 )
imc.c:            IMCSTRFREE( IMCTELLHISTORY( ch, i - 1 ) );
imc.c:            IMCTELLHISTORY( ch, i - 1 ) = IMCSTRALLOC( IMCTELLHISTORY( ch, i ) );
imc.c:   if( !( vic = imc_find_user( imc_nameof( q->to ) ) ) || IMCPERM( vic ) < IMCPERM_MORT )
imc.c:      snprintf( buf, LGST, "No player named %s exists here.", q->to );
imc.c:      imc_send_tell( "*", q->from, buf, 1 );
imc.c:   if( strcasecmp( imc_nameof( q->from ), "ICE" ) )
imc.c:         if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:            snprintf( buf, LGST, "%s is not receiving tells.", q->to );
imc.c:            imc_send_tell( "*", q->from, buf, 1 );
imc.c:      if( imc_isignoring( vic, q->from ) )
imc.c:         if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:            snprintf( buf, LGST, "%s is not receiving tells.", q->to );
imc.c:            imc_send_tell( "*", q->from, buf, 1 );
imc.c:         if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:            snprintf( buf, LGST, "%s is not receiving tells.", q->to );
imc.c:            imc_send_tell( "*", q->from, buf, 1 );
imc.c:         if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:            snprintf( buf, LGST, "%s is currently AFK. Try back later.", q->to );
imc.c:            imc_send_tell( "*", q->from, buf, 1 );
imc.c:      if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:         IMC_RREPLY( vic ) = IMCSTRALLOC( q->from );
imc.c:         IMC_RREPLY_NAME( vic ) = IMCSTRALLOC( imcgetname( q->from ) );
imc.c:      snprintf( buf, LGST, "~C%s ~cimctells you ~c'~W%s~c'~!\r\n", imcgetname( q->from ), txt );
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      if( d->connected == CON_PLAYING && ( ch = d->original ? d->original : d->character ) != NULL
imc.c:         imc_printf( ch, "~p[~GIMC~p] %s %s\r\n", imcgetname( q->from ), txt );
imc.c:      if( channel->history[x] == NULL )
imc.c:         snprintf( buf, LGST, "~R[%-2.2d/%-2.2d %-2.2d:%-2.2d] ~G%s",
imc.c:                   local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, msg );
imc.c:         channel->history[x] = IMCSTRALLOC( buf );
imc.c:         if( IMCIS_SET( channel->flags, IMCCHAN_LOG ) )
imc.c:            snprintf( buf, LGST, "%s%s.log", IMC_DIR, channel->local_name );
imc.c:               fprintf( fp, "%s\n", imc_strip_colors( channel->history[x] ) );
imc.c:      if( x == MAX_IMCHISTORY - 1 )
imc.c:            int z = y - 1;
imc.c:            if( channel->history[z] != NULL )
imc.c:               IMCSTRFREE( channel->history[z] );
imc.c:               channel->history[z] = IMCSTRALLOC( channel->history[y] );
imc.c:         snprintf( buf, LGST, "~R[%-2.2d/%-2.2d %-2.2d:%-2.2d] ~G%s",
imc.c:                   local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, msg );
imc.c:         IMCSTRFREE( channel->history[x] );
imc.c:         channel->history[x] = IMCSTRALLOC( buf );
imc.c:         if( IMCIS_SET( channel->flags, IMCCHAN_LOG ) )
imc.c:            snprintf( buf, LGST, "%s%s.log", IMC_DIR, channel->local_name );
imc.c:               fprintf( fp, "%s\n", imc_strip_colors( channel->history[x] ) );
imc.c:   if( !c->local_name || c->local_name[0] == '\0' || !c->refreshed )
imc.c:      snprintf( buf, LGST, emote ? c->emoteformat : c->regformat, from, txt );
imc.c:      snprintf( buf, LGST, c->socformat, txt );
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      ch = d->original ? d->original : d->character;
imc.c:      if( !ch || d->connected != CON_PLAYING )
imc.c:      if( IMCPERM( ch ) < c->level || !imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:      if( !c->open )
imc.c:         snprintf( name, SMST, "%s@%s", CH_IMCNAME( ch ), this_imcmud->localname );
imc.c:         if( !imc_hasname( c->invited, name ) && strcasecmp( c->owner, name ) )
imc.c:      imc_display_channel( c, q->from, txt, em );
imc.c:   if( !c->open )
imc.c:      snprintf( to, SMST, "IMC@%s", imc_channel_mudof( c->name ) );
imc.c:      p = imc_newpacket( name, "ice-msg-p", to );
imc.c:      p = imc_newpacket( name, "ice-msg-b", "*@*" );
imc.c:   imc_addtopacket( p, "channel=%s", c->name );
imc.c:   if( !( vic = imc_find_user( imc_nameof( q->to ) ) ) )
imc.c:             c->local_name, this_imcmud->localname );
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      person = d->original ? d->original : d->character;
imc.c:      if( !imc_hasname( IMC_LISTEN( person ), c->local_name ) )
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "%-15s", CH_IMCNAME( person ) );
imc.c:         snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "%s", "\r\n" );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "%s", "\r\n" );
imc.c:   if( !c->local_name )
imc.c:      snprintf( buf, IMC_BUFF_SIZE, "Channel %s is not locally configured on %s\r\n", lname, this_imcmud->localname );
imc.c:   else if( c->level > level )
imc.c:      snprintf( buf, IMC_BUFF_SIZE, "Channel %s is above your permission level on %s\r\n", lname, this_imcmud->localname );
imc.c:      if( ( !strcasecmp( cwho, "" ) || !strcasecmp( cwho, "Nobody" ) ) && !strcasecmp( q->to, "*" ) )
imc.c:   p = imc_newpacket( "*", "ice-chan-whoreply", q->from );
imc.c:   imc_addtopacket( p, "channel=%s", c->name );
imc.c:   amount = length - strlen( stripped );  /* Determine amount to put in front of line */
imc.c:   p = imc_newpacket( "*", "who-reply", to );
imc.c:   imcstrlcpy( head, whot->head, LGST );
imc.c:   imcstrlcpy( tail, whot->tail, LGST );
imc.c:   imcstrlcpy( pline, whot->immline, LGST );
imc.c:   imcstrlcpy( pline, whot->plrline, LGST );
imc.c:   imcstrlcpy( master, whot->master, LGST );
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      person = d->original ? d->original : d->character;
imc.c:      if( person && d->connected == CON_PLAYING )
imc.c:            imcstrlcpy( plrheader, whot->plrheader, LGST );
imc.c:            imcstrlcpy( flags, "---", SMST );
imc.c:   for( d = first_descriptor; d; d = d->next )
imc.c:      person = d->original ? d->original : d->character;
imc.c:      if( person && d->connected == CON_PLAYING )
imc.c:            imcstrlcpy( immheader, whot->immheader, SMST );
imc.c:            imcstrlcpy( flags, "---", SMST );
imc.c:             "~W-------------------------------\r\n"
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ),
imc.c:   snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~W%s\r\n",
imc.c:      imc_process_who( q->from );
imc.c:      imc_process_finger( q->from, type );
imc.c:      snprintf( buf, IMC_BUFF_SIZE, "\r\n~WMUD Name    : ~c%s\r\n", this_imcmud->localname );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~WHost        : ~c%s\r\n", this_imcmud->ihost );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~WAdmin Email : ~c%s\r\n", this_imcmud->email );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~WWebsite     : ~c%s\r\n", this_imcmud->www );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~WIMC2 Version: ~c%s\r\n", this_imcmud->versionid );
imc.c:      snprintf( buf + strlen( buf ), IMC_BUFF_SIZE - strlen( buf ), "~WDetails     : ~c%s\r\n", this_imcmud->details );
imc.c:   imc_send_whoreply( q->from, buf );
imc.c:   if( !( vic = imc_find_user( imc_nameof( q->to ) ) ) )
imc.c:   p = imc_newpacket( "*", "whois-reply", to );
imc.c:   if( ( vic = imc_find_user( imc_nameof( q->to ) ) ) != NULL )
imc.c:   if( ( vic = imc_find_user( imc_nameof( q->to ) ) ) != NULL && !IMCISINVIS( vic ) )
imc.c:      snprintf( buf, LGST, "~RIMC Locate: ~Y%s@%s: ~cOnline.\r\n", CH_IMCNAME( vic ), this_imcmud->localname );
imc.c:      imc_send_whoisreply( q->from, buf );
imc.c:   if( !( vic = imc_find_user( imc_nameof( q->to ) ) ) || IMCPERM( vic ) < IMCPERM_MORT )
imc.c:      snprintf( buf, LGST, "No player named %s exists here.", q->to );
imc.c:      imc_send_tell( "*", q->from, buf, 1 );
imc.c:      if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:         snprintf( buf, LGST, "%s is not receiving beeps.", q->to );
imc.c:         imc_send_tell( "*", q->from, buf, 1 );
imc.c:   if( imc_isignoring( vic, q->from ) )
imc.c:      if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:         snprintf( buf, LGST, "%s is not receiving beeps.", q->to );
imc.c:         imc_send_tell( "*", q->from, buf, 1 );
imc.c:      if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:         snprintf( buf, LGST, "%s is not receiving beeps.", q->to );
imc.c:         imc_send_tell( "*", q->from, buf, 1 );
imc.c:      if( strcasecmp( imc_nameof( q->from ), "*" ) )
imc.c:         snprintf( buf, LGST, "%s is currently AFK. Try back later.", q->to );
imc.c:         imc_send_tell( "*", q->from, buf, 1 );
imc.c:   imc_printf( vic, "~c\a%s imcbeeps you.~!\r\n", q->from );
imc.c:   if( !( r = imc_find_reminfo( imc_mudof( q->from ) ) ) )
imc.c:      imc_new_reminfo( imc_mudof( q->from ), version, netname, url, q->route );
imc.c:   r->expired = FALSE;
imc.c:      IMCSTRFREE( r->url );
imc.c:      r->url = IMCSTRALLOC( url );
imc.c:      IMCSTRFREE( r->version );
imc.c:      r->version = IMCSTRALLOC( version );
imc.c:      IMCSTRFREE( r->network );
imc.c:      r->network = IMCSTRALLOC( netname );
imc.c:   if( q->route && q->route[0] != '\0' )
imc.c:      IMCSTRFREE( r->path );
imc.c:      r->path = IMCSTRALLOC( q->route );
imc.c:      IMCSTRFREE( r->host );
imc.c:      r->host = IMCSTRALLOC( host );
imc.c:      IMCSTRFREE( r->port );
imc.c:      r->port = IMCSTRALLOC( iport );
imc.c:      p = imc_newpacket( "*", "is-alive", q->from );
imc.c:      p = imc_newpacket( "*", "is-alive", packet );
imc.c:   imc_addtopacket( p, "versionid=%s", this_imcmud->versionid );
imc.c:   imc_addtopacket( p, "url=%s", this_imcmud->www );
imc.c:   imc_addtopacket( p, "host=%s", this_imcmud->ihost );
imc.c:   imc_addtopacket( p, "port=%d", this_imcmud->iport );
imc.c:   p = imc_newpacket( "*", "keepalive-request", "*@*" );
imc.c:   p = imc_newpacket( "*", "ice-refresh", "IMC@$" );
imc.c:   IMCSTRFREE( c->name );
imc.c:   IMCSTRFREE( c->owner );
imc.c:   IMCSTRFREE( c->operators );
imc.c:   IMCSTRFREE( c->invited );
imc.c:   IMCSTRFREE( c->excluded );
imc.c:   c->name = IMCSTRALLOC( chan );
imc.c:   c->owner = IMCSTRALLOC( owner );
imc.c:   c->operators = IMCSTRALLOC( ops );
imc.c:   c->invited = IMCSTRALLOC( invite );
imc.c:   c->excluded = IMCSTRALLOC( exclude );
imc.c:   c->open = copen;
imc.c:   if( c->level == IMCPERM_NOTSET )
imc.c:      c->level = perm;
imc.c:   c->refreshed = TRUE;
imc.c:   for( user = first_imcucache; user; user = user->next )
imc.c:      if( !strcasecmp( user->name, name ) )
imc.c:         return user->gender;
imc.c:    * -1 means you aren't in the list and need to be put there. 
imc.c:   return -1;
imc.c:   for( user = first_imcucache; user; user = user->next )
imc.c:      fprintf( fp, "Name %s\n", user->name );
imc.c:      fprintf( fp, "Sex  %d\n", user->gender );
imc.c:      fprintf( fp, "Time %ld\n", ( long int )user->time );
imc.c:      next_ucache = ucache->next;
imc.c:      if( imc_time - ucache->time >= 2592000 )
imc.c:         IMCSTRFREE( ucache->name );
imc.c:   for( user = first_imcucache; user; user = user->next )
imc.c:      if( !strcasecmp( user->name, name ) )
imc.c:         user->gender = gender;
imc.c:         user->time = imc_time;
imc.c:   user->name = IMCSTRALLOC( name );
imc.c:   user->gender = gender;
imc.c:   user->time = imc_time;
imc.c:   p = imc_newpacket( visname, "user-cache", "*@*" );
imc.c:   sex = imc_get_ucache_gender( q->from );
imc.c:   imc_ucache_update( q->from, gender );
imc.c:   p = imc_newpacket( "*", "user-cache-request", to );
imc.c:    * Gender of -1 means they aren't in the mud's ucache table. Don't waste the reply packet. 
imc.c:   if( gender == -1 )
imc.c:   snprintf( to, SMST, "*@%s", imc_mudof( q->from ) );
imc.c:   p = imc_newpacket( "*", "user-cache-reply", to );
imc.c:   r->expired = TRUE;
imc.c:   imc_register_packet_handler( "keepalive-request", imc_send_keepalive );
imc.c:   imc_register_packet_handler( "is-alive", imc_recv_isalive );
imc.c:   imc_register_packet_handler( "ice-update", imc_recv_iceupdate );
imc.c:   imc_register_packet_handler( "ice-msg-r", imc_recv_pbroadcast );
imc.c:   imc_register_packet_handler( "ice-msg-b", imc_recv_broadcast );
imc.c:   imc_register_packet_handler( "user-cache", imc_recv_ucache );
imc.c:   imc_register_packet_handler( "user-cache-request", imc_recv_ucache_request );
imc.c:   imc_register_packet_handler( "user-cache-reply", imc_recv_ucache_reply );
imc.c:   imc_register_packet_handler( "ice-destroy", imc_recv_icedestroy );
imc.c:   imc_register_packet_handler( "who-reply", imc_recv_whoreply );
imc.c:   imc_register_packet_handler( "whois-reply", imc_recv_whoisreply );
imc.c:   imc_register_packet_handler( "ice-chan-who", imc_recv_chanwho );
imc.c:   imc_register_packet_handler( "ice-chan-whoreply", imc_recv_chanwhoreply );
imc.c:   imc_register_packet_handler( "close-notify", imc_recv_closenotify );
imc.c:   for( ph = first_phandler; ph; ph = ph->next )
imc.c:      if( !strcasecmp( type, ph->name ) )
imc.c:         return ph->func;
imc.c:   packet = imcone_argument( packet, p->from );
imc.c:   packet = imcone_argument( packet, p->route );
imc.c:   packet = imcone_argument( packet, p->type );
imc.c:   packet = imcone_argument( packet, p->to );
imc.c:    * Banned muds are silently dropped - thanks to WynterNyght@IoG for noticing this was missing. 
imc.c:   if( imc_isbanned( p->from ) )
imc.c:   pfun = pfun_lookup( p->type );
imc.c:                 p->from, seq, p->route, p->type, p->to, packet );
imc.c:         imclog( "No packet handler function has been defined for %s", p->type );
imc.c:    * This might seem slow, but we need to track muds who don't send is-alive packets 
imc.c:   if( !( imc_find_reminfo( imc_mudof( p->from ) ) ) )
imc.c:      imc_new_reminfo( imc_mudof( p->from ), "Unknown", this_imcmud->network, "Unknown", p->route );
imc.c:   this_imcmud->state = IMC_ONLINE;
imc.c:      IMCSTRFREE( this_imcmud->network );
imc.c:      this_imcmud->network = IMCSTRALLOC( netname );
imc.c:   IMCSTRFREE( this_imcmud->servername );
imc.c:   this_imcmud->servername = IMCSTRALLOC( name );
imc.c:/* Handle an autosetup response from a supporting server - Samson 8-12-03 */
imc.c:         imclog( "There is already a mud named %s connected to the network.", this_imcmud->localname );
imc.c:      if( encrypt && encrypt[0] != '\0' && !strcasecmp( encrypt, "SHA256-SET" ) )
imc.c:         imclog( "SHA-256 Authentication has been enabled." );
imc.c:         this_imcmud->sha256pass = TRUE;
imc.c:   const char *ptr = this_imcmud->outbuf;
imc.c:   int nleft = this_imcmud->outtop, nwritten = 0;
imc.c:      if( ( nwritten = send( this_imcmud->desc, ptr, nleft, 0 ) ) <= 0 )
imc.c:         if( nwritten == -1 && errno == EAGAIN )
imc.c:            char *p2 = this_imcmud->outbuf;
imc.c:            this_imcmud->outtop = strlen( this_imcmud->outbuf );
imc.c:      nleft -= nwritten;
imc.c:      imclog( "Packet Sent: %s", this_imcmud->outbuf );
imc.c:      imclog( "Bytes sent: %d", this_imcmud->outtop );
imc.c:   this_imcmud->outbuf[0] = '\0';
imc.c:   this_imcmud->outtop = 0;
imc.c:   if( !strcasecmp( command, "SHA256-AUTH-INIT" ) )
imc.c:         imclog( "SHA-256 Authentication failure: No auth_value was returned by %s.", rname );
imc.c:      snprintf( pwd, SMST, "%ld%s%s", auth_value, this_imcmud->clientpw, this_imcmud->serverpw );
imc.c:      snprintf( response, LGST, "SHA256-AUTH-RESP %s %s version=%d", this_imcmud->localname, cryptpwd, IMC_VERSION );
imc.c:    * SHA-256 response is pretty simple. If you blew the authentication, it happened on the server anyway. 
imc.c:   if( !strcasecmp( command, "SHA256-AUTH-APPR" ) )
imc.c:      imclog( "%s", "SHA-256 Authentication completed." );
imc.c:      if( strcasecmp( this_imcmud->serverpw, pw ) )
imc.c:      if( encrypt[0] != '\0' && !strcasecmp( encrypt, "SHA256-SET" ) )
imc.c:         imclog( "SHA-256 Authentication has been enabled." );
imc.c:         this_imcmud->sha256pass = TRUE;
imc.c:    * * arg1=autosetup name=servername pw=command version=response netname=SHA256-SET
imc.c:   if( this_imcmud->inbuf[0] == '\0' )
imc.c:   k = strlen( this_imcmud->incomm );
imc.c:   for( i = 0; this_imcmud->inbuf[i] != '\0'
imc.c:        && this_imcmud->inbuf[i] != '\n' && this_imcmud->inbuf[i] != '\r' && i < IMC_BUFF_SIZE; i++ )
imc.c:      this_imcmud->incomm[k++] = this_imcmud->inbuf[i];
imc.c:   while( this_imcmud->inbuf[i] == '\n' || this_imcmud->inbuf[i] == '\r' )
imc.c:   this_imcmud->incomm[k] = '\0';
imc.c:   while( ( this_imcmud->inbuf[j] = this_imcmud->inbuf[i + j] ) != '\0' )
imc.c:   this_imcmud->inbuf[j] = '\0';
imc.c:   iStart = strlen( this_imcmud->inbuf );
imc.c:      nRead = recv( this_imcmud->desc, this_imcmud->inbuf + iStart, sizeof( this_imcmud->inbuf ) - 10 - iStart, 0 );
imc.c:         if( iStart >= sizeof( this_imcmud->inbuf ) - 10 )
imc.c:      else if( nRead == 0 && this_imcmud->state == IMC_ONLINE )
imc.c:      else if( nRead == -1 )
imc.c:         imclog( "%s: Descriptor error on #%d: %s", __FUNCTION__, this_imcmud->desc, strerror( iErr ) );
imc.c:   this_imcmud->inbuf[iStart] = '\0';
imc.c:      imcwait--;
imc.c:         if( this_imcmud->sha256pass )
imc.c:            imclog( "%s", "Unable to reconnect using SHA-256, trying standard authentication." );
imc.c:            this_imcmud->sha256pass = FALSE;
imc.c:            imcwait = -2;
imc.c:      imc_startup( TRUE, -1, FALSE );
imc.c:   if( this_imcmud->state == IMC_OFFLINE || this_imcmud->desc == -1 )
imc.c:   FD_SET( this_imcmud->desc, &in_set );
imc.c:   FD_SET( this_imcmud->desc, &out_set );
imc.c:   if( select( this_imcmud->desc + 1, &in_set, &out_set, NULL, &null_time ) < 0 )
imc.c:   if( FD_ISSET( this_imcmud->desc, &in_set ) )
imc.c:         if( this_imcmud->inbuf && this_imcmud->inbuf[0] != '\0' )
imc.c:               if( !strcasecmp( this_imcmud->incomm, "SHA-256 authentication is required." ) )
imc.c:                  imclog( "%s", "Unable to reconnect using standard authentication, trying SHA-256." );
imc.c:                  this_imcmud->sha256pass = TRUE;
imc.c:                  imclog( "Buffer contents: %s", this_imcmud->incomm );
imc.c:         FD_CLR( this_imcmud->desc, &out_set );
imc.c:            imclog( "Packet received: %s", this_imcmud->incomm );
imc.c:         switch ( this_imcmud->state )
imc.c:               imc_process_authentication( this_imcmud->incomm );
imc.c:               this_imcmud->incomm[0] = '\0';
imc.c:               imc_parse_packet( this_imcmud->incomm );
imc.c:               this_imcmud->incomm[0] = '\0';
imc.c:   if( this_imcmud->desc > 0 && this_imcmud->outtop > 0 && FD_ISSET( this_imcmud->desc, &out_set ) && !imc_write_socket(  ) )
imc.c:      this_imcmud->outtop = 0;
imc.c:    * * This isn't a perfect system and never will be. Samson 2-8-04.
imc.c:      if( CH_IMCLEVEL( ch ) < this_imcmud->minlevel )
imc.c:      else if( CH_IMCLEVEL( ch ) >= this_imcmud->minlevel && CH_IMCLEVEL( ch ) < this_imcmud->immlevel )
imc.c:      else if( CH_IMCLEVEL( ch ) >= this_imcmud->immlevel && CH_IMCLEVEL( ch ) < this_imcmud->adminlevel )
imc.c:      else if( CH_IMCLEVEL( ch ) >= this_imcmud->adminlevel && CH_IMCLEVEL( ch ) < this_imcmud->implevel )
imc.c:      else if( CH_IMCLEVEL( ch ) >= this_imcmud->implevel )
imc.c:   if( this_imcmud->state != IMC_ONLINE )
imc.c:      if( IMCPERM( ch ) >= IMCPERM_IMM && imcwait == -2 )
imc.c:   snprintf( buf, SMST, "%s@%s", CH_IMCNAME( ch ), this_imcmud->localname );
imc.c:            if( IMC_LISTEN( ch ) != NULL && this_imcmud->state == IMC_ONLINE )
imc.c:                  if( channel && IMCPERM( ch ) < channel->level )
imc.c:            if( IMC_DENY( ch ) != NULL && this_imcmud->state == IMC_ONLINE )
imc.c:                  if( channel && IMCPERM( ch ) < channel->level )
imc.c:            temp->name = imcfread_line( fp );
imc.c:   for( temp = FIRST_IMCIGNORE( ch ); temp; temp = temp->next )
imc.c:      fprintf( fp, "IMCignore    %s\n", temp->name );
imc.c:            if( channel && IMCPERM( ch ) < channel->level )
imc.c:            if( channel && IMCPERM( ch ) < channel->level )
imc.c:      temp->name = IMCSTRALLOC( line );
imc.c:   for( temp = FIRST_IMCIGNORE( ch ); temp; temp = temp->next )
imc.c:      fbprintf( fp, "IMCIGN   %s\n", temp->name );
imc.c:      ign_next = ign->next;
imc.c:      IMCSTRFREE( ign->name );
imc.c:   for( tempchan = first_imc_channel; tempchan; tempchan = tempchan->next )
imc.c:      if( !tempchan->local_name )
imc.c:      snprintf( filename, 256, "%s%s.hist", IMC_DIR, tempchan->local_name );
imc.c:            tempchan->history[x] = NULL;
imc.c:            tempchan->history[x] = imcfread_line( tempfile );
imc.c:   for( tempchan = first_imc_channel; tempchan; tempchan = tempchan->next )
imc.c:      if( !tempchan->local_name )
imc.c:      if( !tempchan->history[0] )
imc.c:      snprintf( filename, 256, "%s%s.hist", IMC_DIR, tempchan->local_name );
imc.c:         if( tempchan->history[x] != NULL )
imc.c:            fprintf( tempfile, "%s\n", tempchan->history[x] );
imc.c:   for( c = first_imc_channel; c; c = c->next )
imc.c:      if( !c->local_name || c->local_name[0] == '\0' )
imc.c:      fprintf( fp, "ChanName   %s\n", c->name );
imc.c:      fprintf( fp, "ChanLocal  %s\n", c->local_name );
imc.c:      fprintf( fp, "ChanRegF   %s\n", c->regformat );
imc.c:      fprintf( fp, "ChanEmoF   %s\n", c->emoteformat );
imc.c:      fprintf( fp, "ChanSocF   %s\n", c->socformat );
imc.c:      fprintf( fp, "ChanLevel  %d\n", c->level );
imc.c:            IMCKEY( "ChanName", channel->name, imcfread_line( fp ) );
imc.c:            IMCKEY( "ChanLocal", channel->local_name, imcfread_line( fp ) );
imc.c:            IMCKEY( "ChanRegF", channel->regformat, imcfread_line( fp ) );
imc.c:            IMCKEY( "ChanEmoF", channel->emoteformat, imcfread_line( fp ) );
imc.c:            IMCKEY( "ChanSocF", channel->socformat, imcfread_line( fp ) );
imc.c:            IMCKEY( "ChanLevel", channel->level, imcfread_number( fp ) );
imc.c:               if( channel->level > IMCPERM_IMP )
imc.c:                  if( channel->level < this_imcmud->minlevel )
imc.c:                     channel->level = IMCPERM_NONE;
imc.c:                  else if( channel->level >= this_imcmud->minlevel && channel->level < this_imcmud->immlevel )
imc.c:                     channel->level = IMCPERM_MORT;
imc.c:                  else if( channel->level >= this_imcmud->immlevel && channel->level < this_imcmud->adminlevel )
imc.c:                     channel->level = IMCPERM_IMM;
imc.c:                  else if( channel->level >= this_imcmud->adminlevel && channel->level < this_imcmud->implevel )
imc.c:                     channel->level = IMCPERM_ADMIN;
imc.c:                  else if( channel->level >= this_imcmud->implevel )
imc.c:                     channel->level = IMCPERM_IMP;
imc.c:            channel->history[x] = NULL;
imc.c:         channel->refreshed = FALSE;   /* Prevents crash trying to use a bogus channel */
imc.c:         imclog( "configured %s as %s", channel->name, channel->local_name );
imc.c:/* Save current mud-level ban list. Short, simple. */
imc.c:   for( ban = first_imc_ban; ban; ban = ban->next )
imc.c:      fprintf( out, "%s\n", ban->name );
imc.c:   for( color = first_imc_color; color; color = color->next )
imc.c:      fprintf( fp, "Name   %s\n", color->name );
imc.c:      fprintf( fp, "Mudtag %s\n", color->mudtag );
imc.c:      fprintf( fp, "IMCtag %s\n", color->imctag );
imc.c:            IMCKEY( "IMCtag", color->imctag, imcfread_line( fp ) );
imc.c:            IMCKEY( "Mudtag", color->mudtag, imcfread_line( fp ) );
imc.c:            IMCKEY( "Name", color->name, imcfread_line( fp ) );
imc.c:   for( help = first_imc_help; help; help = help->next )
imc.c:      fprintf( fp, "Name %s\n", help->name );
imc.c:      fprintf( fp, "Perm %s\n", imcperm_names[help->level] );
imc.c:      fprintf( fp, "Text %s\n", help->text );
imc.c:            IMCKEY( "Name", help->name, imcfread_line( fp ) );
imc.c:                  imcbug( "imc_readhelp: Command %s loaded with invalid permission. Set to Imp.", help->name );
imc.c:                  help->level = IMCPERM_IMP;
imc.c:                  help->level = permvalue;
imc.c:               while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:               help->text = IMCSTRALLOC( hbuf );
imc.c:   for( cmd = first_imc_command; cmd; cmd = cmd->next )
imc.c:      fprintf( fp, "Name      %s\n", cmd->name );
imc.c:      if( cmd->function != NULL )
imc.c:         fprintf( fp, "Code      %s\n", imc_funcname( cmd->function ) );
imc.c:      fprintf( fp, "Perm      %s\n", imcperm_names[cmd->level] );
imc.c:      fprintf( fp, "Connected %d\n", cmd->connected );
imc.c:      for( alias = cmd->first_alias; alias; alias = alias->next )
imc.c:         fprintf( fp, "Alias     %s\n", alias->name );
imc.c:               alias->name = imcfread_line( fp );
imc.c:               IMCLINK( alias, cmd->first_alias, cmd->last_alias, next, prev );
imc.c:            IMCKEY( "Connected", cmd->connected, imcfread_number( fp ) );
imc.c:               cmd->function = imc_function( word );
imc.c:               if( cmd->function == NULL )
imc.c:                  imcbug( "imc_readcommand: Command %s loaded with invalid function. Set to NULL.", cmd->name );
imc.c:            IMCKEY( "Name", cmd->name, imcfread_line( fp ) );
imc.c:                  imcbug( "imc_readcommand: Command %s loaded with invalid permission. Set to Imp.", cmd->name );
imc.c:                  cmd->level = IMCPERM_IMP;
imc.c:                  cmd->level = permvalue;
imc.c:            IMCKEY( "Name", user->name, imcfread_line( fp ) );
imc.c:            IMCKEY( "Sex", user->gender, imcfread_number( fp ) );
imc.c:            IMCKEY( "Time", user->time, imcfread_number( fp ) );
imc.c:   fprintf( fp, "# %s config file.\n", this_imcmud->versionid );
imc.c:   fprintf( fp, "LocalName      %s\n", this_imcmud->localname );
imc.c:   fprintf( fp, "Autoconnect    %d\n", this_imcmud->autoconnect );
imc.c:   fprintf( fp, "MinPlayerLevel %d\n", this_imcmud->minlevel );
imc.c:   fprintf( fp, "MinImmLevel    %d\n", this_imcmud->immlevel );
imc.c:   fprintf( fp, "AdminLevel     %d\n", this_imcmud->adminlevel );
imc.c:   fprintf( fp, "Implevel       %d\n", this_imcmud->implevel );
imc.c:   fprintf( fp, "InfoName       %s\n", this_imcmud->fullname );
imc.c:   fprintf( fp, "InfoHost       %s\n", this_imcmud->ihost );
imc.c:   fprintf( fp, "InfoPort       %d\n", this_imcmud->iport );
imc.c:   fprintf( fp, "InfoEmail      %s\n", this_imcmud->email );
imc.c:   fprintf( fp, "InfoWWW        %s\n", this_imcmud->www );
imc.c:   fprintf( fp, "InfoBase       %s\n", this_imcmud->base );
imc.c:   fprintf( fp, "InfoDetails    %s\n\n", this_imcmud->details );
imc.c:   fprintf( fp, "ServerAddr     %s\n", this_imcmud->rhost );
imc.c:   fprintf( fp, "ServerPort     %d\n", this_imcmud->rport );
imc.c:   fprintf( fp, "ClientPwd      %s\n", this_imcmud->clientpw );
imc.c:   fprintf( fp, "ServerPwd      %s\n", this_imcmud->serverpw );
imc.c:   fprintf( fp, "SHA256         %d\n", this_imcmud->sha256 );
imc.c:   if( this_imcmud->sha256pass )
imc.c:      fprintf( fp, "SHA256Pwd      %d\n", this_imcmud->sha256pass );
imc.c:            IMCKEY( "Autoconnect", this_imcmud->autoconnect, imcfread_number( fin ) );
imc.c:            IMCKEY( "AdminLevel", this_imcmud->adminlevel, imcfread_number( fin ) );
imc.c:            IMCKEY( "ClientPwd", this_imcmud->clientpw, imcfread_line( fin ) );
imc.c:               if( this_imcmud->base )
imc.c:                  IMCSTRFREE( this_imcmud->base );
imc.c:               this_imcmud->base = IMCSTRALLOC( lbuf1 );
imc.c:               snprintf( lbuf2, LGST, "%s%s", IMC_VERSION_STRING, this_imcmud->base );
imc.c:               this_imcmud->versionid = IMCSTRALLOC( lbuf2 );
imc.c:            IMCKEY( "Implevel", this_imcmud->implevel, imcfread_number( fin ) );
imc.c:            IMCKEY( "InfoName", this_imcmud->fullname, imcfread_line( fin ) );
imc.c:            IMCKEY( "InfoHost", this_imcmud->ihost, imcfread_line( fin ) );
imc.c:            IMCKEY( "InfoPort", this_imcmud->iport, imcfread_number( fin ) );
imc.c:            IMCKEY( "InfoEmail", this_imcmud->email, imcfread_line( fin ) );
imc.c:            IMCKEY( "InfoWWW", this_imcmud->www, imcfread_line( fin ) );
imc.c:            IMCKEY( "InfoBase", this_imcmud->base, imcfread_line( fin ) );
imc.c:            IMCKEY( "InfoDetails", this_imcmud->details, imcfread_line( fin ) );
imc.c:            IMCKEY( "LocalName", this_imcmud->localname, imcfread_line( fin ) );
imc.c:            IMCKEY( "MinImmLevel", this_imcmud->immlevel, imcfread_number( fin ) );
imc.c:            IMCKEY( "MinPlayerLevel", this_imcmud->minlevel, imcfread_number( fin ) );
imc.c:            IMCKEY( "RouterAddr", this_imcmud->rhost, imcfread_line( fin ) );
imc.c:            IMCKEY( "RouterPort", this_imcmud->rport, imcfread_number( fin ) );
imc.c:            IMCKEY( "ServerPwd", this_imcmud->serverpw, imcfread_line( fin ) );
imc.c:            IMCKEY( "ServerAddr", this_imcmud->rhost, imcfread_line( fin ) );
imc.c:            IMCKEY( "ServerPort", this_imcmud->rport, imcfread_number( fin ) );
imc.c:            IMCKEY( "SHA256", this_imcmud->sha256, imcfread_number( fin ) );
imc.c:            IMCKEY( "SHA256Pwd", this_imcmud->sha256pass, imcfread_number( fin ) );
imc.c:         this_imcmud->minlevel = 10;
imc.c:         this_imcmud->immlevel = 101;
imc.c:         this_imcmud->adminlevel = 113;
imc.c:         this_imcmud->implevel = 115;
imc.c:         this_imcmud->network = IMCSTRALLOC( "Unknown" );
imc.c:         this_imcmud->sha256 = TRUE;
imc.c:         this_imcmud->sha256pass = FALSE;
imc.c:         this_imcmud->desc = desc;
imc.c:   if( !this_imcmud->rhost || !this_imcmud->clientpw || !this_imcmud->serverpw )
imc.c:   if( !this_imcmud->localname || this_imcmud->localname[0] == '\0' )
imc.c:   if( !this_imcmud->fullname || this_imcmud->fullname[0] == '\0' )
imc.c:   if( !this_imcmud->ihost || this_imcmud->ihost[0] == '\0' )
imc.c:   if( !this_imcmud->email || this_imcmud->email[0] == '\0' )
imc.c:   if( !this_imcmud->base || this_imcmud->base[0] == '\0' )
imc.c:      this_imcmud->base = IMCSTRALLOC( "Unknown Codebase" );
imc.c:   if( !this_imcmud->www || this_imcmud->www[0] == '\0' )
imc.c:      this_imcmud->www = IMCSTRALLOC( "Not specified" );
imc.c:   if( !this_imcmud->details || this_imcmud->details[0] == '\0' )
imc.c:      this_imcmud->details = IMCSTRALLOC( "No details provided." );
imc.c:   if( !this_imcmud->versionid )
imc.c:      snprintf( cbase, SMST, "%s%s", IMC_VERSION_STRING, this_imcmud->base );
imc.c:      this_imcmud->versionid = IMCSTRALLOC( cbase );
imc.c:   snprintf( iport, SMST, "%d", this_imcmud->iport );
imc.c:   imcstrlcpy( newhead, imcstrrep( newhead, "<%mudfullname%>", this_imcmud->fullname ), LGST );
imc.c:   imcstrlcpy( newhead, imcstrrep( newhead, "<%mudtelnet%>", this_imcmud->ihost ), LGST );
imc.c:   imcstrlcpy( newhead, imcstrrep( newhead, "<%mudurl%>", this_imcmud->www ), LGST );
imc.c:   snprintf( iport, SMST, "%d", this_imcmud->iport );
imc.c:   imcstrlcpy( newtail, imcstrrep( newtail, "<%mudfullname%>", this_imcmud->fullname ), LGST );
imc.c:   imcstrlcpy( newtail, imcstrrep( newtail, "<%mudtelnet%>", this_imcmud->ihost ), LGST );
imc.c:   imcstrlcpy( newtail, imcstrrep( newtail, "<%mudurl%>", this_imcmud->www ), LGST );
imc.c:   IMCSTRFREE( whot->head );
imc.c:   IMCSTRFREE( whot->plrheader );
imc.c:   IMCSTRFREE( whot->immheader );
imc.c:   IMCSTRFREE( whot->plrline );
imc.c:   IMCSTRFREE( whot->immline );
imc.c:   IMCSTRFREE( whot->tail );
imc.c:   IMCSTRFREE( whot->master );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->head = IMCSTRALLOC( parse_who_header( hbuf ) );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->tail = IMCSTRALLOC( parse_who_tail( hbuf ) );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->plrline = IMCSTRALLOC( hbuf );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->immline = IMCSTRALLOC( hbuf );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->immheader = IMCSTRALLOC( hbuf );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->plrheader = IMCSTRALLOC( hbuf );
imc.c:         while( ( hbuf[num] = fgetc( fp ) ) != EOF && hbuf[num] != '' && num < ( LGST - 2 ) )
imc.c:         whot->master = IMCSTRALLOC( hbuf );
imc.c:   int desc = -1;
imc.c:   if( !inet_aton( this_imcmud->rhost, &sa.sin_addr ) )
imc.c:      hostp = gethostbyname( this_imcmud->rhost );
imc.c:         return -1;
imc.c:      memcpy( &sa.sin_addr, hostp->h_addr, hostp->h_length );
imc.c:   sa.sin_addr.s_addr = inet_addr( this_imcmud->rhost );
imc.c:   sa.sin_port = htons( this_imcmud->rport );
imc.c:      return -1;
imc.c:      return -1;
imc.c:   if( connect( desc, ( struct sockaddr * )&sa, sizeof( sa ) ) == -1 )
imc.c:         return -1;
imc.c:   if( this_imcmud->state != IMC_AUTH1 )
imc.c:   if( this_imcmud->desc > 0 )
imc.c:   snprintf( rport, SMST, "%hu", this_imcmud->rport );
imc.c:   n = getaddrinfo( this_imcmud->rhost, rport, &hints, &ai_list );
imc.c:   for( ai = ai_list; ai; ai = ai->ai_next )
imc.c:      desc = socket( ai->ai_family, ai->ai_socktype, ai->ai_protocol );
imc.c:      if( connect( desc, ai->ai_addr, ai->ai_addrlen ) == 0 )
imc.c:      imclog( "%s: socket or connect: failed for %s port %hu", __FUNCTION__, this_imcmud->rhost, this_imcmud->rport );
imc.c:   this_imcmud->state = IMC_AUTH2;
imc.c:   this_imcmud->desc = desc;
imc.c:   this_imcmud->inbuf[0] = '\0';
imc.c:   this_imcmud->outsize = 1000;
imc.c:   IMCCREATE( this_imcmud->outbuf, char, this_imcmud->outsize );
imc.c:    * The MUD is electing to enable SHA256 - this is the default setting 
imc.c:   if( this_imcmud->sha256 )
imc.c:      if( !this_imcmud->sha256pass )
imc.c:                   this_imcmud->localname, this_imcmud->clientpw, IMC_VERSION, this_imcmud->serverpw );
imc.c:         snprintf( buf, LGST, "SHA256-AUTH-REQ %s", this_imcmud->localname );
imc.c:    * The MUD is electing not to use SHA256 for whatever reason - this must be specifically set 
imc.c:                this_imcmud->localname, this_imcmud->clientpw, IMC_VERSION, this_imcmud->serverpw );
imc.c:      c_next = c->next;
imc.c:      pnext = p->next;
imc.c:      ban_next = ban->next;
imc.c:      next_ucache = ucache->next;
imc.c:      IMCSTRFREE( ucache->name );
imc.c:         cmd_next = cmd->next;
imc.c:         for( alias = cmd->first_alias; alias; alias = alias_next )
imc.c:            alias_next = alias->next;
imc.c:            IMCSTRFREE( alias->name );
imc.c:            IMCUNLINK( alias, cmd->first_alias, cmd->last_alias, next, prev );
imc.c:         IMCSTRFREE( cmd->name );
imc.c:         help_next = help->next;
imc.c:         IMCSTRFREE( help->name );
imc.c:         IMCSTRFREE( help->text );
imc.c:         color_next = color->next;
imc.c:         IMCSTRFREE( color->name );
imc.c:         IMCSTRFREE( color->mudtag );
imc.c:         IMCSTRFREE( color->imctag );
imc.c:         ph_next = ph->next;
imc.c:         IMCSTRFREE( ph->name );
imc.c:   if( this_imcmud && this_imcmud->state == IMC_ONLINE )
imc.c:         fprintf( fp, "%s %s\n", ( this_imcmud->network ? this_imcmud->network : "Unknown" ),
imc.c:                  ( this_imcmud->servername ? this_imcmud->servername : "Unknown" ) );
imc.c:   if( this_imcmud && this_imcmud->state == IMC_OFFLINE )
imc.c:   if( this_imcmud->desc > 0 )
imc.c:      close( this_imcmud->desc );
imc.c:   this_imcmud->desc = -1;
imc.c:   this_imcmud->state = IMC_OFFLINE;
imc.c:         IMCSTRFREE( this_imcmud->network );
imc.c:         this_imcmud->network = IMCSTRALLOC( netname );
imc.c:         IMCSTRFREE( this_imcmud->servername );
imc.c:         this_imcmud->servername = IMCSTRALLOC( server );
imc.c:      this_imcmud->state = IMC_ONLINE;
imc.c:      this_imcmud->inbuf[0] = '\0';
imc.c:      this_imcmud->outsize = IMC_BUFF_SIZE;
imc.c:      IMCCREATE( this_imcmud->outbuf, char, this_imcmud->outsize );
imc.c:   this_imcmud->state = IMC_AUTH1;
imc.c:      this_imcmud->state = IMC_OFFLINE;
imc.c:   if( this_imcmud && this_imcmud->state > IMC_OFFLINE )
imc.c:   if( ( !this_imcmud->autoconnect && !force && !connected ) || ( connected && this_imcmud->desc < 1 ) )
imc.c:   if( this_imcmud->autoconnect || force || connected )
imc.c:   snprintf( to, SMST, "IMC@%s", c ? imc_channel_mudof( c->name ) : imc_channel_mudof( chan ) );
imc.c:   p = imc_newpacket( CH_IMCNAME( ch ), "ice-cmd", to );
imc.c:   imc_addtopacket( p, "channel=%s", c ? c->name : chan );
imc.c: * This command will not do "localization" since this is handled automatically now by ice-update packets.
imc.c:      for( c = first_imc_channel; c; c = c->next )
imc.c:         if( c->local_name && c->local_name[0] != '\0' )
imc.c:            imc_printf( ch, "%s ", c->local_name );
imc.c:            imc_printf( ch, "%s ", c->name );
imc.c:    * Permission check -- Xorith 
imc.c:   if( c && c->level > IMCPERM( ch ) )
imc.c:      IMCSTRFREE( c->local_name );
imc.c:      IMCSTRFREE( c->regformat );
imc.c:      IMCSTRFREE( c->emoteformat );
imc.c:      IMCSTRFREE( c->socformat );
imc.c:         IMCSTRFREE( c->history[x] );
imc.c:      if( !c->refreshed )
imc.c:         imc_to_char( "Missing 'newname' argument for 'imcsetup rename'\r\n", ch ); /* Lets be more kind! -- X */
imc.c:         imc_to_char( "Syntax: imcsetup rename <local channel> <newname>\r\n", ch );   /* Fixed syntax message -- X */
imc.c:       * Small change here to give better feedback to the ch -- Xorith 
imc.c:      snprintf( buf, LGST, "Renamed channel '%s' to '%s'.\r\n", c->local_name, arg1 );
imc.c:      IMCSTRFREE( c->local_name );
imc.c:      c->local_name = IMCSTRALLOC( arg1 );
imc.c:         imc_to_char( "Syntax: imcsetup regformat <localchannel|all> <string>\r\n", ch ); /* Syntax Fix -- Xorith */
imc.c:         imc_to_char( "Bad format - must contain exactly 2 %s's.\r\n", ch );
imc.c:         for( c = first_imc_channel; c; c = c->next )
imc.c:            IMCSTRFREE( c->regformat );
imc.c:            c->regformat = IMCSTRALLOC( arg1 );
imc.c:         IMCSTRFREE( c->regformat );
imc.c:         c->regformat = IMCSTRALLOC( arg1 );
imc.c:         imc_to_char( "Syntax: imcsetup emoteformat <localchannel|all> <string>\r\n", ch );  /* Syntax Fix -- Xorith */
imc.c:         imc_to_char( "Bad format - must contain exactly 2 %s's.\r\n", ch );
imc.c:         for( c = first_imc_channel; c; c = c->next )
imc.c:            IMCSTRFREE( c->emoteformat );
imc.c:            c->emoteformat = IMCSTRALLOC( arg1 );
imc.c:         IMCSTRFREE( c->emoteformat );
imc.c:         c->emoteformat = IMCSTRALLOC( arg1 );
imc.c:         imc_to_char( "Bad format - must contain exactly 1 %s.\r\n", ch );
imc.c:         for( c = first_imc_channel; c; c = c->next )
imc.c:            IMCSTRFREE( c->socformat );
imc.c:            c->socformat = IMCSTRALLOC( arg1 );
imc.c:         IMCSTRFREE( c->socformat );
imc.c:         c->socformat = IMCSTRALLOC( arg1 );
imc.c:      int permvalue = -1;
imc.c:       * Added permission checking here -- Xorith 
imc.c:      c->level = permvalue;
imc.c:   int count = 0; /* Count -- Xorith */
imc.c:   char col = 'C';   /* Listening Color -- Xorith */
imc.c:      imc_printf( ch, "~WChannel  : %s\r\n\r\n", c->name );
imc.c:      imc_printf( ch, "~cLocalname: ~w%s\r\n", c->local_name );
imc.c:      imc_printf( ch, "~cPerms    : ~w%s\r\n", imcperm_names[c->level] );
imc.c:      imc_printf( ch, "~cPolicy   : %s\r\n", c->open ? "~gOpen" : "~yPrivate" );
imc.c:      imc_printf( ch, "~cRegFormat: ~w%s\r\n", c->regformat );
imc.c:      imc_printf( ch, "~cEmoFormat: ~w%s\r\n", c->emoteformat );
imc.c:      imc_printf( ch, "~cSocFormat: ~w%s\r\n\r\n", c->socformat );
imc.c:      imc_printf( ch, "~cOwner    : ~w%s\r\n", c->owner );
imc.c:      imc_printf( ch, "~cOperators: ~w%s\r\n", c->operators );
imc.c:      imc_printf( ch, "~cInvite   : ~w%s\r\n", c->invited );
imc.c:      imc_printf( ch, "~cExclude  : ~w%s\r\n", c->excluded );
imc.c:   imc_printf( ch, "~c%-15s ~C%-15s ~B%-15s ~b%-7s ~!%s\r\n\r\n", "Name", "Local name", "Owner", "Perm", "Policy" );
imc.c:   for( c = first_imc_channel; c; c = c->next )
imc.c:      if( IMCPERM( ch ) < c->level )
imc.c:       * If it's locally configured and we're not listening, then color it red -- Xorith 
imc.c:      if( c->local_name )
imc.c:         if( !imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:            col = 'C';  /* Otherwise, keep it Cyan -- X */
imc.c:      imc_printf( ch, "~c%-15.15s ~%c%-*.*s ~B%-15.15s ~b%-7s %s\r\n", c->name, col,
imc.c:                  c->local_name ? 15 : 17, c->local_name ? 15 : 17,
imc.c:                  c->local_name ? c->local_name : "~Y(not local)  ", c->owner,
imc.c:                  imcperm_names[c->level], c->refreshed ? ( c->open ? "~gOpen" : "~yPrivate" ) : "~Runknown" );
imc.c:      count++; /* Keep a count -- Xorith */
imc.c:    * Show the count and a bit of text explaining the red color -- Xorith 
imc.c:      for( c = first_imc_channel; c; c = c->next )
imc.c:         if( !c->local_name )
imc.c:         if( IMCPERM( ch ) >= c->level && !imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:            imc_addname( &IMC_LISTEN( ch ), c->local_name );
imc.c:      for( c = first_imc_channel; c; c = c->next )
imc.c:         if( !c->local_name )
imc.c:         if( imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:            imc_removename( &IMC_LISTEN( ch ), c->local_name );
imc.c:   if( IMCPERM( ch ) < c->level )
imc.c:   if( imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:      imc_removename( &IMC_LISTEN( ch ), c->local_name );
imc.c:      imc_addname( &IMC_LISTEN( ch ), c->local_name );
imc.c:   if( !strcasecmp( argument, this_imcmud->localname ) && IMCPERM( ch ) >= IMCPERM_IMM )
imc.c:      if( this_imcmud->state != IMC_ONLINE )
imc.c:/* Removed imcquery and put in imcinfo. -- Xorith */
imc.c:    * Silly little thing, but since imcchanlist <channel> works... why not? -- Xorith 
imc.c:   imcpager_printf( ch, "~WActive muds on %s:~!\r\n", this_imcmud->network );
imc.c:   imcpager_printf( ch, "~c%-15.15s ~B%-40.40s~! ~g%-15.15s ~G%s", "Name", "IMC2 Version", "Network", "Server" );
imc.c:   imcpager_printf( ch, "\r\n\r\n~c%-15.15s ~B%-40.40s ~g%-15.15s ~G%s",
imc.c:                    this_imcmud->localname, this_imcmud->versionid, this_imcmud->network, this_imcmud->servername );
imc.c:   for( p = first_rinfo; p; p = p->next, count++ )
imc.c:      if( !strcasecmp( p->network, "unknown" ) )
imc.c:         imcstrlcpy( netname, this_imcmud->network, SMST );
imc.c:         imcstrlcpy( netname, p->network, SMST );
imc.c:      if( p->path && p->path[0] != '\0' )
imc.c:         if( ( start = strchr( p->path, '!' ) ) != NULL )
imc.c:            imcstrlcpy( serverpath, p->path, LGST );
imc.c:      imcpager_printf( ch, "\r\n~%c%-15.15s ~B%-40.40s ~g%-15.15s ~G%s",
imc.c:                       p->expired ? 'R' : 'c', p->name, p->version, netname, serverpath );
imc.c:   imcpager_printf( ch, "\r\n~W%d muds on %s found.\r\n", count, this_imcmud->network );
imc.c:   if( this_imcmud && this_imcmud->state > IMC_OFFLINE )
imc.c:   imc_startup( TRUE, -1, FALSE );
imc.c:   if( this_imcmud && this_imcmud->state == IMC_OFFLINE )
imc.c:      this_imcmud->sha256 = !this_imcmud->sha256;
imc.c:      if( this_imcmud->sha256 )
imc.c:         imc_to_char( "SHA-256 support enabled.\r\n", ch );
imc.c:         imc_to_char( "SHA-256 support disabled.\r\n", ch );
imc.c:      this_imcmud->sha256pass = !this_imcmud->sha256pass;
imc.c:      if( this_imcmud->sha256pass )
imc.c:         imc_to_char( "SHA-256 Authentication enabled.\r\n", ch );
imc.c:         imc_to_char( "SHA-256 Authentication disabled.\r\n", ch );
imc.c:      this_imcmud->autoconnect = !this_imcmud->autoconnect;
imc.c:      if( this_imcmud->autoconnect )
imc.c:      imc_printf( ch, "~wLocalname      : ~G%s\r\n", this_imcmud->localname );
imc.c:      imc_printf( ch, "~wAutoconnect    : ~G%s\r\n", this_imcmud->autoconnect ? "Enabled" : "Disabled" );
imc.c:      imc_printf( ch, "~wMinPlayerLevel : ~G%d\r\n", this_imcmud->minlevel );
imc.c:      imc_printf( ch, "~wMinImmLevel    : ~G%d\r\n", this_imcmud->immlevel );
imc.c:      imc_printf( ch, "~wAdminlevel     : ~G%d\r\n", this_imcmud->adminlevel );
imc.c:      imc_printf( ch, "~wImplevel       : ~G%d\r\n", this_imcmud->implevel );
imc.c:      imc_printf( ch, "~wInfoname       : ~G%s\r\n", this_imcmud->fullname );
imc.c:      imc_printf( ch, "~wInfohost       : ~G%s\r\n", this_imcmud->ihost );
imc.c:      imc_printf( ch, "~wInfoport       : ~G%d\r\n", this_imcmud->iport );
imc.c:      imc_printf( ch, "~wInfoemail      : ~G%s\r\n", this_imcmud->email );
imc.c:      imc_printf( ch, "~wInfoWWW        : ~G%s\r\n", this_imcmud->www );
imc.c:      imc_printf( ch, "~wInfoBase       : ~G%s\r\n", this_imcmud->base );
imc.c:      imc_printf( ch, "~wInfoDetails    : ~G%s\r\n\r\n", this_imcmud->details );
imc.c:      imc_printf( ch, "~wServerAddr     : ~G%s\r\n", this_imcmud->rhost );
imc.c:      imc_printf( ch, "~wServerPort     : ~G%d\r\n", this_imcmud->rport );
imc.c:      imc_printf( ch, "~wClientPwd      : ~G%s\r\n", this_imcmud->clientpw );
imc.c:      imc_printf( ch, "~wServerPwd      : ~G%s\r\n", this_imcmud->serverpw );
imc.c:      if( this_imcmud->sha256 )
imc.c:         imc_to_char( "~RThis mud has enabled SHA-256 authentication.\r\n", ch );
imc.c:         imc_to_char( "~RThis mud has disabled SHA-256 authentication.\r\n", ch );
imc.c:      if( this_imcmud->sha256 && this_imcmud->sha256pass )
imc.c:         imc_to_char( "~RThe mud is using SHA-256 encryption to authenticate.\r\n", ch );
imc.c:      this_imcmud->minlevel = value;
imc.c:      this_imcmud->immlevel = value;
imc.c:      this_imcmud->adminlevel = value;
imc.c:      this_imcmud->implevel = value;
imc.c:      IMCSTRFREE( this_imcmud->fullname );
imc.c:      this_imcmud->fullname = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->ihost );
imc.c:      this_imcmud->ihost = IMCSTRALLOC( argument );
imc.c:      this_imcmud->iport = atoi( argument );
imc.c:      imc_printf( ch, "Infoport changed to %d\r\n", this_imcmud->iport );
imc.c:      IMCSTRFREE( this_imcmud->email );
imc.c:      this_imcmud->email = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->www );
imc.c:      this_imcmud->www = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->base );
imc.c:      this_imcmud->base = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->versionid );
imc.c:      snprintf( cbase, SMST, "%s%s", IMC_VERSION_STRING, this_imcmud->base );
imc.c:      this_imcmud->versionid = IMCSTRALLOC( cbase );
imc.c:      IMCSTRFREE( this_imcmud->details );
imc.c:      this_imcmud->details = IMCSTRALLOC( argument );
imc.c:   if( this_imcmud->state != IMC_OFFLINE )
imc.c:      IMCSTRFREE( this_imcmud->rhost );
imc.c:      this_imcmud->rhost = IMCSTRALLOC( argument );
imc.c:      this_imcmud->rport = atoi( argument );
imc.c:      imc_printf( ch, "ServerPort changed to %d\r\n", this_imcmud->rport );
imc.c:      IMCSTRFREE( this_imcmud->clientpw );
imc.c:      this_imcmud->clientpw = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->serverpw );
imc.c:      this_imcmud->serverpw = IMCSTRALLOC( argument );
imc.c:      IMCSTRFREE( this_imcmud->localname );
imc.c:      this_imcmud->localname = IMCSTRALLOC( argument );
imc.c:      this_imcmud->sha256pass = FALSE;
imc.c:/* Modified this command so it's a little more helpful -- Xorith */
imc.c:      for( count = 0, ign = FIRST_IMCIGNORE( ch ); ign; ign = ign->next, count++ )
imc.c:         imc_printf( ch, "%s\r\n", ign->name );
imc.c:      for( ign = FIRST_IMCIGNORE( ch ); ign; ign = ign->next )
imc.c:         if( !strcasecmp( ign->name, argument ) )
imc.c:            IMCSTRFREE( ign->name );
imc.c:      ign->name = IMCSTRALLOC( argument );
imc.c:/* Made this command a little more helpful --Xorith */
imc.c:      for( count = 0, ban = first_imc_ban; ban; ban = ban->next, count++ )
imc.c:         imc_printf( ch, "%s\r\n", ban->name );
imc.c:   if( imc_hasname( IMC_DENY( victim ), channel->local_name ) )
imc.c:      imc_printf( ch, "%s can now listen to %s\r\n", CH_IMCNAME( victim ), channel->local_name );
imc.c:      imc_removename( &IMC_DENY( victim ), channel->local_name );
imc.c:      imc_printf( ch, "%s can no longer listen to %s\r\n", CH_IMCNAME( victim ), channel->local_name );
imc.c:      imc_addname( &IMC_DENY( victim ), channel->local_name );
imc.c:      permvalue = -1;
imc.c:    * Just something to avoid looping through the channel clean-up --Xorith 
imc.c:   if( permvalue == -1 )
imc.c:    * Channel Clean-Up added by Xorith 9-24-03 
imc.c:   if( IMC_LISTEN( victim ) != NULL && this_imcmud->state == IMC_ONLINE )
imc.c:         if( channel && IMCPERM( victim ) < channel->level )
imc.c:                        imcperm_names[channel->level], channel->local_name, imcperm_names[IMCPERM( victim )] );
imc.c:   if( IMCPERM( ch ) < c->level )
imc.c:   if( !c->refreshed )
imc.c:      imc_printf( ch, "%s has not been refreshed yet.\r\n", c->name );
imc.c:         p = imc_newpacket( CH_IMCNAME( ch ), "ice-chan-who", mud );
imc.c:         imc_addtopacket( p, "channel=%s", c->name );
imc.c:         imc_addtopacket( p, "lname=%s", c->local_name ? c->local_name : c->name );
imc.c:   p = imc_newpacket( CH_IMCNAME( ch ), "ice-chan-who", "*" );
imc.c:   imc_addtopacket( p, "channel=%s", c->name );
imc.c:   imc_addtopacket( p, "lname=%s", c->local_name ? c->local_name : c->name );
imc.c:   if( r->expired )
imc.c:      imc_printf( ch, "~W%s ~cis not connected right now.\r\n", r->name );
imc.c:   snprintf( to, SMST, "IMC@%s", r->name );
imc.c:   p = imc_newpacket( CH_IMCNAME( ch ), "remote-admin", to );
imc.c:   if( this_imcmud->sha256pass )
imc.c:      imcstrlcat( buf, "~G---------------------------------------------\r\n", LGST );
imc.c:         snprintf( buf + strlen( buf ), LGST - strlen( buf ), "\r\n~g%s helps:~G\r\n", imcperm_names[perm] );
imc.c:         for( help = first_imc_help; help; help = help->next )
imc.c:            if( help->level != perm )
imc.c:            snprintf( buf + strlen( buf ), LGST - strlen( buf ), "%-15s", help->name );
imc.c:   for( help = first_imc_help; help; help = help->next )
imc.c:      if( !strcasecmp( help->name, argument ) )
imc.c:         if( !help->text || help->text[0] == '\0' )
imc.c:            imc_printf( ch, "~gNo inforation available for topic ~W%s~g.\r\n", help->name );
imc.c:            imc_printf( ch, "~g%s\r\n", help->text );
imc.c:   imc_to_pager( "--------------------------------------------------------------------------\r\n", ch );
imc.c:   for( user = first_imcucache; user; user = user->next )
imc.c:      imcpager_printf( ch, "%-30s %d\r\n", user->name, user->gender );
imc.c:   for( cmd = first_imc_command; cmd; cmd = cmd->next )
imc.c:      if( !strcasecmp( cmd->name, name ) )
imc.c:      for( alias = cmd->first_alias; alias; alias = alias->next )
imc.c:         if( !strcasecmp( alias->name, name ) )
imc.c:      cmd->name = IMCSTRALLOC( name );
imc.c:      cmd->level = IMCPERM( ch );
imc.c:      cmd->connected = FALSE;
imc.c:      imc_printf( ch, "~gCommand ~W%s ~gcreated.\r\n", cmd->name );
imc.c:         cmd->function = imc_function( argument );
imc.c:         if( cmd->function == NULL )
imc.c:            imc_printf( ch, "~gFunction ~W%s ~gdoes not exist - set to NULL.\r\n", argument );
imc.c:         cmd->function = NULL;
imc.c:   if( !imccheck_permissions( ch, cmd->level, cmd->level, FALSE ) )
imc.c:      imc_printf( ch, "~gCommand ~W%s ~ghas been deleted.\r\n", cmd->name );
imc.c:      for( alias = cmd->first_alias; alias; alias = alias_next )
imc.c:         alias_next = alias->next;
imc.c:         IMCUNLINK( alias, cmd->first_alias, cmd->last_alias, next, prev );
imc.c:         IMCSTRFREE( alias->name );
imc.c:      IMCSTRFREE( cmd->name );
imc.c:      for( alias = cmd->first_alias; alias; alias = alias_next )
imc.c:         alias_next = alias->next;
imc.c:         if( !strcasecmp( alias->name, argument ) )
imc.c:            imc_printf( ch, "~W%s ~ghas been removed as an alias for ~W%s\r\n", argument, cmd->name );
imc.c:            IMCUNLINK( alias, cmd->first_alias, cmd->last_alias, next, prev );
imc.c:            IMCSTRFREE( alias->name );
imc.c:      for( tmp = first_imc_command; tmp; tmp = tmp->next )
imc.c:         if( !strcasecmp( tmp->name, argument ) )
imc.c:         for( alias = tmp->first_alias; alias; alias = alias->next )
imc.c:            if( !strcasecmp( argument, alias->name ) )
imc.c:               imc_printf( ch, "~W%s ~gis already an alias for ~W%s\r\n", argument, tmp->name );
imc.c:      alias->name = IMCSTRALLOC( argument );
imc.c:      IMCLINK( alias, cmd->first_alias, cmd->last_alias, next, prev );
imc.c:      imc_printf( ch, "~W%s ~ghas been added as an alias for ~W%s\r\n", alias->name, cmd->name );
imc.c:      cmd->connected = !cmd->connected;
imc.c:      if( cmd->connected )
imc.c:         imc_printf( ch, "~gCommand ~W%s ~gwill now require a connection to IMC2 to use.\r\n", cmd->name );
imc.c:         imc_printf( ch, "~gCommand ~W%s ~gwill no longer require a connection to IMC2 to use.\r\n", cmd->name );
imc.c:      imc_printf( ch, "~gCommand       : ~W%s\r\n", cmd->name );
imc.c:      imc_printf( ch, "~gPermission    : ~W%s\r\n", imcperm_names[cmd->level] );
imc.c:      imc_printf( ch, "~gFunction      : ~W%s\r\n", imc_funcname( cmd->function ) );
imc.c:      imc_printf( ch, "~gConnection Req: ~W%s\r\n", cmd->connected ? "Yes" : "No" );
imc.c:      if( cmd->first_alias )
imc.c:         for( alias = cmd->first_alias; alias; alias = alias->next )
imc.c:            snprintf( buf + strlen( buf ), LGST - strlen( buf ), "%s ", alias->name );
imc.c:      imc_printf( ch, "~gCommand ~W%s ~ghas been renamed to ~W%s.\r\n", cmd->name, argument );
imc.c:      IMCSTRFREE( cmd->name );
imc.c:      cmd->name = IMCSTRALLOC( argument );
imc.c:      cmd->function = imc_function( argument );
imc.c:      if( cmd->function == NULL )
imc.c:         imc_printf( ch, "~gFunction ~W%s ~gdoes not exist - set to NULL.\r\n", argument );
imc.c:      if( !imccheck_permissions( ch, permvalue, cmd->level, FALSE ) )
imc.c:      cmd->level = permvalue;
imc.c:      imc_printf( ch, "~gCommand ~W%s ~gpermission level has been changed to ~W%s.\r\n", cmd->name,
imc.c:   for( help = first_imc_help; help; help = help->next )
imc.c:      if( !strcasecmp( help->name, name ) )
imc.c:      imc_printf( ch, "~W%s ~ghas been renamed to ~W%s.\r\n", help->name, argument );
imc.c:      IMCSTRFREE( help->name );
imc.c:      help->name = IMCSTRALLOC( argument );
imc.c:      if( !imccheck_permissions( ch, permvalue, help->level, FALSE ) )
imc.c:      imc_printf( ch, "~gPermission level for ~W%s ~ghas been changed to ~W%s.\r\n", help->name, imcperm_names[permvalue] );
imc.c:      help->level = permvalue;
imc.c:      rnext = r->next;
imc.c:   p = imc_newpacket( CH_IMCNAME( ch ), "imc-laston", this_imcmud->servername );
imc.c:   imcstrlcat( buf, "~G-------------------------------------\r\n\r\n", LGST );
imc.c:      snprintf( buf + strlen( buf ), LGST - strlen( buf ), "\r\n~g%s commands:~G\r\n", imcperm_names[perm] );
imc.c:      for( cmd = first_imc_command; cmd; cmd = cmd->next )
imc.c:         if( cmd->level != perm )
imc.c:         snprintf( buf + strlen( buf ), LGST - strlen( buf ), "%-15s", cmd->name );
imc.c:   // lower-case the social name before asking the MUD
imc.c:          && mud && mud[0] != '\0' && !strcasecmp( mud, this_imcmud->localname ) )
imc.c:         if( !social->others_auto )
imc.c:         imcstrlcpy( socname, social->others_auto, LGST );
imc.c:            if( !social->others_found )
imc.c:            imcstrlcpy( socname, social->others_found, LGST );
imc.c:            if( !social->vict_found )
imc.c:            imcstrlcpy( socname, social->vict_found, LGST );
imc.c:            if( !social->char_found )
imc.c:            imcstrlcpy( socname, social->char_found, LGST );
imc.c:         if( !social->others_no_arg )
imc.c:         imcstrlcpy( socname, social->others_no_arg, LGST );
imc.c:         if( !social->char_no_arg )
imc.c:         imcstrlcpy( socname, social->char_no_arg, LGST );
imc.c:          && mud && mud[0] != '\0' && !strcasecmp( mud, this_imcmud->localname ) )
imc.c:               i = imc_makename( CH_IMCNAME( ch ), this_imcmud->localname );
imc.c:   skeleton->player.name = IMCSTRALLOC( name );
imc.c:   skeleton->player.short_descr = IMCSTRALLOC( name );
imc.c:   skeleton->in_room = real_room( 1 );
imc.c:   skeleton->name = IMCSTRALLOC( name );
imc.c:   skeleton->short_descr = IMCSTRALLOC( name );
imc.c:   skeleton->in_room = get_room_index( ROOM_VNUM_LIMBO );
imc.c:   IMCSTRFREE( skeleton->player.name );
imc.c:   IMCSTRFREE( skeleton->player.short_descr );
imc.c:   IMCSTRFREE( skeleton->name );
imc.c:   IMCSTRFREE( skeleton->short_descr );
imc.c:/* Socials can now be called anywhere you want them - like for instance, tells.
imc.c: * Thanks to Darien@Sandstorm for this suggestion. -- Samson 2-21-04
imc.c:      if( sex == -1 )
imc.c:   for( cmd = first_imc_command; cmd; cmd = cmd->next )
imc.c:      if( IMCPERM( ch ) < cmd->level )
imc.c:      for( alias = cmd->first_alias; alias; alias = alias->next )
imc.c:         if( !strcasecmp( command, alias->name ) )
imc.c:            command = cmd->name;
imc.c:      if( !strcasecmp( command, cmd->name ) )
imc.c:         if( cmd->connected == TRUE && this_imcmud->state < IMC_ONLINE )
imc.c:         if( cmd->function == NULL )
imc.c:            imcbug( "imc_command_hook: Command %s has no code set!", cmd->name );
imc.c:         ( *cmd->function ) ( ch, argument );
imc.c:   if( !c || c->level > IMCPERM( ch ) )
imc.c:   if( imc_hasname( IMC_DENY( ch ), c->local_name ) )
imc.c:      imc_printf( ch, "You have been denied the use of %s by the administration.\r\n", c->local_name );
imc.c:   if( !c->refreshed )
imc.c:      imc_printf( ch, "The %s channel has not yet been refreshed by the server.\r\n", c->local_name );
imc.c:      imc_printf( ch, "~cThe last %d %s messages:\r\n", MAX_IMCHISTORY, c->local_name );
imc.c:         if( c->history[y] != NULL )
imc.c:            imc_printf( ch, "%s\r\n", c->history[y] );
imc.c:      if( !IMCIS_SET( c->flags, IMCCHAN_LOG ) )
imc.c:         IMCSET_BIT( c->flags, IMCCHAN_LOG );
imc.c:                     c->local_name );
imc.c:         IMCREMOVE_BIT( c->flags, IMCCHAN_LOG );
imc.c:         imc_printf( ch, "~GFile logging disabled for %s.\r\n", c->local_name );
imc.c:   if( !imc_hasname( IMC_LISTEN( ch ), c->local_name ) )
imc.c:                  c->local_name );
imc.c:          * Strip the , and then extra spaces - Remcon 6-28-03 
imc.c:          * Strip the @ and then extra spaces - Remcon 6-28-03 
imc.c:   imc_startup( FALSE, -1, FALSE );
imccfg.h:/* Codebase macros - Change as you might need.
imccfg.h:#define CH_IMCDATA(ch)           ((ch)->pcdata->imcchardata)
imccfg.h:#define CH_IMCLEVEL(ch)          ((ch)->top_level)
imccfg.h:#define CH_IMCNAME(ch)           ((ch)->name)
imccfg.h:#define CH_IMCSEX(ch)            ((ch)->sex)
imccfg.h:#define CH_IMCTITLE(ch)          ((ch)->pcdata->title)
imccfg.h:#define CH_IMCRANK(ch)           ((ch)->pcdata->rank)
imccfg.h:#define CH_IMCRANK(ch)           (title_table[(ch)->class][(ch)->level][(ch)->sex == SEX_FEMALE ? 1 : 0])
imccfg.h:#define CH_IMCRANK(ch)           (title_table[(ch)->class][(ch)->level][(ch)->sex == SEX_FEMALE ? 1 : 0])
imccfg.h:#define CH_IMCRANK(ch)           (class_table[(ch)->class].who_name)
imccfg.h:#define CH_IMCRANK(ch)           (title_table[(ch)->class][(ch)->level][(ch)->sex == SEX_FEMALE ? 1 : 0])
imccfg.h:#define CH_IMCDATA(ch)           ((ch)->player_specials->imcchardata)
imccfg.h:#define CH_IMCDATA(ch)           ((ch)->imcchardata)
imccfg.h:#define CH_IMCLEVEL(ch)          ((ch)->level)
imccfg.h:#define CH_IMCNAME(ch)           ((ch)->name)
imccfg.h:#define CH_IMCSEX(ch)            ((ch)->sex)
imccfg.h:#define LOWER(c)		((c) >= 'A' && (c) <= 'Z' ? (c)+'a'-'A' : (c))
imc.h:/* IMC2 Freedom Client - Developed by Mud Domain.
imc.h: * Copyright 2004-2008 by Roger Libiez ( Samson )
imc.h: * Comments and suggestions welcome: http://www.mudbytes.net/imc2-support-forum
imc.h:#define IMC_VERSION_STRING "IMC2 Freedom CL-2.2 "
imc.h:#define IMCPERM(ch)           (CH_IMCDATA((ch))->imcperm)
imc.h:#define IMCFLAG(ch)           (CH_IMCDATA((ch))->imcflag)
imc.h:#define FIRST_IMCIGNORE(ch)   (CH_IMCDATA((ch))->imcfirst_ignore)
imc.h:#define LAST_IMCIGNORE(ch)    (CH_IMCDATA((ch))->imclast_ignore)
imc.h:#define IMC_LISTEN(ch)        (CH_IMCDATA((ch))->imc_listen)
imc.h:#define IMC_DENY(ch)          (CH_IMCDATA((ch))->imc_denied)
imc.h:#define IMC_RREPLY(ch)        (CH_IMCDATA((ch))->rreply)
imc.h:#define IMC_RREPLY_NAME(ch)   (CH_IMCDATA((ch))->rreply_name)
imc.h:#define IMC_EMAIL(ch)         (CH_IMCDATA((ch))->email)
imc.h:#define IMC_HOMEPAGE(ch)      (CH_IMCDATA((ch))->homepage)
imc.h:#define IMC_AIM(ch)           (CH_IMCDATA((ch))->aim)
imc.h:#define IMC_ICQ(ch)           (CH_IMCDATA((ch))->icq)
imc.h:#define IMC_YAHOO(ch)         (CH_IMCDATA((ch))->yahoo)
imc.h:#define IMC_MSN(ch)           (CH_IMCDATA((ch))->msn)
imc.h:#define IMC_COMMENT(ch)       (CH_IMCDATA((ch))->comment)
imc.h:#define IMCTELLHISTORY(ch,x)  (CH_IMCDATA((ch))->imc_tellhistory[(x)])
imc.h:/* double-linked list handling macros -Thoric ( From the Smaug codebase ) */
imc.h:      (last)->next = (link);                    \
imc.h:   (link)->next = NULL;                         \
imc.h:      (link)->prev = NULL;                      \
imc.h:      (link)->prev = (last);                    \
imc.h:   (link)->prev = (insert)->prev;                     \
imc.h:   if ( !(insert)->prev )                             \
imc.h:      (insert)->prev->next = (link);                  \
imc.h:   (insert)->prev = (link);                           \
imc.h:   (link)->next = (insert);                           \
imc.h:   if ( !(link)->prev )                          \
imc.h:      (first) = (link)->next;                    \
imc.h:	   (first)->prev = NULL;                   \
imc.h:      (link)->prev->next = (link)->next;         \
imc.h:   if( !(link)->next )                           \
imc.h:      (last) = (link)->prev;                     \
imc.h:	   (last)->next = NULL;                    \
imc.h:      (link)->next->prev = (link)->prev;         \
imc.h: * and they look alot neater too. Yes, readability IS important! - Samson
imc.h:typedef struct imc_channel IMC_CHANNEL;   /* Channels, both local and non-local */
imc.h:   char *rreply;  /* IMC reply-to */
imc.h:   char *rreply_name;   /* IMC reply-to shown to char */
imc.h:   char *imc_tellhistory[MAX_IMCTELLHISTORY];   /* History of received imctells - Samson 1-21-04 */
imc.h:   char *email;   /* Person's email address - for imcfinger - Samson 3-21-04 */
imc.h:   char *homepage;   /* Person's homepage - Samson 3-21-04 */
imc.h:   char *aim;  /* Person's AOL Instant Messenger screenname - Samson 3-21-04 */
imc.h:   char *yahoo;   /* Person's Y! screenname - Samson 3-21-04 */
imc.h:   char *msn;  /* Person's MSN Messenger screenname - Samson 3-21-04 */
imc.h:   char *comment; /* Person's personal comment - Samson 3-21-04 */
imc.h:   int icq; /* Person's ICQ UIN Number - Samson 3-21-04 */
imc.h:   char *network; /* Network name of the server, set at keepalive - Samson */
imc.h:   bool sha256;   /* Client will support SHA-256 authentication */
imc.h:   bool sha256pass;  /* Client is using SHA-256 authentication */
imc.h:   bool autoconnect; /* Do we autoconnect on bootup or not? - Samson */
imc.h:    * Conection parameters - These don't save in the config file 
instances.c:	for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next ) {
instances.c:		if(!str_cmp( name, pPrototype->name ))
instances.c:            KEY( "Flags", instance->flags, fread_number( fp ) );
instances.c:            KEY( "GateRoom", instance->gate_room, fread_number( fp ) );
instances.c:            KEY( "HighProtoVnum", instance->high_proto_vnum, fread_number( fp ) );
instances.c:            KEY( "LowProtoVnum", instance->low_proto_vnum, fread_number( fp ) );
instances.c:            KEY( "Name", instance->name, fread_string( fp ) );
instances.c:            KEY( "PhantomMappingVnum", instance->phantom_mapping_vnum, fread_number( fp ) );
instances.c:	fprintf( fp, "LowProtoVnum	%d\n",	instance->low_proto_vnum );
instances.c:	fprintf( fp, "HighProtoVnum	%d\n",	instance->high_proto_vnum );
instances.c:	fprintf( fp, "Name		%s~\n", instance->name );
instances.c:	fprintf( fp, "Flags		%d\n", instance->flags );
instances.c:	fprintf( fp, "PhantomMappingVnum %d\n", instance->phantom_mapping_vnum );
instances.c:	fprintf( fp, "GateRoom		%d\n", instance->gate_room );
instances.c:   for( prototype = first_instance_prototype; prototype; prototype = prototype->next )
instances.c:	   send_to_pager( "------------+-----------+----------------+-----------------+---------------------\r\n", ch );
instances.c:	   for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next )
instances.c:	      pager_printf( ch, "%-11s | %-9d | %-14d | %-15d | %-20d \r\n",
instances.c:	                    pPrototype->name,pPrototype->gate_room,pPrototype->low_proto_vnum,pPrototype->high_proto_vnum,
instances.c:			    pPrototype->phantom_mapping_vnum);
instances.c:	for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next ) {
instances.c:		if(!str_cmp( arg2, pPrototype->name ))
instances.c:			sprintf( buf, "The name %s is already in use!\r\n", pPrototype->name );
instances.c:	pPrototype->name = STRALLOC( arg2 );
instances.c:	pPrototype->low_proto_vnum = 0;
instances.c:	pPrototype->high_proto_vnum = 0;
instances.c:	pPrototype->flags = 0;
instances.c:	pPrototype->phantom_mapping_vnum = 0;
instances.c:	pPrototype->gate_room = 0;
instances.c:	pPrototype->first_instance = NULL;
instances.c:	pPrototype->last_instance = NULL;
instances.c:	pPrototype->prev = NULL;
instances.c:	pPrototype->next = NULL;
instances.c:			pPrototype->low_proto_vnum = vnum;
instances.c:			pPrototype->high_proto_vnum = vnum;
instances.c:			pPrototype->gate_room = vnum;
instances.c:			pPrototype->gate_room = vnum;
instances.c~:	for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next ) {
instances.c~:		if(!str_cmp( name, pPrototype->name ))
instances.c~:            KEY( "Flags", instance->flags, fread_number( fp ) );
instances.c~:            KEY( "GateRoom", instance->gate_room, fread_number( fp ) );
instances.c~:            KEY( "HighProtoVnum", instance->high_proto_vnum, fread_number( fp ) );
instances.c~:            KEY( "LowProtoVnum", instance->low_proto_vnum, fread_number( fp ) );
instances.c~:            KEY( "Name", instance->name, fread_string( fp ) );
instances.c~:            KEY( "PhantomMappingVnum", instance->phantom_mapping_vnum, fread_number( fp ) );
instances.c~:	fprintf( fp, "LowProtoVnum	%d\n",	instance->low_proto_vnum );
instances.c~:	fprintf( fp, "HighProtoVnum	%d\n",	instance->high_proto_vnum );
instances.c~:	fprintf( fp, "Name		%s~\n", instance->name );
instances.c~:	fprintf( fp, "Flags		%d\n", instance->flags );
instances.c~:	fprintf( fp, "PhantomMappingVnum %d\n", instance->phantom_mapping_vnum );
instances.c~:	fprintf( fp, "GateRoom		%d\n", instance->gate_room );
instances.c~:   for( prototype = first_instance_prototype; prototype; prototype = prototype->next )
instances.c~:	   send_to_pager( "------------+-----------+----------------+-----------------+---------------------\r\n", ch );
instances.c~:	   for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next )
instances.c~:	      pager_printf( ch, "%-11s | %-9d | %-14d | %-15d | %-20d \r\n",
instances.c~:	                    pPrototype->name,pPrototype->gate_room,pPrototype->low_proto_vnum,pPrototype->high_proto_vnum,
instances.c~:			    pPrototype->phantom_mapping_vnum);
instances.c~:	for( pPrototype = first_instance_prototype; pPrototype; pPrototype = pPrototype->next ) {
instances.c~:		if(!str_cmp( arg2, pPrototype->name ))
instances.c~:			sprintf( buf, "The name %s is already in use!\r\n", pPrototype->name );
instances.c~:	pPrototype->name = STRALLOC( arg2 );
instances.c~:	pPrototype->low_proto_vnum = 0;
instances.c~:	pPrototype->high_proto_vnum = 0;
instances.c~:	pPrototype->flags = 0;
instances.c~:	pPrototype->phantom_mapping_vnum = 0;
instances.c~:	pPrototype->gate_room = 0;
instances.c~:	pPrototype->first_instance = NULL;
instances.c~:	pPrototype->last_instance = NULL;
instances.c~:	pPrototype->prev = NULL;
instances.c~:	pPrototype->next = NULL;
instances.c~:			pPrototype->low_proto_vnum = vnum;
instances.c~:			pPrototype->high_proto_vnum = vnum;
instances.c~:			pPrototype->gate_room = vnum;
interp.c:*--------------------------------------------------------------------------*
interp.c:* -------------------------------------------------------------------------*
interp.c:*--------------------------------------------------------------------------*
interp.c:* ------------------------------------------------------------------------ *
interp.c:* ------------------------------------------------------------------------ *
interp.c: * Log-all switch.
interp.c:   if( ch->position < position )
interp.c:      switch ( ch->position )
interp.c:   if( ch->substate == SUB_REPEATCMD )
interp.c:      if( ( fun = ch->last_cmd ) == NULL )
interp.c:         ch->substate = SUB_NONE;
interp.c:            for( cmd = command_hash[x]; cmd; cmd = cmd->next )
interp.c:               if( cmd->do_fun == fun )
interp.c:         sprintf( logline, "(%s) %s", cmd->name, argument );
interp.c:       * REMOVE_BIT( ch->affected_by, AFF_HIDE ); 
interp.c:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_FREEZE ) )
interp.c:      for( cmd = command_hash[LOWER( command[0] ) % 126]; cmd; cmd = cmd->next )
interp.c:         if( !str_prefix( command, cmd->name )
interp.c:             && ( cmd->level <= trust
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:                       && is_name( cmd->name, ch->pcdata->bestowments ) && cmd->level <= ( trust + 5 ) ) ) )
interp.c:      if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AFK ) && ( str_cmp( command, "AFK" ) ) )
interp.c:         REMOVE_BIT( ch->act, PLR_AFK );
interp.c:   sprintf( lastplayercmd, "** %s: %s", ch->name, logline );
interp.c:   if( found && cmd->log == LOG_NEVER )
interp.c:   loglvl = found ? cmd->log : LOG_NORMAL;
interp.c:   if( ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_LOG ) )
interp.c:      if( ch->desc && ch->desc->original )
interp.c:         sprintf( log_buf, "Log %s (%s): %s", ch->name, ch->desc->original->name, logline );
interp.c:         sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:       * file only, and not spam the log channel to death   -Thoric
interp.c:      if( fLogAll && loglvl == LOG_NORMAL && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_LOG ) ) )
interp.c:/*	if ( ch->desc && ch->desc->original )
interp.c:		ch->desc->original->level );
interp.c:   if( ch->desc && ch->desc->snoop_by )
interp.c:      sprintf( logname, "%s", ch->name );
interp.c:      write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "% ", 2 );
interp.c:      write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "\r\n", 2 );
interp.c:      tempsub = ch->substate;
interp.c:      ch->substate = SUB_TIMER_DO_ABORT;
interp.c:      ( timer->do_fun ) ( ch, "" );
interp.c:      if( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:         ch->substate = tempsub;
interp.c:         ch->substate = tempsub;
interp.c:          * check for an auto-matic exit command 
interp.c:         if( ( pexit = find_door( ch, command, TRUE ) ) != NULL && IS_SET( pexit->exit_info, EX_xAUTO ) )
interp.c:            if( IS_SET( pexit->exit_info, EX_CLOSED )
interp.c:                && ( !IS_AFFECTED( ch, AFF_PASS_DOOR ) || IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
interp.c:               if( !IS_SET( pexit->exit_info, EX_SECRET ) )
interp.c:                  act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
interp.c:   if( !check_pos( ch, cmd->position ) )
interp.c:    * hardcoding is annoying.. -- Altrag 
interp.c:   if( !str_cmp( cmd->name, "flee" ) && IS_AFFECTED( ch, AFF_BERSERK ) )
interp.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
interp.c:   ch->last_cmd = cmd->do_fun;
interp.c:   ( *cmd->do_fun ) ( ch, argument );
interp.c:   update_userec( &time_used, &cmd->userec );
interp.c:      sprintf( log_buf, "[*****] LAG: %s: %s %s (R:%d S:%d.%06d)", ch->name,
interp.c:               cmd->name, ( cmd->log == LOG_NEVER ? "XXX" : argument ),
interp.c:               ch->in_room ? ch->in_room->vnum : 0, ( int )( time_used.tv_sec ), ( int )( time_used.tv_usec ) );
interp.c:   for( cmd = command_hash[hash]; cmd; cmd = cmd->next )
interp.c:      if( !str_prefix( command, cmd->name ) )
interp.c:      hash = ( c - 'a' ) + 1;
interp.c:   for( social = social_index[hash]; social; social = social->next )
interp.c:      if( !str_prefix( command, social->name ) )
interp.c:   if( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:      send_to_char( "You are anti-social!\r\n", ch );
interp.c:   switch ( ch->position )
interp.c:          * But two players asked for it already!  -- Furey
interp.c:         if( !str_cmp( social->name, "snore" ) )
interp.c:      act( AT_SOCIAL, social->others_no_arg, ch, NULL, victim, TO_ROOM );
interp.c:      act( AT_SOCIAL, social->char_no_arg, ch, NULL, victim, TO_CHAR );
interp.c:      act( AT_SOCIAL, social->others_auto, ch, NULL, victim, TO_ROOM );
interp.c:      act( AT_SOCIAL, social->char_auto, ch, NULL, victim, TO_CHAR );
interp.c:      act( AT_SOCIAL, social->others_found, ch, NULL, victim, TO_NOTVICT );
interp.c:      act( AT_SOCIAL, social->char_found, ch, NULL, victim, TO_CHAR );
interp.c:      act( AT_SOCIAL, social->vict_found, ch, NULL, victim, TO_VICT );
interp.c:          && !IS_AFFECTED( victim, AFF_CHARM ) && IS_AWAKE( victim ) && !IS_SET( victim->pIndexData->progtypes, ACT_PROG ) )
interp.c:               if( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || IS_EVIL( ch ) )
interp.c:               act( AT_SOCIAL, social->others_found, victim, NULL, ch, TO_NOTVICT );
interp.c:               act( AT_SOCIAL, social->char_found, victim, NULL, ch, TO_CHAR );
interp.c:               act( AT_SOCIAL, social->vict_found, victim, NULL, ch, TO_VICT );
interp.c:	  char* numPortion = (char*) malloc(pdot-argument+1);
interp.c:	  memcpy(numPortion, argument, pdot-argument);
interp.c:	  numPortion[pdot-argument] = '\0';
interp.c: * Understands quotes.  Delimiters = { ' ', '-' }
interp.c:      if( *argument == cEnd || *argument == '-' )
interp.c:   if( !sttime || ( !sttime->tv_sec && !sttime->tv_usec ) )
interp.c:   if( vtime->num_uses == 0 )
interp.c:   ntime.tv_sec = vtime->total_time.tv_sec / vtime->num_uses;
interp.c:   carry = ( vtime->total_time.tv_sec % vtime->num_uses ) * 1000000;
interp.c:   ntime.tv_usec = ( vtime->total_time.tv_usec + carry ) / vtime->num_uses;
interp.c:   ch_printf( ch, "Has been used %d times this boot.\r\n", vtime->num_uses );
interp.c:              "\r\n", vtime->min_time.tv_sec, vtime->min_time.tv_usec, ntime.tv_sec,
interp.c:              ntime.tv_usec, vtime->max_time.tv_sec, vtime->max_time.tv_usec );
interp.c:   userec->num_uses++;
interp.c:   if( !timerisset( &userec->min_time ) || timercmp( time_used, &userec->min_time, < ) )
interp.c:      userec->min_time.tv_sec = time_used->tv_sec;
interp.c:      userec->min_time.tv_usec = time_used->tv_usec;
interp.c:   if( !timerisset( &userec->max_time ) || timercmp( time_used, &userec->max_time, > ) )
interp.c:      userec->max_time.tv_sec = time_used->tv_sec;
interp.c:      userec->max_time.tv_usec = time_used->tv_usec;
interp.c:   userec->total_time.tv_sec += time_used->tv_sec;
interp.c:   userec->total_time.tv_usec += time_used->tv_usec;
interp.c:   while( userec->total_time.tv_usec >= 1000000 )
interp.c:      userec->total_time.tv_sec++;
interp.c:      userec->total_time.tv_usec -= 1000000;
magic.c:*--------------------------------------------------------------------------*
magic.c:* -------------------------------------------------------------------------*
magic.c:*--------------------------------------------------------------------------*
magic.c:* ------------------------------------------------------------------------ *
magic.c:* ------------------------------------------------------------------------ *
magic.c:      case SD_FIRE:           return( IS_SET( ch->immune, RIS_FIRE ) );
magic.c:      case SD_COLD:           return( IS_SET( ch->immune, RIS_COLD ) );
magic.c:      case SD_ELECTRICITY:    return( IS_SET( ch->immune, RIS_ELECTRICITY ) );
magic.c:      case SD_ENERGY:         return( IS_SET( ch->immune, RIS_ENERGY ) );
magic.c:      case SD_ACID:           return( IS_SET( ch->immune, RIS_ACID ) );
magic.c:      case SD_POISON:         return( IS_SET( ch->immune, RIS_POISON ) );
magic.c:      case SD_DRAIN:          return( IS_SET( ch->immune, RIS_DRAIN ) );
magic.c:      if( !skill_table[sn]->name )
magic.c:      if( ch->pcdata->learned[sn] > 0
magic.c:          && LOWER( name[0] ) == LOWER( skill_table[sn]->name[0] ) && !str_prefix( name, skill_table[sn]->name ) )
magic.c:   return -1;
magic.c:      if( !herb_table[sn] || !herb_table[sn]->name )
magic.c:         return -1;
magic.c:      if( LOWER( name[0] ) == LOWER( herb_table[sn]->name[0] ) && !str_prefix( name, herb_table[sn]->name ) )
magic.c:   return -1;
magic.c:   return -1;
magic.c:   if( ( sn = bsearch_skill( name, gsn_first_spell, gsn_first_skill - 1 ) ) == -1 )
magic.c:      if( ( sn = bsearch_skill( name, gsn_first_skill, gsn_first_weapon - 1 ) ) == -1 )
magic.c:         if( ( sn = bsearch_skill( name, gsn_first_weapon, gsn_first_tongue - 1 ) ) == -1 )
magic.c:            if( ( sn = bsearch_skill( name, gsn_first_tongue, gsn_top_sn - 1 ) ) == -1 && gsn_top_sn < top_sn )
magic.c:                  if( !skill_table[sn] || !skill_table[sn]->name )
magic.c:                     return -1;
magic.c:                  if( LOWER( name[0] ) == LOWER( skill_table[sn]->name[0] ) && !str_prefix( name, skill_table[sn]->name ) )
magic.c:               return -1;
magic.c: * Return a skilltype pointer based on sn			-Thoric
magic.c:      return IS_VALID_HERB( sn - TYPE_HERB ) ? herb_table[sn - TYPE_HERB] : NULL;
magic.c: * Perform a binary search on a section of the skill table	-Thoric
magic.c:         return -1;
magic.c:      if( LOWER( name[0] ) == LOWER( skill_table[sn]->name[0] ) && !str_prefix( name, skill_table[sn]->name ) )
magic.c:         return -1;
magic.c:      if( strcasecmp( name, skill_table[sn]->name ) < 1 )
magic.c:         top = sn - 1;
magic.c: * Perform a binary search on a section of the skill table	-Thoric
magic.c:         return -1;
magic.c:      if( !strcasecmp( name, skill_table[sn]->name ) )
magic.c:         return -1;
magic.c:      if( strcasecmp( name, skill_table[sn]->name ) < 1 )
magic.c:         top = sn - 1;
magic.c: * Only match skills player knows				-Thoric
magic.c:      if( LOWER( name[0] ) == LOWER( skill_table[sn]->name[0] )
magic.c:          && !str_prefix( name, skill_table[sn]->name ) && ch->pcdata->learned[sn] > 0 )
magic.c:         return -1;
magic.c:      if( strcmp( name, skill_table[sn]->name ) < 1 )
magic.c:         top = sn - 1;
magic.c:   return -1;
magic.c:      return bsearch_skill( name, gsn_first_spell, gsn_first_skill - 1 );
magic.c:      return ch_bsearch_skill( ch, name, gsn_first_spell, gsn_first_skill - 1 );
magic.c:      return bsearch_skill( name, gsn_first_skill, gsn_first_weapon - 1 );
magic.c:      return ch_bsearch_skill( ch, name, gsn_first_skill, gsn_first_weapon - 1 );
magic.c:      return bsearch_skill( name, gsn_first_weapon, gsn_first_tongue - 1 );
magic.c:      return ch_bsearch_skill( ch, name, gsn_first_weapon, gsn_first_tongue - 1 );
magic.c:      return bsearch_skill( name, gsn_first_tongue, gsn_top_sn - 1 );
magic.c:      return ch_bsearch_skill( ch, name, gsn_first_tongue, gsn_top_sn - 1 );
magic.c:      return -1;
magic.c:      if( slot == skill_table[sn]->slot )
magic.c:   return -1;
magic.c: * Fancy message handling for a successful casting		-Thoric
magic.c:   short chitroom = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_ACTION );
magic.c:   short chit = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HIT );
magic.c:   short chitme = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HITME );
magic.c:   if( skill->target != TAR_CHAR_OFFENSIVE )
magic.c:      if( skill->hit_char && skill->hit_char[0] != '\0' )
magic.c:         act( chit, skill->hit_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->type == SKILL_SPELL )
magic.c:   if( ch && skill->hit_room && skill->hit_room[0] != '\0' )
magic.c:      act( chitroom, skill->hit_room, ch, obj, victim, TO_NOTVICT );
magic.c:   if( ch && victim && skill->hit_vict && skill->hit_vict[0] != '\0' )
magic.c:         act( chitme, skill->hit_vict, ch, obj, victim, TO_VICT );
magic.c:         act( chitme, skill->hit_vict, ch, obj, victim, TO_CHAR );
magic.c:   else if( ch && ch == victim && skill->type == SKILL_SPELL )
magic.c:   else if( ch && ch == victim && skill->type == SKILL_SKILL )
magic.c:      if( skill->hit_char && ( skill->hit_char[0] != '\0' ) )
magic.c:         act( chit, skill->hit_char, ch, obj, victim, TO_CHAR );
magic.c: * Fancy message handling for a failed casting			-Thoric
magic.c:   short chitroom = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_ACTION );
magic.c:   short chit = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HIT );
magic.c:   short chitme = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HITME );
magic.c:   if( skill->target != TAR_CHAR_OFFENSIVE )
magic.c:      if( skill->miss_char && skill->miss_char[0] != '\0' )
magic.c:         act( chit, skill->miss_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->type == SKILL_SPELL )
magic.c:   if( ch && skill->miss_room && skill->miss_room[0] != '\0' )
magic.c:      act( chitroom, skill->miss_room, ch, obj, victim, TO_NOTVICT );
magic.c:   if( ch && victim && skill->miss_vict && skill->miss_vict[0] != '\0' )
magic.c:         act( chitme, skill->miss_vict, ch, obj, victim, TO_VICT );
magic.c:         act( chitme, skill->miss_vict, ch, obj, victim, TO_CHAR );
magic.c:      if( skill->miss_char && skill->miss_char[0] != '\0' )
magic.c:         act( chitme, skill->miss_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->type == SKILL_SPELL )
magic.c: * Fancy message handling for being immune to something		-Thoric
magic.c:   short chitroom = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_ACTION );
magic.c:   short chit = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HIT );
magic.c:   short chitme = ( skill->type == SKILL_SPELL ? AT_MAGIC : AT_HITME );
magic.c:   if( skill->target != TAR_CHAR_OFFENSIVE )
magic.c:      if( skill->imm_char && skill->imm_char[0] != '\0' )
magic.c:         act( chit, skill->imm_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->miss_char && skill->miss_char[0] != '\0' )
magic.c:         act( chit, skill->miss_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->type == SKILL_SPELL || skill->type == SKILL_SKILL )
magic.c:   if( ch && skill->imm_room && skill->imm_room[0] != '\0' )
magic.c:      act( chitroom, skill->imm_room, ch, obj, victim, TO_NOTVICT );
magic.c:   else if( ch && skill->miss_room && skill->miss_room[0] != '\0' )
magic.c:      act( chitroom, skill->miss_room, ch, obj, victim, TO_NOTVICT );
magic.c:   if( ch && victim && skill->imm_vict && skill->imm_vict[0] != '\0' )
magic.c:         act( chitme, skill->imm_vict, ch, obj, victim, TO_VICT );
magic.c:         act( chitme, skill->imm_vict, ch, obj, victim, TO_CHAR );
magic.c:   else if( ch && victim && skill->miss_vict && skill->miss_vict[0] != '\0' )
magic.c:         act( chitme, skill->miss_vict, ch, obj, victim, TO_VICT );
magic.c:         act( chitme, skill->miss_vict, ch, obj, victim, TO_CHAR );
magic.c:      if( skill->imm_char && skill->imm_char[0] != '\0' )
magic.c:         act( chit, skill->imm_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->miss_char && skill->miss_char[0] != '\0' )
magic.c:         act( chit, skill->miss_char, ch, obj, victim, TO_CHAR );
magic.c:      else if( skill->type == SKILL_SPELL || skill->type == SKILL_SKILL )
magic.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c: * Make adjustments to saving throw based in RIS		-Thoric
magic.c:   if( IS_SET( ch->immune, ris ) )
magic.c:      modifier -= 10;
magic.c:   if( IS_SET( ch->resistant, ris ) )
magic.c:      modifier -= 2;
magic.c:   if( IS_SET( ch->susceptible, ris ) )
magic.c:/*								    -Thoric
magic.c: * Used for spell dice parsing, ie: 3d8+L-6
magic.c:   if( ( *texp == '(' ) && texp[strlen( texp ) - 1] == ')' )
magic.c:      texp[strlen( texp ) - 1] = '\0';
magic.c:            return ch->hit;
magic.c:            return ch->mana;
magic.c:            return ch->move;
magic.c:         case '-':
magic.c:            --total;
magic.c:      case '-':
magic.c:         total -= rd_parse( ch, level, sexp[1] );
magic.c:   save = 50 + ( victim->top_level - level - victim->saving_poison_death ) * 2;
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   save = 50 + ( victim->top_level - level - victim->saving_wand ) * 2;
magic.c:   save = 50 + ( victim->top_level - level - victim->saving_para_petri ) * 2;
magic.c:   save = 50 + ( victim->top_level - level - victim->saving_breath ) * 2;
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:      level -= 5;
magic.c:   save = 50 + ( victim->top_level - level - victim->saving_spell_staff ) * 2;
magic.c: * Process the spell's required components, if any		-Thoric
magic.c: * -----------------------------------------------
magic.c:   const char *comp = skill->components;
magic.c:      val = -1;
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( obj->item_type == value )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( obj->pIndexData->vnum == value )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( nifty_is_name( check, obj->name ) )
magic.c:            if( ch->gold >= value )
magic.c:                     ch->gold -= value;
magic.c:            if( ch->hit >= value )
magic.c:                     ch->hit -= value;
magic.c:            if( obj->value[val] <= 0 )
magic.c:            else if( --obj->value[val] == 0 )
magic.c:            int count = obj->count;
magic.c:            obj->count = 1;
magic.c:            obj->count = count;
magic.c:   switch ( skill->target )
magic.c:            if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == *victim )
magic.c:         if( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c: * Cast a spell.  Multi-caster and component support by Thoric
magic.c:   switch ( ch->substate )
magic.c:         if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:            if( ( sn = find_spell( ch, arg1, TRUE ) ) < 0 || ( !IS_NPC( ch ) && ch->pcdata->learned[sn] <= 0 ) )
magic.c:            if( skill->type != SKILL_SPELL )
magic.c:            if( !skill->spell_fun )
magic.c:          * Something else removed by Merc         -Thoric
magic.c:         if( ch->position < skill->minimum_position )
magic.c:            switch ( ch->position )
magic.c:         if( skill->spell_fun == spell_null )
magic.c:         if( !skill->spell_fun )
magic.c:         mana = IS_NPC( ch ) ? 0 : skill->min_mana;
magic.c:         if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:         if( skill->participants <= 1 )
magic.c:          * multi-participant spells         -Thoric 
magic.c:         add_timer( ch, TIMER_DO_FUN, UMIN( skill->beats / 10, 3 ), do_cast, 1 );
magic.c:         ch->dest_buf = str_dup( staticbuf );
magic.c:         ch->tempnum = sn;
magic.c:         DISPOSE( ch->dest_buf );
magic.c:         if( IS_VALID_SN( ( sn = ch->tempnum ) ) )
magic.c:            mana = IS_NPC( ch ) ? 0 : skill->min_mana;
magic.c:               ch->mana -= mana / 3;
magic.c:         sn = ch->tempnum;
magic.c:         if( !ch->dest_buf || !IS_VALID_SN( sn ) || skill->type != SKILL_SPELL )
magic.c:            bug( "do_cast: ch->dest_buf NULL or bad sn (%d)", sn );
magic.c:         mana = IS_NPC( ch ) ? 0 : skill->min_mana;
magic.c:         strcpy( staticbuf, ( const char* ) ch->dest_buf );
magic.c:         DISPOSE( ch->dest_buf );
magic.c:         ch->substate = SUB_NONE;
magic.c:         if( skill->participants > 1 )
magic.c:            for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:                   && t->count >= 1 && t->do_fun == do_cast
magic.c:                   && tmp->tempnum == sn && tmp->dest_buf && !str_cmp( ( const char* ) tmp->dest_buf, staticbuf ) )
magic.c:            if( cnt >= skill->participants )
magic.c:               for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:                      && t->count >= 1 && t->do_fun == do_cast
magic.c:                      && tmp->tempnum == sn && tmp->dest_buf && !str_cmp( ( const char* ) tmp->dest_buf, staticbuf ) )
magic.c:                     tmp->mana -= mana;
magic.c:                     tmp->substate = SUB_NONE;
magic.c:                     tmp->tempnum = -1;
magic.c:                     DISPOSE( tmp->dest_buf );
magic.c:                  ch->mana -= mana / 2;
magic.c:   if( str_cmp( skill->name, "ventriloquate" ) )
magic.c:      WAIT_STATE( ch, skill->beats );
magic.c:    * Getting ready to cast... check for spell components  -Thoric
magic.c:         ch->mana -= mana / 2;
magic.c:   if( !IS_NPC( ch ) && abs( ch->alignment - skill->alignment ) > 1010 )
magic.c:      if( ch->alignment > skill->alignment )
magic.c:            ch->mana -= mana / 2;
magic.c:      if( ch->alignment < skill->alignment )
magic.c:            ch->mana -= mana / 2;
magic.c:   if( !IS_NPC( ch ) && ( number_percent(  ) + skill->difficulty * 5 ) > ch->pcdata->learned[sn] )
magic.c:       * Some more interesting loss of concentration messages  -Thoric 
magic.c:            if( ch->fighting )
magic.c:            if( ch->fighting )
magic.c:         ch->mana -= mana / 2;
magic.c:      ch->mana -= mana;
magic.c:      if( ( skill->target == TAR_CHAR_DEFENSIVE
magic.c:            || skill->target == TAR_CHAR_SELF ) && victim && IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:         retcode = ( *skill->spell_fun ) ( sn, ch->skill_level[FORCE_ABILITY], ch, vo );
magic.c:         update_userec( &time_used, &skill->userec );
magic.c:      force_exp = skill->min_level * skill->min_level * 10;
magic.c:                 ( exp_level( ch->skill_level[FORCE_ABILITY] + 1 ) - exp_level( ch->skill_level[FORCE_ABILITY] ) ) / 35 );
magic.c:      if( !ch->fighting )
magic.c:    * Fixed up a weird mess here, and added double safeguards -Thoric
magic.c:   if( skill->target == TAR_CHAR_OFFENSIVE && victim && !char_died( victim ) && victim != ch )
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:            if( victim->master != ch && !victim->fighting )
magic.c:   int levdiff = ch->top_level - level;
magic.c:   if( sn == -1 )
magic.c:   if( !skill || !skill->spell_fun )
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:    * 40 scrolls in battle too often ;)     -Thoric
magic.c:   if( ( skill->target == TAR_CHAR_OFFENSIVE || number_bits( 7 ) == 1 ) /* 1/128 schance if non-offensive */
magic.c:       && skill->type != SKILL_HERB && !chance( ch, 95 + levdiff ) )
magic.c:            act( AT_MAGIC, "The $t backfires!", ch, skill->name, victim, TO_CHAR );
magic.c:               act( AT_MAGIC, "$n's $t backfires!", ch, skill->name, victim, TO_VICT );
magic.c:            act( AT_MAGIC, "$n's $t backfires!", ch, skill->name, victim, TO_NOTVICT );
magic.c:            act( AT_MAGIC, "The $t backfires!", ch, skill->name, victim, TO_CHAR );
magic.c:               act( AT_MAGIC, "$n's $t backfires!", ch, skill->name, victim, TO_VICT );
magic.c:            act( AT_MAGIC, "$n's $t backfires!", ch, skill->name, victim, TO_NOTVICT );
magic.c:   switch ( skill->target )
magic.c:            target_name = victim->name;
magic.c:            target_name = obj->name;
magic.c:         if( skill->type != SKILL_HERB && IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:         if( skill->type != SKILL_HERB && IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:   retcode = ( *skill->spell_fun ) ( sn, level, ch, vo );
magic.c:   update_userec( &time_used, &skill->userec );
magic.c:   if( skill->target == TAR_CHAR_OFFENSIVE && victim != ch && !char_died( victim ) )
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:         if( victim == vch && !victim->fighting && victim->master != ch )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   af.modifier = -4;
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:      vch_next = vch->next;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == ch->in_room )
magic.c:         if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      if( !ch_died && vch->in_room->area == ch->in_room->area && IS_OUTSIDE( vch ) && IS_AWAKE( vch ) )
magic.c:   ch->alignment = ch->alignment - 50;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 70;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 90;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:      af.modifier = number_range( 0, 2 ) - victim->sex;
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) || IS_SET( victim->immune, RIS_CHARM ) )
magic.c:       || level < victim->top_level || circle_follow( victim, ch ) || saves_spell_staff( schance, victim ) )
magic.c:   if( victim->master )
magic.c:   sprintf( buf, "%s has charmed %s.", ch->name, victim->name );
magic.c:   log_string_plus( buf, LOG_NORMAL, ch->top_level );
magic.c:    to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->top_level ) );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:      af.modifier = -1;
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:      weather_info.change -= dice( level / 3, 4 );
magic.c:   mushroom->value[0] = 5 + level;
magic.c:   mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:   if( obj->item_type != ITEM_DRINK_CON )
magic.c:   if( obj->value[2] != LIQ_WATER && obj->value[1] != 0 )
magic.c:   water = UMIN( level * ( weather_info.sky >= SKY_RAINING ? 4 : 2 ), obj->value[0] - obj->value[1] );
magic.c:      obj->value[2] = LIQ_WATER;
magic.c:      obj->value[1] += water;
magic.c:      if( !is_name( "water", obj->name ) )
magic.c:         sprintf( buf, "%s water", obj->name );
magic.c:         STRFREE( obj->name );
magic.c:         obj->name = STRALLOC( buf );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:      ch->alignment = ch->alignment + 25;
magic.c:      ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:         ch->alignment = ch->alignment + 25;
magic.c:         ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:      victim->mental_state = URANGE( -100, victim->mental_state, -10 );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   af.modifier = -1;
magic.c:   ch->alignment = ch->alignment - 50;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD )
magic.c:      if( obj->value[3] != 0 )
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   if( victim->affected_by && ch == victim )
magic.c:      while( victim->first_affect )
magic.c:         affect_remove( victim, victim->first_affect );
magic.c:      victim->affected_by = race_table[victim->race].affected;
magic.c:      if( victim->affected_by == race_table[victim->race].affected
magic.c:          || level < victim->top_level || saves_spell_staff( level, victim ) )
magic.c:      if( IS_SET( victim->affected_by, affected_by ) )
magic.c:   REMOVE_BIT( victim->affected_by, affected_by );
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:      vch_next = vch->next;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == ch->in_room )
magic.c:         if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      if( !ch_died && vch->in_room->area == ch->in_room->area )
magic.c:   if( obj->item_type != ITEM_WEAPON || IS_OBJ_STAT( obj, ITEM_MAGIC ) || obj->first_affect )
magic.c:    * Bug fix here. -- Alty 
magic.c:   paf->type = -1;
magic.c:   paf->duration = -1;
magic.c:   paf->location = APPLY_HITROLL;
magic.c:   paf->modifier = level / 15;
magic.c:   paf->bitvector = 0;
magic.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
magic.c:   paf->type = -1;
magic.c:   paf->duration = -1;
magic.c:   paf->location = APPLY_DAMROLL;
magic.c:   paf->modifier = level / 15;
magic.c:   paf->bitvector = 0;
magic.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
magic.c:      SET_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:      SET_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:      SET_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:      SET_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   ch->alignment = ch->alignment - 200;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   schance = ris_save( victim, victim->top_level, RIS_DRAIN );
magic.c:   if( victim->top_level <= 2 )
magic.c:      dam = ch->hit + 1;
magic.c:      victim->mana /= 2;
magic.c:      victim->move /= 2;
magic.c:      ch->hit += dam;
magic.c:   if( ch->hit > ch->max_hit )
magic.c:      ch->hit = ch->max_hit;
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   for( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:      if( !IS_NPC( ich ) && IS_SET( ich->act, PLR_WIZINVIS ) )
magic.c:      REMOVE_BIT( ich->affected_by, AFF_HIDE );
magic.c:      if( ich->race != RACE_DEFEL )
magic.c:         REMOVE_BIT( ich->affected_by, AFF_INVISIBLE );
magic.c:      if( ich->race != RACE_NOGHRI )
magic.c:         REMOVE_BIT( ich->affected_by, AFF_SNEAK );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   dam = UMAX( 20, victim->hit - dice( 1, 4 ) );
magic.c:                 obj->name,
magic.c:                 extra_bit_name( obj->extra_flags ), magic_bit_name( obj->magic_flags ), obj->weight, obj->cost );
magic.c:      switch ( obj->item_type )
magic.c:            ch_printf( ch, "Level %d spells of:", obj->value[0] );
magic.c:            if( obj->value[1] >= 0 && ( sktmp = get_skilltype( obj->value[1] ) ) != NULL )
magic.c:               send_to_char( sktmp->name, ch );
magic.c:            if( obj->value[2] >= 0 && ( sktmp = get_skilltype( obj->value[2] ) ) != NULL )
magic.c:               send_to_char( sktmp->name, ch );
magic.c:            if( obj->value[3] >= 0 && ( sktmp = get_skilltype( obj->value[3] ) ) != NULL )
magic.c:               send_to_char( sktmp->name, ch );
magic.c:            ch_printf( ch, "Has %d(%d) charges of level %d", obj->value[1], obj->value[2], obj->value[0] );
magic.c:            if( obj->value[3] >= 0 && ( sktmp = get_skilltype( obj->value[3] ) ) != NULL )
magic.c:               send_to_char( sktmp->name, ch );
magic.c:                       obj->value[1], obj->value[2], ( obj->value[1] + obj->value[2] ) / 2 );
magic.c:            if( obj->value[3] == WEAPON_BLASTER )
magic.c:               if( obj->blaster_setting == BLASTER_FULL )
magic.c:               else if( obj->blaster_setting == BLASTER_HIGH )
magic.c:               else if( obj->blaster_setting == BLASTER_NORMAL )
magic.c:               else if( obj->blaster_setting == BLASTER_HALF )
magic.c:               else if( obj->blaster_setting == BLASTER_LOW )
magic.c:               else if( obj->blaster_setting == BLASTER_STUN )
magic.c:               ch_printf( ch, "It has %d out of %d charges.\r\n", obj->value[4], obj->value[5] );
magic.c:            else if( obj->value[3] == WEAPON_LIGHTSABER ||
magic.c:                     obj->value[3] == WEAPON_VIBRO_BLADE || obj->value[3] == WEAPON_FORCE_PIKE )
magic.c:               ch_printf( ch, "It has %d out of %d units of charge remaining.\r\n", obj->value[4], obj->value[5] );
magic.c:            else if( obj->value[3] == WEAPON_BOWCASTER )
magic.c:               ch_printf( ch, "It has %d out of %d energy bolts remaining.\r\n", obj->value[4], obj->value[5] );
magic.c:            ch_printf( ch, "It has %d charges.\r\n", obj->value[0] );
magic.c:            ch_printf( ch, "It has %d energy bolts.\r\n", obj->value[0] );
magic.c:            ch_printf( ch, "It has %d units of charge.\r\n", obj->value[0] );
magic.c:            ch_printf( ch, "Current armor class is %d. ( based on current condition )\r\n", obj->value[0] );
magic.c:            ch_printf( ch, "Maximum armor class is %d. ( based on top condition )\r\n", obj->value[1] );
magic.c:                       apply_ac( obj, obj->wear_loc ) );
magic.c:      for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
magic.c:      for( paf = obj->first_affect; paf; paf = paf->next )
magic.c:      if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:                    victim->name,
magic.c:                    victim->top_level - ( victim->top_level % 5 ), victim->top_level - ( victim->top_level % 5 ) + 5 );
magic.c:         ch_printf( ch, "%s appears to be level %d.\r\n", victim->name, victim->top_level );
magic.c:      ch_printf( ch, "%s looks like %s.\r\n", victim->name, aoran( get_race( victim ) ) );
magic.c:      if( ( chance( ch, 50 ) && ch->top_level >= victim->top_level + 10 ) || IS_IMMORTAL( ch ) )
magic.c:         ch_printf( ch, "%s appears to be affected by: ", victim->name );
magic.c:         if( !victim->first_affect )
magic.c:         for( paf = victim->first_affect; paf; paf = paf->next )
magic.c:            if( victim->first_affect != victim->last_affect )
magic.c:               if( paf != victim->last_affect && ( sktmp = get_skilltype( paf->type ) ) != NULL )
magic.c:                  ch_printf( ch, "%s, ", sktmp->name );
magic.c:               if( paf == victim->last_affect && ( sktmp = get_skilltype( paf->type ) ) != NULL )
magic.c:                  ch_printf( ch, "and %s.\r\n", sktmp->name );
magic.c:               if( ( sktmp = get_skilltype( paf->type ) ) != NULL )
magic.c:                  ch_printf( ch, "%s.\r\n", sktmp->name );
magic.c:/* Modifications on 1/2/96 to work on player/object - Scryn */
magic.c:      if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:         SET_BIT( obj->extra_flags, ITEM_INVIS );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   ap = victim->alignment;
magic.c:   else if( ap > -100 )
magic.c:   else if( ap > -350 )
magic.c:   else if( ap > -700 )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:   for( obj = first_object; obj; obj = obj->next )
magic.c:      if( !can_see_obj( ch, obj ) || !nifty_is_name( target_name, obj->name ) )
magic.c:      for( cnt = 0, in_obj = obj; in_obj->in_obj && cnt < 100; in_obj = in_obj->in_obj, ++cnt )
magic.c:                  obj->pIndexData->vnum, obj->short_descr, MAX_NEST );
magic.c:      if( in_obj->carried_by )
magic.c:         if( IS_IMMORTAL( in_obj->carried_by )
magic.c:             && !IS_NPC( in_obj->carried_by )
magic.c:             && ( get_trust( ch ) < in_obj->carried_by->pcdata->wizinvis )
magic.c:             && IS_SET( in_obj->carried_by->act, PLR_WIZINVIS ) )
magic.c:         sprintf( buf, "%s carried by %s.\r\n", obj_short( obj ), PERS( in_obj->carried_by, ch ) );
magic.c:         sprintf( buf, "%s in %s.\r\n", obj_short( obj ), in_obj->in_room == NULL ? "somewhere" : in_obj->in_room->name );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:    * What's this?  You can't save vs. magic missile!      -Thoric
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   af.modifier = -2;
magic.c:   victim->mental_state = URANGE( 20, victim->mental_state + ( first ? 5 : 0 ), 100 );
magic.c:   if( !ch->in_room->first_content )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:      if( can_see_obj( ch, obj ) && nifty_is_name( target_name, obj->name ) )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c:   if( !IS_NPC( victim ) && victim->fighting )
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:       || level < victim->top_level
magic.c:       || ( victim != ch && IS_SET( victim->in_room->room_flags, ROOM_SAFE ) ) || saves_spell_staff( schance, victim ) )
magic.c:      if( !victim->fighting )
magic.c:      sprintf( log_buf, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:      log_string_plus( log_buf, LOG_NORMAL, ch->top_level );
magic.c:      to_channel( log_buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->top_level ) );
magic.c:      victim->position = POS_SLEEPING;
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:      if( !is_name( speaker, vch->name ) )
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   af.modifier = -2;
magic.c: * A spell as it should be				-Thoric
magic.c:      for( obj_lose = victim->first_carrying; obj_lose; obj_lose = obj_next )
magic.c:         obj_next = obj_lose->next_content;
magic.c:         switch ( obj_lose->item_type )
magic.c:               if( obj_lose->value[0] > 0 )
magic.c:                  if( ( iWear = obj_lose->wear_loc ) != WEAR_NONE )
magic.c:                     victim->armor += apply_ac( obj_lose, iWear );   // <-- victim is LOSING the benefit of obj->value[0]
magic.c:                  obj_lose->value[0] -= 1;   //      so we need to ADD to his AC
magic.c:                  obj_lose->cost = 0;
magic.c:                     victim->armor -= apply_ac( obj_lose, iWear );   // <-- victim now regains the benefit of the adjusted
magic.c:               }  //      obj->value[0] so we need to SUBTRACT to his AC
magic.c:               empty_obj( obj_lose, NULL, victim->in_room );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:      for( obj_lose = victim->first_carrying; obj_lose; obj_lose = obj_next )
magic.c:         obj_next = obj_lose->next_content;
magic.c:         switch ( obj_lose->item_type )
magic.c:         if( obj_lose->item_type == ITEM_CONTAINER )
magic.c:            empty_obj( obj_lose, NULL, victim->in_room );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:      for( obj_lose = victim->first_carrying; obj_lose; obj_lose = obj_next )
magic.c:         obj_next = obj_lose->next_content;
magic.c:         switch ( obj_lose->item_type )
magic.c:         if( obj_lose->item_type == ITEM_CONTAINER )
magic.c:            empty_obj( obj_lose, NULL, victim->in_room );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c: *        enchant armour?  (say -1/-2/-3 ac )
magic.c:/* Working on DM's transport eq suggestion - Scryn 8/13 */
magic.c: * opens a 2-way EX_PORTAL from caster's room to room inhabited by  
magic.c:       || !victim->in_room
magic.c:       || IS_SET( victim->in_room->room_flags, ROOM_PRIVATE )
magic.c:       || IS_SET( victim->in_room->room_flags, ROOM_SOLITARY )
magic.c:       || IS_SET( victim->in_room->room_flags, ROOM_PROTOTYPE )
magic.c:       || IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || victim->top_level >= level + 15
magic.c:       || ( IS_NPC( victim ) && IS_SET( victim->act, ACT_PROTOTYPE ) )
magic.c:   location = victim->in_room;
magic.c:   original = ch->in_room;
magic.c:   if( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND )
magic.c:      if( obj->value[2] == obj->value[1] || obj->value[1] > ( obj->pIndexData->value[1] * 4 ) )
magic.c:         if( damage( ch, ch, obj->level * 2, TYPE_UNDEFINED ) == rCHAR_DIED || char_died( ch ) )
magic.c:         obj->value[1] *= 2;
magic.c:         obj->value[2] = obj->value[1];
magic.c:         obj->value[2] = obj->value[1];
magic.c:      else if( chance( ch, 50 - ( ch->skill_level[FORCE_ABILITY] ) ) )
magic.c:         --obj->value[1];
magic.c:         obj->value[2] = obj->value[1];
magic.c: * -Thoric
magic.c: * Vampire version of astral_walk				-Thoric
magic.c: * Cleric version of astral_walk				-Thoric
magic.c:      REMOVE_BIT( obj->extra_flags, ITEM_INVIS );
magic.c:         if( victim->race == RACE_DEFEL )
magic.c:         if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:            if( chance( ch, 50 ) && ch->skill_level[FORCE_ABILITY] < victim->top_level )
magic.c:            if( chance( ch, 50 ) && ch->skill_level[FORCE_ABILITY] + 15 < victim->top_level )
magic.c:         REMOVE_BIT( victim->affected_by, AFF_INVISIBLE );
magic.c:   for( corpse = ch->in_room->first_content; corpse; corpse = corpse_next )
magic.c:      corpse_next = corpse->next_content;
magic.c:      if( corpse->item_type == ITEM_CORPSE_NPC && corpse->cost != -5 )
magic.c:   if( ( pMobIndex = get_mob_index( ( short )abs( corpse->cost ) ) ) == NULL )
magic.c:      if( ch->mana - ( pMobIndex->level * 4 ) < 0 )
magic.c:         ch->mana -= ( pMobIndex->level * 4 );
magic.c:   if( IS_IMMORTAL( ch ) || ( chance( ch, 75 ) && pMobIndex->level - ch->top_level < 10 ) )
magic.c:      char_to_room( mob, ch->in_room );
magic.c:      mob->top_level = UMIN( ch->top_level / 2, pMobIndex->level );
magic.c:      mob->race = pMobIndex->race;  /* should be undead */
magic.c:       * Fix so mobs wont have 0 hps and crash mud - Scryn 2/20/96 
magic.c:      if( !pMobIndex->hitnodice )
magic.c:         mob->max_hit = pMobIndex->level * 8 + number_range( pMobIndex->level * pMobIndex->level / 4,
magic.c:                                                             pMobIndex->level * pMobIndex->level );
magic.c:         mob->max_hit = dice( pMobIndex->hitnodice, pMobIndex->hitsizedice ) + pMobIndex->hitplus;
magic.c:      mob->max_hit = UMAX( URANGE( mob->max_hit / 4,
magic.c:                                   ( mob->max_hit * corpse->value[3] ) / 100, ch->top_level * dice( 20, 10 ) ), 1 );
magic.c:      mob->hit = mob->max_hit;
magic.c:      mob->damroll = ch->top_level / 8;
magic.c:      mob->hitroll = ch->top_level / 6;
magic.c:      mob->alignment = ch->alignment;
magic.c:      act( AT_MAGIC, "$n makes $T rise from the grave!", ch, NULL, pMobIndex->short_descr, TO_ROOM );
magic.c:      act( AT_MAGIC, "You make $T rise from the grave!", ch, NULL, pMobIndex->short_descr, TO_CHAR );
magic.c:      sprintf( buf, "animated corpse %s", pMobIndex->player_name );
magic.c:      STRFREE( mob->name );
magic.c:      mob->name = STRALLOC( buf );
magic.c:      sprintf( buf, "The animated corpse of %s", pMobIndex->short_descr );
magic.c:      STRFREE( mob->short_descr );
magic.c:      mob->short_descr = STRALLOC( buf );
magic.c:      sprintf( buf, "An animated corpse of %s struggles with the horror of its undeath.\r\n", pMobIndex->short_descr );
magic.c:      STRFREE( mob->long_descr );
magic.c:      mob->long_descr = STRALLOC( buf );
magic.c:      if( corpse->first_content )
magic.c:         for( obj = corpse->first_content; obj; obj = obj_next )
magic.c:            obj_next = obj->next_content;
magic.c:            obj_to_room( obj, corpse->in_room );
magic.c:/* Works now.. -- Altrag */
magic.c:   if( ch->desc->original )
magic.c:   if( victim->desc )
magic.c:      ch_printf( ch, "%s is already possessed.\r\n", victim->short_descr );
magic.c:   if( IS_SET( victim->immune, RIS_MAGIC ) )
magic.c:   if( IS_AFFECTED( victim, AFF_POSSESS ) || level < ( victim->top_level + 30 ) || victim->desc || !chance( ch, 25 ) )
magic.c:   ch->alignment = ch->alignment - 50;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   af.duration = 20 + ( ch->skill_level[FORCE_ABILITY] - victim->top_level ) / 2;
magic.c:   sprintf( buf, "You have possessed %s!\r\n", victim->short_descr );
magic.c:   ch->desc->character = victim;
magic.c:   ch->desc->original = ch;
magic.c:   victim->desc = ch->desc;
magic.c:   ch->desc = NULL;
magic.c:   ch->switched = victim;
magic.c:/* Ignores pickproofs, but can't unlock containers. -- Altrag 17/2/96 */
magic.c:    * exits.  -Thoric
magic.c:       || !IS_SET( pexit->exit_info, EX_CLOSED )
magic.c:       || !IS_SET( pexit->exit_info, EX_LOCKED ) || IS_SET( pexit->exit_info, EX_PICKPROOF ) )
magic.c:   REMOVE_BIT( pexit->exit_info, EX_LOCKED );
magic.c:   if( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:      REMOVE_BIT( pexit->rexit->exit_info, EX_LOCKED );
magic.c:   check_room_for_traps( ch, TRAP_UNLOCK | trap_door[pexit->vdir] );
magic.c:/* Tells to sleepers in are. -- Altrag 17/2/96 */
magic.c:   if( victim->position != POS_SLEEPING )
magic.c:   if( ch->desc->original )
magic.c:   char_to_room( poly_mob, ch->in_room );
magic.c:   ch->desc->character = poly_mob;
magic.c:   ch->desc->original = ch;
magic.c:   poly_mob->desc = ch->desc;
magic.c:   ch->desc = NULL;
magic.c:   ch->switched = poly_mob;
magic.c:   SET_BIT( mob->act, ACT_POLYMORPHED );
magic.c:   if( !IS_NPC( ch ) || !IS_SET( ch->act, ACT_POLYMORPHED ) )
magic.c:   REMOVE_BIT( ch->act, ACT_POLYMORPHED );
magic.c:   char_from_room( ch->desc->original );
magic.c:   if( ch->desc->character )
magic.c:      mob = ch->desc->character;
magic.c:      char_to_room( ch->desc->original, ch->desc->character->in_room ); /*WORKS!! */
magic.c:      ch->desc->character = ch->desc->original;
magic.c:      ch->desc->original = NULL;
magic.c:      ch->desc->character->desc = ch->desc;
magic.c:      ch->desc->character->switched = NULL;
magic.c:      ch->desc = NULL;
magic.c:    if(ch->desc->original->pcdata->clan)
magic.c:      location = get_room_index(ch->desc->original->pcdata->clan->recall);
magic.c:    char_to_room(ch->desc->original, location);
magic.c:   ch->desc->character = ch->desc->original;
magic.c:   ch->desc->original = NULL;
magic.c:   ch->desc->character->desc = ch->desc;
magic.c:   ch->desc->character->switched = NULL;
magic.c:   ch->desc = NULL;
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   level = UMIN( level / 2, sizeof( dam_each ) / sizeof( dam_each[0] ) - 1 );
magic.c: * saving throw check						-Thoric
magic.c:   if( skill->saves )
magic.c:      switch ( skill->saves )
magic.c: * Generic offensive spell damage attack			-Thoric
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( skill->dice )
magic.c:      dam = UMAX( 0, dice_parse( ch, level, skill->dice ) );
magic.c:   if( retcode == rNONE && skill->first_affect && !char_died( ch ) && !char_died( victim ) )
magic.c: * Generic area attack						-Thoric
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   affects = ( skill->first_affect ? TRUE : FALSE );
magic.c:   if( skill->hit_char && skill->hit_char[0] != '\0' )
magic.c:      act( AT_MAGIC, skill->hit_char, ch, NULL, NULL, TO_CHAR );
magic.c:   if( skill->hit_room && skill->hit_room[0] != '\0' )
magic.c:      act( AT_MAGIC, skill->hit_room, ch, NULL, NULL, TO_ROOM );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( !IS_NPC( vch ) && IS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         else if( skill->dice )
magic.c:            dam = dice_parse( ch, level, skill->dice );
magic.c:   for( saf = skill->first_affect; saf; saf = saf->next )
magic.c:      if( saf->location >= REVERSE_APPLY )
magic.c:      if( ( af.bitvector = saf->bitvector ) != 0
magic.c:            ch->alignment = ch->alignment - 100;
magic.c:            ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:            victim->mental_state = URANGE( 30, victim->mental_state + 2, 100 );
magic.c:      af.duration = dice_parse( ch, level, saf->duration );
magic.c:      af.modifier = dice_parse( ch, level, saf->modifier );
magic.c:      af.location = saf->location % REVERSE_APPLY;
magic.c:               if( ch != victim && victim->hit < victim->max_hit && af.modifier > 0 )
magic.c:                  ch->alignment = ch->alignment + 20;
magic.c:                  ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:               if( af.modifier > 0 && victim->hit >= victim->max_hit )
magic.c:               victim->hit = URANGE( 0, victim->hit + af.modifier, victim->max_hit );
magic.c:               if( af.modifier > 0 && victim->mana >= victim->max_mana )
magic.c:                  ch->alignment = ch->alignment + 25;
magic.c:                  ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:               victim->mana = URANGE( 0, victim->mana + af.modifier, victim->max_mana );
magic.c:               if( af.modifier > 0 && victim->move >= victim->max_move )
magic.c:               victim->move = URANGE( 0, victim->move + af.modifier, victim->max_move );
magic.c: * Generic spell affect						-Thoric
magic.c:   if( !skill->first_affect )
magic.c:      if( ( skill->type != SKILL_HERB
magic.c:            && IS_SET( victim->immune, RIS_MAGIC ) ) || is_immune( victim, SPELL_DAMAGE( skill ) ) )
magic.c:      if( ( saf = skill->first_affect ) && !saf->next
magic.c:          && saf->location == APPLY_STRIPSN && !is_affected( victim, dice_parse( ch, level, saf->modifier ) ) )
magic.c:      if( skill->hit_char && skill->hit_char[0] != '\0' )
magic.c:         if( strstr( skill->hit_char, "$N" ) )
magic.c:            act( AT_MAGIC, skill->hit_char, ch, NULL, NULL, TO_CHAR );
magic.c:      if( skill->hit_room && skill->hit_room[0] != '\0' )
magic.c:         if( strstr( skill->hit_room, "$N" ) )
magic.c:            act( AT_MAGIC, skill->hit_room, ch, NULL, NULL, TO_ROOM );
magic.c:      if( skill->hit_vict && skill->hit_vict[0] != '\0' )
magic.c:         victim = victim->in_room->first_person;
magic.c:         victim = ch->in_room->first_person;
magic.c:   for( ; victim; victim = victim->next_in_room )
magic.c:             || IS_SET( victim->immune, RIS_MAGIC )
magic.c:            act( AT_MAGIC, skill->hit_vict, ch, NULL, victim, TO_VICT );
magic.c:               act( AT_MAGIC, skill->hit_room, ch, NULL, victim, TO_NOTVICT );
magic.c:               act( AT_MAGIC, skill->hit_room, ch, NULL, victim, TO_CHAR );
magic.c:            act( AT_MAGIC, skill->hit_room, ch, NULL, victim, TO_ROOM );
magic.c:               act( AT_MAGIC, skill->hit_vict, ch, NULL, ch, TO_CHAR );
magic.c:               act( AT_MAGIC, skill->hit_char, ch, NULL, ch, TO_CHAR );
magic.c:            act( AT_MAGIC, skill->hit_char, ch, NULL, victim, TO_CHAR );
magic.c: * Generic inventory object spell				-Thoric
magic.c:            if( obj->item_type != ITEM_DRINK_CON )
magic.c:            if( obj->value[2] != LIQ_WATER && obj->value[1] != 0 )
magic.c:            water = UMIN( ( skill->dice ? dice_parse( ch, level, skill->dice ) : level )
magic.c:                          * ( weather_info.sky >= SKY_RAINING ? 2 : 1 ), obj->value[0] - obj->value[1] );
magic.c:               obj->value[2] = LIQ_WATER;
magic.c:               obj->value[1] += water;
magic.c:               if( !is_name( "water", obj->name ) )
magic.c:                  sprintf( buf, "%s water", obj->name );
magic.c:                  STRFREE( obj->name );
magic.c:                  obj->name = STRALLOC( buf );
magic.c:            switch ( obj->item_type )
magic.c:                  obj->value[3] = 1;
magic.c:             && ( obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON ) )
magic.c:            switch ( obj->item_type )
magic.c:                  obj->value[3] = 0;
magic.c:               if( obj->cost > ch->skill_level[FORCE_ABILITY] * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->skill_level[FORCE_ABILITY] - obj->level < 20
magic.c:                   || obj->cost > ch->skill_level[FORCE_ABILITY] * get_curr_int( ch ) / 5 )
magic.c:               if( ch->skill_level[FORCE_ABILITY] - obj->level < 5
magic.c:                   || obj->cost > ch->skill_level[FORCE_ABILITY] * 10 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->skill_level[FORCE_ABILITY] - obj->level < 0
magic.c:                   || obj->cost > ch->skill_level[FORCE_ABILITY] * 50 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               clone->timer = skill->dice ? dice_parse( ch, level, skill->dice ) : 0;
magic.c:            if( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD )
magic.c:               if( obj->value[3] != 0 )
magic.c:         if( IS_OBJ_STAT( obj, ITEM_INVIS ) || chance( ch, skill->dice ? dice_parse( ch, level, skill->dice ) : 20 ) )
magic.c:         SET_BIT( obj->extra_flags, ITEM_INVIS );
magic.c: * Generic object creating spell				-Thoric
magic.c:   int vnum = skill->value;
magic.c:   obj->timer = skill->dice ? dice_parse( ch, level, skill->dice ) : 0;
magic.c:      obj_to_room( obj, ch->in_room );
magic.c: * Generic mob creating spell					-Thoric
magic.c:   int vnum = skill->value;
magic.c:   mob->top_level = UMIN( lvl, skill->dice ? dice_parse( ch, level, skill->dice ) : mob->top_level );
magic.c:   mob->armor = interpolate( mob->top_level, 100, -100 );
magic.c:   mob->max_hit = mob->top_level * 8 + number_range( mob->top_level * mob->top_level / 4, mob->top_level * mob->top_level );
magic.c:   mob->hit = mob->max_hit;
magic.c:   mob->gold = 0;
magic.c:   char_to_room( mob, ch->in_room );
magic.c: * Generic handler for new "SMAUG" spells			-Thoric
magic.c:   switch ( skill->target )
magic.c:                  victim->mental_state = URANGE( -100, victim->mental_state, -10 );
magic.c:   dam = level * number_range( 1, 6 ) - 31;
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:/* Non-offensive spell! */
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   dam = 2 * level * number_range( 1, 6 ) - 31;
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   l = UMAX( 1, level - 90 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c: * Black-magicish guys
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   ch->alignment = ch->alignment - 100;
magic.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
magic.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) || ( obj->item_type == ITEM_CORPSE_NPC ) || ( obj->item_type == ITEM_CORPSE_PC ) )
magic.c:   val = obj->cost / 2;
magic.c:   ch->gold += val;
magic.c:   if( cur_obj == obj->serial )
Makefile:#CYGWIN = -DCYGWIN
Makefile:NEED_DL = -ldl
Makefile:EXPORT_SYMBOLS = -export-dynamic
Makefile:NEED_MATH = -lm
Makefile:#IMC2 - Comment out to disable IMC2 support
Makefile:C_FLAGS = -g2 $(W_FLAGS) $(PROF) $(EXPORT_SYMBOLS)
Makefile:L_FLAGS = $(PROF) $(NEED_MATH) -lz $(NEED_DL)
Makefile:D_FLAGS = -g2 -O $(PROF) $(SOLARIS_LINK)
Makefile:W_FLAGS = -Wall -Werror -Wshadow -Wformat-security -Winline -Wpointer-arith -Wcast-align -Wredundant-decls -Wwrite-strings
Makefile:   C_FLAGS := $(C_FLAGS) -DIMC -DIMCSMAUG
Makefile:	$(MAKE) -s swreality
Makefile:	$(MAKE) -s dns
Makefile:-include dependencies.d
Makefile:	rm -f swreality.exe
Makefile:	dlltool --export-all --output-def swreality.def $(O_FILES)
Makefile:	dlltool --dllname swreality.exe --output-exp swreality.exp --def swreality.def
Makefile:	$(CC) -o swreality.exe $(O_FILES) swreality.exp $(L_FLAGS)
Makefile:	@echo -e "Generating dependency file ...";
Makefile:	@$(CC) -MM $(C_FLAGS) $(C_FILES) > dependencies.d
Makefile:	@perl -pi -e 's.^([a-z]).o/$$1.g' dependencies.d
Makefile:	@echo -e "Done compiling mud.";
Makefile:	@rm -f o/*.o swreality.exe dependencies.d resolver.exe resolver.o *~
Makefile:	rm -f swreality
Makefile:	$(CC) -export-dynamic -o swreality $(O_FILES) $(L_FLAGS)
Makefile:	@echo -e "Generating dependency file ...";
Makefile:	@$(CC) -MM $(C_FLAGS) $(C_FILES) > dependencies.d
Makefile:	@perl -pi -e 's.^([a-z]).o/$$1.g' dependencies.d
Makefile:	@echo -e "Done compiling mud.";
Makefile:	@rm -f o/*.o swreality dependencies.d resolver resolver.o *~
Makefile:	rm -f resolver
Makefile:	$(CC) $(D_FLAGS) -o resolver resolver.o
Makefile:	@echo -e "Done compiling DNS resolver.";
Makefile:	$(CC) -c $(C_FLAGS) $<
Makefile:	indent -ts3 -nut -nsaf -nsai -nsaw -npcs -npsl -ncs -nbc -bls -prs -bap -cbi0 -cli3 -bli0 -l125 -lp -i3 -cdb -c1 -cd1 -sc -pmt $(C_FILES)
Makefile:	indent -ts3 -nut -nsaf -nsai -nsaw -npcs -npsl -ncs -nbc -bls -prs -bap -cbi0 -cli3 -bli0 -l125 -lp -i3 -cdb -c1 -cd1 -sc -pmt $(H_FILES)
Makefile:	$(CC) -c $(C_FLAGS) $< -o $@
Makefile~:#CYGWIN = -DCYGWIN
Makefile~:NEED_DL = -ldl
Makefile~:EXPORT_SYMBOLS = -export-dynamic
Makefile~:NEED_MATH = -lm
Makefile~:#IMC2 - Comment out to disable IMC2 support
Makefile~:C_FLAGS = -g2 $(W_FLAGS) $(PROF) $(EXPORT_SYMBOLS)
Makefile~:L_FLAGS = $(PROF) $(NEED_MATH) -lz $(NEED_DL)
Makefile~:D_FLAGS = -g2 -O $(PROF) $(SOLARIS_LINK)
Makefile~:W_FLAGS = -Wall -Werror -Wshadow -Wformat-security -Winline -Wpointer-arith -Wcast-align -Wredundant-decls -Wwrite-strings
Makefile~:   C_FLAGS := $(C_FLAGS) -DIMC -DIMCSMAUG
Makefile~:	$(MAKE) -s swreality
Makefile~:	$(MAKE) -s dns
Makefile~:-include dependencies.d
Makefile~:	rm -f swreality.exe
Makefile~:	dlltool --export-all --output-def swreality.def $(O_FILES)
Makefile~:	dlltool --dllname swreality.exe --output-exp swreality.exp --def swreality.def
Makefile~:	$(CC) -o swreality.exe $(O_FILES) swreality.exp $(L_FLAGS)
Makefile~:	@echo -e "Generating dependency file ...";
Makefile~:	@$(CC) -MM $(C_FLAGS) $(C_FILES) > dependencies.d
Makefile~:	@perl -pi -e 's.^([a-z]).o/$$1.g' dependencies.d
Makefile~:	@echo -e "Done compiling mud.";
Makefile~:	@rm -f o/*.o swreality.exe dependencies.d resolver.exe resolver.o *~
Makefile~:	rm -f swreality
Makefile~:	$(CC) -export-dynamic -o swreality $(O_FILES) $(L_FLAGS)
Makefile~:	@echo -e "Generating dependency file ...";
Makefile~:	@$(CC) -MM $(C_FLAGS) $(C_FILES) > dependencies.d
Makefile~:	@perl -pi -e 's.^([a-z]).o/$$1.g' dependencies.d
Makefile~:	@echo -e "Done compiling mud.";
Makefile~:	@rm -f o/*.o swreality dependencies.d resolver resolver.o *~
Makefile~:	rm -f resolver
Makefile~:	$(CC) $(D_FLAGS) -o resolver resolver.o
Makefile~:	@echo -e "Done compiling DNS resolver.";
Makefile~:	$(CC) -c $(C_FLAGS) $<
Makefile~:	indent -ts3 -nut -nsaf -nsai -nsaw -npcs -npsl -ncs -nbc -bls -prs -bap -cbi0 -cli3 -bli0 -l125 -lp -i3 -cdb -c1 -cd1 -sc -pmt $(C_FILES)
Makefile~:	indent -ts3 -nut -nsaf -nsai -nsaw -npcs -npsl -ncs -nbc -bls -prs -bap -cbi0 -cli3 -bli0 -l125 -lp -i3 -cdb -c1 -cd1 -sc -pmt $(H_FILES)
Makefile~:	$(CC) -c $(C_FLAGS) $< -o $@
makeobjs.c:*--------------------------------------------------------------------------*
makeobjs.c:* -------------------------------------------------------------------------*
makeobjs.c:*--------------------------------------------------------------------------*
makeobjs.c:* ------------------------------------------------------------------------ *
makeobjs.c:* ------------------------------------------------------------------------ *
makeobjs.c:   fire->timer = number_fuzzy( timer );
makeobjs.c:   trap->timer = 0;
makeobjs.c:   trap->value[0] = v0;
makeobjs.c:   trap->value[1] = v1;
makeobjs.c:   trap->value[2] = v2;
makeobjs.c:   trap->value[3] = v3;
makeobjs.c: * Turn an object into scraps.		-Thoric
makeobjs.c:   scraps->timer = number_range( 5, 15 );
makeobjs.c:   if( obj->pIndexData->vnum == OBJ_VNUM_SCRAPS )
makeobjs.c:      STRFREE( scraps->short_descr );
makeobjs.c:      scraps->short_descr = STRALLOC( "some debris" );
makeobjs.c:      STRFREE( scraps->description );
makeobjs.c:      scraps->description = STRALLOC( "Bits of debris lie on the ground here." );
makeobjs.c:      sprintf( buf, scraps->short_descr, obj->short_descr );
makeobjs.c:      STRFREE( scraps->short_descr );
makeobjs.c:      scraps->short_descr = STRALLOC( buf );
makeobjs.c:      sprintf( buf, scraps->description, obj->short_descr );
makeobjs.c:      STRFREE( scraps->description );
makeobjs.c:      scraps->description = STRALLOC( buf );
makeobjs.c:   if( obj->carried_by )
makeobjs.c:      act( AT_OBJECT, "$p falls to the ground in scraps!", obj->carried_by, obj, NULL, TO_CHAR );
makeobjs.c:      if( obj == get_eq_char( obj->carried_by, WEAR_WIELD )
makeobjs.c:          && ( tmpobj = get_eq_char( obj->carried_by, WEAR_DUAL_WIELD ) ) != NULL )
makeobjs.c:         tmpobj->wear_loc = WEAR_WIELD;
makeobjs.c:      obj_to_room( scraps, obj->carried_by->in_room );
makeobjs.c:   else if( obj->in_room )
makeobjs.c:      if( ( ch = obj->in_room->first_person ) != NULL )
makeobjs.c:      obj_to_room( scraps, obj->in_room );
makeobjs.c:   if( ( obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_CORPSE_PC ) && obj->first_content )
makeobjs.c:      if( ch && ch->in_room )
makeobjs.c:      if( obj->carried_by )
makeobjs.c:         empty_obj( obj, NULL, obj->carried_by->in_room );
makeobjs.c:      else if( obj->in_room )
makeobjs.c:         empty_obj( obj, NULL, obj->in_room );
makeobjs.c:      else if( obj->in_obj )
makeobjs.c:         empty_obj( obj, obj->in_obj, NULL );
makeobjs.c:      name = ch->short_descr;
makeobjs.c:      if( IS_SET( ch->act, ACT_DROID ) )
makeobjs.c:      corpse->timer = 6;
makeobjs.c:      if( ch->gold > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:         obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:         ch->gold = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:      corpse->cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      corpse->value[2] = corpse->timer;
makeobjs.c:      name = ch->name;
makeobjs.c:      corpse->timer = 40;
makeobjs.c:      corpse->value[2] = ( int )( corpse->timer / 8 );
makeobjs.c:      corpse->value[3] = 0;
makeobjs.c:      if( ch->gold > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:         obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:         ch->gold = 0;
makeobjs.c:    * Added corpse name - make locate easier , other skills 
makeobjs.c:   STRFREE( corpse->name );
makeobjs.c:   corpse->name = STRALLOC( buf );
makeobjs.c:   sprintf( buf, corpse->short_descr, name );
makeobjs.c:   STRFREE( corpse->short_descr );
makeobjs.c:   corpse->short_descr = STRALLOC( buf );
makeobjs.c:   sprintf( buf, corpse->description, name );
makeobjs.c:   STRFREE( corpse->description );
makeobjs.c:   corpse->description = STRALLOC( buf );
makeobjs.c:   for( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:      obj_next = obj->next_content;
makeobjs.c:   return obj_to_room( corpse, ch->in_room );
makeobjs.c:   obj->timer = number_range( 2, 4 );
makeobjs.c:   obj->value[1] = number_range( 3, UMIN( 5, ch->top_level ) );
makeobjs.c:   obj_to_room( obj, ch->in_room );
makeobjs.c:   obj->timer = number_range( 1, 2 );
makeobjs.c:   obj_to_room( obj, ch->in_room );
makeobjs.c:      sprintf( buf, obj->short_descr, amount );
makeobjs.c:      STRFREE( obj->short_descr );
makeobjs.c:      obj->short_descr = STRALLOC( buf );
makeobjs.c:      obj->value[0] = amount;
mccp.c: * -----------------------------------------------------------|   (0...0)   *
mccp.c: * -----------------------------------------------------------|    {o o}    *
mccp.c: * ------------------------------------------------------------------------ *
mccp.c: * ------------------------------------------------------------------------ *
mccp.c: * mccp.c - support functions for mccp (the Mud Client Compression Protocol)
mccp.c:   if( !d->mccp->out_compress )
mccp.c:   len = d->mccp->out_compress->next_out - d->mccp->out_compress_buf;
mccp.c:         nBlock = UMIN( len - iStart, 4096 );
mccp.c:         if( ( nWrite = write( d->descriptor, d->mccp->out_compress_buf + iStart, nBlock ) ) < 0 )
mccp.c:            memmove( d->mccp->out_compress_buf, d->mccp->out_compress_buf + iStart, len - iStart );
mccp.c:         d->mccp->out_compress->next_out = d->mccp->out_compress_buf + len - iStart;
mccp.c:   if( d->mccp->out_compress )
mccp.c:   CREATE( d->mccp->out_compress_buf, unsigned char, COMPRESS_BUF_SIZE );
mccp.c:   s->next_in = NULL;
mccp.c:   s->avail_in = 0;
mccp.c:   s->next_out = d->mccp->out_compress_buf;
mccp.c:   s->avail_out = COMPRESS_BUF_SIZE;
mccp.c:   s->zalloc = Z_NULL;
mccp.c:   s->zfree = Z_NULL;
mccp.c:   s->opaque = NULL;
mccp.c:      DISPOSE( d->mccp->out_compress_buf );
mccp.c:   d->can_compress = TRUE;
mccp.c:   d->mccp->out_compress = s;
mccp.c:   if( !d->mccp->out_compress )
mccp.c:   d->mccp->out_compress->avail_in = 0;
mccp.c:   d->mccp->out_compress->next_in = dummy;
mccp.c:   if( deflate( d->mccp->out_compress, Z_FINISH ) != Z_STREAM_END )
mccp.c:   deflateEnd( d->mccp->out_compress );
mccp.c:   DISPOSE( d->mccp->out_compress_buf );
mccp.c:   DISPOSE( d->mccp->out_compress );
mccp.c:   if( !ch->desc )
mccp.c:   if( !ch->desc->mccp->out_compress )
mccp.c:      if( !compressStart( ch->desc ) )
mccp.c:      compressEnd( ch->desc );
mccp.c:      ch->desc->can_compress = FALSE;
mccp.h: * -----------------------------------------------------------|   (0...0)   *
mccp.h: * -----------------------------------------------------------|    {o o}    *
mccp.h: * ------------------------------------------------------------------------ *
mccp.h: * ------------------------------------------------------------------------ *
misc.c:*--------------------------------------------------------------------------*
misc.c:* -------------------------------------------------------------------------*
misc.c:*--------------------------------------------------------------------------*
misc.c:* ------------------------------------------------------------------------ *
misc.c:* ------------------------------------------------------------------------ *
misc.c:   if( !ch->in_room )
misc.c:   if( IS_NPC( ch ) || !ch->pcdata )
misc.c:   if( ch->plr_home != NULL )
misc.c:   room = ch->in_room;
misc.c:   for( pArea = first_bsort; pArea; pArea = pArea->next_sort )
misc.c:      if( room->area == pArea )
misc.c:   if( !IS_SET( room->room_flags, ROOM_EMPTY_HOME ) )
misc.c:   if( ch->gold < 100000 )
misc.c:   STRFREE( room->name );
misc.c:   room->name = STRALLOC( argument );
misc.c:   ch->gold -= 100000;
misc.c:   REMOVE_BIT( room->room_flags, ROOM_EMPTY_HOME );
misc.c:   SET_BIT( room->room_flags, ROOM_PLR_HOME );
misc.c:   fold_area( room->area, room->area->filename, FALSE );
misc.c:   ch->plr_home = room;
misc.c:   if( ch->in_room->vnum != 10001 )
misc.c:   if( ch->gold < ch->top_level * 200 )
misc.c:      ch_printf( ch, "You don't have enough credits... You need %d.\r\n", ch->top_level * 200 );
misc.c:      ch->gold -= ch->top_level * 200;
misc.c:      ch_printf( ch, "You pay %d credits for cloning.\r\n", ch->top_level * 200 );
misc.c:   flags = ch->act;
misc.c:   REMOVE_BIT( ch->act, PLR_KILLER );
misc.c:   credits = ch->gold;
misc.c:   ch->gold = 0;
misc.c:   played = ch->played;
misc.c:   ch->played = ch->played / 2;
misc.c:   bank = ch->pcdata->bank;
misc.c:   ch->pcdata->bank = 0;
misc.c:   home = ch->plr_home;
misc.c:   ch->plr_home = NULL;
misc.c:   if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
misc.c:      strcpy( clanname, ch->pcdata->clan_name );
misc.c:      STRFREE( ch->pcdata->clan_name );
misc.c:      ch->pcdata->clan_name = STRALLOC( "" );
misc.c:      strcpy( bestowments, ch->pcdata->bestowments );
misc.c:      DISPOSE( ch->pcdata->bestowments );
misc.c:      ch->pcdata->bestowments = str_dup( "" );
misc.c:      STRFREE( ch->pcdata->clan_name );
misc.c:      ch->pcdata->clan_name = STRALLOC( clanname );
misc.c:      DISPOSE( ch->pcdata->bestowments );
misc.c:      ch->pcdata->bestowments = str_dup( clanname );
misc.c:   ch->plr_home = home;
misc.c:   ch->played = played;
misc.c:   ch->gold = credits;
misc.c:   ch->pcdata->bank = bank;
misc.c:   ch->act = flags;
misc.c:   ch->hit--;
misc.c:   if( IS_NPC( ch ) || !ch->pcdata )
misc.c:   if( ch->pcdata->learned[gsn_grenades] <= 0 )
misc.c:   if( !obj || obj->item_type != ITEM_GRENADE )
misc.c:   obj->timer = 1;
misc.c:   STRFREE( obj->armed_by );
misc.c:   obj->armed_by = STRALLOC( ch->name );
misc.c:   ch_printf( ch, "You arm %s.\r\n", obj->short_descr );
misc.c:   if( !wield || wield->item_type != ITEM_WEAPON )
misc.c:   if( wield->value[3] == WEAPON_BLASTER )
misc.c:      if( obj && obj->item_type != ITEM_AMMO )
misc.c:         if( obj->value[0] > wield->value[5] )
misc.c:         charge = obj->value[0];
misc.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:            if( obj->item_type == ITEM_AMMO )
misc.c:               if( obj->value[0] > wield->value[5] )
misc.c:               charge = obj->value[0];
misc.c:   else if( wield->value[3] == WEAPON_BOWCASTER )
misc.c:      if( obj && obj->item_type != ITEM_BOLT )
misc.c:         if( obj->value[0] > wield->value[5] )
misc.c:         charge = obj->value[0];
misc.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:            if( obj->item_type == ITEM_BOLT )
misc.c:               if( obj->value[0] > wield->value[5] )
misc.c:               charge = obj->value[0];
misc.c:      if( obj && obj->item_type != ITEM_BATTERY )
misc.c:         charge = obj->value[0];
misc.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
misc.c:            if( obj->item_type == ITEM_BATTERY )
misc.c:               charge = obj->value[0];
misc.c:      if( wield->value[3] == WEAPON_LIGHTSABER )
misc.c:      else if( wield->value[3] == WEAPON_VIBRO_BLADE )
misc.c:         ch_printf( ch, "You replace your power cell.\r\nYour vibro-blade is charged to %d/%d units.\r\n", charge, charge );
misc.c:      else if( wield->value[3] == WEAPON_FORCE_PIKE )
misc.c:         ch_printf( ch, "You replace your power cell.\r\nYour force-pike is charged to %d/%d units.\r\n", charge, charge );
misc.c:   wield->value[4] = charge;
misc.c:   if( wield && !( wield->item_type == ITEM_WEAPON && wield->value[3] == WEAPON_BLASTER ) )
misc.c:   if( wield2 && !( wield2->item_type == ITEM_WEAPON && wield2->value[3] == WEAPON_BLASTER ) )
misc.c:         wield->blaster_setting = BLASTER_FULL;
misc.c:         wield2->blaster_setting = BLASTER_FULL;
misc.c:         wield->blaster_setting = BLASTER_HIGH;
misc.c:         wield2->blaster_setting = BLASTER_HIGH;
misc.c:         wield->blaster_setting = BLASTER_NORMAL;
misc.c:         wield2->blaster_setting = BLASTER_NORMAL;
misc.c:         wield->blaster_setting = BLASTER_HALF;
misc.c:         wield2->blaster_setting = BLASTER_HALF;
misc.c:         wield->blaster_setting = BLASTER_LOW;
misc.c:         wield2->blaster_setting = BLASTER_LOW;
misc.c:         wield->blaster_setting = BLASTER_STUN;
misc.c:         wield2->blaster_setting = BLASTER_STUN;
misc.c:   if( ( device = get_eq_char( ch, WEAR_HOLD ) ) == NULL || !nifty_is_name( argd, device->name ) )
misc.c:   if( device->item_type == ITEM_SPICE )
misc.c:   if( device->item_type != ITEM_DEVICE )
misc.c:   if( device->value[2] <= 0 )
misc.c:      if( ch->fighting )
misc.c:   if( device->value[2] > 0 )
misc.c:      device->value[2]--;
misc.c:      retcode = obj_cast_spell( device->value[3], device->value[0], ch, victim, obj );
misc.c:   if( obj->item_type == ITEM_DEVICE )
misc.c:   if( obj->item_type != ITEM_SPICE )
misc.c:   if( obj->in_obj )
misc.c:      act( AT_PLAIN, "You take $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:      act( AT_PLAIN, "$n takes $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 48 ) )
misc.c:      drug = obj->value[0];
misc.c:      ch->pcdata->drug_level[drug] = UMIN( ch->pcdata->drug_level[drug] + obj->value[1], 255 );
misc.c:      if( ch->pcdata->drug_level[drug] >= 255 || ch->pcdata->drug_level[drug] > ( ch->pcdata->addiction[drug] + 100 ) )
misc.c:         ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:         af.modifier = -5;
misc.c:         af.duration = ch->pcdata->drug_level[drug];
misc.c:         ch->hit = 1;
misc.c:               af.modifier = -10;
misc.c:               af.duration = URANGE( 1, ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug], obj->value[1] );
misc.c:               af.duration = URANGE( 1, ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug], obj->value[1] );
misc.c:            af.type = -1;
misc.c:            af.duration = URANGE( 1, 2 * ( ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ), 2 * obj->value[1] );
misc.c:            af.type = -1;
misc.c:            af.duration = URANGE( 1, 2 * ( ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ), 2 * obj->value[1] );
misc.c:            af.type = -1;
misc.c:            af.duration = URANGE( 1, 2 * ( ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ), 2 * obj->value[1] );
misc.c:            af.duration = URANGE( 1, 2 * ( ch->pcdata->drug_level[drug] - ch->pcdata->addiction[drug] ), 2 * obj->value[1] );
misc.c:   if( cur_obj == obj->serial )
misc.c:      ch->max_mana++;
misc.c:      ch->max_mana++;
misc.c:      if( ch->max_hit > 100 )
misc.c:         ch->max_hit--;
misc.c:      ch->hit--;
misc.c: * Many enhancements added by Thoric (ie: filling non-drink containers)
misc.c:      dest_item = obj->item_type;
misc.c:   src_item1 = src_item2 = src_item3 = src_item4 = -1;
misc.c:      if( IS_SET( obj->value[1], CONT_CLOSED ) )
misc.c:         act( AT_PLAIN, "The $d is closed.", ch, NULL, obj->name, TO_CHAR );
misc.c:      if( get_obj_weight( obj ) / obj->count >= obj->value[0] )
misc.c:      diff = obj->value[0] - obj->value[1];
misc.c:      if( diff < 1 || obj->value[1] >= obj->value[0] )
misc.c:   if( dest_item == ITEM_PIPE && IS_SET( obj->value[3], PIPE_FULLOFASH ) )
misc.c:          * right.  Check out Lord Fitzgibbon if you're curious.  -Narn 
misc.c:         if( source->item_type != src_item1 && source->item_type != src_item2
misc.c:             && source->item_type != src_item3 && source->item_type != src_item4 )
misc.c:      for( source = ch->in_room->first_content; source; source = src_next )
misc.c:         src_next = source->next_content;
misc.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
misc.c:                || ( get_obj_weight( source ) + get_obj_weight( obj ) / obj->count ) > obj->value[0] )
misc.c:            if( all && arg2[3] == '.' && !nifty_is_name( &arg2[4], source->name ) )
misc.c:            if( source->item_type == ITEM_MONEY )
misc.c:               ch->gold += source->value[0];
misc.c:            if( source->item_type == src_item1
misc.c:                || source->item_type == src_item2 || source->item_type == src_item3 || source->item_type == src_item4 )
misc.c:      switch ( source->item_type )
misc.c:            if( !source->in_room /* disallow inventory items */
misc.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
misc.c:                || ( get_obj_weight( source ) + get_obj_weight( obj ) / obj->count ) > obj->value[0] )
misc.c:            pd = source->short_descr;
misc.c:            if( str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
misc.c:               for( gch = first_char; gch; gch = gch->next )
misc.c:                  if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
misc.c:            if( source->item_type == ITEM_CONTAINER   /* don't remove */
misc.c:                && IS_SET( source->value[1], CONT_CLOSED ) )
misc.c:               act( AT_PLAIN, "The $d is closed.", ch, NULL, source->name, TO_CHAR );
misc.c:            if( ( otmp = source->first_content ) == NULL )
misc.c:               otmp_next = otmp->next_content;
misc.c:                   || ch->carry_number + otmp->count > can_carry_n( ch )
misc.c:                   || ch->carry_weight + get_obj_weight( otmp ) > can_carry_w( ch )
misc.c:                   || ( get_obj_weight( source ) + get_obj_weight( obj ) / obj->count ) > obj->value[0] )
misc.c:   if( source->value[1] < 1 )
misc.c:   if( source->count > 1 && source->item_type != ITEM_FOUNTAIN )
misc.c:   switch ( source->item_type )
misc.c:         bug( "do_fill: got bad item type: %d", source->item_type );
misc.c:         if( obj->value[1] != 0 && obj->value[2] != 0 )
misc.c:         obj->value[2] = 0;
misc.c:         obj->value[1] = obj->value[0];
misc.c:         if( obj->value[1] != 0 && obj->value[2] != 13 )
misc.c:         obj->value[2] = 13;
misc.c:         if( source->value[1] < diff )
misc.c:            diff = source->value[1];
misc.c:         obj->value[1] += diff;
misc.c:         if( ( source->value[1] -= diff ) < 1 )
misc.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
misc.c:         obj->value[2] = source->value[2];
misc.c:         if( source->value[1] < diff )
misc.c:            diff = source->value[1];
misc.c:         obj->value[1] += diff;
misc.c:         if( ( source->value[1] -= diff ) < 1 )
misc.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
misc.c:         obj->value[2] = source->value[2];
misc.c:         if( source->value[1] < diff )
misc.c:            diff = source->value[1];
misc.c:         obj->value[1] += diff;
misc.c:         source->value[1] -= diff;
misc.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
misc.c:         obj->value[2] = source->value[2];
misc.c:         if( source->value[1] < diff )
misc.c:            diff = source->value[1];
misc.c:         obj->value[1] += diff;
misc.c:         source->value[1] -= diff;
misc.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
misc.c:         if( ( obj->item_type == ITEM_FOUNTAIN ) || ( obj->item_type == ITEM_BLOOD ) )
misc.c:   if( obj->count > 1 && obj->item_type != ITEM_FOUNTAIN )
misc.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 40 )
misc.c:   switch ( obj->item_type )
misc.c:         if( obj->carried_by == ch )
misc.c:         if( obj->carried_by == ch )
misc.c:            do_quaff( ch, obj->name );
misc.c:            ch->pcdata->condition[COND_THIRST] = 40;
misc.c:         if( obj->value[1] <= 0 )
misc.c:         if( ( liquid = obj->value[2] ) >= LIQ_MAX )
misc.c:            liquid = obj->value[2] = 0;
misc.c:         amount = 1; /* UMIN(amount, obj->value[1]); */
misc.c:            if( ch->pcdata->condition[COND_DRUNK] > 24 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 18 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 12 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 8 )
misc.c:            else if( ch->pcdata->condition[COND_DRUNK] > 5 )
misc.c:            if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:            if( ch->pcdata->condition[COND_THIRST] > 40 )
misc.c:            else if( ch->pcdata->condition[COND_THIRST] > 36 )
misc.c:            else if( ch->pcdata->condition[COND_THIRST] > 30 )
misc.c:         if( obj->value[3] )
misc.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:            af.duration = 3 * obj->value[3];
misc.c:         obj->value[1] -= amount;
misc.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:      if( obj->item_type != ITEM_FOOD && obj->item_type != ITEM_PILL )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( obj->in_obj )
misc.c:      act( AT_PLAIN, "You take $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:      act( AT_PLAIN, "$n takes $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:      if( !obj->action_desc || obj->action_desc[0] == '\0' )
misc.c:   switch ( obj->item_type )
misc.c:         if( obj->timer > 0 && obj->value[1] > 0 )
misc.c:            foodcond = ( obj->timer * 10 ) / obj->value[1];
misc.c:            condition = ch->pcdata->condition[COND_FULL];
misc.c:            gain_condition( ch, COND_FULL, ( obj->value[0] * foodcond ) / 10 );
misc.c:            if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:            else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:         if( obj->value[3] != 0 || ( foodcond < 4 && number_range( 0, foodcond + 1 ) == 0 ) )
misc.c:            if( obj->value[3] != 0 )
misc.c:               ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:               ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:            af.duration = 2 * obj->value[0] * ( obj->value[3] > 0 ? obj->value[3] : 1 );
misc.c:         if( !IS_NPC( ch ) && obj->value[4] )
misc.c:            condition = ch->pcdata->condition[COND_FULL];
misc.c:            gain_condition( ch, COND_FULL, obj->value[4] );
misc.c:            if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:            else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:         retcode = obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
misc.c:            retcode = obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
misc.c:            retcode = obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
misc.c:   if( obj->serial == cur_obj )
misc.c:   if( obj->item_type != ITEM_POTION )
misc.c:      if( obj->item_type == ITEM_DRINK_CON )
misc.c:         do_drink( ch, obj->name );
misc.c:    * Fullness checking               -Thoric
misc.c:   if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_FULL] >= 48 || ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:   if( obj->in_obj )
misc.c:      act( AT_PLAIN, "You take $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:      act( AT_PLAIN, "$n takes $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:    * If fighting, chance of dropping potion         -Thoric
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 48 ) )
misc.c:      retcode = obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
misc.c:         retcode = obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
misc.c:         retcode = obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
misc.c:   if( cur_obj == obj->serial )
misc.c:   if( scroll->item_type != ITEM_SCROLL )
misc.c:   if( IS_NPC( ch ) && ( scroll->pIndexData->vnum == OBJ_VNUM_SCROLL_SCRIBING ) )
misc.c:   if( ( scroll->pIndexData->vnum == OBJ_VNUM_SCROLL_SCRIBING ) && ( ch->top_level + 10 < scroll->value[0] ) )
misc.c:   retcode = obj_cast_spell( scroll->value[1], scroll->value[0], ch, victim, obj );
misc.c:      retcode = obj_cast_spell( scroll->value[2], scroll->value[0], ch, victim, obj );
misc.c:      retcode = obj_cast_spell( scroll->value[3], scroll->value[0], ch, victim, obj );
misc.c:   if( scroll->serial == cur_obj )
misc.c: * Function to handle the state changing of a triggerobject (lever)  -Thoric
misc.c:   if( IS_SET( obj->value[0], TRIG_UP ) )
misc.c:   switch ( obj->item_type )
misc.c:   if( ( pull ) && IS_SET( obj->pIndexData->progtypes, PULL_PROG ) )
misc.c:      if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         REMOVE_BIT( obj->value[0], TRIG_UP );
misc.c:   if( ( !pull ) && IS_SET( obj->pIndexData->progtypes, PUSH_PROG ) )
misc.c:      if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         SET_BIT( obj->value[0], TRIG_UP );
misc.c:   if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         REMOVE_BIT( obj->value[0], TRIG_UP );
misc.c:         SET_BIT( obj->value[0], TRIG_UP );
misc.c:   if( IS_SET( obj->value[0], TRIG_TELEPORT )
misc.c:       || IS_SET( obj->value[0], TRIG_TELEPORTALL ) || IS_SET( obj->value[0], TRIG_TELEPORTPLUS ) )
misc.c:      if( ( room = get_room_index( obj->value[1] ) ) == NULL )
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_SHOWROOMDESC ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_TELEPORTALL ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_TELEPORTPLUS ) )
misc.c:      teleport( ch, obj->value[1], flags );
misc.c:   if( IS_SET( obj->value[0], TRIG_RAND4 ) || IS_SET( obj->value[0], TRIG_RAND6 ) )
misc.c:      if( ( room = get_room_index( obj->value[1] ) ) == NULL )
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_RAND4 ) )
misc.c:      for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:   if( IS_SET( obj->value[0], TRIG_DEATH ) )
misc.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRIGGER in room %d!", ch->name, ch->in_room->vnum );
misc.c:   if( IS_SET( obj->value[0], TRIG_OLOAD ) )
misc.c:      if( !( pObjIndex = get_obj_index( obj->value[1] ) ) )
misc.c:         bug( "%s: obj points to invalid object vnum %d", __FUNCTION__, obj->value[1] );
misc.c:      if( obj->value[2] > 0 && !( room = get_room_index( obj->value[2] ) ) )
misc.c:         bug( "%s: obj points to invalid room vnum %d", __FUNCTION__, obj->value[2] );
misc.c:      if( !( tobj = create_object( pObjIndex, URANGE( 0, obj->value[3], MAX_LEVEL ) ) ) )
misc.c:         bug( "%s: obj couldnt create_obj vnum %d at level %d", __FUNCTION__, obj->value[1], obj->value[3] );
misc.c:            obj_to_room( tobj, ch->in_room );
misc.c:   if( IS_SET( obj->value[0], TRIG_MLOAD ) )
misc.c:      if( !( pMobIndex = get_mob_index( obj->value[1] ) ) )
misc.c:         bug( "%s: obj points to invalid mob vnum %d", __FUNCTION__, obj->value[1] );
misc.c:      room = ch->in_room;
misc.c:      if( obj->value[2] > 0 && !( room = get_room_index( obj->value[2] ) ) )
misc.c:         bug( "%s: obj points to invalid room vnum %d", __FUNCTION__, obj->value[2] );
misc.c:         bug( "%s: obj couldnt create_mobile vnum %d", __FUNCTION__, obj->value[1] );
misc.c:   if( IS_SET( obj->value[0], TRIG_CAST ) )
misc.c:      if( obj->value[1] <= 0 || !IS_VALID_SN( obj->value[1] ) )
misc.c:         bug( "%s: obj points to invalid sn [%d]", __FUNCTION__, obj->value[1] );
misc.c:      obj_cast_spell( obj->value[1], URANGE( 1, ( obj->value[2] > 0 ) ? obj->value[2] : ch->top_level, MAX_LEVEL ), ch, ch, NULL );
misc.c:   if( IS_SET( obj->value[0], TRIG_CONTAINER ) )
misc.c:      room = get_room_index( obj->value[1] );
misc.c:         room = obj->in_room;
misc.c:         bug( "%s: obj points to invalid room %d", __FUNCTION__, obj->value[1] );
misc.c:      for( container = ch->in_room->first_content; container; container = container->next_content )
misc.c:         if( container->pIndexData->vnum == obj->value[2] )
misc.c:         bug( "%s: obj points to a container [%d] thats not where it should be?", __FUNCTION__, obj->value[2] );
misc.c:      if( container->item_type != ITEM_CONTAINER )
misc.c:         bug( "%s: obj points to object [%d], but it isn't a container.", __FUNCTION__, obj->value[2] );
misc.c:      if( IS_SET( obj->value[3], CONT_CLOSEABLE ) )
misc.c:         TOGGLE_BIT( container->value[1], CONT_CLOSEABLE );
misc.c:      if( IS_SET( obj->value[3], CONT_PICKPROOF ) )
misc.c:         TOGGLE_BIT( container->value[1], CONT_PICKPROOF );
misc.c:      if( IS_SET( obj->value[3], CONT_CLOSED ) )
misc.c:         TOGGLE_BIT( container->value[1], CONT_CLOSED );
misc.c:      if( IS_SET( obj->value[3], CONT_LOCKED ) )
misc.c:         TOGGLE_BIT( container->value[1], CONT_LOCKED );
misc.c:   if( IS_SET( obj->value[0], TRIG_DOOR ) )
misc.c:      room = get_room_index( obj->value[1] );
misc.c:         room = obj->in_room;
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_D_NORTH ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_SOUTH ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_EAST ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_WEST ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_UP ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_DOWN ) )
misc.c:         if( !IS_SET( obj->value[0], TRIG_PASSAGE ) )
misc.c:            bug( "PullOrPush: obj points to non-exit %d", obj->value[1] );
misc.c:         to_room = get_room_index( obj->value[2] );
misc.c:            bug( "PullOrPush: dest points to invalid room %d", obj->value[2] );
misc.c:         pexit->keyword = STRALLOC( "" );
misc.c:         pexit->description = STRALLOC( "" );
misc.c:         pexit->key = -1;
misc.c:         pexit->exit_info = 0;
misc.c:      if( IS_SET( obj->value[0], TRIG_UNLOCK ) && IS_SET( pexit->exit_info, EX_LOCKED ) )
misc.c:         REMOVE_BIT( pexit->exit_info, EX_LOCKED );
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
misc.c:      if( IS_SET( obj->value[0], TRIG_LOCK ) && !IS_SET( pexit->exit_info, EX_LOCKED ) )
misc.c:         SET_BIT( pexit->exit_info, EX_LOCKED );
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            SET_BIT( pexit_rev->exit_info, EX_LOCKED );
misc.c:      if( IS_SET( obj->value[0], TRIG_OPEN ) && IS_SET( pexit->exit_info, EX_CLOSED ) )
misc.c:         REMOVE_BIT( pexit->exit_info, EX_CLOSED );
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:            act( AT_ACTION, "The $d opens.", rch, NULL, pexit->keyword, TO_CHAR );
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            REMOVE_BIT( pexit_rev->exit_info, EX_CLOSED );
misc.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:               act( AT_ACTION, "The $d opens.", rch, NULL, pexit_rev->keyword, TO_CHAR );
misc.c:      if( IS_SET( obj->value[0], TRIG_CLOSE ) && !IS_SET( pexit->exit_info, EX_CLOSED ) )
misc.c:         SET_BIT( pexit->exit_info, EX_CLOSED );
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:            act( AT_ACTION, "The $d closes.", rch, NULL, pexit->keyword, TO_CHAR );
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            SET_BIT( pexit_rev->exit_info, EX_CLOSED );
misc.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:               act( AT_ACTION, "The $d closes.", rch, NULL, pexit_rev->keyword, TO_CHAR );
misc.c:   if( pipe->item_type != ITEM_PIPE )
misc.c:   if( !IS_SET( pipe->value[3], PIPE_TAMPED ) )
misc.c:      SET_BIT( pipe->value[3], PIPE_TAMPED );
misc.c:   if( pipe->item_type != ITEM_PIPE )
misc.c:   if( !IS_SET( pipe->value[3], PIPE_LIT ) )
misc.c:   if( pipe->value[1] > 0 )
misc.c:      if( IS_VALID_HERB( pipe->value[2] ) && pipe->value[2] < top_herb )
misc.c:         int sn = pipe->value[2] + TYPE_HERB;
misc.c:         WAIT_STATE( ch, skill->beats );
misc.c:         if( skill->spell_fun )
misc.c:            obj_cast_spell( sn, UMIN( skill->min_level, ch->top_level ), ch, ch, NULL );
misc.c:         bug( "do_smoke: bad herb type %d", pipe->value[2] );
misc.c:      SET_BIT( pipe->value[3], PIPE_HOT );
misc.c:      if( --pipe->value[1] < 1 )
misc.c:         REMOVE_BIT( pipe->value[3], PIPE_LIT );
misc.c:         SET_BIT( pipe->value[3], PIPE_DIRTY );
misc.c:         SET_BIT( pipe->value[3], PIPE_FULLOFASH );
misc.c:   if( pipe->item_type != ITEM_PIPE )
misc.c:   if( !IS_SET( pipe->value[3], PIPE_LIT ) )
misc.c:      if( pipe->value[1] < 1 )
misc.c:      SET_BIT( pipe->value[3], PIPE_LIT );
misc.c:   if( obj->count > 1 )
misc.c:   switch ( obj->item_type )
misc.c:         REMOVE_BIT( obj->value[3], PIPE_FULLOFASH );
misc.c:         REMOVE_BIT( obj->value[3], PIPE_LIT );
misc.c:         obj->value[1] = 0;
misc.c:         if( obj->value[1] < 1 )
misc.c:         obj->value[1] = 0;
misc.c:         if( IS_SET( obj->value[1], CONT_CLOSED ) )
misc.c:            act( AT_PLAIN, "The $d is closed.", ch, NULL, obj->name, TO_CHAR );
misc.c:         if( !obj->first_content )
misc.c:            if( IS_SET( ch->in_room->room_flags, ROOM_NODROP ) || ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_LITTERBUG ) ) )
misc.c:            if( IS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) )
misc.c:            if( empty_obj( obj, NULL, ch->in_room ) )
misc.c:            if( dest->item_type != ITEM_CONTAINER )
misc.c:            if( IS_SET( dest->value[1], CONT_CLOSED ) )
misc.c:               act( AT_PLAIN, "The $d is closed.", ch, NULL, dest->name, TO_CHAR );
misc.c:               if( !dest->carried_by && IS_SET( sysdata.save_flags, SV_PUT ) )
misc.c: * Apply a salve/ointment					-Thoric
misc.c:   if( obj->item_type != ITEM_SALVE )
misc.c:   --obj->value[1];
misc.c:      if( !obj->action_desc || obj->action_desc[0] == '\0' )
misc.c:         if( obj->value[1] <= 0 )
misc.c:   WAIT_STATE( ch, obj->value[2] );
misc.c:   retcode = obj_cast_spell( obj->value[4], obj->value[0], ch, ch, NULL );
misc.c:      retcode = obj_cast_spell( obj->value[5], obj->value[0], ch, ch, NULL );
misc.c:   if( !obj_extracted( obj ) && obj->value[1] <= 0 )
misc.c:   const char *srcptr = obj->action_desc;
misc.c:               srcptr--;
misc.c:   switch ( obj->item_type )
misc.c:         act( AT_ACTION, charbuf, ch, obj, liq_table[obj->value[2]].liq_name, TO_CHAR );
misc.c:         act( AT_ACTION, roombuf, ch, obj, liq_table[obj->value[2]].liq_name, TO_ROOM );
misc.c:   if( !ch->in_room )
misc.c:   if( ch->position < POS_FIGHTING )
misc.c:   if( ch->position < POS_STANDING )
misc.c:   if( IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
misc.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SPACECRAFT ) )
misc.c:   if( ch->gold < ( ch->top_level - 9 ) )
misc.c:   vnum = ch->in_room->vnum;
misc.c:   for( vnum = ch->in_room->area->low_r_vnum; vnum <= ch->in_room->area->hi_r_vnum; vnum++ )
misc.c:         if( IS_SET( room->room_flags, ROOM_HOTEL ) && !IS_SET( room->room_flags, ROOM_PLR_HOME ) )
misc.c:   ch->gold -= UMAX( ch->top_level - 9, 0 );
misc.c:   switch ( ch->substate )
misc.c:         for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
misc.c:            if( IS_NPC( mob ) && IS_SET( mob->act, ACT_TRAIN ) )
misc.c:            if( mob->perm_str <= ch->perm_str || ch->perm_str >= 20 + race_table[ch->race].str_plus || ch->perm_str >= 25 )
misc.c:            if( mob->perm_dex <= ch->perm_dex || ch->perm_dex >= 20 + race_table[ch->race].dex_plus || ch->perm_dex >= 25 )
misc.c:            if( mob->perm_int <= ch->perm_int || ch->perm_int >= 20 + race_table[ch->race].int_plus || ch->perm_int >= 25 )
misc.c:            if( mob->perm_wis <= ch->perm_wis || ch->perm_wis >= 20 + race_table[ch->race].wis_plus || ch->perm_wis >= 25 )
misc.c:            if( mob->perm_con <= ch->perm_con || ch->perm_con >= 20 + race_table[ch->race].con_plus || ch->perm_con >= 25 )
misc.c:            if( mob->perm_cha <= ch->perm_cha || ch->perm_cha >= 20 + race_table[ch->race].cha_plus || ch->perm_cha >= 25 )
misc.c:         ch->dest_buf = str_dup( arg );
misc.c:         if( !ch->dest_buf )
misc.c:         strcpy( arg, ( const char* ) ch->dest_buf );
misc.c:         DISPOSE( ch->dest_buf );
misc.c:         DISPOSE( ch->dest_buf );
misc.c:         ch->substate = SUB_NONE;
misc.c:   ch->substate = SUB_NONE;
misc.c:      ch->perm_str++;
misc.c:      ch->perm_dex++;
misc.c:      ch->perm_int++;
misc.c:      ch->perm_wis++;
misc.c:      ch->perm_con++;
misc.c:      ch->perm_cha++;
misc.c:   if( IS_NPC( ch ) || !ch->pcdata )
misc.c:   if( strcmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
misc.c:      sprintf( logbuf, "%s attempting to commit suicide... WRONG PASSWORD!", ch->name );
misc.c:   if( IS_NPC( ch ) || !ch->pcdata )
misc.c:   if( !ch->in_room || !IS_SET( ch->in_room->room_flags, ROOM_BANK ) )
misc.c:      if( ch->gold < amount )
misc.c:      ch->gold -= amount;
misc.c:      ch->pcdata->bank += amount;
misc.c:      if( ch->pcdata->bank < amount )
misc.c:      ch->gold += amount;
misc.c:      ch->pcdata->bank -= amount;
misc.c:      ch_printf( ch, "You have %ld credits in your account.\r\n", ch->pcdata->bank );
mssp.c: * -----------------------------------------------------------|   (0...0)   *
mssp.c: * -----------------------------------------------------------|    {o o}    *
mssp.c: * ------------------------------------------------------------------------ *
mssp.c: * ------------------------------------------------------------------------ *
mssp.c:*  Co-Owner/Coder SW: TGA                                         *
mssp.c:*  www.t-n-k-games.com                                            *
mssp.c:*  Server with the MSSP-Plaintext protocol                        *
mssp.c:*  information to anyone who does an MSSP-REQUEST at the login    *
mssp.c:*  protocol, Cratylus for the MSSP-Plaintext idea, and Elanthis   *
mssp.c:   DISPOSE( mssp_info->mudname );
mssp.c:   DISPOSE( mssp_info->hostname );
mssp.c:   DISPOSE( mssp_info->contact );
mssp.c:   DISPOSE( mssp_info->icon );
mssp.c:   DISPOSE( mssp_info->language );
mssp.c:   DISPOSE( mssp_info->location );
mssp.c:   DISPOSE( mssp_info->website );
mssp.c:   DISPOSE( mssp_info->family );
mssp.c:   DISPOSE( mssp_info->genre );
mssp.c:   DISPOSE( mssp_info->gamePlay );
mssp.c:   DISPOSE( mssp_info->gameSystem );
mssp.c:   DISPOSE( mssp_info->intermud );
mssp.c:   DISPOSE( mssp_info->status );
mssp.c:   DISPOSE( mssp_info->subgenre );
mssp.c:   DISPOSE( mssp_info->equipmentSystem );
mssp.c:   DISPOSE( mssp_info->multiplaying );
mssp.c:   DISPOSE( mssp_info->playerKilling );
mssp.c:   DISPOSE( mssp_info->questSystem );
mssp.c:   DISPOSE( mssp_info->roleplaying );
mssp.c:   DISPOSE( mssp_info->trainingSystem );
mssp.c:   DISPOSE( mssp_info->worldOriginality );
mssp.c:      fprintf( fp, "Mudname           %s~\n", mssp_info->mudname );
mssp.c:      fprintf( fp, "Hostname          %s~\n", mssp_info->hostname );
mssp.c:      fprintf( fp, "Contact           %s~\n", mssp_info->contact );
mssp.c:      fprintf( fp, "Icon              %s~\n", mssp_info->icon );
mssp.c:      fprintf( fp, "Language          %s~\n", mssp_info->language );
mssp.c:      fprintf( fp, "Location          %s~\n", mssp_info->location );
mssp.c:      fprintf( fp, "Website           %s~\n", mssp_info->website );
mssp.c:      fprintf( fp, "Family            %s~\n", mssp_info->family );
mssp.c:      fprintf( fp, "Genre             %s~\n", mssp_info->genre );
mssp.c:      fprintf( fp, "GamePlay          %s~\n", mssp_info->gamePlay );
mssp.c:      fprintf( fp, "GameSystem        %s~\n", mssp_info->gameSystem );
mssp.c:      fprintf( fp, "Intermud          %s~\n", mssp_info->intermud );
mssp.c:      fprintf( fp, "Status            %s~\n", mssp_info->status );
mssp.c:      fprintf( fp, "SubGenre          %s~\n", mssp_info->subgenre );
mssp.c:      fprintf( fp, "Created           %d\n", mssp_info->created );
mssp.c:      fprintf( fp, "MinAge            %d\n", mssp_info->minAge );
mssp.c:      fprintf( fp, "Worlds            %d\n", mssp_info->worlds );
mssp.c:      fprintf( fp, "Ansi              %d\n", mssp_info->ansi );
mssp.c:      fprintf( fp, "MCCP              %d\n", mssp_info->mccp );
mssp.c:      fprintf( fp, "MCP               %d\n", mssp_info->mcp );
mssp.c:      fprintf( fp, "MSP               %d\n", mssp_info->msp );
mssp.c:      fprintf( fp, "SSL               %d\n", mssp_info->ssl );
mssp.c:      fprintf( fp, "MXP               %d\n", mssp_info->mxp );
mssp.c:      fprintf( fp, "Pueblo            %d\n", mssp_info->pueblo );
mssp.c:      fprintf( fp, "Vt100             %d\n", mssp_info->vt100 );
mssp.c:      fprintf( fp, "Xterm256          %d\n", mssp_info->xterm256 );
mssp.c:      fprintf( fp, "Pay2Play          %d\n", mssp_info->pay2play );
mssp.c:      fprintf( fp, "Pay4Perks         %d\n", mssp_info->pay4perks );
mssp.c:      fprintf( fp, "HiringBuilders    %d\n", mssp_info->hiringBuilders );
mssp.c:      fprintf( fp, "HiringCoders      %d\n", mssp_info->hiringCoders );
mssp.c:      fprintf( fp, "AdultMaterial     %d\n", mssp_info->adultMaterial );
mssp.c:      fprintf( fp, "Multiclassing     %d\n", mssp_info->multiclassing );
mssp.c:      fprintf( fp, "NewbieFriendly    %d\n", mssp_info->newbieFriendly );
mssp.c:      fprintf( fp, "PlayerCities      %d\n", mssp_info->playerCities );
mssp.c:      fprintf( fp, "PlayerClans       %d\n", mssp_info->playerClans );
mssp.c:      fprintf( fp, "PlayerCrafting    %d\n", mssp_info->playerCrafting );
mssp.c:      fprintf( fp, "PlayerGuilds      %d\n", mssp_info->playerGuilds );
mssp.c:      fprintf( fp, "EquipmentSystem   %s~\n", mssp_info->equipmentSystem );
mssp.c:      fprintf( fp, "Multiplaying      %s~\n", mssp_info->multiplaying );
mssp.c:      fprintf( fp, "PlayerKilling     %s~\n", mssp_info->playerKilling );
mssp.c:      fprintf( fp, "QuestSystem       %s~\n", mssp_info->questSystem );
mssp.c:      fprintf( fp, "RolePlaying       %s~\n", mssp_info->roleplaying );
mssp.c:      fprintf( fp, "TrainingSystem    %s~\n", mssp_info->trainingSystem );
mssp.c:      fprintf( fp, "WorldOriginality  %s~\n", mssp_info->worldOriginality );
mssp.c:            KEY( "AdultMaterial", mssp_info->adultMaterial, fread_number( fp ) );
mssp.c:            KEY( "Ansi", mssp_info->ansi, fread_number( fp ) );
mssp.c:            KEY( "Contact", mssp_info->contact, fread_string_nohash( fp ) );
mssp.c:            KEY( "Created", mssp_info->created, fread_number( fp ) );
mssp.c:            KEY( "EquipmentSystem", mssp_info->equipmentSystem, fread_string_nohash( fp ) );
mssp.c:            KEY( "Family", mssp_info->family, fread_string_nohash( fp ) );
mssp.c:            KEY( "Genre", mssp_info->genre, fread_string_nohash( fp ) );
mssp.c:            KEY( "GamePlay", mssp_info->gamePlay, fread_string_nohash( fp ) );
mssp.c:            KEY( "GameSystem", mssp_info->gameSystem, fread_string_nohash( fp ) );
mssp.c:            KEY( "Hostname", mssp_info->hostname, fread_string_nohash( fp ) );
mssp.c:            KEY( "HiringBuilders", mssp_info->hiringBuilders, fread_number( fp ) );
mssp.c:            KEY( "HiringCoders", mssp_info->hiringCoders, fread_number( fp ) );
mssp.c:            KEY( "Icon", mssp_info->icon, fread_string_nohash( fp ) );
mssp.c:            KEY( "Intermud", mssp_info->intermud, fread_string_nohash( fp ) );
mssp.c:            KEY( "Language", mssp_info->language, fread_string_nohash( fp ) );
mssp.c:            KEY( "Location", mssp_info->location, fread_string_nohash( fp ) );
mssp.c:            KEY( "MCCP", mssp_info->mccp, fread_number( fp ) );
mssp.c:            KEY( "MCP", mssp_info->mcp, fread_number( fp ) );
mssp.c:            KEY( "MinAge", mssp_info->minAge, fread_number( fp ) );
mssp.c:            KEY( "MSP", mssp_info->msp, fread_number( fp ) );
mssp.c:            KEY( "Mudname", mssp_info->mudname, fread_string_nohash( fp ) );
mssp.c:            KEY( "Multiclassing", mssp_info->multiclassing, fread_number( fp ) );
mssp.c:            KEY( "Multiplaying", mssp_info->multiplaying, fread_string_nohash( fp ) );
mssp.c:            KEY( "MXP", mssp_info->mxp, fread_number( fp ) );
mssp.c:            KEY( "NewbieFriendly", mssp_info->newbieFriendly, fread_number( fp ) );
mssp.c:            KEY( "Pay2Play", mssp_info->pay2play, fread_number( fp ) );
mssp.c:            KEY( "Pay4Perks", mssp_info->pay4perks, fread_number( fp ) );
mssp.c:            KEY( "PlayerCities", mssp_info->playerCities, fread_number( fp ) );
mssp.c:            KEY( "PlayerClans", mssp_info->playerClans, fread_number( fp ) );
mssp.c:            KEY( "PlayerCrafting", mssp_info->playerCrafting, fread_number( fp ) );
mssp.c:            KEY( "PlayerGuilds", mssp_info->playerGuilds, fread_number( fp ) );
mssp.c:            KEY( "PlayerKilling", mssp_info->playerKilling, fread_string_nohash( fp ) );
mssp.c:            KEY( "Pueblo", mssp_info->pueblo, fread_number( fp ) );
mssp.c:            KEY( "QuestSystem", mssp_info->questSystem, fread_string_nohash( fp ) );
mssp.c:            KEY( "RolePlaying", mssp_info->roleplaying, fread_string_nohash( fp ) );
mssp.c:            KEY( "SSL", mssp_info->ssl, fread_number( fp ) );
mssp.c:            KEY( "Status", mssp_info->status, fread_string_nohash( fp ) );
mssp.c:            KEY( "SubGenre", mssp_info->subgenre, fread_string_nohash( fp ) );
mssp.c:            KEY( "TrainingSystem", mssp_info->trainingSystem, fread_string_nohash( fp ) );
mssp.c:            KEY( "Vt100", mssp_info->vt100, fread_number( fp ) );
mssp.c:            KEY( "Website", mssp_info->website, fread_string_nohash( fp ) );
mssp.c:            KEY( "WorldOriginality", mssp_info->worldOriginality, fread_string_nohash( fp ) );
mssp.c:            KEY( "Worlds", mssp_info->worlds, fread_number( fp ) );
mssp.c:            KEY( "Xterm256", mssp_info->xterm256, fread_number( fp ) );
mssp.c:   ch_printf( ch, "&zMudname           &W%s\r\n", mssp_info->mudname );
mssp.c:   ch_printf( ch, "&zHostname          &W%s\r\n", mssp_info->hostname );
mssp.c:   ch_printf( ch, "&zContact           &W%s\r\n", mssp_info->contact );
mssp.c:   ch_printf( ch, "&zIcon              &W%s\r\n", mssp_info->icon );
mssp.c:   ch_printf( ch, "&zLanguage          &W%s\r\n", mssp_info->language );
mssp.c:   ch_printf( ch, "&zLocation          &W%s\r\n", mssp_info->location );
mssp.c:   ch_printf( ch, "&zWebsite           &W%s\r\n", mssp_info->website );
mssp.c:   ch_printf( ch, "&zFamily            &W%s\r\n", mssp_info->family );
mssp.c:   ch_printf( ch, "&zGenre             &W%s\r\n", mssp_info->genre );
mssp.c:   ch_printf( ch, "&zGamePlay          &W%s\r\n", mssp_info->gamePlay );
mssp.c:   ch_printf( ch, "&zGameSystem        &W%s\r\n", mssp_info->gameSystem );
mssp.c:   ch_printf( ch, "&zIntermud          &W%s\r\n", mssp_info->intermud );
mssp.c:   ch_printf( ch, "&zStatus            &W%s\r\n", mssp_info->status );
mssp.c:   ch_printf( ch, "&zSubGenre          &W%s\r\n", mssp_info->subgenre );
mssp.c:   ch_printf( ch, "&zCreated           &W%d\r\n", mssp_info->created );
mssp.c:   ch_printf( ch, "&zMinAge            &W%d\r\n", mssp_info->minAge );
mssp.c:   ch_printf( ch, "&zWorlds            &W%d\r\n", mssp_info->worlds );
mssp.c:   ch_printf( ch, "&zAnsi              &W%s\r\n", MSSP_YN( mssp_info->ansi ) );
mssp.c:   ch_printf( ch, "&zMCCP              &W%s\r\n", MSSP_YN( mssp_info->mccp ) );
mssp.c:   ch_printf( ch, "&zMCP               &W%s\r\n", MSSP_YN( mssp_info->mcp ) );
mssp.c:   ch_printf( ch, "&zMSP               &W%s\r\n", MSSP_YN( mssp_info->msp ) );
mssp.c:   ch_printf( ch, "&zSSL               &W%s\r\n", MSSP_YN( mssp_info->ssl ) );
mssp.c:   ch_printf( ch, "&zMXP               &W%s\r\n", MSSP_YN( mssp_info->mxp ) );
mssp.c:   ch_printf( ch, "&zPueblo            &W%s\r\n", MSSP_YN( mssp_info->pueblo ) );
mssp.c:   ch_printf( ch, "&zVt100             &W%s\r\n", MSSP_YN( mssp_info->vt100 ) );
mssp.c:   ch_printf( ch, "&zXterm256          &W%s\r\n", MSSP_YN( mssp_info->xterm256 ) );
mssp.c:   ch_printf( ch, "&zPay2Play          &W%s\r\n", MSSP_YN( mssp_info->pay2play ) );
mssp.c:   ch_printf( ch, "&zPay4Perks         &W%s\r\n", MSSP_YN( mssp_info->pay4perks ) );
mssp.c:   ch_printf( ch, "&zHiringBuilders    &W%s\r\n", MSSP_YN( mssp_info->hiringBuilders ) );
mssp.c:   ch_printf( ch, "&zHiringCoders      &W%s\r\n", MSSP_YN( mssp_info->hiringCoders ) );
mssp.c:   ch_printf( ch, "&zAdultMaterial     &W%s\r\n", MSSP_YN( mssp_info->adultMaterial ));
mssp.c:   ch_printf( ch, "&zMulticlassing     &W%s\r\n", MSSP_YN( mssp_info->multiclassing ));
mssp.c:   ch_printf( ch, "&zNewbieFriendly    &W%s\r\n", MSSP_YN( mssp_info->newbieFriendly ));
mssp.c:   ch_printf( ch, "&zPlayerCities      &W%s\r\n", MSSP_YN( mssp_info->playerCities ));
mssp.c:   ch_printf( ch, "&zPlayerClans       &W%s\r\n", MSSP_YN( mssp_info->playerClans ));
mssp.c:   ch_printf( ch, "&zPlayerCrafting    &W%s\r\n", MSSP_YN( mssp_info->playerCrafting ));
mssp.c:   ch_printf( ch, "&zPlayerGuilds      &W%s\r\n", MSSP_YN( mssp_info->playerGuilds ));
mssp.c:   ch_printf( ch, "&zEquipmentSystem   &W%s\r\n", mssp_info->equipmentSystem );
mssp.c:   ch_printf( ch, "&zMultiplaying      &W%s\r\n", mssp_info->multiplaying );
mssp.c:   ch_printf( ch, "&zPlayerKilling     &W%s\r\n", mssp_info->playerKilling );
mssp.c:   ch_printf( ch, "&zQuestSystem       &W%s\r\n", mssp_info->questSystem );
mssp.c:   ch_printf( ch, "&zRolePlaying       &W%s\r\n", mssp_info->roleplaying );
mssp.c:   ch_printf( ch, "&zTrainingSystem    &W%s\r\n", mssp_info->trainingSystem );
mssp.c:   ch_printf( ch, "&zWorldOriginality  &W%s\r\n", mssp_info->worldOriginality );
mssp.c:      strptr = &mssp_info->mudname;
mssp.c:      strptr = &mssp_info->hostname;
mssp.c:      strptr = &mssp_info->contact;
mssp.c:      strptr = &mssp_info->icon;
mssp.c:      strptr = &mssp_info->language;
mssp.c:      strptr = &mssp_info->location;
mssp.c:      strptr = &mssp_info->website;
mssp.c:      strptr = &mssp_info->family;
mssp.c:      strptr = &mssp_info->genre;
mssp.c:      strptr = &mssp_info->gamePlay;
mssp.c:      strptr = &mssp_info->gameSystem;
mssp.c:      strptr = &mssp_info->intermud;
mssp.c:      strptr = &mssp_info->status;
mssp.c:      strptr = &mssp_info->subgenre;
mssp.c:      ynptr = &mssp_info->ansi;
mssp.c:      ynptr = &mssp_info->mccp;
mssp.c:      ynptr = &mssp_info->mcp;
mssp.c:      ynptr = &mssp_info->msp;
mssp.c:      ynptr = &mssp_info->ssl;
mssp.c:      ynptr = &mssp_info->mxp;
mssp.c:      ynptr = &mssp_info->pueblo;
mssp.c:      ynptr = &mssp_info->vt100;
mssp.c:      ynptr = &mssp_info->xterm256;
mssp.c:      ynptr = &mssp_info->pay2play;
mssp.c:      ynptr = &mssp_info->pay4perks;
mssp.c:      ynptr = &mssp_info->hiringBuilders;
mssp.c:      ynptr = &mssp_info->hiringCoders;
mssp.c:      ynptr = &mssp_info->adultMaterial;
mssp.c:      ynptr = &mssp_info->multiclassing;
mssp.c:      ynptr = &mssp_info->newbieFriendly;
mssp.c:      ynptr = &mssp_info->playerCities;
mssp.c:      ynptr = &mssp_info->playerClans;
mssp.c:      ynptr = &mssp_info->playerCrafting;
mssp.c:      ynptr = &mssp_info->playerGuilds;
mssp.c:      mssp_info->worlds = value;
mssp.c:      mssp_info->created = value;
mssp.c:         DISPOSE( mssp_info->multiplaying );
mssp.c:         mssp_info->multiplaying = str_dup( argument );
mssp.c:         DISPOSE( mssp_info->playerKilling );
mssp.c:         mssp_info->playerKilling = str_dup( argument );
mssp.c:         DISPOSE( mssp_info->trainingSystem );
mssp.c:         mssp_info->trainingSystem = str_dup( argument );
mssp.c:         DISPOSE( mssp_info->equipmentSystem );
mssp.c:         mssp_info->equipmentSystem = str_dup( argument );
mssp.c:      DISPOSE( mssp_info->questSystem );
mssp.c:      mssp_info->questSystem = str_dup( argument );
mssp.c:      DISPOSE( mssp_info->roleplaying );
mssp.c:      mssp_info->roleplaying = str_dup( argument );
mssp.c:      DISPOSE( mssp_info->worldOriginality );
mssp.c:      mssp_info->worldOriginality = str_dup( argument );
mssp.c:      mssp_info->minAge = value;
mssp.c:   for( d = first_descriptor; d; d = d->next )
mssp.c:      if( d->connected >= CON_PLAYING )
mssp.c:   write_to_descriptor( d, "\r\nMSSP-REPLY-START\r\n", 0 );
mssp.c:   mssp_reply( d, "HOSTNAME", "%s", mssp_info->hostname );
mssp.c:   mssp_reply( d, "CONTACT", "%s", mssp_info->contact );
mssp.c:   mssp_reply( d, "CREATED", "%d", mssp_info->created );
mssp.c:   mssp_reply( d, "ICON", "%s", mssp_info->icon );
mssp.c:   mssp_reply( d, "LANGUAGE", "%s", mssp_info->language );
mssp.c:   mssp_reply( d, "LOCATION", "%s", mssp_info->location );
mssp.c:   mssp_reply( d, "MINIMUM AGE", "%d", mssp_info->minAge );
mssp.c:   mssp_reply( d, "NAME", "%s", mssp_info->mudname );
mssp.c:   mssp_reply( d, "WEBSITE", "%s", mssp_info->website );
mssp.c:   mssp_reply( d, "FAMILY", "%s", mssp_info->family );
mssp.c:   mssp_reply( d, "GENRE", "%s", mssp_info->genre );
mssp.c:   mssp_reply( d, "GAMEPLAY", "%s", mssp_info->gamePlay );
mssp.c:   mssp_reply( d, "GAMESYSTEM", "%s", mssp_info->gameSystem );
mssp.c:   mssp_reply( d, "INTERMUD", "%s", mssp_info->intermud );
mssp.c:   mssp_reply( d, "STATUS", "%s", mssp_info->status );
mssp.c:   mssp_reply( d, "SUBGENRE", "%s", mssp_info->subgenre );
mssp.c:   mssp_reply( d, "WORLDS", "%d", mssp_info->worlds );
mssp.c:   mssp_reply( d, "ANSI", "%d", mssp_info->ansi );
mssp.c:   mssp_reply( d, "MCCP", "%d", mssp_info->mccp );
mssp.c:   mssp_reply( d, "MCP", "%d", mssp_info->mcp );
mssp.c:   mssp_reply( d, "MSP", "%d", mssp_info->msp );
mssp.c:   mssp_reply( d, "SSL", "%d", mssp_info->ssl );
mssp.c:   mssp_reply( d, "MXP", "%d", mssp_info->mxp );
mssp.c:   mssp_reply( d, "PUEBLO", "%d", mssp_info->pueblo );
mssp.c:   mssp_reply( d, "VT100", "%d", mssp_info->vt100 );
mssp.c:   mssp_reply( d, "XTERM 256 COLORS", "%d", mssp_info->xterm256 );
mssp.c:   mssp_reply( d, "PAY TO PLAY", "%d", mssp_info->pay2play );
mssp.c:   mssp_reply( d, "PAY FOR PERKS", "%d", mssp_info->pay4perks );
mssp.c:   mssp_reply( d, "HIRING BUILDERS", "%d", mssp_info->hiringBuilders );
mssp.c:   mssp_reply( d, "HIRING CODERS", "%d", mssp_info->hiringCoders );
mssp.c:   mssp_reply( d, "ADULT MATERIAL", "%d", mssp_info->adultMaterial );
mssp.c:   mssp_reply( d, "MULTICLASSING", "%d", mssp_info->multiclassing );
mssp.c:   mssp_reply( d, "NEWBIE FRIENDLY", "%d", mssp_info->newbieFriendly );
mssp.c:   mssp_reply( d, "PLAYER CITIES", "%d", mssp_info->playerCities );
mssp.c:   mssp_reply( d, "PLAYER CLANSS", "%d", mssp_info->playerClans );
mssp.c:   mssp_reply( d, "PLAYER CRAFTING", "%d", mssp_info->playerCrafting );
mssp.c:   mssp_reply( d, "PLAYER GUILDS", "%d", mssp_info->playerGuilds );
mssp.c:   mssp_reply( d, "EQUIPMENT SYSTEM", "%s", mssp_info->equipmentSystem );
mssp.c:   mssp_reply( d, "MULTIPLAYING", "%s", mssp_info->multiplaying );
mssp.c:   mssp_reply( d, "PLAYERKILLING", "%s", mssp_info->playerKilling );
mssp.c:   mssp_reply( d, "QUEST SYSTEM", "%s", mssp_info->questSystem );
mssp.c:   mssp_reply( d, "ROLEPLAYING", "%s", mssp_info->roleplaying );
mssp.c:   mssp_reply( d, "TRAINING SYSTEM", "%s", mssp_info->trainingSystem );
mssp.c:   mssp_reply( d, "WORLD ORIGINALITY", "%s", mssp_info->worldOriginality );
mssp.c:   write_to_descriptor( d, "MSSP-REPLY-END\r\n", 0 );
mssp.h: * -----------------------------------------------------------|   (0...0)   *
mssp.h: * -----------------------------------------------------------|    {o o}    *
mssp.h: * ------------------------------------------------------------------------ *
mssp.h: * ------------------------------------------------------------------------ *
mssp.h:*  Co-Owner/Coder SW: TGA                                         *
mssp.h:*  www.t-n-k-games.com                                            *
mssp.h:*  Server with the MSSP-Plaintext protocol                        *
mssp.h:*  information to anyone who does an MSSP-REQUEST at the login    *
mssp.h:*  protocol, Cratylus for the MSSP-Plaintext idea, and Elanthis   *
mud_comm.c:*--------------------------------------------------------------------------*
mud_comm.c:* -------------------------------------------------------------------------*
mud_comm.c:*--------------------------------------------------------------------------*
mud_comm.c:* ------------------------------------------------------------------------ *
mud_comm.c:* ------------------------------------------------------------------------ *
mud_comm.c:*  was written by N'Atas-ha.						   *
mud_comm.c:   if( !( victim->pIndexData->progtypes ) )
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", victim->name, victim->pIndexData->vnum );
mud_comm.c:              victim->short_descr, victim->long_descr[0] != '\0' ? victim->long_descr : "(none).\r\n" );
mud_comm.c:              victim->hit, victim->max_hit, victim->mana, victim->max_mana, victim->move, victim->max_move );
mud_comm.c:              victim->top_level, victim->alignment, GET_AC( victim ), victim->gold );
mud_comm.c:   for( mprg = victim->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:      ch_printf( ch, "%s>%s %s\r\n%s\r\n", ( mprg->fileprog ? "(FILEPROG) " : "" ),
mud_comm.c:         mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
mud_comm.c:/* Opstat - Scryn 8/12*/
mud_comm.c:   if( !( obj->pIndexData->progtypes ) )
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", obj->name, obj->pIndexData->vnum );
mud_comm.c:   ch_printf( ch, "Short description: %s.\r\n", obj->short_descr );
mud_comm.c:   for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:      ch_printf( ch, ">%s %s\r\n%s\r\n", mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
mud_comm.c:/* Rpstat - Scryn 8/12 */
mud_comm.c:   if( !( ch->in_room->progtypes ) )
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:      ch_printf( ch, ">%s %s\r\n%s\r\n", mprog_type_to_name( mprg->type ), mprg->arglist, mprg->comlist );
mud_comm.c:      progbug( "Mpasound - No argument", ch );
mud_comm.c:   actflags = ch->act;
mud_comm.c:   REMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   was_in_room = ch->in_room;
mud_comm.c:   for( pexit = was_in_room->first_exit; pexit; pexit = pexit->next )
mud_comm.c:      if( pexit->to_room && pexit->to_room != was_in_room )
mud_comm.c:         ch->in_room = pexit->to_room;
mud_comm.c:   ch->act = actflags;
mud_comm.c:   ch->in_room = was_in_room;
mud_comm.c:      progbug( "MpKill - no argument", ch );
mud_comm.c:      progbug( "MpKill - Victim not in room", ch );
mud_comm.c:      progbug( "MpKill - Bad victim to attack", ch );
mud_comm.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
mud_comm.c:      progbug( "MpKill - Charmed mob attacking master", ch );
mud_comm.c:   if( ch->position == POS_FIGHTING )
mud_comm.c:      progbug( "MpKill - Already fighting", ch );
mud_comm.c:      progbug( "Mpjunk - No argument", ch );
mud_comm.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:         obj_next = obj->next_content;
mud_comm.c:         if( arg[3] == '\0' || is_name( &arg[4], obj->name ) )
mud_comm.c:            if( obj->wear_loc != WEAR_NONE )
mud_comm.c: * color indicator (e.g. _red, _whi_, _blu).  -  Gorog
mud_comm.c:      return ( cptr - color_list ) / 4;
mud_comm.c:      return ( cptr - blink_list ) / 4 + AT_BLINK;
mud_comm.c:      progbug( "Mpechoaround - No argument", ch );
mud_comm.c:      progbug( "Mpechoaround - victim does not exist", ch );
mud_comm.c:   actflags = ch->act;
mud_comm.c:   REMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:    * DONT_UPPER prevents argument[0] from being captilized. --Shaddai
mud_comm.c:   ch->act = actflags;
mud_comm.c:      progbug( "Mpechoat - No argument", ch );
mud_comm.c:      progbug( "Mpechoat - victim does not exist", ch );
mud_comm.c:   actflags = ch->act;
mud_comm.c:   REMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:    * DONT_UPPER prevents argument[0] from being captilized. --Shaddai
mud_comm.c:   ch->act = actflags;
mud_comm.c:      progbug( "Mpecho - called w/o argument", ch );
mud_comm.c:   actflags = ch->act;
mud_comm.c:   REMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:    * DONT_UPPER prevents argument[0] from being captilized. --Shaddai
mud_comm.c:   ch->act = actflags;
mud_comm.c:      progbug( "Mpmload - Bad vnum as arg", ch );
mud_comm.c:      progbug( "Mpmload - Bad mob vnum", ch );
mud_comm.c:   char_to_room( victim, ch->in_room );
mud_comm.c:      progbug( "Mpoload - Bad syntax", ch );
mud_comm.c:         progbug( "Mpoload - Bad level syntax", ch );
mud_comm.c:         progbug( "Mpoload - Bad level", ch );
mud_comm.c:         progbug( "Mpoload - Bad timer", ch );
mud_comm.c:      progbug( "Mpoload - Bad vnum arg", ch );
mud_comm.c:   obj->timer = timer;
mud_comm.c:      obj_to_room( obj, ch->in_room );
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:         vnext = victim->next_in_room;
mud_comm.c:      while( ch->in_room->first_content )
mud_comm.c:         extract_obj( ch->in_room->first_content );
mud_comm.c:	    progbug( "Mppurge - Bad argument", ch );
mud_comm.c:      progbug( "Mppurge - Trying to purge a PC", ch );
mud_comm.c:      progbug( "Mppurge - Trying to purge oneself", ch );
mud_comm.c:   if( IS_NPC( victim ) && victim->pIndexData->vnum == MOB_VNUM_SUPERMOB )
mud_comm.c:/* Allow mobiles to go wizinvis with programs -- SB */
mud_comm.c:         progbug( "Mpinvis - Non numeric argument ", ch );
mud_comm.c:         progbug( "MPinvis - Invalid level ", ch );
mud_comm.c:      ch->mobinvis = level;
mud_comm.c:   if( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->top_level;
mud_comm.c:   if( IS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c:      REMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:      SET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:      progbug( "Mpgoto - No argument", ch );
mud_comm.c:      progbug( "Mpgoto - No such location", ch );
mud_comm.c:   if( ch->fighting )
mud_comm.c:      progbug( "Mpat - Bad argument", ch );
mud_comm.c:      progbug( "Mpat - No such location", ch );
mud_comm.c:   original = ch->in_room;
mud_comm.c:   for( wch = first_char; wch; wch = wch->next )
mud_comm.c:      progbug( "Mptransfer - Bad syntax", ch );
mud_comm.c:         progbug( "Mptransfer - No such location", ch );
mud_comm.c:      location = ch->in_room;
mud_comm.c:    * Put in the variable nextinroom to make this work right. -Narn 
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:         nextinroom = victim->next_in_room;
mud_comm.c:    * This will only transfer PC's in the area not Mobs --Shaddai 
mud_comm.c:      for( d = first_descriptor; d; d = d->next )
mud_comm.c:         if( !d->character || ( d->connected != CON_PLAYING &&  d->connected != CON_EDITING )
mud_comm.c:             || ch->in_room->area != d->character->in_room->area )
mud_comm.c:         if( ch == d->character )
mud_comm.c:         transfer_char( ch, d->character, location );
mud_comm.c:      progbug( "Mptransfer - No such person", ch );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc )
mud_comm.c:      progbug( "Mpforce - Bad syntax", ch );
mud_comm.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c:         progbug( "Mpforce - No such victim", ch );
mud_comm.c:         progbug( "Mpforce - Forcing oneself", ch );
mud_comm.c:      if( !IS_NPC( victim ) && ( !victim->desc ) && IS_IMMORTAL( victim ) )
mud_comm.c:         progbug( "Mpforce - Attempting to force link dead immortal", ch );
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:   hp += victim->hit;
mud_comm.c:   victim->hit = ( hp > 32000 || hp < 0 || hp > victim->max_hit ) ? victim->max_hit : hp;
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:   gexp = URANGE( 1, gexp, ( exp_level( victim->skill_level[ability] + 1 ) - exp_level( victim->skill_level[ability] ) ) );
mud_comm.c: * opens a 1-way passage from room x to room y in direction z
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpOpenPassage - Bad syntax", ch );
mud_comm.c:      if( !IS_SET( pexit->exit_info, EX_PASSAGE ) )
mud_comm.c:      progbug( "MpOpenPassage - Exit exists", ch );
mud_comm.c:   pexit->keyword = STRALLOC( "" );
mud_comm.c:   pexit->description = STRALLOC( "" );
mud_comm.c:   pexit->key = -1;
mud_comm.c:   pexit->exit_info = EX_PASSAGE;
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:      progbug( "MpClosePassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpClosePassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpClosePassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpClosePassage - Bad syntax", ch );
mud_comm.c:      progbug( "MpClosePassage - Bad syntax", ch );
mud_comm.c:   if( !IS_SET( pexit->exit_info, EX_PASSAGE ) )
mud_comm.c:      progbug( "MpClosePassage - Exit not a passage", ch );
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:   if( !IS_NPC( ch ) || ( ch->desc && get_trust( ch ) < LEVEL_IMMORTAL ) )
mud_comm.c:   if( vict->position <= POS_SLEEPING )
mud_comm.c:      progbug( "Mpapply - bad syntax", ch );
mud_comm.c:      progbug( "Mpapply - no such player in room.", ch );
mud_comm.c:   if( !victim->desc )
mud_comm.c:   if( victim->pcdata->auth_state >= 1 )
mud_comm.c:            victim->name, victim->desc->host, race_table[victim->race].race_name );
mud_comm.c:   victim->pcdata->auth_state = 1;
mud_comm.c:      progbug( "Mpapplyb - bad syntax", ch );
mud_comm.c:      progbug( "Mpapplyb - no such player in room.", ch );
mud_comm.c:   if( !victim->desc )
mud_comm.c:   switch ( victim->pcdata->auth_state )
mud_comm.c:                  victim->name, victim->desc->host, race_table[victim->race].race_name );
mud_comm.c:         victim->pcdata->auth_state = 1;
mud_comm.c:         REMOVE_BIT( victim->pcdata->flags, PCFLAG_UNAUTHED );
mud_comm.c:         if( victim->fighting )
mud_comm.c: * Deposit some gold into the current area's economy		-Thoric
mud_comm.c:      progbug( "Mpdeposit - bad syntax", ch );
mud_comm.c:   if( gold <= ch->gold && ch->in_room )
mud_comm.c:      ch->gold -= gold;
mud_comm.c:      boost_economy( ch->in_room->area, gold );
mud_comm.c: * Withdraw some gold from the current area's economy		-Thoric
mud_comm.c:      progbug( "Mpwithdraw - bad syntax", ch );
mud_comm.c:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c:      ch->gold += gold;
mud_comm.c:      lower_economy( ch->in_room->area, gold );
mud_comm.c:   if( victim->position == POS_DEAD )
mud_comm.c:         dam -= ( int )( dam / 4 );
mud_comm.c:   victim->hit -= dam;
mud_comm.c:   if( !IS_NPC( victim ) && get_trust( victim ) >= LEVEL_IMMORTAL && victim->hit < 1 )
mud_comm.c:      victim->hit = 1;
mud_comm.c:   if( !npcvict && get_trust( victim ) >= LEVEL_IMMORTAL && get_trust( ch ) >= LEVEL_IMMORTAL && victim->hit < 1 )
mud_comm.c:      victim->hit = 1;
mud_comm.c:   switch ( victim->position )
mud_comm.c:         if( dam > victim->max_hit / 4 )
mud_comm.c:         if( victim->hit < victim->max_hit / 4 )
mud_comm.c:   if( victim->position == POS_DEAD )
mud_comm.c:                  victim->name, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_comm.c:   if( !npcvict && !victim->desc )
mud_comm.c:      if( number_range( 0, victim->wait ) == 0 )
mud_comm.c:      if( ( IS_SET( victim->act, ACT_WIMPY ) && number_bits( 1 ) == 0
mud_comm.c:            && victim->hit < victim->max_hit / 2 )
mud_comm.c:          || ( IS_AFFECTED( victim, AFF_CHARM ) && victim->master && victim->master->in_room != victim->in_room ) )
mud_comm.c:   if( !npcvict && victim->hit > 0 && victim->hit <= victim->wimpy && victim->wait == 0 )
mud_comm.c:   else if( !npcvict && IS_SET( victim->act, PLR_FLEE ) )
mud_comm.c:      vnum = -1;
mud_comm.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:      if( ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
mud_comm.c:   if( vnum != -1 )
mud_comm.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:      if( !nifty_is_name_prefix( arg, rch->name ) )
mud.h: *--------------------------------------------------------------------------*
mud.h: * -------------------------------------------------------------------------*
mud.h: *--------------------------------------------------------------------------*
mud.h: * ------------------------------------------------------------------------ *
mud.h: * ------------------------------------------------------------------------ *
mud.h:#define LEVEL_HERO		   (MAX_LEVEL - 5)
mud.h:#define LEVEL_IMMORTAL		   (MAX_LEVEL - 4)
mud.h:#define LEVEL_INFINITE		   (MAX_LEVEL - 1)
mud.h:#define LEVEL_ETERNAL		   (MAX_LEVEL - 1)
mud.h:#define LEVEL_IMPLEMENTOR	   (MAX_LEVEL - 1)
mud.h:#define LEVEL_SUB_IMPLEM	   (MAX_LEVEL - 1)
mud.h:#define LEVEL_ASCENDANT		   (MAX_LEVEL - 2)
mud.h:#define LEVEL_GREATER		   (MAX_LEVEL - 2)
mud.h:#define LEVEL_GOD		   (MAX_LEVEL - 2)
mud.h:#define LEVEL_LESSER		   (MAX_LEVEL - 3)
mud.h:#define LEVEL_TRUEIMM		   (MAX_LEVEL - 3)
mud.h:#define LEVEL_DEMI		   (MAX_LEVEL - 3)
mud.h:#define LEVEL_SAVIOR		   (MAX_LEVEL - 3)
mud.h:#define LEVEL_CREATOR		   (MAX_LEVEL - 3)
mud.h:#define LEVEL_ACOLYTE		   (MAX_LEVEL - 4)
mud.h:#define LEVEL_NEOPHYTE		   (MAX_LEVEL - 4)
mud.h:#define LEVEL_AVATAR		   (MAX_LEVEL - 5)
mud.h: * Stuff for area versions --Shaddai
mud.h:#define HAS_SPELL_INDEX     -1
mud.h:Version 2: Skipped - Probably won't ever see these, but originated from Smaug 1.8.
mud.h:* do_who output structure -- Narn
mud.h:   CON_GET_NAME = -99,
mud.h:#define ABILITY_NONE		-1
mud.h:* Languages -- Altrag
mud.h:#define LASER_DAMAGED    -1
mud.h:/* make that none - ugh - time for another field? :P */
mud.h:/* Magic flags - extra extra_flags for objects that are used in spells */
mud.h:/* Blaster settings - only saves on characters */
mud.h:#define EX_RES1                   BV09 /* are these res[1-4] important? */
mud.h:   WEAR_NONE = -1, WEAR_LIGHT = 0, WEAR_FINGER_L, WEAR_FINGER_R, WEAR_NECK_1,
mud.h:/* Bits for pc_data->flags. */
mud.h:/* Area defines - Scryn 8/11
mud.h:/* Area flags - Narn Mar/96 */
mud.h:* This is the in-memory version of #MOBILES.
mud.h:   time_t release_date; /* Auto-helling.. Altrag */
mud.h:   int magic_flags;  /*Need more bitvectors for spells - Scryn */
mud.h:   int magic_flags;  /*Need more bitvectors for spells - Scryn */
mud.h:* Area-reset definition.
mud.h:* Used to keep track of system settings and statistics		-Thoric
mud.h:* Must be non-overlapping with spell/skill types,
mud.h:#define TYPE_UNDEFINED               -1
mud.h:   const char *spell_fun_name;   /* Spell function name - Trax */
mud.h:   const char *skill_fun_name;   /* Skill function name - Trax */
mud.h:   CHAR_DATA *seller;   /* a pointer to the seller - which may NOT quit */
mud.h:   CHAR_DATA *buyer; /* a pointer to the buyer - which may NOT quit */
mud.h:   int bet; /* last bet - or 0 if noone has bet anything */
mud.h:   short pulse;   /* how many pulses (.25 sec) until another call-out ? */
mud.h:#define LOWER( c )        ( (c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : (c) )
mud.h:#define UPPER( c )        ( (c) >= 'a' && (c) <= 'z' ? (c) + 'A' - 'a' : (c) )
mud.h:   if( str_free((point)) == -1 )             \
mud.h:/* double-linked list handling macros -Thoric */
mud.h:   (last)->next = (link);                \
mud.h:   (link)->next = NULL;                     \
mud.h:   (link)->prev = NULL;                  \
mud.h:   (link)->prev = (last);                \
mud.h:   (link)->prev = (insert)->prev;               \
mud.h:   if ( !(insert)->prev )                       \
mud.h:   (insert)->prev->next = (link);            \
mud.h:   (insert)->prev = (link);                     \
mud.h:   (link)->next = (insert);                     \
mud.h:   if ( !(link)->prev )                         \
mud.h:   (first) = (link)->next;                   \
mud.h:   (first)->prev = NULL;                  \
mud.h:   (link)->prev->next = (link)->next;        \
mud.h:   if ( !(link)->next )                         \
mud.h:   (last) = (link)->prev;                    \
mud.h:   (last)->next = NULL;                   \
mud.h:   (link)->next->prev = (link)->prev;        \
mud.h:   for ( ptr = (last); ptr->prev; ptr = ptr->prev );		\
mud.h:   for ( ptr = (first); ptr->next; ptr = ptr->next );		\
mud.h:   for ( ptr = (first); ptr; ptr = ptr->next )			\
mud.h:   if ( ptr->prev != pptr )					\
mud.h:   bug( "CHECK_LINKS(%s): %p:->prev != %p.  Fixing.",	\
mud.h:   ptr->prev = pptr;					\
mud.h:   if ( ptr->prev && ptr->prev->next != ptr )		\
mud.h:   bug( "CHECK_LINKS(%s): %p:->prev->next != %p.  Fixing.",\
mud.h:   ptr->prev->next = ptr;					\
mud.h:   for ( ptr = (last); ptr; ptr = ptr->prev )			\
mud.h:   if ( ptr->next != pptr )					\
mud.h:   bug( "CHECK_LINKS (%s): %p:->next != %p.  Fixing.",	\
mud.h:   ptr->next = pptr;					\
mud.h:   if ( ptr->next && ptr->next->prev != ptr )		\
mud.h:   bug( "CHECK_LINKS(%s): %p:->next->prev != %p.  Fixing.",\
mud.h:   ptr->next->prev = ptr;					\
mud.h:   if ( ((gsn) = skill_lookup((skill))) == -1 )		\
mud.h:   if ( (ch)->substate == SUB_RESTRICTED )			\
mud.h:#define IS_NPC(ch)		(IS_SET((ch)->act, ACT_IS_NPC))
mud.h:#define IS_AFFECTED(ch, sn)	(IS_SET((ch)->affected_by, (sn)))
mud.h:#define HAS_BODYPART(ch, part)	((ch)->xflags == 0 || IS_SET((ch)->xflags, (part)))
mud.h:#define IS_GOOD(ch)		((ch)->alignment >= 350)
mud.h:#define IS_EVIL(ch)		((ch)->alignment <= -350)
mud.h:#define IS_AWAKE(ch)		((ch)->position > POS_SLEEPING)
mud.h:#define GET_AC(ch)		( (ch)->armor + ( IS_AWAKE(ch) ? dex_app[get_curr_dex(ch)].defensive : 0 ) \
mud.h:   - ( (ch)->race == RACE_DEFEL ? (ch)->skill_level[COMBAT_ABILITY]*2+5 : (ch)->skill_level[COMBAT_ABILITY]/2 ) )
mud.h:#define GET_HITROLL(ch)		((ch)->hitroll				    \
mud.h:   +(2-(abs((ch)->mental_state)/10)))
mud.h:#define GET_DAMROLL(ch)		((ch)->damroll                              \
mud.h:   +(((ch)->mental_state > 5		    \
mud.h:   &&(ch)->mental_state < 15) ? 1 : 0) )
mud.h:   (ch)->in_room->room_flags,		    \
mud.h:   (ch)->in_room->room_flags,              \
mud.h:   ( (ch)->pcdata->condition[COND_DRUNK] \
mud.h:   && (ch)->pcdata->clan			    )
mud.h:#define WAIT_STATE(ch, npulse)	((ch)->wait = UMAX((ch)->wait, (npulse)))
mud.h:#define EXIT(ch, door)		( get_exit( (ch)->in_room, door ) )
mud.h:   && (EXIT((ch),(door))->to_room != NULL)  \
mud.h:   && !IS_SET(EXIT((ch), (door))->exit_info, EX_CLOSED))
mud.h:   && skill_table[(sn)]->name )
mud.h:   && herb_table[(sn)]->name )
mud.h:#define SPELL_FLAG(skill, flag)	( IS_SET((skill)->flags, (flag)) )
mud.h:#define SPELL_DAMAGE(skill)	( ((skill)->flags     ) & 7 )
mud.h:#define SPELL_ACTION(skill)	( ((skill)->flags >> 3) & 7 )
mud.h:#define SPELL_CLASS(skill)	( ((skill)->flags >> 6) & 7 )
mud.h:#define SPELL_POWER(skill)	( ((skill)->flags >> 9) & 3 )
mud.h:#define SET_SDAM(skill, val)	( (skill)->flags =  ((skill)->flags & SDAM_MASK) + ((val) & 7) )
mud.h:#define SET_SACT(skill, val)	( (skill)->flags =  ((skill)->flags & SACT_MASK) + (((val) & 7) << 3) )
mud.h:#define SET_SCLA(skill, val)	( (skill)->flags =  ((skill)->flags & SCLA_MASK) + (((val) & 7) << 6) )
mud.h:#define SET_SPOW(skill, val)	( (skill)->flags =  ((skill)->flags & SPOW_MASK) + (((val) & 3) << 9) )
mud.h:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h:/* RIS by gsn lookups. -- Altrag.
mud.h:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h:   && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h:   && ch->pcdata->auth_state == 1		     \
mud.h:   && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h:#define CAN_WEAR(obj, part)	(IS_SET((obj)->wear_flags,  (part)))
mud.h:#define IS_OBJ_STAT(obj, stat)	(IS_SET((obj)->extra_flags, (stat)))
mud.h:   ( IS_NPC(ch) ? (ch)->short_descr	\
mud.h:   : (ch)->name ) : "someone" )
mud.h:* Most output files (bug, idea, typo, shutdown) are append-only.
mud.h:* every half hour - trying to
mud.h:/* object saving defines for fread/write_obj. -- Altrag */
mud.h:#define ERROR_PROG        -1
mud.h~: *--------------------------------------------------------------------------*
mud.h~: * -------------------------------------------------------------------------*
mud.h~: *--------------------------------------------------------------------------*
mud.h~: * ------------------------------------------------------------------------ *
mud.h~: * ------------------------------------------------------------------------ *
mud.h~:#define LEVEL_HERO		   (MAX_LEVEL - 5)
mud.h~:#define LEVEL_IMMORTAL		   (MAX_LEVEL - 4)
mud.h~:#define LEVEL_INFINITE		   (MAX_LEVEL - 1)
mud.h~:#define LEVEL_ETERNAL		   (MAX_LEVEL - 1)
mud.h~:#define LEVEL_IMPLEMENTOR	   (MAX_LEVEL - 1)
mud.h~:#define LEVEL_SUB_IMPLEM	   (MAX_LEVEL - 1)
mud.h~:#define LEVEL_ASCENDANT		   (MAX_LEVEL - 2)
mud.h~:#define LEVEL_GREATER		   (MAX_LEVEL - 2)
mud.h~:#define LEVEL_GOD		   (MAX_LEVEL - 2)
mud.h~:#define LEVEL_LESSER		   (MAX_LEVEL - 3)
mud.h~:#define LEVEL_TRUEIMM		   (MAX_LEVEL - 3)
mud.h~:#define LEVEL_DEMI		   (MAX_LEVEL - 3)
mud.h~:#define LEVEL_SAVIOR		   (MAX_LEVEL - 3)
mud.h~:#define LEVEL_CREATOR		   (MAX_LEVEL - 3)
mud.h~:#define LEVEL_ACOLYTE		   (MAX_LEVEL - 4)
mud.h~:#define LEVEL_NEOPHYTE		   (MAX_LEVEL - 4)
mud.h~:#define LEVEL_AVATAR		   (MAX_LEVEL - 5)
mud.h~: * Stuff for area versions --Shaddai
mud.h~:#define HAS_SPELL_INDEX     -1
mud.h~:Version 2: Skipped - Probably won't ever see these, but originated from Smaug 1.8.
mud.h~:* do_who output structure -- Narn
mud.h~:   CON_GET_NAME = -99,
mud.h~:#define ABILITY_NONE		-1
mud.h~:* Languages -- Altrag
mud.h~:#define LASER_DAMAGED    -1
mud.h~:/* make that none - ugh - time for another field? :P */
mud.h~:/* Magic flags - extra extra_flags for objects that are used in spells */
mud.h~:/* Blaster settings - only saves on characters */
mud.h~:#define EX_RES1                   BV09 /* are these res[1-4] important? */
mud.h~:   WEAR_NONE = -1, WEAR_LIGHT = 0, WEAR_FINGER_L, WEAR_FINGER_R, WEAR_NECK_1,
mud.h~:/* Bits for pc_data->flags. */
mud.h~:/* Area defines - Scryn 8/11
mud.h~:/* Area flags - Narn Mar/96 */
mud.h~:* This is the in-memory version of #MOBILES.
mud.h~:   time_t release_date; /* Auto-helling.. Altrag */
mud.h~:   int magic_flags;  /*Need more bitvectors for spells - Scryn */
mud.h~:   int magic_flags;  /*Need more bitvectors for spells - Scryn */
mud.h~:* Area-reset definition.
mud.h~:* Used to keep track of system settings and statistics		-Thoric
mud.h~:* Must be non-overlapping with spell/skill types,
mud.h~:#define TYPE_UNDEFINED               -1
mud.h~:   const char *spell_fun_name;   /* Spell function name - Trax */
mud.h~:   const char *skill_fun_name;   /* Skill function name - Trax */
mud.h~:   CHAR_DATA *seller;   /* a pointer to the seller - which may NOT quit */
mud.h~:   CHAR_DATA *buyer; /* a pointer to the buyer - which may NOT quit */
mud.h~:   int bet; /* last bet - or 0 if noone has bet anything */
mud.h~:   short pulse;   /* how many pulses (.25 sec) until another call-out ? */
mud.h~:#define LOWER( c )        ( (c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : (c) )
mud.h~:#define UPPER( c )        ( (c) >= 'a' && (c) <= 'z' ? (c) + 'A' - 'a' : (c) )
mud.h~:   if( str_free((point)) == -1 )             \
mud.h~:/* double-linked list handling macros -Thoric */
mud.h~:   (last)->next = (link);                \
mud.h~:   (link)->next = NULL;                     \
mud.h~:   (link)->prev = NULL;                  \
mud.h~:   (link)->prev = (last);                \
mud.h~:   (link)->prev = (insert)->prev;               \
mud.h~:   if ( !(insert)->prev )                       \
mud.h~:   (insert)->prev->next = (link);            \
mud.h~:   (insert)->prev = (link);                     \
mud.h~:   (link)->next = (insert);                     \
mud.h~:   if ( !(link)->prev )                         \
mud.h~:   (first) = (link)->next;                   \
mud.h~:   (first)->prev = NULL;                  \
mud.h~:   (link)->prev->next = (link)->next;        \
mud.h~:   if ( !(link)->next )                         \
mud.h~:   (last) = (link)->prev;                    \
mud.h~:   (last)->next = NULL;                   \
mud.h~:   (link)->next->prev = (link)->prev;        \
mud.h~:   for ( ptr = (last); ptr->prev; ptr = ptr->prev );		\
mud.h~:   for ( ptr = (first); ptr->next; ptr = ptr->next );		\
mud.h~:   for ( ptr = (first); ptr; ptr = ptr->next )			\
mud.h~:   if ( ptr->prev != pptr )					\
mud.h~:   bug( "CHECK_LINKS(%s): %p:->prev != %p.  Fixing.",	\
mud.h~:   ptr->prev = pptr;					\
mud.h~:   if ( ptr->prev && ptr->prev->next != ptr )		\
mud.h~:   bug( "CHECK_LINKS(%s): %p:->prev->next != %p.  Fixing.",\
mud.h~:   ptr->prev->next = ptr;					\
mud.h~:   for ( ptr = (last); ptr; ptr = ptr->prev )			\
mud.h~:   if ( ptr->next != pptr )					\
mud.h~:   bug( "CHECK_LINKS (%s): %p:->next != %p.  Fixing.",	\
mud.h~:   ptr->next = pptr;					\
mud.h~:   if ( ptr->next && ptr->next->prev != ptr )		\
mud.h~:   bug( "CHECK_LINKS(%s): %p:->next->prev != %p.  Fixing.",\
mud.h~:   ptr->next->prev = ptr;					\
mud.h~:   if ( ((gsn) = skill_lookup((skill))) == -1 )		\
mud.h~:   if ( (ch)->substate == SUB_RESTRICTED )			\
mud.h~:#define IS_NPC(ch)		(IS_SET((ch)->act, ACT_IS_NPC))
mud.h~:#define IS_AFFECTED(ch, sn)	(IS_SET((ch)->affected_by, (sn)))
mud.h~:#define HAS_BODYPART(ch, part)	((ch)->xflags == 0 || IS_SET((ch)->xflags, (part)))
mud.h~:#define IS_GOOD(ch)		((ch)->alignment >= 350)
mud.h~:#define IS_EVIL(ch)		((ch)->alignment <= -350)
mud.h~:#define IS_AWAKE(ch)		((ch)->position > POS_SLEEPING)
mud.h~:#define GET_AC(ch)		( (ch)->armor + ( IS_AWAKE(ch) ? dex_app[get_curr_dex(ch)].defensive : 0 ) \
mud.h~:   - ( (ch)->race == RACE_DEFEL ? (ch)->skill_level[COMBAT_ABILITY]*2+5 : (ch)->skill_level[COMBAT_ABILITY]/2 ) )
mud.h~:#define GET_HITROLL(ch)		((ch)->hitroll				    \
mud.h~:   +(2-(abs((ch)->mental_state)/10)))
mud.h~:#define GET_DAMROLL(ch)		((ch)->damroll                              \
mud.h~:   +(((ch)->mental_state > 5		    \
mud.h~:   &&(ch)->mental_state < 15) ? 1 : 0) )
mud.h~:   (ch)->in_room->room_flags,		    \
mud.h~:   (ch)->in_room->room_flags,              \
mud.h~:   ( (ch)->pcdata->condition[COND_DRUNK] \
mud.h~:   && (ch)->pcdata->clan			    )
mud.h~:#define WAIT_STATE(ch, npulse)	((ch)->wait = UMAX((ch)->wait, (npulse)))
mud.h~:#define EXIT(ch, door)		( get_exit( (ch)->in_room, door ) )
mud.h~:   && (EXIT((ch),(door))->to_room != NULL)  \
mud.h~:   && !IS_SET(EXIT((ch), (door))->exit_info, EX_CLOSED))
mud.h~:   && skill_table[(sn)]->name )
mud.h~:   && herb_table[(sn)]->name )
mud.h~:#define SPELL_FLAG(skill, flag)	( IS_SET((skill)->flags, (flag)) )
mud.h~:#define SPELL_DAMAGE(skill)	( ((skill)->flags     ) & 7 )
mud.h~:#define SPELL_ACTION(skill)	( ((skill)->flags >> 3) & 7 )
mud.h~:#define SPELL_CLASS(skill)	( ((skill)->flags >> 6) & 7 )
mud.h~:#define SPELL_POWER(skill)	( ((skill)->flags >> 9) & 3 )
mud.h~:#define SET_SDAM(skill, val)	( (skill)->flags =  ((skill)->flags & SDAM_MASK) + ((val) & 7) )
mud.h~:#define SET_SACT(skill, val)	( (skill)->flags =  ((skill)->flags & SACT_MASK) + (((val) & 7) << 3) )
mud.h~:#define SET_SCLA(skill, val)	( (skill)->flags =  ((skill)->flags & SCLA_MASK) + (((val) & 7) << 6) )
mud.h~:#define SET_SPOW(skill, val)	( (skill)->flags =  ((skill)->flags & SPOW_MASK) + (((val) & 3) << 9) )
mud.h~:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h~:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h~:/* RIS by gsn lookups. -- Altrag.
mud.h~:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h~:   && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h~:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h~:   && ch->pcdata->auth_state == 1		     \
mud.h~:   && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h~:#define CAN_WEAR(obj, part)	(IS_SET((obj)->wear_flags,  (part)))
mud.h~:#define IS_OBJ_STAT(obj, stat)	(IS_SET((obj)->extra_flags, (stat)))
mud.h~:   ( IS_NPC(ch) ? (ch)->short_descr	\
mud.h~:   : (ch)->name ) : "someone" )
mud.h~:* Most output files (bug, idea, typo, shutdown) are append-only.
mud.h~:* every half hour - trying to
mud.h~:/* object saving defines for fread/write_obj. -- Altrag */
mud.h~:#define ERROR_PROG        -1
mud_prog.c:*--------------------------------------------------------------------------*
mud_prog.c:* -------------------------------------------------------------------------*
mud_prog.c:*--------------------------------------------------------------------------*
mud_prog.c:* ------------------------------------------------------------------------ *
mud_prog.c:* ------------------------------------------------------------------------ *
mud_prog.c:*  was written by N'Atas-ha.						   *
mud_prog.c:      if( supermob->in_room != *supermob_room )
mud_prog.c:          STRFREE( supermob->short_descr );
mud_prog.c:          STRFREE( supermob->description );
mud_prog.c:          supermob->short_descr = QUICKLINK( supermob_obj->short_descr );
mud_prog.c:          snprintf( buf, 128, "Object #%d", supermob_obj->pIndexData->vnum );
mud_prog.c:          supermob->description = STRALLOC( buf );
mud_prog.c:         STRFREE( supermob->short_descr );
mud_prog.c:         STRFREE( supermob->description );
mud_prog.c:         supermob->short_descr = QUICKLINK( (*supermob_room)->name );
mud_prog.c:         snprintf( buf, 128, "Room #%d", (*supermob_room)->vnum );
mud_prog.c:         supermob->description = STRALLOC( buf );
mud_prog.c:      *supermob_room = supermob->in_room;
mud_prog.c: * Redone by Altrag.. kill all that big copy-code that performs the
mud_prog.c:         if( !mob->in_room )
mud_prog.c:         room = mob->in_room;
mud_prog.c:      return mprog_veval( ( ( room->area->high_economy > 0 ) ? 1000000000 : 0 )
mud_prog.c:                          + room->area->low_economy, opr, atoi( rval ), mob );
mud_prog.c:      for( oMob = mob->in_room->first_person; oMob; oMob = oMob->next_in_room )
mud_prog.c:         if( IS_NPC( oMob ) && oMob->pIndexData->vnum == vnum )
mud_prog.c:         pMob = chkchar->pIndexData;
mud_prog.c:      return mprog_veval( pMob->killed, opr, atoi( rval ), mob );
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      for( pObj = mob->in_room->first_content; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      for( pObj = mob->in_room->first_content; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->in_room->first_content; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->in_room->first_content; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( pObj->wear_loc != WEAR_NONE && can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( pObj->wear_loc != WEAR_NONE && can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( pObj->wear_loc == WEAR_NONE && can_see_obj( mob, pObj ) && pObj->pIndexData->vnum == vnum )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:      for( pObj = mob->first_carrying; pObj; pObj = pObj->next_content )
mud_prog.c:         if( pObj->wear_loc == WEAR_NONE && can_see_obj( mob, pObj ) && pObj->item_type == type )
mud_prog.c:            lhsvl += pObj->count;
mud_prog.c:      rhsvl = is_number( rval ) ? atoi( rval ) : -1;
mud_prog.c:         return ( IS_NPC( chkchar ) && IS_SET( chkchar->act, ACT_MOBINVIS ) );
mud_prog.c:         return ( IS_NPC( chkchar ) ? mprog_veval( chkchar->mobinvis, opr, atoi( rval ), mob ) : FALSE );
mud_prog.c:         return ( chkchar->position == POS_MOUNTED );
mud_prog.c:         return ( chkchar->master != NULL && chkchar->master->in_room == chkchar->in_room );
mud_prog.c:         return mprog_veval( ( chkchar->hit * 100 ) / chkchar->max_hit, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkchar->in_room->vnum, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkchar->was_in_room->vnum, opr, atoi( rval ), mob );
mud_prog.c:         return IS_SET( chkchar->in_room->room_flags, ROOM_NO_RECALL ) ? TRUE : FALSE;
mud_prog.c:         return mprog_veval( chkchar->sex, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkchar->position, opr, atoi( rval ), mob );
mud_prog.c:         return IS_NPC( actor ) ? FALSE : mprog_veval( chkchar->pcdata->quest_number, opr, atoi( rval ), mob );
mud_prog.c:         return IS_NPC( actor ) ? FALSE : mprog_veval( chkchar->pcdata->release_date, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkchar->gold, opr, atoi( rval ), mob );
mud_prog.c:            return mprog_seval( npc_race[chkchar->race], opr, rval, mob );
mud_prog.c:         return mprog_seval( ( char * )race_table[chkchar->race].race_name, opr, rval, mob );
mud_prog.c:         if( IS_NPC( chkchar ) || !chkchar->pcdata->clan )
mud_prog.c:         return mprog_seval( chkchar->pcdata->clan->name, opr, rval, mob );
mud_prog.c:         for( senator = first_senator; senator; senator = senator->next )
mud_prog.c:            if( !str_cmp( chkchar->name, senator->name ) )
mud_prog.c:         if( IS_NPC( chkchar ) || !chkchar->pcdata->clan )
mud_prog.c:         return mprog_veval( chkchar->pcdata->clan->clan_type, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->item_type, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[0], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[1], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[2], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[3], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[4], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[5], opr, atoi( rval ), mob );
mud_prog.c:         lhsvl = ( chkchar == mob ) ? chkchar->gold : chkchar->pIndexData->vnum;
mud_prog.c:      return mprog_veval( chkobj->pIndexData->vnum, opr, atoi( rval ), mob );
mud_prog.c:         return mprog_seval( chkchar->name, opr, rval, mob );
mud_prog.c:      return mprog_seval( chkobj->name, opr, rval, mob );
mud_prog.c: *  performance for stability. -Haus
mud_prog.c: *  as a weapon type? -Narn
mud_prog.c: *  Added char_died and obj_extracted checks	-Thoric
mud_prog.c:            if( mob->name )
mud_prog.c:               one_argument( mob->name, t );
mud_prog.c:            if( mob->short_descr )
mud_prog.c:               strcpy( t, mob->short_descr );
mud_prog.c:            one_argument( actor->name, t );
mud_prog.c:                  strcpy( t, actor->short_descr );
mud_prog.c:                  strcpy( t, actor->name );
mud_prog.c:                  strcat( t, actor->pcdata->title );
mud_prog.c:            one_argument( vict->name, t );
mud_prog.c:                  strcpy( t, vict->short_descr );
mud_prog.c:                  strcpy( t, vict->name );
mud_prog.c:                  strcat( t, vict->pcdata->title );
mud_prog.c:            one_argument( rndm->name, t );
mud_prog.c:                  strcpy( t, rndm->short_descr );
mud_prog.c:                  strcpy( t, rndm->name );
mud_prog.c:                  strcat( t, rndm->pcdata->title );
mud_prog.c:            can_see( mob, actor ) ? strcpy( t, he_she[actor->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see( mob, actor ) ? strcpy( t, him_her[actor->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see( mob, actor ) ? strcpy( t, his_her[actor->sex] ) : strcpy( t, "someone's" );
mud_prog.c:            can_see( mob, vict ) ? strcpy( t, he_she[vict->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see( mob, vict ) ? strcpy( t, him_her[vict->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see( mob, vict ) ? strcpy( t, his_her[vict->sex] ) : strcpy( t, "someone's" );
mud_prog.c:            strcpy( t, he_she[mob->sex] );
mud_prog.c:            strcpy( t, him_her[mob->sex] );
mud_prog.c:            strcpy( t, his_her[mob->sex] );
mud_prog.c:            can_see( mob, rndm ) ? strcpy( t, he_she[rndm->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see( mob, rndm ) ? strcpy( t, him_her[rndm->sex] ) : strcpy( t, "someone's" );
mud_prog.c:            can_see( mob, rndm ) ? strcpy( t, his_her[rndm->sex] ) : strcpy( t, "someone" );
mud_prog.c:            can_see_obj( mob, obj ) ? one_argument( obj->name, t ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, obj ) ? strcpy( t, obj->short_descr ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, v_obj ) ? one_argument( v_obj->name, t ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, v_obj ) ? strcpy( t, v_obj->short_descr ) : strcpy( t, "something" );
mud_prog.c:            strcpy( t, aoran( obj->name ) );
mud_prog.c:          switch ( *( obj->name ) )
mud_prog.c:            strcpy( t, aoran( v_obj->name ) );
mud_prog.c:      supermob_room = mob->in_room;
mud_prog.c:    * Next couple of checks stop program looping. -- Altrag 
mud_prog.c:      --prog_nest;
mud_prog.c:    *    -Haus
mud_prog.c:    * This used to ignore players MAX_LEVEL - 3 and higher (standard
mud_prog.c:    * you may be chosen as the random player. -Narn
mud_prog.c:   for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      if( mob->mpscriptpos > strlen( tmpcmndlst ) )
mud_prog.c:         mob->mpscriptpos = 0;
mud_prog.c:         command_list += mob->mpscriptpos;
mud_prog.c:         mob->mpscriptpos = 0;
mud_prog.c:    * use it to increase/decrease max allowed nesting.  -Narn 
mud_prog.c:         --prog_nest;
mud_prog.c:       * Script prog support  -Thoric 
mud_prog.c:         mob->mpscriptpos = command_list - tmpcmndlst;
mud_prog.c:         --prog_nest;
mud_prog.c:             * Ok, this one's a no-brainer. 
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               ignorelevel--;
mud_prog.c:            iflevel--;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:               --prog_nest;
mud_prog.c:            --prog_nest;
mud_prog.c:   --prog_nest;
mud_prog.c:   vnum = mob->pIndexData->vnum;
mud_prog.c:         if( ( start == arg || *( start - 1 ) == ' ' )
mud_prog.c:            if( ( start == arg || *( start - 1 ) == ' ' )
mud_prog.c:   for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( mprg->type & type )
mud_prog.c:         strcpy( temp1, mprg->arglist );
mud_prog.c:               if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                  mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:                  if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                     mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( ( mprg->type & type ) && ( number_percent(  ) <= atoi( mprg->arglist ) ) )
mud_prog.c:         mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      trigger_time = ( time_info.hour == atoi( mprg->arglist ) );
mud_prog.c:         if( mprg->triggered )
mud_prog.c:            mprg->triggered = FALSE;
mud_prog.c:      if( ( mprg->type & type ) && ( ( !mprg->triggered ) || ( mprg->type && HOUR_PROG ) ) )
mud_prog.c:         mprg->triggered = TRUE;
mud_prog.c:         mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   for( runner = mob_act_list; runner; runner = runner->next )
mud_prog.c:      if( runner->vo == mob )
mud_prog.c:   runner->vo = mob;
mud_prog.c:   runner->next = NULL;
mud_prog.c:    * instead. -Druid
mud_prog.c:      while( tmp_mal->next != NULL )
mud_prog.c:         tmp_mal = tmp_mal->next;
mud_prog.c:      tmp_mal->next = runner;
mud_prog.c:   if( IS_NPC( mob ) && IS_SET( mob->pIndexData->progtypes, ACT_PROG ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( mprg->type & ACT_PROG && mprog_keyword_check( buf, mprg->arglist ) )
mud_prog.c: * Losing the head of the list -Druid
mud_prog.c:      if( mob->mpactnum > 0 )
mud_prog.c:         tmp_mal = mob->mpact;
mud_prog.c:         while( tmp_mal->next != NULL )
mud_prog.c:            tmp_mal = tmp_mal->next;
mud_prog.c:         tmp_mal->next = tmp_act;
mud_prog.c:         mob->mpact = tmp_act;
mud_prog.c:      tmp_act->next = NULL;
mud_prog.c:      tmp_act->buf = str_dup( buf );
mud_prog.c:      tmp_act->ch = ch;
mud_prog.c:      tmp_act->obj = obj;
mud_prog.c:      tmp_act->vo = vo;
mud_prog.c:      mob->mpactnum++;
mud_prog.c:   if( IS_NPC( mob ) && ( mob->pIndexData->progtypes & BRIBE_PROG ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      sprintf( buf, obj->short_descr, amount );
mud_prog.c:      STRFREE( obj->short_descr );
mud_prog.c:      obj->short_descr = STRALLOC( buf );
mud_prog.c:      obj->value[0] = amount;
mud_prog.c:      mob->gold -= amount;
mud_prog.c:      for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( ( mprg->type & BRIBE_PROG ) && ( amount >= atoi( mprg->arglist ) ) )
mud_prog.c:            mprog_driver( mprg->comlist, mob, ch, obj, NULL, FALSE );
mud_prog.c:   if( IS_NPC( mob ) && killer != mob && ( mob->pIndexData->progtypes & DEATH_PROG ) )
mud_prog.c:   if( IS_NPC( mob ) && ( mob->pIndexData->progtypes & ENTRY_PROG ) )
mud_prog.c:   if( IS_NPC( mob ) && ( mob->pIndexData->progtypes & FIGHT_PROG ) )
mud_prog.c:   if( IS_NPC( mob ) && ( mob->pIndexData->progtypes & GIVE_PROG ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         one_argument( mprg->arglist, buf );
mud_prog.c:         if( ( mprg->type & GIVE_PROG ) && ( ( !str_cmp( obj->name, mprg->arglist ) ) || ( !str_cmp( "all", buf ) ) ) )
mud_prog.c:            mprog_driver( mprg->comlist, mob, ch, obj, NULL, FALSE );
mud_prog.c:   sprintf( buf, "mprog_greet_trigger -> %s", ch->name );
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      vmob_next = vmob->next_in_room;
mud_prog.c:      if( !IS_NPC( vmob ) || vmob->fighting || !IS_AWAKE( vmob ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:      if( vmob->pIndexData->progtypes & GREET_PROG )
mud_prog.c:      else if( vmob->pIndexData->progtypes & ALL_GREET_PROG )
mud_prog.c:   if( IS_NPC( mob ) && ( mob->pIndexData->progtypes & HITPRCNT_PROG ) )
mud_prog.c:      for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( ( mprg->type & HITPRCNT_PROG ) && ( ( 100 * mob->hit / mob->max_hit ) < atoi( mprg->arglist ) ) )
mud_prog.c:            mprog_driver( mprg->comlist, mob, ch, NULL, NULL, FALSE );
mud_prog.c:   if( mob->pIndexData->progtypes & RAND_PROG )
mud_prog.c:   if( mob->pIndexData->progtypes & TIME_PROG )
mud_prog.c:   if( mob->pIndexData->progtypes & HOUR_PROG )
mud_prog.c:   for( vmob = actor->in_room->first_person; vmob; vmob = vmob->next_in_room )
mud_prog.c:      if( IS_NPC( vmob ) && ( vmob->pIndexData->progtypes & SPEECH_PROG ) )
mud_prog.c:         if( IS_NPC( actor ) && actor->pIndexData == vmob->pIndexData )
mud_prog.c:   if( mob->pIndexData->progtypes & SCRIPT_PROG )
mud_prog.c:      for( mprg = mob->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( ( mprg->type & SCRIPT_PROG ) )
mud_prog.c:            if( mprg->arglist[0] == '\0' || mob->mpscriptpos != 0 || atoi( mprg->arglist ) == time_info.hour )
mud_prog.c:               mprog_driver( mprg->comlist, mob, NULL, NULL, NULL, TRUE );
mud_prog.c:   if( obj->pIndexData->progtypes & SCRIPT_PROG )
mud_prog.c:      for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( ( mprg->type & SCRIPT_PROG ) )
mud_prog.c:            if( mprg->arglist[0] == '\0' || obj->mpscriptpos != 0 || atoi( mprg->arglist ) == time_info.hour )
mud_prog.c:               mprog_driver( mprg->comlist, supermob, NULL, NULL, NULL, TRUE );
mud_prog.c:               obj->mpscriptpos = supermob->mpscriptpos;
mud_prog.c:   if( room->progtypes & SCRIPT_PROG )
mud_prog.c:      for( mprg = room->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:         if( ( mprg->type & SCRIPT_PROG ) )
mud_prog.c:            if( mprg->arglist[0] == '\0' || room->mpscriptpos != 0 || atoi( mprg->arglist ) == time_info.hour )
mud_prog.c:               mprog_driver( mprg->comlist, supermob, NULL, NULL, NULL, TRUE );
mud_prog.c:               room->mpscriptpos = supermob->mpscriptpos;
mud_prog.c:   for( in_obj = obj; in_obj->in_obj; in_obj = in_obj->in_obj )
mud_prog.c:   if( in_obj->carried_by )
mud_prog.c:      room = in_obj->carried_by->in_room;
mud_prog.c:      room = obj->in_room;
mud_prog.c:   if( supermob->short_descr )
mud_prog.c:      STRFREE( supermob->short_descr );
mud_prog.c:   supermob->short_descr = QUICKLINK( obj->short_descr );
mud_prog.c:   supermob->mpscriptpos = obj->mpscriptpos;
mud_prog.c:   sprintf( buf, "Object #%d", obj->pIndexData->vnum );
mud_prog.c:   STRFREE( supermob->description );
mud_prog.c:   supermob->description = STRALLOC( buf );
mud_prog.c:   for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( ( mprg->type & type ) && ( number_percent(  ) <= atoi( mprg->arglist ) ) )
mud_prog.c:         mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   if ( obj->pIndexData->progtypes & ACT_PROG ) 
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:      if( vobj->pIndexData->progtypes & GREET_PROG )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:      if( vobj->pIndexData->progtypes & SPEECH_PROG )
mud_prog.c:   if( !obj || !obj->pIndexData )
mud_prog.c:   if( obj->pIndexData->progtypes & RAND_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & WEAR_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & USE_PROG )
mud_prog.c:      if( obj->item_type == ITEM_STAFF )
mud_prog.c:   if( obj->pIndexData->progtypes & REMOVE_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & SAC_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & GET_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & DAMAGE_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & REPAIR_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & DROP_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & EXA_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & ZAP_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & PULL_PROG )
mud_prog.c:   if( obj->pIndexData->progtypes & PUSH_PROG )
mud_prog.c:   if( mobj->pIndexData->progtypes & ACT_PROG )
mud_prog.c: * Losing the head of the list -Druid
mud_prog.c:      if( mobj->mpactnum > 0 )
mud_prog.c:         tmp_mal = mobj->mpact;
mud_prog.c:         while( tmp_mal->next != NULL )
mud_prog.c:            tmp_mal = tmp_mal->next;
mud_prog.c:         tmp_mal->next = tmp_act;
mud_prog.c:         mobj->mpact = tmp_act;
mud_prog.c:      tmp_act->next = NULL;
mud_prog.c:      tmp_act->buf = str_dup( buf );
mud_prog.c:      tmp_act->ch = ch;
mud_prog.c:      tmp_act->obj = obj;
mud_prog.c:      tmp_act->vo = vo;
mud_prog.c:      mobj->mpactnum++;
mud_prog.c:   for( mprg = iobj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( mprg->type & type )
mud_prog.c:         strcpy( temp1, mprg->arglist );
mud_prog.c:               if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                  mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:                  if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                     mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:      STRFREE( supermob->short_descr );
mud_prog.c:      supermob->short_descr = QUICKLINK( room->name );
mud_prog.c:      STRFREE( supermob->name );
mud_prog.c:      supermob->name = QUICKLINK( room->name );
mud_prog.c:      supermob->mpscriptpos = room->mpscriptpos;
mud_prog.c:      sprintf( buf, "Room #%d", room->vnum );
mud_prog.c:      STRFREE( supermob->description );
mud_prog.c:      supermob->description = STRALLOC( buf );
mud_prog.c:   if( !mob->in_room )
mud_prog.c:   for( mprg = mob->in_room->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( ( mprg->type & type ) && ( number_percent(  ) <= atoi( mprg->arglist ) ) )
mud_prog.c:         mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c: * Unhold. -- Alty
mud_prog.c:   if( room->progtypes & ACT_PROG )
mud_prog.c: * Losing the head of the list -Druid
mud_prog.c:      if( room->mpactnum > 0 )
mud_prog.c:         tmp_mal = room->mpact;
mud_prog.c:         while( tmp_mal->next != NULL )
mud_prog.c:            tmp_mal = tmp_mal->next;
mud_prog.c:         tmp_mal->next = tmp_act;
mud_prog.c:         room->mpact = tmp_act;
mud_prog.c:      tmp_act->next = NULL;
mud_prog.c:      tmp_act->buf = str_dup( buf );
mud_prog.c:      tmp_act->ch = ch;
mud_prog.c:      tmp_act->obj = obj;
mud_prog.c:      tmp_act->vo = vo;
mud_prog.c:      room->mpactnum++;
mud_prog.c:   if( ch->in_room->progtypes & LEAVE_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & ENTER_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & SLEEP_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & REST_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & RFIGHT_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & RDEATH_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & SPEECH_PROG )
mud_prog.c:      rprog_wordlist_check( txt, supermob, ch, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:   if( ch->in_room->progtypes & RAND_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( actor && !char_died( actor ) && actor->in_room )
mud_prog.c:      room = actor->in_room;
mud_prog.c:   for( mprg = room->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      if( mprg->type & type )
mud_prog.c:         strcpy( temp1, mprg->arglist );
mud_prog.c:               if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                  mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:                  if( ( start == dupl || *( start - 1 ) == ' ' )
mud_prog.c:                     mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   for( mprg = room->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      trigger_time = ( time_info.hour == atoi( mprg->arglist ) );
mud_prog.c:         if( mprg->triggered )
mud_prog.c:            mprg->triggered = FALSE;
mud_prog.c:      if( ( mprg->type & type ) && ( ( !mprg->triggered ) || ( mprg->type & HOUR_PROG ) ) )
mud_prog.c:         mprg->triggered = TRUE;
mud_prog.c:         mprog_driver( mprg->comlist, mob, actor, obj, vo, FALSE );
mud_prog.c:   if( ch->in_room->progtypes & TIME_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:   if( ch->in_room->progtypes & HOUR_PROG )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:   if( mob->pIndexData->vnum == MOB_VNUM_SUPERMOB )
mud_prog.c:      sprintf( buf, "%s, %s.", str, mob->description == NULL ? "(unknown)" : mob->description );
mud_prog.c:      sprintf( buf, "%s, Mob #%d.", str, mob->pIndexData->vnum );
mud_prog.c:   thru 5-10000 rooms every pulse.. can we say lag? -- Alty */
mud_prog.c:   for( runner = room_act_list; runner; runner = runner->next )
mud_prog.c:      if( runner->vo == room )
mud_prog.c:   runner->vo = room;
mud_prog.c:   runner->next = NULL;
mud_prog.c:    * instead. -Druid
mud_prog.c:      while( tmp_ral->next != NULL )
mud_prog.c:         tmp_ral = tmp_ral->next;
mud_prog.c:      tmp_ral->next = runner;
mud_prog.c:     ROOM_INDEX_DATA *room = ( ROOM_INDEX_DATA* ) runner->vo;
mud_prog.c:      while( ( mpact = room->mpact ) != NULL )
mud_prog.c:         if( mpact->ch->in_room == room )
mud_prog.c:            rprog_wordlist_check( mpact->buf, supermob, mpact->ch, mpact->obj, mpact->vo, ACT_PROG, room );
mud_prog.c:         room->mpact = mpact->next;
mud_prog.c:         DISPOSE( mpact->buf );
mud_prog.c:      room->mpact = NULL;
mud_prog.c:      room->mpactnum = 0;
mud_prog.c:      room_act_list = runner->next;
mud_prog.c:   for( runner = obj_act_list; runner; runner = runner->next )
mud_prog.c:      if( runner->vo == obj )
mud_prog.c:   runner->vo = obj;
mud_prog.c:   runner->next = NULL;
mud_prog.c:    * instead. -Druid
mud_prog.c:      while( tmp_oal->next != NULL )
mud_prog.c:         tmp_oal = tmp_oal->next;
mud_prog.c:      tmp_oal->next = runner;
mud_prog.c:     OBJ_DATA *obj = ( OBJ_DATA* ) runner->vo;
mud_prog.c:      while( ( mpact = obj->mpact ) != NULL )
mud_prog.c:         oprog_wordlist_check( mpact->buf, supermob, mpact->ch, mpact->obj, mpact->vo, ACT_PROG, obj );
mud_prog.c:         obj->mpact = mpact->next;
mud_prog.c:         DISPOSE( mpact->buf );
mud_prog.c:      obj->mpact = NULL;
mud_prog.c:      obj->mpactnum = 0;
mud_prog.c:      obj_act_list = runner->next;
player.c:*--------------------------------------------------------------------------*
player.c:* -------------------------------------------------------------------------*
player.c:*--------------------------------------------------------------------------*
player.c:* ------------------------------------------------------------------------ *
player.c:* ------------------------------------------------------------------------ *
player.c:   ch_printf( ch, "You have %d credits.\r\n", ch->gold );
player.c:   ch_printf( ch, "\r\nScore for %s the %s.\r\n", ch->name, ch->pcdata->title );
player.c:   if( get_trust( ch ) != ch->top_level )
player.c:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:   ch_printf( ch, "Race: %3d year old %-10.10s                Log In:  %s\r",
player.c:              get_age( ch ), capitalize( get_race( ch ) ), ctime( &( ch->logon ) ) );
player.c:   ch_printf( ch, "Hitroll: %-2.2d  Damroll: %-2.2d   Armor: %-4d        Saved:  %s\r",
player.c:              GET_HITROLL( ch ), GET_DAMROLL( ch ), GET_AC( ch ), ch->save_time ? ctime( &( ch->save_time ) ) : "no\n" );
player.c:   ch_printf( ch, "Align: %-5d    Wimpy: %-3d                    Time:   %s\r",
player.c:              ch->alignment, ch->wimpy, ctime( &current_time ) );
player.c:   if( ch->skill_level[FORCE_ABILITY] > 1 || IS_IMMORTAL( ch ) )
player.c:                 ch->hit, ch->max_hit, ch->move, ch->max_move, ch->mana, ch->max_mana );
player.c:      ch_printf( ch, "Hit Points: %d of %d     Move: %d of %d\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:         if( ability != FORCE_ABILITY || ch->skill_level[FORCE_ABILITY] > 1 )
player.c:            ch_printf( ch, "%-15s   Level: %-3d   Max: %-3d   Exp: %-10ld   Next: %-10ld\r\n",
player.c:                       ability_name[ability], ch->skill_level[ability], max_level( ch, ability ), ch->experience[ability],
player.c:                       exp_level( ch->skill_level[ability] + 1 ) );
player.c:            ch_printf( ch, "%-15s   Level: %-3d   Max: ???   Exp: ???          Next: ???\r\n",
player.c:                       ability_name[ability], ch->skill_level[ability], ch->experience[ability] );
player.c:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:   ch_printf( ch, "CREDITS: %-10d   BANK: %-10d    Pkills: %-5.5d   Mkills: %-5.5d\r\n",
player.c:              ch->gold, ch->pcdata->bank, ch->pcdata->pkills, ch->pcdata->mkills );
player.c:              ch->carry_weight, can_carry_w( ch ), ch->carry_number, can_carry_n( ch ) );
player.c:              IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? 'X' : ' ',
player.c:              ch->pcdata->pagerlen, IS_SET( ch->act, PLR_AUTOEXIT ) ? 'X' : ' ',
player.c:              IS_SET( ch->act, PLR_AUTOLOOT ) ? 'X' : ' ', IS_SET( ch->act, PLR_AUTOSAC ) ? 'X' : ' ' );
player.c:   switch ( ch->position )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c:   if( ch->position != POS_SLEEPING )
player.c:      switch ( ch->mental_state / 10 )
player.c:         case -10:
player.c:         case -9:
player.c:         case -8:
player.c:         case -7:
player.c:         case -6:
player.c:         case -5:
player.c:         case -4:
player.c:         case -3:
player.c:         case -2:
player.c:         case -1:
player.c:   else if( ch->mental_state > 45 )
player.c:   else if( ch->mental_state > 25 )
player.c:   else if( ch->mental_state < -35 )
player.c:   else if( ch->mental_state < -25 )
player.c:      if( ch->pcdata->drug_level[drug] > 0 || ch->pcdata->drug_level[drug] > 0 )
player.c:         ch_printf( ch, "%s(%d/%d) ", spice_table[drug], ch->pcdata->drug_level[drug], ch->pcdata->addiction[drug] );
player.c:      if( knows_language( ch, lang_array[iLang], ch ) || ( IS_NPC( ch ) && ch->speaks == 0 ) )
player.c:         if( lang_array[iLang] & ch->speaking || ( IS_NPC( ch ) && !ch->speaking ) )
player.c:   ch_printf( ch, "WANTED ON: %s\r\n", flag_string( ch->pcdata->wanted_flags, planet_flags ) );
player.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c:      ch_printf( ch, "You are bestowed with the command(s): %s.\r\n", ch->pcdata->bestowments );
player.c:   if( ch->pcdata->clan )
player.c:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:      ch_printf( ch, "ORGANIZATION: %-35s Pkills/Deaths: %3.3d/%3.3d",
player.c:                 ch->pcdata->clan->name, ch->pcdata->clan->pkills, ch->pcdata->clan->pdeaths );
player.c:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:                 IS_SET( ch->act, PLR_WIZINVIS ) ? "X" : " ", ch->pcdata->wizinvis );
player.c:      ch_printf( ch, "Bamfin:  %s\r\n", ( ch->pcdata->bamfin[0] != '\0' )
player.c:                 ? ch->pcdata->bamfin : "%s appears in a swirling mist.", ch->name );
player.c:      ch_printf( ch, "Bamfout: %s\r\n", ( ch->pcdata->bamfout[0] != '\0' )
player.c:                 ? ch->pcdata->bamfout : "%s leaves in a swirling mist.", ch->name );
player.c:       * Area Loaded info - Scryn 8/11
player.c:      if( ch->pcdata->area )
player.c:         ch_printf( ch, "Vnums:   Room (%-5.5d - %-5.5d)   Object (%-5.5d - %-5.5d)   Mob (%-5.5d - %-5.5d)\r\n",
player.c:                    ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
player.c:                    ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
player.c:                    ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
player.c:         ch_printf( ch, "Area Loaded [%s]\r\n", ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "yes" : "no" );
player.c:   if( ch->first_affect )
player.c:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:         if( ( sktmp = get_skilltype( paf->type ) ) == NULL )
player.c:         if( ch->top_level < 20 )
player.c:            ch_printf( ch, "[%-34.34s]    ", sktmp->name );
player.c:            if( paf->modifier == 0 )
player.c:               ch_printf( ch, "[%-24.24s;%5d rds]    ", sktmp->name, paf->duration );
player.c:            else if( paf->modifier > 999 )
player.c:               ch_printf( ch, "[%-15.15s; %7.7s;%5d rds]    ",
player.c:                          sktmp->name, tiny_affect_loc_name( paf->location ), paf->duration );
player.c:               ch_printf( ch, "[%-11.11s;%+-3.3d %7.7s;%5d rds]    ",
player.c:                          sktmp->name, paf->modifier, tiny_affect_loc_name( paf->location ), paf->duration );
player.c:   if( ch->race < MAX_NPC_RACE && ch->race >= 0 )
player.c:      return ( npc_race[ch->race] );
player.c:              ch->name, IS_NPC( ch ) ? "" : ch->pcdata->title, ch->top_level, get_age( ch ), ( get_age( ch ) - 17 ) );
player.c:   if( get_trust( ch ) != ch->top_level )
player.c:   if( IS_SET( ch->act, ACT_MOBINVIS ) )
player.c:      ch_printf( ch, "You are mobinvis at level %d.\r\n", ch->mobinvis );
player.c:   ch_printf( ch, "You have %d/%d hit, %d/%d movement.\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c:              ch->carry_number, can_carry_n( ch ), ch->carry_weight, can_carry_w( ch ) );
player.c:   ch_printf( ch, "You have have %d credits.\r\n", ch->gold );
player.c:                 ch->pcdata->quest_accum, ch->pcdata->quest_curr );
player.c:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOEXIT ) ) ? "yes" : "no",
player.c:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOLOOT ) ) ? "yes" : "no",
player.c:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOSAC ) ) ? "yes" : "no",
player.c:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOGOLD ) ) ? "yes" : "no" );
player.c:   ch_printf( ch, "Wimpy set to %d hit points.\r\n", ch->wimpy );
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c:   switch ( ch->mental_state / 10 )
player.c:      case -10:
player.c:      case -9:
player.c:      case -8:
player.c:      case -7:
player.c:      case -6:
player.c:      case -5:
player.c:      case -4:
player.c:      case -3:
player.c:      case -2:
player.c:      case -1:
player.c:   switch ( ch->position )
player.c:   if( ch->top_level >= 25 )
player.c:   else if( GET_AC( ch ) >= -20 )
player.c:   else if( GET_AC( ch ) >= -40 )
player.c:   else if( GET_AC( ch ) >= -60 )
player.c:   else if( GET_AC( ch ) >= -80 )
player.c:   else if( GET_AC( ch ) >= -100 )
player.c:   if( ch->top_level >= 15 )
player.c:   if( ch->top_level >= 10 )
player.c:      ch_printf( ch, "Alignment: %d.  ", ch->alignment );
player.c:   if( ch->alignment > 900 )
player.c:   else if( ch->alignment > 700 )
player.c:   else if( ch->alignment > 350 )
player.c:   else if( ch->alignment > 100 )
player.c:   else if( ch->alignment > -100 )
player.c:   else if( ch->alignment > -350 )
player.c:   else if( ch->alignment > -700 )
player.c:   else if( ch->alignment > -900 )
player.c:   if( ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:         if( ( skill = get_skilltype( paf->type ) ) != NULL )
player.c:            ch_printf( ch, "Spell: '%s'", skill->name );
player.c:            if( ch->top_level >= 20 )
player.c:                          affect_loc_name( paf->location ), paf->modifier, paf->duration );
player.c:                 ch->pcdata->wizinvis, IS_SET( ch->act, PLR_WIZINVIS ) ? "ON" : "OFF" );
player.c:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
player.c:         ch_printf( ch, "Room Range: %d - %d\r\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
player.c:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
player.c:         ch_printf( ch, "Obj Range : %d - %d\r\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
player.c:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
player.c:         ch_printf( ch, "Mob Range : %d - %d\r\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
player.c:/*								-Thoric
player.c:      if( ability != FORCE_ABILITY || ch->skill_level[FORCE_ABILITY] > 1 )
player.c:         ch_printf( ch, "%-15s   Level: %-3d   Max: %-3d   Exp: %-10ld   Next: %-10ld\r\n",
player.c:                    ability_name[ability], ch->skill_level[ability], max_level( ch, ability ), ch->experience[ability],
player.c:                    exp_level( ch->skill_level[ability] + 1 ) );
player.c:         ch_printf( ch, "%-15s   Level: %-3d   Max: ???   Exp: ???          Next: ???\r\n",
player.c:                    ability_name[ability], ch->skill_level[ability], ch->experience[ability] );
player.c:      ch_printf( ch, "%s\r\n", affect_bit_name( ch->affected_by ) );
player.c:      if( ch->top_level >= 20 )
player.c:         if( ch->resistant > 0 )
player.c:            ch_printf( ch, "%s\r\n", flag_string( ch->resistant, ris_flags ) );
player.c:         if( ch->immune > 0 )
player.c:            ch_printf( ch, "%s\r\n", flag_string( ch->immune, ris_flags ) );
player.c:         if( ch->susceptible > 0 )
player.c:            ch_printf( ch, "%s\r\n", flag_string( ch->susceptible, ris_flags ) );
player.c:   if( !ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:         if( ( skill = get_skilltype( paf->type ) ) != NULL )
player.c:            if( ch->top_level >= 20 )
player.c:               if( paf->duration < 25 )
player.c:               if( paf->duration < 6 )
player.c:               ch_printf( ch, "(%5d)   ", paf->duration );
player.c:            ch_printf( ch, "%-18s\r\n", skill->name );
player.c:   show_list_to_char( ch->first_carrying, ch, TRUE, TRUE );
player.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
player.c:         if( obj->wear_loc == iWear )
player.c:               switch ( obj->item_type )
player.c:                     if( obj->value[1] == 0 )
player.c:                        obj->value[1] = obj->value[0];
player.c:                     if( obj->value[1] == 0 )
player.c:                        obj->value[1] = 1;
player.c:                     dam = ( short )( ( obj->value[0] * 10 ) / obj->value[1] );
player.c:                     dam = INIT_WEAPON_CONDITION - obj->value[0];
player.c:                     if( obj->value[3] == WEAPON_BLASTER )
player.c:                        if( obj->blaster_setting == BLASTER_FULL )
player.c:                        else if( obj->blaster_setting == BLASTER_HIGH )
player.c:                        else if( obj->blaster_setting == BLASTER_NORMAL )
player.c:                        else if( obj->blaster_setting == BLASTER_HALF )
player.c:                        else if( obj->blaster_setting == BLASTER_LOW )
player.c:                        else if( obj->blaster_setting == BLASTER_STUN )
player.c:                        ch_printf( ch, " %d", obj->value[4] );
player.c:                     else if( ( obj->value[3] == WEAPON_LIGHTSABER ||
player.c:                                obj->value[3] == WEAPON_VIBRO_BLADE
player.c:                                || obj->value[3] == WEAPON_FORCE_PIKE || obj->value[3] == WEAPON_BOWCASTER ) )
player.c:                        ch_printf( ch, "%d", obj->value[4] );
player.c:   STRFREE( ch->pcdata->title );
player.c:   ch->pcdata->title = STRALLOC( buf );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( ( get_trust( ch ) <= LEVEL_IMMORTAL ) && ( !nifty_is_name( ch->name, argument ) ) )
player.c:      if( !ch->pcdata->homepage )
player.c:         ch->pcdata->homepage = str_dup( "" );
player.c:      ch_printf( ch, "Your homepage is: %s\r\n", show_tilde( ch->pcdata->homepage ) );
player.c:      if( ch->pcdata->homepage )
player.c:         DISPOSE( ch->pcdata->homepage );
player.c:      ch->pcdata->homepage = str_dup( "" );
player.c:   if( ch->pcdata->homepage )
player.c:      DISPOSE( ch->pcdata->homepage );
player.c:   ch->pcdata->homepage = str_dup( buf );
player.c: * Set your personal description				-Thoric
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_DESC;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->description );
player.c:         STRFREE( ch->description );
player.c:         ch->description = copy_buffer( ch );
player.c:/* Ripped off do_description for whois bio's -- Scryn*/
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_BIO;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->pcdata->bio );
player.c:         STRFREE( ch->pcdata->bio );
player.c:         ch->pcdata->bio = copy_buffer( ch );
player.c:   ch_printf( ch, "You report: %d/%d hp %d/%d mv.\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c:   sprintf( buf, "$n reports: %d/%d hp %d/%d.", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c:   if( ch->pcdata->prompt )
player.c:      STRFREE( ch->pcdata->prompt );
player.c:    * Can add a list of pre-set prompts here if wanted.. perhaps
player.c:    * 'prompt 1' brings up a different, pre-set prompt 
player.c:      ch->pcdata->prompt = STRALLOC( "" );
player.c:      ch->pcdata->prompt = STRALLOC( prompt );
player.c:	   if( IS_NPC( ch ) || !ch->pcdata->pilotprompt || !*ch->pcdata->pilotprompt )
player.c:		sprintf( buf, "Current prompt string: %s\n\r", ch->pcdata->pilotprompt );
player.c:   if( ch->pcdata->pilotprompt )
player.c:      STRFREE( ch->pcdata->pilotprompt );
player.c:    * Can add a list of pre-set prompts here if wanted.. perhaps
player.c:    * 'prompt 1' brings up a different, pre-set prompt 
player.c:      ch->pcdata->pilotprompt = STRALLOC( "" );
player.c:      ch->pcdata->pilotprompt = STRALLOC( prompt );
player.c~:*--------------------------------------------------------------------------*
player.c~:* -------------------------------------------------------------------------*
player.c~:*--------------------------------------------------------------------------*
player.c~:* ------------------------------------------------------------------------ *
player.c~:* ------------------------------------------------------------------------ *
player.c~:   ch_printf( ch, "You have %d credits.\r\n", ch->gold );
player.c~:   ch_printf( ch, "\r\nScore for %s the %s.\r\n", ch->name, ch->pcdata->title );
player.c~:   if( get_trust( ch ) != ch->top_level )
player.c~:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:   ch_printf( ch, "Race: %3d year old %-10.10s                Log In:  %s\r",
player.c~:              get_age( ch ), capitalize( get_race( ch ) ), ctime( &( ch->logon ) ) );
player.c~:   ch_printf( ch, "Hitroll: %-2.2d  Damroll: %-2.2d   Armor: %-4d        Saved:  %s\r",
player.c~:              GET_HITROLL( ch ), GET_DAMROLL( ch ), GET_AC( ch ), ch->save_time ? ctime( &( ch->save_time ) ) : "no\n" );
player.c~:   ch_printf( ch, "Align: %-5d    Wimpy: %-3d                    Time:   %s\r",
player.c~:              ch->alignment, ch->wimpy, ctime( &current_time ) );
player.c~:   if( ch->skill_level[FORCE_ABILITY] > 1 || IS_IMMORTAL( ch ) )
player.c~:                 ch->hit, ch->max_hit, ch->move, ch->max_move, ch->mana, ch->max_mana );
player.c~:      ch_printf( ch, "Hit Points: %d of %d     Move: %d of %d\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c~:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:         if( ability != FORCE_ABILITY || ch->skill_level[FORCE_ABILITY] > 1 )
player.c~:            ch_printf( ch, "%-15s   Level: %-3d   Max: %-3d   Exp: %-10ld   Next: %-10ld\r\n",
player.c~:                       ability_name[ability], ch->skill_level[ability], max_level( ch, ability ), ch->experience[ability],
player.c~:                       exp_level( ch->skill_level[ability] + 1 ) );
player.c~:            ch_printf( ch, "%-15s   Level: %-3d   Max: ???   Exp: ???          Next: ???\r\n",
player.c~:                       ability_name[ability], ch->skill_level[ability], ch->experience[ability] );
player.c~:   send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:   ch_printf( ch, "CREDITS: %-10d   BANK: %-10d    Pkills: %-5.5d   Mkills: %-5.5d\r\n",
player.c~:              ch->gold, ch->pcdata->bank, ch->pcdata->pkills, ch->pcdata->mkills );
player.c~:              ch->carry_weight, can_carry_w( ch ), ch->carry_number, can_carry_n( ch ) );
player.c~:              IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? 'X' : ' ',
player.c~:              ch->pcdata->pagerlen, IS_SET( ch->act, PLR_AUTOEXIT ) ? 'X' : ' ',
player.c~:              IS_SET( ch->act, PLR_AUTOLOOT ) ? 'X' : ' ', IS_SET( ch->act, PLR_AUTOSAC ) ? 'X' : ' ' );
player.c~:   switch ( ch->position )
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c~:   if( ch->position != POS_SLEEPING )
player.c~:      switch ( ch->mental_state / 10 )
player.c~:         case -10:
player.c~:         case -9:
player.c~:         case -8:
player.c~:         case -7:
player.c~:         case -6:
player.c~:         case -5:
player.c~:         case -4:
player.c~:         case -3:
player.c~:         case -2:
player.c~:         case -1:
player.c~:   else if( ch->mental_state > 45 )
player.c~:   else if( ch->mental_state > 25 )
player.c~:   else if( ch->mental_state < -35 )
player.c~:   else if( ch->mental_state < -25 )
player.c~:      if( ch->pcdata->drug_level[drug] > 0 || ch->pcdata->drug_level[drug] > 0 )
player.c~:         ch_printf( ch, "%s(%d/%d) ", spice_table[drug], ch->pcdata->drug_level[drug], ch->pcdata->addiction[drug] );
player.c~:      if( knows_language( ch, lang_array[iLang], ch ) || ( IS_NPC( ch ) && ch->speaks == 0 ) )
player.c~:         if( lang_array[iLang] & ch->speaking || ( IS_NPC( ch ) && !ch->speaking ) )
player.c~:   ch_printf( ch, "WANTED ON: %s\r\n", flag_string( ch->pcdata->wanted_flags, planet_flags ) );
player.c~:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
player.c~:      ch_printf( ch, "You are bestowed with the command(s): %s.\r\n", ch->pcdata->bestowments );
player.c~:   if( ch->pcdata->clan )
player.c~:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:      ch_printf( ch, "ORGANIZATION: %-35s Pkills/Deaths: %3.3d/%3.3d",
player.c~:                 ch->pcdata->clan->name, ch->pcdata->clan->pkills, ch->pcdata->clan->pdeaths );
player.c~:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:                 IS_SET( ch->act, PLR_WIZINVIS ) ? "X" : " ", ch->pcdata->wizinvis );
player.c~:      ch_printf( ch, "Bamfin:  %s\r\n", ( ch->pcdata->bamfin[0] != '\0' )
player.c~:                 ? ch->pcdata->bamfin : "%s appears in a swirling mist.", ch->name );
player.c~:      ch_printf( ch, "Bamfout: %s\r\n", ( ch->pcdata->bamfout[0] != '\0' )
player.c~:                 ? ch->pcdata->bamfout : "%s leaves in a swirling mist.", ch->name );
player.c~:       * Area Loaded info - Scryn 8/11
player.c~:      if( ch->pcdata->area )
player.c~:         ch_printf( ch, "Vnums:   Room (%-5.5d - %-5.5d)   Object (%-5.5d - %-5.5d)   Mob (%-5.5d - %-5.5d)\r\n",
player.c~:                    ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
player.c~:                    ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
player.c~:                    ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
player.c~:         ch_printf( ch, "Area Loaded [%s]\r\n", ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "yes" : "no" );
player.c~:   if( ch->first_affect )
player.c~:      send_to_char( "----------------------------------------------------------------------------\r\n", ch );
player.c~:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c~:         if( ( sktmp = get_skilltype( paf->type ) ) == NULL )
player.c~:         if( ch->top_level < 20 )
player.c~:            ch_printf( ch, "[%-34.34s]    ", sktmp->name );
player.c~:            if( paf->modifier == 0 )
player.c~:               ch_printf( ch, "[%-24.24s;%5d rds]    ", sktmp->name, paf->duration );
player.c~:            else if( paf->modifier > 999 )
player.c~:               ch_printf( ch, "[%-15.15s; %7.7s;%5d rds]    ",
player.c~:                          sktmp->name, tiny_affect_loc_name( paf->location ), paf->duration );
player.c~:               ch_printf( ch, "[%-11.11s;%+-3.3d %7.7s;%5d rds]    ",
player.c~:                          sktmp->name, paf->modifier, tiny_affect_loc_name( paf->location ), paf->duration );
player.c~:   if( ch->race < MAX_NPC_RACE && ch->race >= 0 )
player.c~:      return ( npc_race[ch->race] );
player.c~:              ch->name, IS_NPC( ch ) ? "" : ch->pcdata->title, ch->top_level, get_age( ch ), ( get_age( ch ) - 17 ) );
player.c~:   if( get_trust( ch ) != ch->top_level )
player.c~:   if( IS_SET( ch->act, ACT_MOBINVIS ) )
player.c~:      ch_printf( ch, "You are mobinvis at level %d.\r\n", ch->mobinvis );
player.c~:   ch_printf( ch, "You have %d/%d hit, %d/%d movement.\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c~:              ch->carry_number, can_carry_n( ch ), ch->carry_weight, can_carry_w( ch ) );
player.c~:   ch_printf( ch, "You have have %d credits.\r\n", ch->gold );
player.c~:                 ch->pcdata->quest_accum, ch->pcdata->quest_curr );
player.c~:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOEXIT ) ) ? "yes" : "no",
player.c~:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOLOOT ) ) ? "yes" : "no",
player.c~:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOSAC ) ) ? "yes" : "no",
player.c~:              ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOGOLD ) ) ? "yes" : "no" );
player.c~:   ch_printf( ch, "Wimpy set to %d hit points.\r\n", ch->wimpy );
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > 10 )
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] == 0 )
player.c~:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] == 0 )
player.c~:   switch ( ch->mental_state / 10 )
player.c~:      case -10:
player.c~:      case -9:
player.c~:      case -8:
player.c~:      case -7:
player.c~:      case -6:
player.c~:      case -5:
player.c~:      case -4:
player.c~:      case -3:
player.c~:      case -2:
player.c~:      case -1:
player.c~:   switch ( ch->position )
player.c~:   if( ch->top_level >= 25 )
player.c~:   else if( GET_AC( ch ) >= -20 )
player.c~:   else if( GET_AC( ch ) >= -40 )
player.c~:   else if( GET_AC( ch ) >= -60 )
player.c~:   else if( GET_AC( ch ) >= -80 )
player.c~:   else if( GET_AC( ch ) >= -100 )
player.c~:   if( ch->top_level >= 15 )
player.c~:   if( ch->top_level >= 10 )
player.c~:      ch_printf( ch, "Alignment: %d.  ", ch->alignment );
player.c~:   if( ch->alignment > 900 )
player.c~:   else if( ch->alignment > 700 )
player.c~:   else if( ch->alignment > 350 )
player.c~:   else if( ch->alignment > 100 )
player.c~:   else if( ch->alignment > -100 )
player.c~:   else if( ch->alignment > -350 )
player.c~:   else if( ch->alignment > -700 )
player.c~:   else if( ch->alignment > -900 )
player.c~:   if( ch->first_affect )
player.c~:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c~:         if( ( skill = get_skilltype( paf->type ) ) != NULL )
player.c~:            ch_printf( ch, "Spell: '%s'", skill->name );
player.c~:            if( ch->top_level >= 20 )
player.c~:                          affect_loc_name( paf->location ), paf->modifier, paf->duration );
player.c~:                 ch->pcdata->wizinvis, IS_SET( ch->act, PLR_WIZINVIS ) ? "ON" : "OFF" );
player.c~:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
player.c~:         ch_printf( ch, "Room Range: %d - %d\r\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
player.c~:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
player.c~:         ch_printf( ch, "Obj Range : %d - %d\r\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
player.c~:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
player.c~:         ch_printf( ch, "Mob Range : %d - %d\r\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
player.c~:/*								-Thoric
player.c~:      if( ability != FORCE_ABILITY || ch->skill_level[FORCE_ABILITY] > 1 )
player.c~:         ch_printf( ch, "%-15s   Level: %-3d   Max: %-3d   Exp: %-10ld   Next: %-10ld\r\n",
player.c~:                    ability_name[ability], ch->skill_level[ability], max_level( ch, ability ), ch->experience[ability],
player.c~:                    exp_level( ch->skill_level[ability] + 1 ) );
player.c~:         ch_printf( ch, "%-15s   Level: %-3d   Max: ???   Exp: ???          Next: ???\r\n",
player.c~:                    ability_name[ability], ch->skill_level[ability], ch->experience[ability] );
player.c~:      ch_printf( ch, "%s\r\n", affect_bit_name( ch->affected_by ) );
player.c~:      if( ch->top_level >= 20 )
player.c~:         if( ch->resistant > 0 )
player.c~:            ch_printf( ch, "%s\r\n", flag_string( ch->resistant, ris_flags ) );
player.c~:         if( ch->immune > 0 )
player.c~:            ch_printf( ch, "%s\r\n", flag_string( ch->immune, ris_flags ) );
player.c~:         if( ch->susceptible > 0 )
player.c~:            ch_printf( ch, "%s\r\n", flag_string( ch->susceptible, ris_flags ) );
player.c~:   if( !ch->first_affect )
player.c~:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c~:         if( ( skill = get_skilltype( paf->type ) ) != NULL )
player.c~:            if( ch->top_level >= 20 )
player.c~:               if( paf->duration < 25 )
player.c~:               if( paf->duration < 6 )
player.c~:               ch_printf( ch, "(%5d)   ", paf->duration );
player.c~:            ch_printf( ch, "%-18s\r\n", skill->name );
player.c~:   show_list_to_char( ch->first_carrying, ch, TRUE, TRUE );
player.c~:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
player.c~:         if( obj->wear_loc == iWear )
player.c~:               switch ( obj->item_type )
player.c~:                     if( obj->value[1] == 0 )
player.c~:                        obj->value[1] = obj->value[0];
player.c~:                     if( obj->value[1] == 0 )
player.c~:                        obj->value[1] = 1;
player.c~:                     dam = ( short )( ( obj->value[0] * 10 ) / obj->value[1] );
player.c~:                     dam = INIT_WEAPON_CONDITION - obj->value[0];
player.c~:                     if( obj->value[3] == WEAPON_BLASTER )
player.c~:                        if( obj->blaster_setting == BLASTER_FULL )
player.c~:                        else if( obj->blaster_setting == BLASTER_HIGH )
player.c~:                        else if( obj->blaster_setting == BLASTER_NORMAL )
player.c~:                        else if( obj->blaster_setting == BLASTER_HALF )
player.c~:                        else if( obj->blaster_setting == BLASTER_LOW )
player.c~:                        else if( obj->blaster_setting == BLASTER_STUN )
player.c~:                        ch_printf( ch, " %d", obj->value[4] );
player.c~:                     else if( ( obj->value[3] == WEAPON_LIGHTSABER ||
player.c~:                                obj->value[3] == WEAPON_VIBRO_BLADE
player.c~:                                || obj->value[3] == WEAPON_FORCE_PIKE || obj->value[3] == WEAPON_BOWCASTER ) )
player.c~:                        ch_printf( ch, "%d", obj->value[4] );
player.c~:   STRFREE( ch->pcdata->title );
player.c~:   ch->pcdata->title = STRALLOC( buf );
player.c~:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c~:   if( ( get_trust( ch ) <= LEVEL_IMMORTAL ) && ( !nifty_is_name( ch->name, argument ) ) )
player.c~:      if( !ch->pcdata->homepage )
player.c~:         ch->pcdata->homepage = str_dup( "" );
player.c~:      ch_printf( ch, "Your homepage is: %s\r\n", show_tilde( ch->pcdata->homepage ) );
player.c~:      if( ch->pcdata->homepage )
player.c~:         DISPOSE( ch->pcdata->homepage );
player.c~:      ch->pcdata->homepage = str_dup( "" );
player.c~:   if( ch->pcdata->homepage )
player.c~:      DISPOSE( ch->pcdata->homepage );
player.c~:   ch->pcdata->homepage = str_dup( buf );
player.c~: * Set your personal description				-Thoric
player.c~:   if( !ch->desc )
player.c~:   switch ( ch->substate )
player.c~:         ch->substate = SUB_PERSONAL_DESC;
player.c~:         ch->dest_buf = ch;
player.c~:         start_editing( ch, ch->description );
player.c~:         STRFREE( ch->description );
player.c~:         ch->description = copy_buffer( ch );
player.c~:/* Ripped off do_description for whois bio's -- Scryn*/
player.c~:   if( !ch->desc )
player.c~:   switch ( ch->substate )
player.c~:         ch->substate = SUB_PERSONAL_BIO;
player.c~:         ch->dest_buf = ch;
player.c~:         start_editing( ch, ch->pcdata->bio );
player.c~:         STRFREE( ch->pcdata->bio );
player.c~:         ch->pcdata->bio = copy_buffer( ch );
player.c~:   ch_printf( ch, "You report: %d/%d hp %d/%d mv.\r\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c~:   sprintf( buf, "$n reports: %d/%d hp %d/%d.", ch->hit, ch->max_hit, ch->move, ch->max_move );
player.c~:   if( ch->pcdata->prompt )
player.c~:      STRFREE( ch->pcdata->prompt );
player.c~:    * Can add a list of pre-set prompts here if wanted.. perhaps
player.c~:    * 'prompt 1' brings up a different, pre-set prompt 
player.c~:      ch->pcdata->prompt = STRALLOC( "" );
player.c~:      ch->pcdata->prompt = STRALLOC( prompt );
player.c~:	   if( IS_NPC( ch ) || !ch->pcdata->pilotprompt || !*ch->pcdata->pilotprompt )
player.c~:		sprintf( buf, "Current prompt string: %s\n\r", ch->pcdata->pilotprompt );
player.c~:   if( ch->pcdata->pilotprompt )
player.c~:      STRFREE( ch->pcdata->pilotprompt );
player.c~:    * Can add a list of pre-set prompts here if wanted.. perhaps
player.c~:    * 'prompt 1' brings up a different, pre-set prompt 
player.c~:      ch->pcdata->pilotprompt = STRALLOC( "" );
player.c~:      ch->pcdata->pilotprompt = STRALLOC( prompt );
reset.c:*--------------------------------------------------------------------------*
reset.c:* -------------------------------------------------------------------------*
reset.c:*--------------------------------------------------------------------------*
reset.c:* ------------------------------------------------------------------------ *
reset.c:* ------------------------------------------------------------------------ *
reset.c: * Used by area-reset 'P', 'T' and 'H' commands.
reset.c:   for( obj = first_object; obj; obj = obj->next )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:   for( obj = pRoomIndex->first_content; obj; obj = obj->next_content )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:   switch( pReset->command )
reset.c:                   *num, pReset->command, pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3 );
reset.c:         mob = get_mob_index( pReset->arg1 );
reset.c:         room = get_room_index( pReset->arg3 );
reset.c:            strncpy( mobname, mob->player_name, MAX_STRING_LENGTH );
reset.c:            strncpy( roomname, room->name, MAX_STRING_LENGTH );
reset.c:         snprintf( buf, MAX_STRING_LENGTH, "%2d) %s (%d) -> %s Room: %d [%d]\r\n", *num, mobname, pReset->arg1,
reset.c:            roomname, pReset->arg3, pReset->arg2 );
reset.c:         for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
reset.c:            switch( tReset->command )
reset.c:                  if( !( obj = get_obj_index( tReset->arg1 ) ) )
reset.c:                     strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:                  snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (equip) %s (%d) -> %s (%s) [%d]\r\n",
reset.c:                     *num, objname, tReset->arg1, mobname, wear_locs[tReset->arg3], tReset->arg2 );
reset.c:                  if( !( obj = get_obj_index( tReset->arg1 ) ) )
reset.c:                     strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:                  snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (carry) %s (%d) -> %s [%d]\r\n",
reset.c:                     *num, objname, tReset->arg1, mobname, tReset->arg2 );
reset.c:            if( tReset->first_reset )
reset.c:               for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
reset.c:                  switch( gReset->command )
reset.c:                        if( !( obj2 = get_obj_index( gReset->arg1 ) ) )
reset.c:                           strncpy( objname, obj2->name, MAX_STRING_LENGTH );
reset.c:                        if( gReset->arg3 > 0 && ( obj = get_obj_index( gReset->arg3 ) ) == NULL )
reset.c:                           strncpy( roomname, obj->name, MAX_STRING_LENGTH );
reset.c:                        snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (put) %s (%d) -> %s (%d) [%d]\r\n",
reset.c:                           *num, objname, gReset->arg1, roomname, obj ? obj->vnum : gReset->arg3, gReset->arg2 );
reset.c:         if( !( obj = get_obj_index( pReset->arg1 ) ) )
reset.c:            strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:         room = get_room_index( pReset->arg3 );
reset.c:            strncpy( roomname, room->name, MAX_STRING_LENGTH );
reset.c:         snprintf( buf, MAX_STRING_LENGTH, "%2d) (object) %s (%d) -> %s Room: %d [%d]\r\n",
reset.c:            *num, objname, pReset->arg1, roomname, pReset->arg3, pReset->arg2 );
reset.c:         for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
reset.c:            switch( tReset->command )
reset.c:                  if( !( obj2 = get_obj_index( tReset->arg1 ) ) )
reset.c:                     strncpy( objname, obj2->name, MAX_STRING_LENGTH );
reset.c:                  if( tReset->arg3 > 0 && ( obj = get_obj_index( tReset->arg3 ) ) == NULL )
reset.c:                     strncpy( roomname, obj->name, MAX_STRING_LENGTH );
reset.c:                  snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (put) %s (%d) -> %s (%d) [%d]\r\n",
reset.c:                     *num, objname, tReset->arg1, roomname, obj ? obj->vnum : tReset->arg3, tReset->arg2 );
reset.c:                  snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (trap) %d %d %d %d (%s) -> %s (%d)\r\n",
reset.c:                     *num, tReset->extra, tReset->arg1, tReset->arg2, tReset->arg3, flag_string( tReset->extra, trap_flags ),
reset.c:                     objname, obj ? obj->vnum : 0 );
reset.c:                  snprintf( buf+strlen(buf), MAX_STRING_LENGTH-strlen(buf), "%2d) (hide) -> %s\r\n", *num, objname );
reset.c:         if( pReset->arg2 < 0 || pReset->arg2 > MAX_DIR + 1 )
reset.c:            pReset->arg2 = 0;
reset.c:         if( !( room = get_room_index( pReset->arg1 ) ) )
reset.c:            snprintf( objname, MAX_STRING_LENGTH, "%s (no exit)", dir_name[pReset->arg2] );
reset.c:            strncpy( roomname, room->name, MAX_STRING_LENGTH );
reset.c:            snprintf( objname, MAX_STRING_LENGTH, "%s%s", dir_name[pReset->arg2], get_exit( room, pReset->arg2 ) ? "" : " (NO EXIT!)" );
reset.c:         switch ( pReset->arg3 )
reset.c:                   *num, mobname, pReset->arg3, objname, pReset->arg2, roomname, pReset->arg1 );
reset.c:         if( !( room = get_room_index( pReset->arg1 ) ) )
reset.c:            strncpy( roomname, room->name, MAX_STRING_LENGTH );
reset.c:         snprintf( buf, MAX_STRING_LENGTH, "%2d) Randomize exits 0 to %d -> %s (%d)\r\n", *num, pReset->arg2, roomname, pReset->arg1 );
reset.c:         if( !( room = get_room_index( pReset->arg3 ) ) )
reset.c:            strncpy( roomname, room->name, MAX_STRING_LENGTH );
reset.c:         snprintf( buf, MAX_STRING_LENGTH, "%2d) Trap: %d %d %d %d (%s) -> %s (%d)\r\n",
reset.c:            *num, pReset->extra, pReset->arg1, pReset->arg2, pReset->arg3, flag_string( pReset->extra, trap_flags ),
reset.c:            roomname, room ? room->vnum : 0 );
reset.c: * Create a new reset (for online building) - Thoric
reset.c:   pReset->command	= letter;
reset.c:   pReset->extra	= extra;
reset.c:   pReset->arg1	= arg1;
reset.c:   pReset->arg2	= arg2;
reset.c:   pReset->arg3	= arg3;
reset.c:   if( ( cm == 'O' || cm == 'P' ) && obj->pIndexData->vnum == OBJ_VNUM_TRAP )
reset.c:         add_reset( room, 'T', obj->value[3], obj->value[1], obj->value[0], v3 );
reset.c:   add_reset( room, cm, ( cm == 'P' ? iNest : 0 ), obj->pIndexData->vnum, v2, v3 );
reset.c:   for( inobj = obj->first_content; inobj; inobj = inobj->next_content )
reset.c:      if( inobj->pIndexData->vnum == OBJ_VNUM_TRAP )
reset.c:   for( inobj = obj->first_content; inobj; inobj = inobj->next_content )
reset.c:      add_obj_reset( room, 'P', inobj, inobj->count, obj->pIndexData->vnum );
reset.c:      iNest--;
reset.c:   for( tReset = pReset->first_reset; tReset; tReset = tReset_next )
reset.c:      tReset_next = tReset->next_reset;
reset.c:      UNLINK( tReset, pReset->first_reset, pReset->last_reset, next_reset, prev_reset );
reset.c:   pReset->first_reset = pReset->last_reset = NULL;
reset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:      add_reset( pRoom, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:         if( obj->wear_loc == WEAR_NONE )
reset.c:            add_obj_reset( pRoom, 'E', obj, 1, obj->wear_loc );
reset.c:   for( obj = pRoom->first_content; obj; obj = obj->next_content )
reset.c:      add_obj_reset( pRoom, 'O', obj, obj->count, pRoom->vnum );
reset.c:      for( pexit = pRoom->first_exit; pexit; pexit = pexit->next )
reset.c:         if( !IS_SET( pexit->exit_info, EX_ISDOOR ) )
reset.c:         if( IS_SET( pexit->exit_info, EX_CLOSED ) )
reset.c:            if( IS_SET( pexit->exit_info, EX_LOCKED ) )
reset.c:         add_reset( pRoom, 'D', 0, pRoom->vnum, pexit->vdir, state );
reset.c:   for( pReset = room->first_reset; pReset; pReset = pReset_next )
reset.c:      pReset_next = pReset->next;
reset.c:      UNLINK( pReset, room->first_reset, room->last_reset, next, prev );
reset.c:   room->first_reset = room->last_reset = NULL;
reset.c:      for( room = area->first_room; room; room = room->next_aroom )
reset.c:/* Function modified from original form - Samson */
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   if( !can_rmodify( ch, ch->in_room ) )
reset.c:   if( ch->in_room->area != ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER )
reset.c:   if( ch->in_room->first_reset )
reset.c:      wipe_resets( ch->in_room );
reset.c:   instaroom( ch, ch->in_room, dodoors );
reset.c:/* Function modified from original form - Samson */
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   pArea = ch->pcdata->area;
reset.c:   for( pRoom = pArea->first_room; pRoom; pRoom = pRoom->next_aroom )
reset.c:   int min = UMAX( pArea->low_soft_range, 1 );
reset.c:   int max = UMIN( pArea->hi_soft_range, min + 15 );
reset.c:   if( pObjIndex->level > 0 )
reset.c:      olevel = UMIN( pObjIndex->level, MAX_LEVEL );
reset.c:      switch ( pObjIndex->item_type )
reset.c:            olevel = pObjIndex->value[0];
reset.c:   for( obj = list; obj; obj = obj->next_content )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:         if( obj->count > 1 )
reset.c:            nMatch += obj->count;
reset.c:   const char *filename = room->area->filename;
reset.c:   if( !room->first_reset )
reset.c:   for( pReset = room->first_reset; pReset; pReset = pReset->next )
reset.c:      switch ( pReset->command )
reset.c:            bug( "%s: %s: bad command %c.", __FUNCTION__, filename, pReset->command );
reset.c:            if( !( pMobIndex = get_mob_index( pReset->arg1 ) ) )
reset.c:               bug( "%s: %s: 'M': bad mob vnum %d.", __FUNCTION__, filename, pReset->arg1 );
reset.c:            if( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
reset.c:               bug( "%s: %s: 'M': bad room vnum %d.", __FUNCTION__, filename, pReset->arg3 );
reset.c:            if( !pReset->sreset )
reset.c:               ROOM_INDEX_DATA *pRoomPrev = get_room_index( pReset->arg3 - 1 );
reset.c:               if( pRoomPrev && IS_SET( pRoomPrev->room_flags, ROOM_PET_SHOP ) )
reset.c:                  SET_BIT( mob->act, ACT_PET );
reset.c:               SET_BIT( mob->affected_by, AFF_INFRARED );
reset.c:            mob->resetvnum = pRoomIndex->vnum;
reset.c:            mob->resetnum = onreset;
reset.c:            pReset->sreset = FALSE;
reset.c:            level = URANGE( 0, mob->top_level - 2, LEVEL_AVATAR );
reset.c:            if( pReset->first_reset )
reset.c:               for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
reset.c:                  switch( tReset->command )
reset.c:                        if( !( pObjIndex = get_obj_index( tReset->arg1 ) ) )
reset.c:                           bug( "%s: %s: 'E' or 'G': bad obj vnum %d.", __FUNCTION__, filename, tReset->arg1 );
reset.c:                        if( mob->pIndexData->pShop )
reset.c:                           int olevel = generate_itemlevel( room->area, pObjIndex );
reset.c:                           SET_BIT( obj->extra_flags, ITEM_INVENTORY );
reset.c:                        obj->level = URANGE( 0, obj->level, LEVEL_AVATAR );
reset.c:                        if( tReset->command == 'E' )
reset.c:                           if( obj->carried_by != mob )
reset.c:                              bug( "'E' reset: can't give object %d to mob %d.", obj->pIndexData->vnum, mob->pIndexData->vnum );
reset.c:                           equip_char( mob, obj, tReset->arg3 );
reset.c:                        if( tReset->first_reset )
reset.c:                           for( gReset = tReset->first_reset; gReset; gReset = gReset->next_reset )
reset.c:                              switch( gReset->command )
reset.c:                                    SET_BIT( lastobj->extra_flags, ITEM_HIDDEN );
reset.c:                                    if( !( pObjIndex = get_obj_index( gReset->arg1 ) ) )
reset.c:                                       bug( "%s: %s: 'P': bad obj vnum %d.", __FUNCTION__, filename, gReset->arg1 );
reset.c:                                    iNest = gReset->extra;
reset.c:                                    if( !( pObjToIndex = get_obj_index( gReset->arg3 ) ) )
reset.c:                                       bug( "%s: %s: 'P': bad objto vnum %d.", __FUNCTION__, filename, gReset->arg3 );
reset.c:                                    if( count_obj_list( pObjIndex, to_obj->first_content ) > 0 )
reset.c:                                    obj = create_object( pObjIndex, number_fuzzy( UMAX( generate_itemlevel( room->area, pObjIndex ), to_obj->level ) ) );
reset.c:                                       pObjIndex->count += ( num - 1 );
reset.c:                                    obj->count = gReset->arg2;
reset.c:                                    obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:                                    obj->count = gReset->arg2;
reset.c:                                    if( gReset->arg3 == OBJ_VNUM_MONEY_ONE )
reset.c:                                       gReset->arg3 = to_obj->pIndexData->vnum;
reset.c:            if( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )
reset.c:               bug( "%s: %s: 'O': bad obj vnum %d.", __FUNCTION__, filename, pReset->arg1 );
reset.c:            if( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
reset.c:               bug( "%s: %s: 'O': bad room vnum %d.", __FUNCTION__, filename, pReset->arg3 );
reset.c:            if( count_obj_list( pObjIndex, pRoomIndex->first_content ) < 1 )
reset.c:               obj = create_object( pObjIndex, number_fuzzy( generate_itemlevel( room->area, pObjIndex ) ) );
reset.c:                  pObjIndex->count += ( num - 1 );
reset.c:               obj->count = pReset->arg2;
reset.c:               obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:               obj->cost = 0;
reset.c:               obj->extra_flags = pObjIndex->extra_flags;
reset.c:                  obj->value[x] = pObjIndex->value[x];
reset.c:            if( pReset->first_reset )
reset.c:               for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
reset.c:                  switch( tReset->command )
reset.c:                        SET_BIT( lastobj->extra_flags, ITEM_HIDDEN );
reset.c:                        if( !IS_SET( tReset->extra, TRAP_OBJ ) )
reset.c:                           if( tReset->arg3 > 0 )
reset.c:                              if( !( pObjToIndex = get_obj_index( tReset->arg3 ) ) )
reset.c:                                 bug( "%s: %s: 'T': bad objto vnum %d.", __FUNCTION__, filename, tReset->arg3 );
reset.c:                              if( room->area->nplayer > 0 || !( to_obj = get_obj_type( pObjToIndex ) ) ||
reset.c:                                ( to_obj->carried_by && !IS_NPC( to_obj->carried_by ) ) || is_trapped( to_obj ) )
reset.c:                           pobj = make_trap( tReset->arg2, tReset->arg1, number_fuzzy( to_obj->level ), tReset->extra );
reset.c:                        if( !( pObjIndex = get_obj_index( tReset->arg1 ) ) )
reset.c:                           bug( "%s: %s: 'P': bad obj vnum %d.", __FUNCTION__, filename, tReset->arg1 );
reset.c:                        iNest = tReset->extra;
reset.c:                        if( !( pObjToIndex = get_obj_index( tReset->arg3 ) ) )
reset.c:                           bug( "%s: %s: 'P': bad objto vnum %d.", __FUNCTION__, filename, tReset->arg3 );
reset.c:                           bug( "%s: %s: 'P': Exceeded nesting limit of %d. Room %d.", __FUNCTION__, filename, MAX_NEST, room->vnum );
reset.c:                        if( count_obj_list( pObjIndex, to_obj->first_content ) > 0 )
reset.c:                        obj = create_object( pObjIndex, number_fuzzy( UMAX( generate_itemlevel( room->area, pObjIndex ), to_obj->level ) ) );
reset.c:                           pObjIndex->count += ( num - 1 );
reset.c:                        obj->count = tReset->arg2;
reset.c:                        obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:                        obj->count = tReset->arg2;
reset.c:                        if( tReset->arg3 == OBJ_VNUM_MONEY_ONE )
reset.c:                           tReset->arg3 = to_obj->pIndexData->vnum;
reset.c:            if( IS_SET( pReset->extra, TRAP_OBJ ) )
reset.c:               bug( "%s: Object trap found in room %d reset list", __FUNCTION__, room->vnum );
reset.c:               if( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )
reset.c:                  bug( "%s: %s: 'T': bad room %d.", __FUNCTION__, filename, pReset->arg3 );
reset.c:               if( room->area->nplayer > 0 || count_obj_list( get_obj_index( OBJ_VNUM_TRAP ), pRoomIndex->first_content ) > 0 )
reset.c:               to_obj = make_trap( pReset->arg1, pReset->arg1, 10, pReset->extra );
reset.c:            if( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
reset.c:               bug( "%s: %s: 'D': bad room vnum %d.", __FUNCTION__, filename, pReset->arg1 );
reset.c:            if( !( pexit = get_exit( pRoomIndex, pReset->arg2 ) ) )
reset.c:            switch ( pReset->arg3 )
reset.c:                  REMOVE_BIT( pexit->exit_info, EX_CLOSED );
reset.c:                  REMOVE_BIT( pexit->exit_info, EX_LOCKED );
reset.c:                  SET_BIT( pexit->exit_info, EX_CLOSED );
reset.c:                  REMOVE_BIT( pexit->exit_info, EX_LOCKED );
reset.c:                  if( IS_SET( pexit->exit_info, EX_xSEARCHABLE ) )
reset.c:                     SET_BIT( pexit->exit_info, EX_SECRET );
reset.c:                  SET_BIT( pexit->exit_info, EX_CLOSED );
reset.c:                  SET_BIT( pexit->exit_info, EX_LOCKED );
reset.c:                  if( IS_SET( pexit->exit_info, EX_xSEARCHABLE ) )
reset.c:                     SET_BIT( pexit->exit_info, EX_SECRET );
reset.c:            if( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )
reset.c:               bug( "%s: %s: 'R': bad room vnum %d.", __FUNCTION__, filename, pReset->arg1 );
reset.c:            randomize_exits( pRoomIndex, pReset->arg2 - 1 );
reset.c:   if( !area->first_room )
reset.c:   for( room = area->first_room; room; room = room->next_aroom )
reset.c:   for( pReset = room->first_reset; pReset; pReset = pReset->next )
reset.c:      switch( pReset->command )
reset.c:            for( tReset = pReset->first_reset; tReset; tReset = tReset->next_reset )
reset.c:               switch( tReset->command )
reset.c:                     if( tReset->arg3 == 0 )
reset.c:                           tReset->extra = 1000000;
reset.c:                        else if( lastobj->command != 'P' || lastobj->arg3 > 0 )
reset.c:                           tReset->extra = 0;
reset.c:                           tReset->extra = lastobj->extra + 1;
reset.c: * Add a reset to an area -Thoric
reset.c:   pReset->sreset = TRUE;
reset.c:         room->last_mob_reset = pReset;
reset.c:         if( !room->last_mob_reset )
reset.c:         room->last_obj_reset = pReset;
reset.c:         LINK( pReset, room->last_mob_reset->first_reset, room->last_mob_reset->last_reset, next_reset, prev_reset );
reset.c:         if( !room->last_obj_reset )
reset.c:         LINK( pReset, room->last_obj_reset->first_reset, room->last_obj_reset->last_reset, next_reset, prev_reset );
reset.c:         room->last_obj_reset = pReset;
reset.c:            pReset->prev_reset = NULL;
reset.c:            pReset->next_reset = room->last_obj_reset->first_reset;
reset.c:            if( room->last_obj_reset->first_reset )
reset.c:               room->last_obj_reset->first_reset->prev_reset = pReset;
reset.c:            room->last_obj_reset->first_reset = pReset;
reset.c:            if( !room->last_obj_reset->last_reset )
reset.c:               room->last_obj_reset->last_reset = pReset;
reset.c:         pReset->prev_reset = NULL;
reset.c:         pReset->next_reset = room->last_obj_reset->first_reset;
reset.c:         if( room->last_obj_reset->first_reset )
reset.c:            room->last_obj_reset->first_reset->prev_reset = pReset;
reset.c:         room->last_obj_reset->first_reset = pReset;
reset.c:         if( !room->last_obj_reset->last_reset )
reset.c:            room->last_obj_reset->last_reset = pReset;
reset.c:   LINK( pReset, room->first_reset, room->last_reset, next, prev );
reset.c:   for( pReset = room->first_reset; pReset; pReset = pReset->next )
reset.c:      if( pReset->command != 'O' )
reset.c:      if( !( pobj = get_obj_index( pReset->arg1 ) ) )
reset.c:      if( is_name( arg, pobj->name ) && ++cnt == num )
reset.c:      reset_area( ch->in_room->area );
reset.c:      for( pReset = ch->in_room->first_reset; pReset; pReset = pReset_next )
reset.c:         pReset_next = pReset->next;
reset.c:            UNLINK( pReset, ch->in_room->first_reset, ch->in_room->last_reset, next, prev );
reset.c:         for( tReset = pReset->first_reset; tReset; tReset = tReset_next )
reset.c:            tReset_next = tReset->next_reset;
reset.c:               UNLINK( tReset, pReset->first_reset, pReset->last_reset, next_reset, prev_reset );
reset.c:            for( gReset = tReset->first_reset; gReset; gReset = gReset_next )
reset.c:               gReset_next = gReset->next_reset;
reset.c:                  UNLINK( gReset, tReset->first_reset, tReset->last_reset, next_reset, prev_reset );
reset.c:      pReset = make_reset( 'R', 0, ch->in_room->vnum, vnum, 0 );
reset.c:      pReset->prev = NULL;
reset.c:      pReset->next = ch->in_room->first_reset;
reset.c:      if( ch->in_room->first_reset )
reset.c:         ch->in_room->first_reset->prev = pReset;
reset.c:      ch->in_room->first_reset = pReset;
reset.c:      if( !ch->in_room->last_reset )
reset.c:         ch->in_room->last_reset = pReset;
reset.c:         vnum = ch->in_room->vnum;
reset.c:         num = is_number( arg ) ? atoi( arg ) : -1;
reset.c:         chrg = is_number( arg ) ? atoi( arg ) : -1;
reset.c:         if( !( pReset = find_oreset( ch->in_room, oname ) ) )
reset.c:         num = is_number( arg ) ? atoi( arg ) : -1;
reset.c:         chrg = is_number( arg ) ? atoi( arg ) : -1;
reset.c:         tReset->prev_reset = NULL;
reset.c:         tReset->next_reset = pReset->first_reset;
reset.c:         if( pReset->first_reset )
reset.c:            pReset->first_reset->prev_reset = tReset;
reset.c:         pReset->first_reset = tReset;
reset.c:         if( !pReset->last_reset )
reset.c:            pReset->last_reset = tReset;
reset.c:         tReset->prev = NULL;
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:      if( !( pReset = find_oreset( ch->in_room, argument ) ) )
reset.c:         tReset->prev_reset = NULL;
reset.c:         tReset->next_reset = pReset->first_reset;
reset.c:         if( pReset->first_reset )
reset.c:            pReset->first_reset->prev_reset = tReset;
reset.c:         pReset->first_reset = tReset;
reset.c:         if( !pReset->last_reset )
reset.c:            pReset->last_reset = tReset;
reset.c:         tReset->prev = NULL;
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:   if( !( room = get_room_index( ch->resetvnum ) ) )
reset.c:   for( pReset = room->first_reset; pReset; pReset = pReset_next )
reset.c:      pReset_next = pReset->next;
reset.c:      if( ++nfind == ch->resetnum )
reset.c:         pReset->sreset = setting;
reset.c:      for( tReset = pReset->first_reset; tReset; tReset = tReset_next )
reset.c:         tReset_next = tReset->next_reset;
reset.c:         if( ++nfind == ch->resetnum )
reset.c:            tReset->sreset = setting;
reset.c:         for( gReset = tReset->first_reset; gReset; gReset = gReset_next )
reset.c:            gReset_next = gReset->next_reset;
reset.c:            if( ++nfind == ch->resetnum )
reset.c:               gReset->sreset = setting;
Binary file resolver matches
resolver.c: *                   ^     +----- |  / ^     ^ |     | +-\                  *
resolver.c: *                 /   \   +---   |<   | \ / | |     | |  |                 *
resolver.c: *                /-----\  |      | \  |  v  | |     | |  /                 *
resolver.c: *               /       \ |      |  \ |     | +-----+ +-/                  *
resolver.c: * AFKMud Copyright 1997-2002 Alsherok. Contributors: Samson, Dwip, Whir,   *
resolver.c:    	strcmp( from->h_name, "localhost" ) ? from->h_name : "local-host" );
Binary file resolver.o matches
save.c:*--------------------------------------------------------------------------*
save.c:* -------------------------------------------------------------------------*
save.c:*--------------------------------------------------------------------------*
save.c:* ------------------------------------------------------------------------ *
save.c:* ------------------------------------------------------------------------ *
save.c: * Array to keep track of equipment temporarily.		-Thoric
save.c: * Array of containers read for proper re-nesting of objects.
save.c:   if( ch->plr_home )
save.c:      sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:         templvl = ch->top_level;
save.c:         ch->top_level = LEVEL_HERO;   /* make sure EQ doesn't get lost */
save.c:         contents = ch->plr_home->last_content;
save.c:         ch->top_level = templvl;
save.c: * Un-equip character before saving to ensure proper	-Thoric
save.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:      if( obj->wear_loc > -1 && obj->wear_loc < MAX_WEAR )
save.c:            if( !save_equipment[obj->wear_loc][x] )
save.c:               save_equipment[obj->wear_loc][x] = obj;
save.c:                     ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c: * Re-equip character					-Thoric
save.c:   if( !IS_NPC( ch ) && ch->pcdata->clan )
save.c:      save_clan( ch->pcdata->clan );
save.c:   if( ch->desc && ch->desc->original )
save.c:      ch = ch->desc->original;
save.c:   ch->save_time = current_time;
save.c:   sprintf( strsave, "%s%c/%s", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:    * Auto-backup pfile (can cause lag with high disk access situtations
save.c:      sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:    * Save immortal stats, level & vnums for wizlist    -Thoric
save.c:      sprintf( strback, "%s%s", GOD_DIR, capitalize( ch->name ) );
save.c:         fprintf( fp, "Level        %d\n", ch->top_level );
save.c:         fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:      if( ch->first_carrying )
save.c:         fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY, ch->pcdata->hotboot );
save.c:      if( ch->comments )   /* comments */
save.c:   if( ch->desc && ch->desc->original )
save.c:      ch = ch->desc->original;
save.c:   ch->save_time = current_time;
save.c:   sprintf( strsave, "%s%c/%s.clone", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:    * Auto-backup pfile (can cause lag with high disk access situtations
save.c:      sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:      if( ch->comments )   /* comments */
save.c:   fprintf( fp, "Name         %s~\n", ch->name );
save.c:   if( ch->short_descr && ch->short_descr[0] != '\0' )
save.c:      fprintf( fp, "ShortDescr   %s~\n", ch->short_descr );
save.c:   if( ch->long_descr && ch->long_descr[0] != '\0' )
save.c:      fprintf( fp, "LongDescr    %s~\n", ch->long_descr );
save.c:   if( ch->description && ch->description[0] != '\0' )
save.c:      fprintf( fp, "Description  %s~\n", ch->description );
save.c:   fprintf( fp, "Sex          %d\n", ch->sex );
save.c:   fprintf( fp, "Race         %d\n", ch->race );
save.c:   fprintf( fp, "MainAbility  %d\n", ch->main_ability );
save.c:   fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:   fprintf( fp, "Toplevel     %d\n", ch->top_level );
save.c:   if( ch->trust )
save.c:      fprintf( fp, "Trust        %d\n", ch->trust );
save.c:   fprintf( fp, "Textcolor     %d\n", ch->textcolor );
save.c:   fprintf( fp, "Played       %d\n", ch->played + ( int )( current_time - ch->logon ) );
save.c:            ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:              && ch->was_in_room ) ? ch->was_in_room->vnum : ch->in_room->vnum );
save.c:   if( ch->plr_home != NULL )
save.c:      fprintf( fp, "PlrHome      %d\n", ch->plr_home->vnum );
save.c:   fprintf( fp, "HpManaMove   %d %d 0 0 %d %d\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
save.c:   fprintf( fp, "Force        %d %d %d %d\n", ch->perm_frc, ch->mod_frc, ch->mana, ch->max_mana );
save.c:   fprintf( fp, "Gold         %d\n", ch->gold );
save.c:   fprintf( fp, "Bank         %ld\n", ch->pcdata->bank );
save.c:         fprintf( fp, "Ability        %d %d %ld\n", ability, ch->skill_level[ability], ch->experience[ability] );
save.c:   if( ch->act )
save.c:      fprintf( fp, "Act          %d\n", ch->act );
save.c:   if( ch->affected_by )
save.c:      fprintf( fp, "AffectedBy   %d\n", ch->affected_by );
save.c:   fprintf( fp, "Position     %d\n", ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:            ch->saving_poison_death, ch->saving_wand, ch->saving_para_petri, ch->saving_breath, ch->saving_spell_staff );
save.c:   fprintf( fp, "Alignment    %d\n", ch->alignment );
save.c:   fprintf( fp, "Glory        %d\n", ch->pcdata->quest_curr );
save.c:   fprintf( fp, "MGlory       %d\n", ch->pcdata->quest_accum );
save.c:   fprintf( fp, "Hitroll      %d\n", ch->hitroll );
save.c:   fprintf( fp, "Damroll      %d\n", ch->damroll );
save.c:   fprintf( fp, "Armor        %d\n", ch->armor );
save.c:   if( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n", ch->wimpy );
save.c:   if( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n", ch->deaf );
save.c:   if( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n", ch->resistant );
save.c:   if( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n", ch->immune );
save.c:   if( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n", ch->susceptible );
save.c:   if( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n", ch->pcdata->outcast_time );
save.c:   if( ch->pcdata && ch->pcdata->restore_time )
save.c:      fprintf( fp, "Restore_time %ld\n", ch->pcdata->restore_time );
save.c:   if( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n", ch->mental_state );
save.c:      fprintf( fp, "Vnum         %d\n", ch->pIndexData->vnum );
save.c:      fprintf( fp, "Mobinvis     %d\n", ch->mobinvis );
save.c:      fprintf( fp, "Password     %s~\n", ch->pcdata->pwd );
save.c:      if( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:         fprintf( fp, "Bamfin       %s~\n", ch->pcdata->bamfin );
save.c:      if( ch->pcdata->email && ch->pcdata->email[0] != '\0' )
save.c:         fprintf( fp, "Email       %s~\n", ch->pcdata->email );
save.c:      if( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:         fprintf( fp, "Bamfout      %s~\n", ch->pcdata->bamfout );
save.c:      if( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c:         fprintf( fp, "Rank         %s~\n", ch->pcdata->rank );
save.c:      if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:         fprintf( fp, "Bestowments  %s~\n", ch->pcdata->bestowments );
save.c:      fprintf( fp, "Title        %s~\n", ch->pcdata->title );
save.c:      if( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:         fprintf( fp, "Homepage     %s~\n", ch->pcdata->homepage );
save.c:      if( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:         fprintf( fp, "Bio          %s~\n", ch->pcdata->bio );
save.c:      if( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:         fprintf( fp, "AuthedBy     %s~\n", ch->pcdata->authed_by );
save.c:      if( ch->pcdata->min_snoop )
save.c:         fprintf( fp, "Minsnoop     %d\n", ch->pcdata->min_snoop );
save.c:      if( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:         fprintf( fp, "Prompt       %s~\n", ch->pcdata->prompt );
save.c:      if( ch->pcdata->pilotprompt && *ch->pcdata->pilotprompt )
save.c:         fprintf( fp, "PilotPrompt       %s~\n", ch->pcdata->pilotprompt );
save.c:      if( ch->pcdata->pagerlen != 24 )
save.c:         fprintf( fp, "Pagerlen     %d\n", ch->pcdata->pagerlen );
save.c:         fprintf( fp, " %d", ch->pcdata->addiction[drug] );
save.c:         fprintf( fp, " %d", ch->pcdata->drug_level[drug] );
save.c:      if( ch->pcdata->wanted_flags )
save.c:         fprintf( fp, "Wanted       %d\n", ch->pcdata->wanted_flags );
save.c:      if( IS_IMMORTAL( ch ) || ch->pcdata->area )
save.c:         fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:      if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:         fprintf( fp, "Clan         %s~\n", ch->pcdata->clan_name );
save.c:      fprintf( fp, "Flags        %d\n", ch->pcdata->flags );
save.c:      if( ch->pcdata->release_date > current_time )
save.c:         fprintf( fp, "Helled       %d %s~\n", ( int )ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:      if( ch->pcdata->pkills )
save.c:         fprintf( fp, "PKills       %d\n", ch->pcdata->pkills );
save.c:      if( ch->pcdata->pdeaths )
save.c:         fprintf( fp, "PDeaths      %d\n", ch->pcdata->pdeaths );
save.c:      fprintf( fp, "MKills       %d\n", ch->pcdata->mkills );
save.c:      fprintf( fp, "MDeaths      %d\n", ch->pcdata->mdeaths );
save.c:      if( ch->pcdata->illegal_pk )
save.c:         fprintf( fp, "IllegalPK    %d\n", ch->pcdata->illegal_pk );
save.c:               ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
save.c:               ch->mod_str, ch->mod_int, ch->mod_wis, ch->mod_dex, ch->mod_con, ch->mod_cha, ch->mod_lck );
save.c:               ch->pcdata->condition[0], ch->pcdata->condition[1], ch->pcdata->condition[2], ch->pcdata->condition[3] );
save.c:      if( ch->desc && ch->desc->host )
save.c:         fprintf( fp, "Site         %s\n", ch->desc->host );
save.c:         fprintf( fp, "Site         (Link-Dead)\n" );
save.c:         if( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:            switch ( skill_table[sn]->type )
save.c:                  fprintf( fp, "Skill        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:                  fprintf( fp, "Spell        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:                  fprintf( fp, "Weapon       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:                  fprintf( fp, "Tongue       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
save.c:      if( paf->type >= 0 && ( skill = get_skilltype( paf->type ) ) == NULL )
save.c:      if( paf->type >= 0 && paf->type < TYPE_PERSONAL )
save.c:                  skill->name, paf->duration, paf->modifier, paf->location, paf->bitvector );
save.c:                  paf->type, paf->duration, paf->modifier, paf->location, paf->bitvector );
save.c:   track = URANGE( 2, ( ( ch->top_level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:      if( ch->pcdata->killed[sn].vnum == 0 )
save.c:      fprintf( fp, "Killed       %d %d\n", ch->pcdata->killed[sn].vnum, ch->pcdata->killed[sn].count );
save.c:    * Save color values - Samson 9-29-98 
save.c:         fprintf( fp, "%d ", ch->colors[x] );
save.c:   if( obj->prev_content && os_type != OS_CORPSE )
save.c:      fwrite_obj( ch, obj->prev_content, fp, iNest, OS_CARRY, hotboot );
save.c:      if( obj->item_type == ITEM_KEY && !IS_OBJ_STAT( obj, ITEM_CLANOBJECT ) )
save.c:    * Catch deleted objects              -Thoric
save.c:    * Do NOT save prototype items!          -Thoric
save.c:    * DO NOT save corpses lying on the ground as a hotboot item, they already saved elsewhere! - Samson 
save.c:   if( hotboot && obj->item_type == ITEM_CORPSE_PC )
save.c:    * Corpse saving. -- Altrag 
save.c:   if( obj->count > 1 )
save.c:      fprintf( fp, "Count        %d\n", obj->count );
save.c:   if( obj->name && ( !obj->pIndexData->name  || str_cmp( obj->name, obj->pIndexData->name ) ) )
save.c:      fprintf( fp, "Name         %s~\n", obj->name );
save.c:   if( obj->short_descr && ( !obj->pIndexData->short_descr || str_cmp( obj->short_descr, obj->pIndexData->short_descr ) ) )
save.c:      fprintf( fp, "ShortDescr   %s~\n", obj->short_descr );
save.c:   if( obj->description && ( !obj->pIndexData->description || str_cmp( obj->description, obj->pIndexData->description ) ) )
save.c:      fprintf( fp, "Description  %s~\n", obj->description );
save.c:   if( obj->action_desc && ( !obj->pIndexData->action_desc || str_cmp( obj->action_desc, obj->pIndexData->action_desc ) ) )
save.c:      fprintf( fp, "ActionDesc   %s~\n", obj->action_desc );
save.c:   fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum );
save.c:   if( ( os_type == OS_CORPSE || hotboot ) && obj->in_room )
save.c:      fprintf( fp, "Room         %d\n", obj->in_room->vnum );
save.c:      fprintf( fp, "Rvnum	   %d\n", obj->room_vnum );
save.c:   if( obj->extra_flags != obj->pIndexData->extra_flags )
save.c:      fprintf( fp, "ExtraFlags   %d\n", obj->extra_flags );
save.c:   if( obj->wear_flags != obj->pIndexData->wear_flags )
save.c:      fprintf( fp, "WearFlags    %d\n", obj->wear_flags );
save.c:   wear_loc = -1;
save.c:   if( wear_loc != -1 )
save.c:   if( obj->item_type != obj->pIndexData->item_type )
save.c:      fprintf( fp, "ItemType     %d\n", obj->item_type );
save.c:   if( obj->weight != obj->pIndexData->weight )
save.c:      fprintf( fp, "Weight       %d\n", obj->weight );
save.c:   if( obj->level )
save.c:      fprintf( fp, "Level        %d\n", obj->level );
save.c:   if( obj->timer )
save.c:      fprintf( fp, "Timer        %d\n", obj->timer );
save.c:   if( obj->cost != obj->pIndexData->cost )
save.c:      fprintf( fp, "Cost         %d\n", obj->cost );
save.c:   if( obj->value[0] || obj->value[1] || obj->value[2] || obj->value[3] || obj->value[4] || obj->value[5] )
save.c:               obj->value[0], obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5] );
save.c:   switch ( obj->item_type )
save.c:      case ITEM_PILL:  /* was down there with staff and wand, wrongly - Scryn */
save.c:         if( IS_VALID_SN( obj->value[1] ) )
save.c:            fprintf( fp, "Spell 1      '%s'\n", skill_table[obj->value[1]]->name );
save.c:         if( IS_VALID_SN( obj->value[2] ) )
save.c:            fprintf( fp, "Spell 2      '%s'\n", skill_table[obj->value[2]]->name );
save.c:         if( IS_VALID_SN( obj->value[3] ) )
save.c:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c:         if( IS_VALID_SN( obj->value[3] ) )
save.c:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c:         if( IS_VALID_SN( obj->value[4] ) )
save.c:            fprintf( fp, "Spell 4      '%s'\n", skill_table[obj->value[4]]->name );
save.c:         if( IS_VALID_SN( obj->value[5] ) )
save.c:            fprintf( fp, "Spell 5      '%s'\n", skill_table[obj->value[5]]->name );
save.c:   for( paf = obj->first_affect; paf; paf = paf->next )
save.c:       * Save extra object affects           -Thoric
save.c:      if( paf->type < 0 || paf->type >= top_sn )
save.c:                  paf->type,
save.c:                  paf->duration,
save.c:                  ( ( paf->location == APPLY_WEAPONSPELL
save.c:                      || paf->location == APPLY_WEARSPELL
save.c:                      || paf->location == APPLY_REMOVESPELL
save.c:                      || paf->location == APPLY_STRIPSN )
save.c:                    && IS_VALID_SN( paf->modifier ) )
save.c:                  ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
save.c:                  skill_table[paf->type]->name,
save.c:                  paf->duration,
save.c:                  ( ( paf->location == APPLY_WEAPONSPELL
save.c:                      || paf->location == APPLY_WEARSPELL
save.c:                      || paf->location == APPLY_REMOVESPELL
save.c:                      || paf->location == APPLY_STRIPSN )
save.c:                    && IS_VALID_SN( paf->modifier ) )
save.c:                  ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
save.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
save.c:      fprintf( fp, "ExtraDescr   %s~ %s~\n", ed->keyword, ed->description );
save.c:   if( obj->first_content )
save.c:      fwrite_obj( ch, obj->last_content, fp, iNest + 1, OS_CARRY, hotboot );
save.c:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c:   ch->textcolor = 0;
save.c:   d->character = ch;
save.c:   ch->desc = d;
save.c:   ch->name = STRALLOC( name );
save.c:   ch->act = PLR_BLANK | PLR_COMBINE | PLR_PROMPT;
save.c:   ch->perm_str = 10;
save.c:   ch->perm_int = 10;
save.c:   ch->perm_wis = 10;
save.c:   ch->perm_dex = 10;
save.c:   ch->perm_con = 10;
save.c:   ch->perm_cha = 10;
save.c:   ch->perm_lck = 10;
save.c:   ch->pcdata->condition[COND_THIRST] = 48;
save.c:   ch->pcdata->condition[COND_FULL] = 48;
save.c:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:   ch->pcdata->wizinvis = 0;
save.c:   ch->mental_state = -10;
save.c:   ch->mobinvis = 0;
save.c:      ch->pcdata->learned[i] = 0;
save.c:   ch->pcdata->release_date = 0;
save.c:   ch->pcdata->helled_by = NULL;
save.c:   ch->saving_poison_death = 0;
save.c:   ch->saving_wand = 0;
save.c:   ch->saving_para_petri = 0;
save.c:   ch->saving_breath = 0;
save.c:   ch->saving_spell_staff = 0;
save.c:   ch->comments = NULL; /* comments */
save.c:   ch->pcdata->pagerlen = 24;
save.c:   ch->mob_clan = STRALLOC( "" );
save.c:   ch->was_sentinel = NULL;
save.c:   ch->plr_home = NULL;
save.c:   ch->pcdata->hotboot = FALSE;  /* Never changed except when PC is saved during hotboot save */
save.c:   if( stat( strsave, &fst ) != -1 )
save.c:                  preload ? "Preloading" : "Loading", ch->name, ( int )fst.st_size / 1024 );
save.c:       * Cheat so that bug will show line #'s -- Altrag 
save.c:      ch->short_descr = STRALLOC( "" );
save.c:      ch->long_descr = STRALLOC( "" );
save.c:      ch->description = STRALLOC( "" );
save.c:      ch->editor = NULL;
save.c:      ch->pcdata->clan_name = STRALLOC( "" );
save.c:      ch->pcdata->clan = NULL;
save.c:      ch->pcdata->pwd = str_dup( "" );
save.c:      ch->pcdata->email = str_dup( "" );
save.c:      ch->pcdata->bamfin = str_dup( "" );
save.c:      ch->pcdata->bamfout = str_dup( "" );
save.c:      ch->pcdata->rank = str_dup( "" );
save.c:      ch->pcdata->bestowments = str_dup( "" );
save.c:      ch->pcdata->title = STRALLOC( "" );
save.c:      ch->pcdata->homepage = str_dup( "" );
save.c:      ch->pcdata->bio = STRALLOC( "" );
save.c:      ch->pcdata->authed_by = STRALLOC( "" );
save.c:      ch->pcdata->prompt = STRALLOC( "" );
save.c:      ch->pcdata->pilotprompt = STRALLOC( "" );
save.c:      ch->pcdata->r_range_lo = 0;
save.c:      ch->pcdata->r_range_hi = 0;
save.c:      ch->pcdata->m_range_lo = 0;
save.c:      ch->pcdata->m_range_hi = 0;
save.c:      ch->pcdata->o_range_lo = 0;
save.c:      ch->pcdata->o_range_hi = 0;
save.c:      ch->pcdata->wizinvis = 0;
save.c:      ch->pcdata->wanted_flags = 0;
save.c:      if( !ch->pcdata->clan_name )
save.c:         ch->pcdata->clan_name = STRALLOC( "" );
save.c:         ch->pcdata->clan = NULL;
save.c:      if( !ch->pcdata->bio )
save.c:         ch->pcdata->bio = STRALLOC( "" );
save.c:      if( !ch->pcdata->authed_by )
save.c:         ch->pcdata->authed_by = STRALLOC( "" );
save.c:         if( ch->pcdata->wizinvis < 2 )
save.c:            ch->pcdata->wizinvis = ch->top_level;
save.c:      if( ch->plr_home != NULL )
save.c:    * Setup color values in case player has none set - Samson 
save.c:   memcpy( &ch->colors, &default_set, sizeof( default_set ) );
save.c:            KEY( "Act", ch->act, fread_number( fp ) );
save.c:            KEY( "AffectedBy", ch->affected_by, fread_number( fp ) );
save.c:            KEY( "Alignment", ch->alignment, fread_number( fp ) );
save.c:            KEY( "Armor", ch->armor, fread_number( fp ) );
save.c:               ch->pcdata->addiction[0] = x0;
save.c:               ch->pcdata->addiction[1] = x1;
save.c:               ch->pcdata->addiction[2] = x2;
save.c:               ch->pcdata->addiction[3] = x3;
save.c:               ch->pcdata->addiction[4] = x4;
save.c:               ch->pcdata->addiction[5] = x5;
save.c:               ch->pcdata->addiction[6] = x6;
save.c:               ch->pcdata->addiction[7] = x7;
save.c:               ch->pcdata->addiction[8] = x8;
save.c:               ch->pcdata->addiction[9] = x9;
save.c:                  ch->skill_level[x0] = x1;
save.c:                  ch->experience[x0] = x2;
save.c:                  paf->type = fread_number( fp );
save.c:                  paf->type = sn;
save.c:               paf->duration = fread_number( fp );
save.c:               paf->modifier = fread_number( fp );
save.c:               paf->location = fread_number( fp );
save.c:               paf->bitvector = fread_number( fp );
save.c:               LINK( paf, ch->first_affect, ch->last_affect, next, prev );
save.c:               ch->mod_str = x1;
save.c:               ch->mod_int = x2;
save.c:               ch->mod_wis = x3;
save.c:               ch->mod_dex = x4;
save.c:               ch->mod_con = x5;
save.c:               ch->mod_cha = x6;
save.c:               ch->mod_lck = x7;
save.c:                  ch->mod_lck = 0;
save.c:               ch->perm_str = x1;
save.c:               ch->perm_int = x2;
save.c:               ch->perm_wis = x3;
save.c:               ch->perm_dex = x4;
save.c:               ch->perm_con = x5;
save.c:               ch->perm_cha = x6;
save.c:               ch->perm_lck = x7;
save.c:                  ch->perm_lck = 13;
save.c:            KEY( "AuthedBy", ch->pcdata->authed_by, fread_string( fp ) );
save.c:            KEY( "Bamfin", ch->pcdata->bamfin, fread_string_nohash( fp ) );
save.c:            KEY( "Bamfout", ch->pcdata->bamfout, fread_string_nohash( fp ) );
save.c:            KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:            KEY( "Bio", ch->pcdata->bio, fread_string( fp ) );
save.c:            KEY( "Bank", ch->pcdata->bank, fread_number( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                           ch->pcdata->clan_name );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:                  ch->colors[x] = fread_number( fp );
save.c:               ch->pcdata->condition[0] = x1;
save.c:               ch->pcdata->condition[1] = x2;
save.c:               ch->pcdata->condition[2] = x3;
save.c:               ch->pcdata->condition[3] = x4;
save.c:            KEY( "Damroll", ch->damroll, fread_number( fp ) );
save.c:            KEY( "Deaf", ch->deaf, fread_number( fp ) );
save.c:            KEY( "Description", ch->description, fread_string( fp ) );
save.c:               ch->pcdata->drug_level[0] = x0;
save.c:               ch->pcdata->drug_level[1] = x1;
save.c:               ch->pcdata->drug_level[2] = x2;
save.c:               ch->pcdata->drug_level[3] = x3;
save.c:               ch->pcdata->drug_level[4] = x4;
save.c:               ch->pcdata->drug_level[5] = x5;
save.c:               ch->pcdata->drug_level[6] = x6;
save.c:               ch->pcdata->drug_level[7] = x7;
save.c:               ch->pcdata->drug_level[8] = x8;
save.c:               ch->pcdata->drug_level[9] = x9;
save.c:            KEY( "Flags", ch->pcdata->flags, fread_number( fp ) );
save.c:               ch->perm_frc = x1;
save.c:               ch->mod_frc = x2;
save.c:               ch->mana = x3;
save.c:               ch->max_mana = x4;
save.c:            KEY( "Glory", ch->pcdata->quest_curr, fread_number( fp ) );
save.c:            KEY( "Gold", ch->gold, fread_number( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                           ch->pcdata->clan_name );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:               ch->pcdata->release_date = fread_number( fp );
save.c:               ch->pcdata->helled_by = fread_string( fp );
save.c:               if( ch->pcdata->release_date < current_time )
save.c:                  STRFREE( ch->pcdata->helled_by );
save.c:                  ch->pcdata->helled_by = NULL;
save.c:                  ch->pcdata->release_date = 0;
save.c:            KEY( "Hitroll", ch->hitroll, fread_number( fp ) );
save.c:            KEY( "Homepage", ch->pcdata->homepage, fread_string_nohash( fp ) );
save.c:               ch->hit = x1;
save.c:               ch->max_hit = x2;
save.c:               ch->move = x5;
save.c:               ch->max_move = x6;
save.c:                  ch->perm_frc = number_range( 1, 20 );
save.c:                  ch->max_mana = x4;
save.c:                  ch->mana = x4;
save.c:                  ch->perm_frc = 1;
save.c:                  ch->max_mana = x4;
save.c:            KEY( "IllegalPK", ch->pcdata->illegal_pk, fread_number( fp ) );
save.c:            KEY( "Immune", ch->immune, fread_number( fp ) );
save.c:                  ch->pcdata->killed[killcnt].vnum = fread_number( fp );
save.c:                  ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:            KEY( "LongDescr", ch->long_descr, fread_string( fp ) );
save.c:               ch->speaks = fread_number( fp );
save.c:               ch->speaking = fread_number( fp );
save.c:            KEY( "MainAbility", ch->main_ability, fread_number( fp ) );
save.c:            KEY( "MDeaths", ch->pcdata->mdeaths, fread_number( fp ) );
save.c:            KEY( "Mentalstate", ch->mental_state, fread_number( fp ) );
save.c:            KEY( "MGlory", ch->pcdata->quest_accum, fread_number( fp ) );
save.c:            KEY( "Minsnoop", ch->pcdata->min_snoop, fread_number( fp ) );
save.c:            KEY( "MKills", ch->pcdata->mkills, fread_number( fp ) );
save.c:            KEY( "Mobinvis", ch->mobinvis, fread_number( fp ) );
save.c:               ch->pcdata->m_range_lo = fread_number( fp );
save.c:               ch->pcdata->m_range_hi = fread_number( fp );
save.c:            KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:               ch->pcdata->o_range_lo = fread_number( fp );
save.c:               ch->pcdata->o_range_hi = fread_number( fp );
save.c:            KEY( "Pagerlen", ch->pcdata->pagerlen, fread_number( fp ) );
save.c:            KEY( "Password", ch->pcdata->pwd, fread_string_nohash( fp ) );
save.c:            KEY( "PDeaths", ch->pcdata->pdeaths, fread_number( fp ) );
save.c:            KEY( "PKills", ch->pcdata->pkills, fread_number( fp ) );
save.c:            KEY( "Played", ch->played, fread_number( fp ) );
save.c:            KEY( "Position", ch->position, fread_number( fp ) );
save.c:            KEY( "Prompt", ch->pcdata->prompt, fread_string( fp ) );
save.c:            KEY( "PilotPrompt", ch->pcdata->pilotprompt, fread_string( fp ) );
save.c:               ch->plr_home = get_room_index( fread_number( fp ) );
save.c:               if( !ch->plr_home )
save.c:                  ch->plr_home = NULL;
save.c:            KEY( "Race", ch->race, fread_number( fp ) );
save.c:            KEY( "Rank", ch->pcdata->rank, fread_string_nohash( fp ) );
save.c:            KEY( "Resistant", ch->resistant, fread_number( fp ) );
save.c:            KEY( "Restore_time", ch->pcdata->restore_time, fread_number( fp ) );
save.c:               ch->in_room = get_room_index( fread_number( fp ) );
save.c:               if( !ch->in_room )
save.c:                  ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:               ch->pcdata->r_range_lo = fread_number( fp );
save.c:               ch->pcdata->r_range_hi = fread_number( fp );
save.c:            KEY( "Sex", ch->sex, fread_number( fp ) );
save.c:            KEY( "ShortDescr", ch->short_descr, fread_string( fp ) );
save.c:            KEY( "Susceptible", ch->susceptible, fread_number( fp ) );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_poison_death = ch->saving_wand;
save.c:               ch->saving_para_petri = ch->saving_wand;
save.c:               ch->saving_breath = ch->saving_wand;
save.c:               ch->saving_spell_staff = ch->saving_wand;
save.c:               ch->saving_poison_death = fread_number( fp );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_para_petri = fread_number( fp );
save.c:               ch->saving_breath = fread_number( fp );
save.c:               ch->saving_spell_staff = fread_number( fp );
save.c:                     sn = bsearch_skill_exact( fread_word( fp ), gsn_first_skill, gsn_first_weapon - 1 );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_spell, gsn_first_skill - 1 );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:               if( !ch->short_descr )
save.c:                  ch->short_descr = STRALLOC( "" );
save.c:               if( !ch->long_descr )
save.c:                  ch->long_descr = STRALLOC( "" );
save.c:               if( !ch->description )
save.c:                  ch->description = STRALLOC( "" );
save.c:               if( !ch->pcdata->pwd )
save.c:                  ch->pcdata->pwd = str_dup( "" );
save.c:               if( !ch->pcdata->email )
save.c:                  ch->pcdata->email = str_dup( "" );
save.c:               if( !ch->pcdata->bamfin )
save.c:                  ch->pcdata->bamfin = str_dup( "" );
save.c:               if( !ch->pcdata->bamfout )
save.c:                  ch->pcdata->bamfout = str_dup( "" );
save.c:               if( !ch->pcdata->bio )
save.c:                  ch->pcdata->bio = STRALLOC( "" );
save.c:               if( !ch->pcdata->rank )
save.c:                  ch->pcdata->rank = str_dup( "" );
save.c:               if( !ch->pcdata->bestowments )
save.c:                  ch->pcdata->bestowments = str_dup( "" );
save.c:               if( !ch->pcdata->title )
save.c:                  ch->pcdata->title = STRALLOC( "" );
save.c:               if( !ch->pcdata->homepage )
save.c:                  ch->pcdata->homepage = str_dup( "" );
save.c:               if( !ch->pcdata->authed_by )
save.c:                  ch->pcdata->authed_by = STRALLOC( "" );
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               ch->editor = NULL;
save.c:               killcnt = URANGE( 2, ( ( ch->top_level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:                  ch->pcdata->killed[killcnt].vnum = 0;
save.c:                     if( ch->skill_level[ability] == 0 )
save.c:                        ch->skill_level[ability] = 1;
save.c:               if( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:                   * ch->speaking = LANG_COMMON;      
save.c:                  ch->speaking = race_table[ch->race].language;
save.c:                  ch->speaks = ~0;
save.c:                  if( ch->speaking == 0 )
save.c:                     ch->speaking = ~0;
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:                  hitgain = ( ( int )( current_time - lastplayed ) / 60 );
save.c:                  ch->hit = URANGE( 1, ch->hit + hitgain, ch->max_hit );
save.c:                  ch->move = URANGE( 1, ch->move + hitgain, ch->max_move );
save.c:                  if( ch->skill_level[FORCE_ABILITY] > 1 )
save.c:                     ch->mana = URANGE( 0, ch->mana + hitgain, ch->max_mana );
save.c:                  if( !skill_table[sn]->name )
save.c:                  if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
save.c:                  if( ch->pcdata->learned[sn] > 0 && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
save.c:                     ch->pcdata->learned[sn] = 0;
save.c:            KEY( "Email", ch->pcdata->email, fread_string_nohash( fp ) );
save.c:            KEY( "Toplevel", ch->top_level, fread_number( fp ) );
save.c:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_tongue, gsn_top_sn - 1 );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:            KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:            KEY( "Textcolor", ch->textcolor, fread_number( fp ) );
save.c:             * Let no character be trusted higher than one below maxlevel -- Narn 
save.c:            ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:               ch->pcdata->title = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->title[0] ) || isdigit( ch->pcdata->title[0] ) )
save.c:                  sprintf( buf, " %s", ch->pcdata->title );
save.c:                  if( ch->pcdata->title )
save.c:                     STRFREE( ch->pcdata->title );
save.c:                  ch->pcdata->title = STRALLOC( buf );
save.c:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_weapon, gsn_first_tongue - 1 );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:            KEY( "Wimpy", ch->wimpy, fread_number( fp ) );
save.c:            KEY( "WizInvis", ch->pcdata->wizinvis, fread_number( fp ) );
save.c:            KEY( "Wanted", ch->pcdata->wanted_flags, fread_number( fp ) );
save.c:      room = ch->in_room;
save.c:      if( ch->tempnum == -9999 )
save.c:   obj->count = 1;
save.c:   obj->wear_loc = -1;
save.c:   obj->weight = 1;
save.c:                  paf->type = fread_number( fp );
save.c:                     paf->type = sn;
save.c:               paf->duration = fread_number( fp );
save.c:               paf->location = fread_number( fp );
save.c:               paf->bitvector = fread_number( fp );
save.c:               if( paf->location == APPLY_WEAPONSPELL
save.c:                   || paf->location == APPLY_WEARSPELL || paf->location == APPLY_REMOVESPELL )
save.c:                  paf->modifier = slot_lookup( pafmod );
save.c:                  paf->modifier = pafmod;
save.c:               LINK( paf, obj->first_affect, obj->last_affect, next, prev );
save.c:            KEY( "Actiondesc", obj->action_desc, fread_string( fp ) );
save.c:            KEY( "Cost", obj->cost, fread_number( fp ) );
save.c:            KEY( "Count", obj->count, fread_number( fp ) );
save.c:            KEY( "Description", obj->description, fread_string( fp ) );
save.c:            KEY( "ExtraFlags", obj->extra_flags, fread_number( fp ) );
save.c:               ed->keyword = fread_string( fp );
save.c:               ed->description = fread_string( fp );
save.c:               LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c:                  if( obj->name )
save.c:                     bug( "%s: %s incomplete object.", __FUNCTION__, obj->name );
save.c:                  short wear_loc = obj->wear_loc;
save.c:                  if( !obj->name )
save.c:                     obj->name = QUICKLINK( obj->pIndexData->name );
save.c:                  if( !obj->description )
save.c:                     obj->description = QUICKLINK( obj->pIndexData->description );
save.c:                  if( !obj->short_descr )
save.c:                     obj->short_descr = QUICKLINK( obj->pIndexData->short_descr );
save.c:                  if( !obj->action_desc )
save.c:                     obj->action_desc = QUICKLINK( obj->pIndexData->action_desc );
save.c:                  obj->pIndexData->count += obj->count;
save.c:                  if( !obj->serial )
save.c:                     cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
save.c:                     obj->serial = obj->pIndexData->serial = cur_obj_serial;
save.c:                  numobjsloaded += obj->count;
save.c:                  if( file_ver > 1 || obj->wear_loc < -1 || obj->wear_loc >= MAX_WEAR )
save.c:                     obj->wear_loc = -1;
save.c:                   * Corpse saving. -- Altrag 
save.c:                     if( file_ver > 1 && wear_loc > -1 && wear_loc < MAX_WEAR )
save.c:                     if( rgObjNest[iNest - 1] )
save.c:                        separate_obj( rgObjNest[iNest - 1] );
save.c:                        obj = obj_to_obj( obj, rgObjNest[iNest - 1] );
save.c:                        bug( "Fread_obj: nest layer missing %d", iNest - 1 );
save.c:            KEY( "ItemType", obj->item_type, fread_number( fp ) );
save.c:            KEY( "Level", obj->level, fread_number( fp ) );
save.c:            KEY( "Name", obj->name, fread_string( fp ) );
save.c:            KEY( "Rvnum", obj->room_vnum, fread_number( fp ) );
save.c:            KEY( "ShortDescr", obj->short_descr, fread_string( fp ) );
save.c:                  obj->value[iValue] = sn;
save.c:            KEY( "Timer", obj->timer, fread_number( fp ) );
save.c:               obj->value[0] = x1;
save.c:               obj->value[1] = x2;
save.c:               obj->value[2] = x3;
save.c:               obj->value[3] = x4;
save.c:               obj->value[4] = x5;
save.c:               obj->value[5] = x6;
save.c:               if( ( obj->pIndexData = get_obj_index( vnum ) ) == NULL )
save.c:                  obj->cost = obj->pIndexData->cost;
save.c:                  obj->weight = obj->pIndexData->weight;
save.c:                  obj->item_type = obj->pIndexData->item_type;
save.c:                  obj->wear_flags = obj->pIndexData->wear_flags;
save.c:                  obj->extra_flags = obj->pIndexData->extra_flags;
save.c:            KEY( "WearFlags", obj->wear_flags, fread_number( fp ) );
save.c:            KEY( "WearLoc", obj->wear_loc, fread_number( fp ) );
save.c:            KEY( "Weight", obj->weight, fread_number( fp ) );
save.c:         if( obj->name )
save.c:            STRFREE( obj->name );
save.c:         if( obj->description )
save.c:            STRFREE( obj->description );
save.c:         if( obj->short_descr )
save.c:            STRFREE( obj->short_descr );
save.c:         while( ( ed = obj->first_extradesc ) != NULL )
save.c:            STRFREE( ed->keyword );
save.c:            STRFREE( ed->description );
save.c:            UNLINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c:         while( ( paf = obj->first_affect ) != NULL )
save.c:            UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
save.c: * Based on last time modified, show when a player was last on	-Thoric
save.c:   if( stat( buf, &fst ) != -1 && check_parse_name( capitalize( name ) ) )
save.c:      name = ch->name;
save.c:    * Go by vnum, less chance of screwups. -- Altrag 
save.c:   for( corpse = first_object; corpse; corpse = corpse->next )
save.c:      if( corpse->pIndexData->vnum == OBJ_VNUM_CORPSE_PC &&
save.c:          corpse->in_room != NULL && !str_cmp( corpse->short_descr + 14, name ) )
save.c:      if( de->d_name[0] != '.' )
save.c:         sprintf( strArea, "%s%s", CORPSE_DIR, de->d_name );
save.c:         fprintf( stderr, "Corpse -> %s\n", strArea );
save.c:    ROOM_INDEX_DATA *storeroom = ch->plr_home;
save.c:    if( IS_NPC( ch ) || ch->plr_home == NULL )
save.c:    for( obj = storeroom->first_content; obj; obj = obj_next )
save.c:        obj_next = obj->next_content;
save.c:    sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c:                bug( ch->name, 0 );
save.c:                bug( ch->name, 0 );
save.c:        for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
save.c:            tobj_next = tobj->next_content;
save.c~:*--------------------------------------------------------------------------*
save.c~:* -------------------------------------------------------------------------*
save.c~:*--------------------------------------------------------------------------*
save.c~:* ------------------------------------------------------------------------ *
save.c~:* ------------------------------------------------------------------------ *
save.c~: * Array to keep track of equipment temporarily.		-Thoric
save.c~: * Array of containers read for proper re-nesting of objects.
save.c~:   if( ch->plr_home )
save.c~:      sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:         templvl = ch->top_level;
save.c~:         ch->top_level = LEVEL_HERO;   /* make sure EQ doesn't get lost */
save.c~:         contents = ch->plr_home->last_content;
save.c~:         ch->top_level = templvl;
save.c~: * Un-equip character before saving to ensure proper	-Thoric
save.c~:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c~:      if( obj->wear_loc > -1 && obj->wear_loc < MAX_WEAR )
save.c~:            if( !save_equipment[obj->wear_loc][x] )
save.c~:               save_equipment[obj->wear_loc][x] = obj;
save.c~:                     ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c~: * Re-equip character					-Thoric
save.c~:   if( !IS_NPC( ch ) && ch->pcdata->clan )
save.c~:      save_clan( ch->pcdata->clan );
save.c~:   if( ch->desc && ch->desc->original )
save.c~:      ch = ch->desc->original;
save.c~:   ch->save_time = current_time;
save.c~:   sprintf( strsave, "%s%c/%s", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:    * Auto-backup pfile (can cause lag with high disk access situtations
save.c~:      sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:    * Save immortal stats, level & vnums for wizlist    -Thoric
save.c~:      sprintf( strback, "%s%s", GOD_DIR, capitalize( ch->name ) );
save.c~:         fprintf( fp, "Level        %d\n", ch->top_level );
save.c~:         fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c~:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c~:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c~:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c~:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c~:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c~:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c~:      if( ch->first_carrying )
save.c~:         fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY, ch->pcdata->hotboot );
save.c~:      if( ch->comments )   /* comments */
save.c~:   if( ch->desc && ch->desc->original )
save.c~:      ch = ch->desc->original;
save.c~:   ch->save_time = current_time;
save.c~:   sprintf( strsave, "%s%c/%s.clone", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:    * Auto-backup pfile (can cause lag with high disk access situtations
save.c~:      sprintf( strback, "%s%c/%s", BACKUP_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:      if( ch->comments )   /* comments */
save.c~:   fprintf( fp, "Name         %s~\n", ch->name );
save.c~:   if( ch->short_descr && ch->short_descr[0] != '\0' )
save.c~:      fprintf( fp, "ShortDescr   %s~\n", ch->short_descr );
save.c~:   if( ch->long_descr && ch->long_descr[0] != '\0' )
save.c~:      fprintf( fp, "LongDescr    %s~\n", ch->long_descr );
save.c~:   if( ch->description && ch->description[0] != '\0' )
save.c~:      fprintf( fp, "Description  %s~\n", ch->description );
save.c~:   fprintf( fp, "Sex          %d\n", ch->sex );
save.c~:   fprintf( fp, "Race         %d\n", ch->race );
save.c~:   fprintf( fp, "MainAbility  %d\n", ch->main_ability );
save.c~:   fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c~:   fprintf( fp, "Toplevel     %d\n", ch->top_level );
save.c~:   if( ch->trust )
save.c~:      fprintf( fp, "Trust        %d\n", ch->trust );
save.c~:   fprintf( fp, "Textcolor     %d\n", ch->textcolor );
save.c~:   fprintf( fp, "Played       %d\n", ch->played + ( int )( current_time - ch->logon ) );
save.c~:            ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c~:              && ch->was_in_room ) ? ch->was_in_room->vnum : ch->in_room->vnum );
save.c~:   if( ch->plr_home != NULL )
save.c~:      fprintf( fp, "PlrHome      %d\n", ch->plr_home->vnum );
save.c~:   fprintf( fp, "HpManaMove   %d %d 0 0 %d %d\n", ch->hit, ch->max_hit, ch->move, ch->max_move );
save.c~:   fprintf( fp, "Force        %d %d %d %d\n", ch->perm_frc, ch->mod_frc, ch->mana, ch->max_mana );
save.c~:   fprintf( fp, "Gold         %d\n", ch->gold );
save.c~:   fprintf( fp, "Bank         %ld\n", ch->pcdata->bank );
save.c~:         fprintf( fp, "Ability        %d %d %ld\n", ability, ch->skill_level[ability], ch->experience[ability] );
save.c~:   if( ch->act )
save.c~:      fprintf( fp, "Act          %d\n", ch->act );
save.c~:   if( ch->affected_by )
save.c~:      fprintf( fp, "AffectedBy   %d\n", ch->affected_by );
save.c~:   fprintf( fp, "Position     %d\n", ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c~:            ch->saving_poison_death, ch->saving_wand, ch->saving_para_petri, ch->saving_breath, ch->saving_spell_staff );
save.c~:   fprintf( fp, "Alignment    %d\n", ch->alignment );
save.c~:   fprintf( fp, "Glory        %d\n", ch->pcdata->quest_curr );
save.c~:   fprintf( fp, "MGlory       %d\n", ch->pcdata->quest_accum );
save.c~:   fprintf( fp, "Hitroll      %d\n", ch->hitroll );
save.c~:   fprintf( fp, "Damroll      %d\n", ch->damroll );
save.c~:   fprintf( fp, "Armor        %d\n", ch->armor );
save.c~:   if( ch->wimpy )
save.c~:      fprintf( fp, "Wimpy        %d\n", ch->wimpy );
save.c~:   if( ch->deaf )
save.c~:      fprintf( fp, "Deaf         %d\n", ch->deaf );
save.c~:   if( ch->resistant )
save.c~:      fprintf( fp, "Resistant    %d\n", ch->resistant );
save.c~:   if( ch->immune )
save.c~:      fprintf( fp, "Immune       %d\n", ch->immune );
save.c~:   if( ch->susceptible )
save.c~:      fprintf( fp, "Susceptible  %d\n", ch->susceptible );
save.c~:   if( ch->pcdata && ch->pcdata->outcast_time )
save.c~:      fprintf( fp, "Outcast_time %ld\n", ch->pcdata->outcast_time );
save.c~:   if( ch->pcdata && ch->pcdata->restore_time )
save.c~:      fprintf( fp, "Restore_time %ld\n", ch->pcdata->restore_time );
save.c~:   if( ch->mental_state != -10 )
save.c~:      fprintf( fp, "Mentalstate  %d\n", ch->mental_state );
save.c~:      fprintf( fp, "Vnum         %d\n", ch->pIndexData->vnum );
save.c~:      fprintf( fp, "Mobinvis     %d\n", ch->mobinvis );
save.c~:      fprintf( fp, "Password     %s~\n", ch->pcdata->pwd );
save.c~:      if( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c~:         fprintf( fp, "Bamfin       %s~\n", ch->pcdata->bamfin );
save.c~:      if( ch->pcdata->email && ch->pcdata->email[0] != '\0' )
save.c~:         fprintf( fp, "Email       %s~\n", ch->pcdata->email );
save.c~:      if( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c~:         fprintf( fp, "Bamfout      %s~\n", ch->pcdata->bamfout );
save.c~:      if( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c~:         fprintf( fp, "Rank         %s~\n", ch->pcdata->rank );
save.c~:      if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c~:         fprintf( fp, "Bestowments  %s~\n", ch->pcdata->bestowments );
save.c~:      fprintf( fp, "Title        %s~\n", ch->pcdata->title );
save.c~:      if( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c~:         fprintf( fp, "Homepage     %s~\n", ch->pcdata->homepage );
save.c~:      if( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c~:         fprintf( fp, "Bio          %s~\n", ch->pcdata->bio );
save.c~:      if( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c~:         fprintf( fp, "AuthedBy     %s~\n", ch->pcdata->authed_by );
save.c~:      if( ch->pcdata->min_snoop )
save.c~:         fprintf( fp, "Minsnoop     %d\n", ch->pcdata->min_snoop );
save.c~:      if( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c~:         fprintf( fp, "Prompt       %s~\n", ch->pcdata->prompt );
save.c~:      if( ch->pcdata->pilotprompt && *ch->pcdata->pilotprompt )
save.c~:         fprintf( fp, "PilotPrompt       %s~\n", ch->pcdata->pilotprompt );
save.c~:      if( ch->pcdata->pagerlen != 24 )
save.c~:         fprintf( fp, "Pagerlen     %d\n", ch->pcdata->pagerlen );
save.c~:         fprintf( fp, " %d", ch->pcdata->addiction[drug] );
save.c~:         fprintf( fp, " %d", ch->pcdata->drug_level[drug] );
save.c~:      if( ch->pcdata->wanted_flags )
save.c~:         fprintf( fp, "Wanted       %d\n", ch->pcdata->wanted_flags );
save.c~:      if( IS_IMMORTAL( ch ) || ch->pcdata->area )
save.c~:         fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c~:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c~:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c~:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c~:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c~:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c~:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c~:      if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c~:         fprintf( fp, "Clan         %s~\n", ch->pcdata->clan_name );
save.c~:      fprintf( fp, "Flags        %d\n", ch->pcdata->flags );
save.c~:      if( ch->pcdata->release_date > current_time )
save.c~:         fprintf( fp, "Helled       %d %s~\n", ( int )ch->pcdata->release_date, ch->pcdata->helled_by );
save.c~:      if( ch->pcdata->pkills )
save.c~:         fprintf( fp, "PKills       %d\n", ch->pcdata->pkills );
save.c~:      if( ch->pcdata->pdeaths )
save.c~:         fprintf( fp, "PDeaths      %d\n", ch->pcdata->pdeaths );
save.c~:      fprintf( fp, "MKills       %d\n", ch->pcdata->mkills );
save.c~:      fprintf( fp, "MDeaths      %d\n", ch->pcdata->mdeaths );
save.c~:      if( ch->pcdata->illegal_pk )
save.c~:         fprintf( fp, "IllegalPK    %d\n", ch->pcdata->illegal_pk );
save.c~:               ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
save.c~:               ch->mod_str, ch->mod_int, ch->mod_wis, ch->mod_dex, ch->mod_con, ch->mod_cha, ch->mod_lck );
save.c~:               ch->pcdata->condition[0], ch->pcdata->condition[1], ch->pcdata->condition[2], ch->pcdata->condition[3] );
save.c~:      if( ch->desc && ch->desc->host )
save.c~:         fprintf( fp, "Site         %s\n", ch->desc->host );
save.c~:         fprintf( fp, "Site         (Link-Dead)\n" );
save.c~:         if( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c~:            switch ( skill_table[sn]->type )
save.c~:                  fprintf( fp, "Skill        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c~:                  fprintf( fp, "Spell        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c~:                  fprintf( fp, "Weapon       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c~:                  fprintf( fp, "Tongue       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c~:   for( paf = ch->first_affect; paf; paf = paf->next )
save.c~:      if( paf->type >= 0 && ( skill = get_skilltype( paf->type ) ) == NULL )
save.c~:      if( paf->type >= 0 && paf->type < TYPE_PERSONAL )
save.c~:                  skill->name, paf->duration, paf->modifier, paf->location, paf->bitvector );
save.c~:                  paf->type, paf->duration, paf->modifier, paf->location, paf->bitvector );
save.c~:   track = URANGE( 2, ( ( ch->top_level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c~:      if( ch->pcdata->killed[sn].vnum == 0 )
save.c~:      fprintf( fp, "Killed       %d %d\n", ch->pcdata->killed[sn].vnum, ch->pcdata->killed[sn].count );
save.c~:    * Save color values - Samson 9-29-98 
save.c~:         fprintf( fp, "%d ", ch->colors[x] );
save.c~:   if( obj->prev_content && os_type != OS_CORPSE )
save.c~:      fwrite_obj( ch, obj->prev_content, fp, iNest, OS_CARRY, hotboot );
save.c~:      if( obj->item_type == ITEM_KEY && !IS_OBJ_STAT( obj, ITEM_CLANOBJECT ) )
save.c~:    * Catch deleted objects              -Thoric
save.c~:    * Do NOT save prototype items!          -Thoric
save.c~:    * DO NOT save corpses lying on the ground as a hotboot item, they already saved elsewhere! - Samson 
save.c~:   if( hotboot && obj->item_type == ITEM_CORPSE_PC )
save.c~:    * Corpse saving. -- Altrag 
save.c~:   if( obj->count > 1 )
save.c~:      fprintf( fp, "Count        %d\n", obj->count );
save.c~:   if( obj->name && ( !obj->pIndexData->name  || str_cmp( obj->name, obj->pIndexData->name ) ) )
save.c~:      fprintf( fp, "Name         %s~\n", obj->name );
save.c~:   if( obj->short_descr && ( !obj->pIndexData->short_descr || str_cmp( obj->short_descr, obj->pIndexData->short_descr ) ) )
save.c~:      fprintf( fp, "ShortDescr   %s~\n", obj->short_descr );
save.c~:   if( obj->description && ( !obj->pIndexData->description || str_cmp( obj->description, obj->pIndexData->description ) ) )
save.c~:      fprintf( fp, "Description  %s~\n", obj->description );
save.c~:   if( obj->action_desc && ( !obj->pIndexData->action_desc || str_cmp( obj->action_desc, obj->pIndexData->action_desc ) ) )
save.c~:      fprintf( fp, "ActionDesc   %s~\n", obj->action_desc );
save.c~:   fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum );
save.c~:   if( ( os_type == OS_CORPSE || hotboot ) && obj->in_room )
save.c~:      fprintf( fp, "Room         %d\n", obj->in_room->vnum );
save.c~:      fprintf( fp, "Rvnum	   %d\n", obj->room_vnum );
save.c~:   if( obj->extra_flags != obj->pIndexData->extra_flags )
save.c~:      fprintf( fp, "ExtraFlags   %d\n", obj->extra_flags );
save.c~:   if( obj->wear_flags != obj->pIndexData->wear_flags )
save.c~:      fprintf( fp, "WearFlags    %d\n", obj->wear_flags );
save.c~:   wear_loc = -1;
save.c~:   if( wear_loc != -1 )
save.c~:   if( obj->item_type != obj->pIndexData->item_type )
save.c~:      fprintf( fp, "ItemType     %d\n", obj->item_type );
save.c~:   if( obj->weight != obj->pIndexData->weight )
save.c~:      fprintf( fp, "Weight       %d\n", obj->weight );
save.c~:   if( obj->level )
save.c~:      fprintf( fp, "Level        %d\n", obj->level );
save.c~:   if( obj->timer )
save.c~:      fprintf( fp, "Timer        %d\n", obj->timer );
save.c~:   if( obj->cost != obj->pIndexData->cost )
save.c~:      fprintf( fp, "Cost         %d\n", obj->cost );
save.c~:   if( obj->value[0] || obj->value[1] || obj->value[2] || obj->value[3] || obj->value[4] || obj->value[5] )
save.c~:               obj->value[0], obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5] );
save.c~:   switch ( obj->item_type )
save.c~:      case ITEM_PILL:  /* was down there with staff and wand, wrongly - Scryn */
save.c~:         if( IS_VALID_SN( obj->value[1] ) )
save.c~:            fprintf( fp, "Spell 1      '%s'\n", skill_table[obj->value[1]]->name );
save.c~:         if( IS_VALID_SN( obj->value[2] ) )
save.c~:            fprintf( fp, "Spell 2      '%s'\n", skill_table[obj->value[2]]->name );
save.c~:         if( IS_VALID_SN( obj->value[3] ) )
save.c~:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c~:         if( IS_VALID_SN( obj->value[3] ) )
save.c~:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c~:         if( IS_VALID_SN( obj->value[4] ) )
save.c~:            fprintf( fp, "Spell 4      '%s'\n", skill_table[obj->value[4]]->name );
save.c~:         if( IS_VALID_SN( obj->value[5] ) )
save.c~:            fprintf( fp, "Spell 5      '%s'\n", skill_table[obj->value[5]]->name );
save.c~:   for( paf = obj->first_affect; paf; paf = paf->next )
save.c~:       * Save extra object affects           -Thoric
save.c~:      if( paf->type < 0 || paf->type >= top_sn )
save.c~:                  paf->type,
save.c~:                  paf->duration,
save.c~:                  ( ( paf->location == APPLY_WEAPONSPELL
save.c~:                      || paf->location == APPLY_WEARSPELL
save.c~:                      || paf->location == APPLY_REMOVESPELL
save.c~:                      || paf->location == APPLY_STRIPSN )
save.c~:                    && IS_VALID_SN( paf->modifier ) )
save.c~:                  ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
save.c~:                  skill_table[paf->type]->name,
save.c~:                  paf->duration,
save.c~:                  ( ( paf->location == APPLY_WEAPONSPELL
save.c~:                      || paf->location == APPLY_WEARSPELL
save.c~:                      || paf->location == APPLY_REMOVESPELL
save.c~:                      || paf->location == APPLY_STRIPSN )
save.c~:                    && IS_VALID_SN( paf->modifier ) )
save.c~:                  ? skill_table[paf->modifier]->slot : paf->modifier, paf->location, paf->bitvector );
save.c~:   for( ed = obj->first_extradesc; ed; ed = ed->next )
save.c~:      fprintf( fp, "ExtraDescr   %s~ %s~\n", ed->keyword, ed->description );
save.c~:   if( obj->first_content )
save.c~:      fwrite_obj( ch, obj->last_content, fp, iNest + 1, OS_CARRY, hotboot );
save.c~:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c~:   ch->textcolor = 0;
save.c~:   d->character = ch;
save.c~:   ch->desc = d;
save.c~:   ch->name = STRALLOC( name );
save.c~:   ch->act = PLR_BLANK | PLR_COMBINE | PLR_PROMPT;
save.c~:   ch->perm_str = 10;
save.c~:   ch->perm_int = 10;
save.c~:   ch->perm_wis = 10;
save.c~:   ch->perm_dex = 10;
save.c~:   ch->perm_con = 10;
save.c~:   ch->perm_cha = 10;
save.c~:   ch->perm_lck = 10;
save.c~:   ch->pcdata->condition[COND_THIRST] = 48;
save.c~:   ch->pcdata->condition[COND_FULL] = 48;
save.c~:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c~:   ch->pcdata->wizinvis = 0;
save.c~:   ch->mental_state = -10;
save.c~:   ch->mobinvis = 0;
save.c~:      ch->pcdata->learned[i] = 0;
save.c~:   ch->pcdata->release_date = 0;
save.c~:   ch->pcdata->helled_by = NULL;
save.c~:   ch->saving_poison_death = 0;
save.c~:   ch->saving_wand = 0;
save.c~:   ch->saving_para_petri = 0;
save.c~:   ch->saving_breath = 0;
save.c~:   ch->saving_spell_staff = 0;
save.c~:   ch->comments = NULL; /* comments */
save.c~:   ch->pcdata->pagerlen = 24;
save.c~:   ch->mob_clan = STRALLOC( "" );
save.c~:   ch->was_sentinel = NULL;
save.c~:   ch->plr_home = NULL;
save.c~:   ch->pcdata->hotboot = FALSE;  /* Never changed except when PC is saved during hotboot save */
save.c~:   if( stat( strsave, &fst ) != -1 )
save.c~:                  preload ? "Preloading" : "Loading", ch->name, ( int )fst.st_size / 1024 );
save.c~:       * Cheat so that bug will show line #'s -- Altrag 
save.c~:      ch->short_descr = STRALLOC( "" );
save.c~:      ch->long_descr = STRALLOC( "" );
save.c~:      ch->description = STRALLOC( "" );
save.c~:      ch->editor = NULL;
save.c~:      ch->pcdata->clan_name = STRALLOC( "" );
save.c~:      ch->pcdata->clan = NULL;
save.c~:      ch->pcdata->pwd = str_dup( "" );
save.c~:      ch->pcdata->email = str_dup( "" );
save.c~:      ch->pcdata->bamfin = str_dup( "" );
save.c~:      ch->pcdata->bamfout = str_dup( "" );
save.c~:      ch->pcdata->rank = str_dup( "" );
save.c~:      ch->pcdata->bestowments = str_dup( "" );
save.c~:      ch->pcdata->title = STRALLOC( "" );
save.c~:      ch->pcdata->homepage = str_dup( "" );
save.c~:      ch->pcdata->bio = STRALLOC( "" );
save.c~:      ch->pcdata->authed_by = STRALLOC( "" );
save.c~:      ch->pcdata->prompt = STRALLOC( "" );
save.c~:      ch->pcdata->pilotprompt = STRALLOC( "" );
save.c~:      ch->pcdata->r_range_lo = 0;
save.c~:      ch->pcdata->r_range_hi = 0;
save.c~:      ch->pcdata->m_range_lo = 0;
save.c~:      ch->pcdata->m_range_hi = 0;
save.c~:      ch->pcdata->o_range_lo = 0;
save.c~:      ch->pcdata->o_range_hi = 0;
save.c~:      ch->pcdata->wizinvis = 0;
save.c~:      ch->pcdata->wanted_flags = 0;
save.c~:      if( !ch->pcdata->clan_name )
save.c~:         ch->pcdata->clan_name = STRALLOC( "" );
save.c~:         ch->pcdata->clan = NULL;
save.c~:      if( !ch->pcdata->bio )
save.c~:         ch->pcdata->bio = STRALLOC( "" );
save.c~:      if( !ch->pcdata->authed_by )
save.c~:         ch->pcdata->authed_by = STRALLOC( "" );
save.c~:         if( ch->pcdata->wizinvis < 2 )
save.c~:            ch->pcdata->wizinvis = ch->top_level;
save.c~:      if( ch->plr_home != NULL )
save.c~:    * Setup color values in case player has none set - Samson 
save.c~:   memcpy( &ch->colors, &default_set, sizeof( default_set ) );
save.c~:            KEY( "Act", ch->act, fread_number( fp ) );
save.c~:            KEY( "AffectedBy", ch->affected_by, fread_number( fp ) );
save.c~:            KEY( "Alignment", ch->alignment, fread_number( fp ) );
save.c~:            KEY( "Armor", ch->armor, fread_number( fp ) );
save.c~:               ch->pcdata->addiction[0] = x0;
save.c~:               ch->pcdata->addiction[1] = x1;
save.c~:               ch->pcdata->addiction[2] = x2;
save.c~:               ch->pcdata->addiction[3] = x3;
save.c~:               ch->pcdata->addiction[4] = x4;
save.c~:               ch->pcdata->addiction[5] = x5;
save.c~:               ch->pcdata->addiction[6] = x6;
save.c~:               ch->pcdata->addiction[7] = x7;
save.c~:               ch->pcdata->addiction[8] = x8;
save.c~:               ch->pcdata->addiction[9] = x9;
save.c~:                  ch->skill_level[x0] = x1;
save.c~:                  ch->experience[x0] = x2;
save.c~:                  paf->type = fread_number( fp );
save.c~:                  paf->type = sn;
save.c~:               paf->duration = fread_number( fp );
save.c~:               paf->modifier = fread_number( fp );
save.c~:               paf->location = fread_number( fp );
save.c~:               paf->bitvector = fread_number( fp );
save.c~:               LINK( paf, ch->first_affect, ch->last_affect, next, prev );
save.c~:               ch->mod_str = x1;
save.c~:               ch->mod_int = x2;
save.c~:               ch->mod_wis = x3;
save.c~:               ch->mod_dex = x4;
save.c~:               ch->mod_con = x5;
save.c~:               ch->mod_cha = x6;
save.c~:               ch->mod_lck = x7;
save.c~:                  ch->mod_lck = 0;
save.c~:               ch->perm_str = x1;
save.c~:               ch->perm_int = x2;
save.c~:               ch->perm_wis = x3;
save.c~:               ch->perm_dex = x4;
save.c~:               ch->perm_con = x5;
save.c~:               ch->perm_cha = x6;
save.c~:               ch->perm_lck = x7;
save.c~:                  ch->perm_lck = 13;
save.c~:            KEY( "AuthedBy", ch->pcdata->authed_by, fread_string( fp ) );
save.c~:            KEY( "Bamfin", ch->pcdata->bamfin, fread_string_nohash( fp ) );
save.c~:            KEY( "Bamfout", ch->pcdata->bamfout, fread_string_nohash( fp ) );
save.c~:            KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c~:            KEY( "Bio", ch->pcdata->bio, fread_string( fp ) );
save.c~:            KEY( "Bank", ch->pcdata->bank, fread_number( fp ) );
save.c~:               ch->pcdata->clan_name = fread_string( fp );
save.c~:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c~:                           ch->pcdata->clan_name );
save.c~:                  STRFREE( ch->pcdata->clan_name );
save.c~:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c~:                  ch->colors[x] = fread_number( fp );
save.c~:               ch->pcdata->condition[0] = x1;
save.c~:               ch->pcdata->condition[1] = x2;
save.c~:               ch->pcdata->condition[2] = x3;
save.c~:               ch->pcdata->condition[3] = x4;
save.c~:            KEY( "Damroll", ch->damroll, fread_number( fp ) );
save.c~:            KEY( "Deaf", ch->deaf, fread_number( fp ) );
save.c~:            KEY( "Description", ch->description, fread_string( fp ) );
save.c~:               ch->pcdata->drug_level[0] = x0;
save.c~:               ch->pcdata->drug_level[1] = x1;
save.c~:               ch->pcdata->drug_level[2] = x2;
save.c~:               ch->pcdata->drug_level[3] = x3;
save.c~:               ch->pcdata->drug_level[4] = x4;
save.c~:               ch->pcdata->drug_level[5] = x5;
save.c~:               ch->pcdata->drug_level[6] = x6;
save.c~:               ch->pcdata->drug_level[7] = x7;
save.c~:               ch->pcdata->drug_level[8] = x8;
save.c~:               ch->pcdata->drug_level[9] = x9;
save.c~:            KEY( "Flags", ch->pcdata->flags, fread_number( fp ) );
save.c~:               ch->perm_frc = x1;
save.c~:               ch->mod_frc = x2;
save.c~:               ch->mana = x3;
save.c~:               ch->max_mana = x4;
save.c~:            KEY( "Glory", ch->pcdata->quest_curr, fread_number( fp ) );
save.c~:            KEY( "Gold", ch->gold, fread_number( fp ) );
save.c~:               ch->pcdata->clan_name = fread_string( fp );
save.c~:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c~:                           ch->pcdata->clan_name );
save.c~:                  STRFREE( ch->pcdata->clan_name );
save.c~:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c~:               ch->pcdata->release_date = fread_number( fp );
save.c~:               ch->pcdata->helled_by = fread_string( fp );
save.c~:               if( ch->pcdata->release_date < current_time )
save.c~:                  STRFREE( ch->pcdata->helled_by );
save.c~:                  ch->pcdata->helled_by = NULL;
save.c~:                  ch->pcdata->release_date = 0;
save.c~:            KEY( "Hitroll", ch->hitroll, fread_number( fp ) );
save.c~:            KEY( "Homepage", ch->pcdata->homepage, fread_string_nohash( fp ) );
save.c~:               ch->hit = x1;
save.c~:               ch->max_hit = x2;
save.c~:               ch->move = x5;
save.c~:               ch->max_move = x6;
save.c~:                  ch->perm_frc = number_range( 1, 20 );
save.c~:                  ch->max_mana = x4;
save.c~:                  ch->mana = x4;
save.c~:                  ch->perm_frc = 1;
save.c~:                  ch->max_mana = x4;
save.c~:            KEY( "IllegalPK", ch->pcdata->illegal_pk, fread_number( fp ) );
save.c~:            KEY( "Immune", ch->immune, fread_number( fp ) );
save.c~:                  ch->pcdata->killed[killcnt].vnum = fread_number( fp );
save.c~:                  ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c~:            KEY( "LongDescr", ch->long_descr, fread_string( fp ) );
save.c~:               ch->speaks = fread_number( fp );
save.c~:               ch->speaking = fread_number( fp );
save.c~:            KEY( "MainAbility", ch->main_ability, fread_number( fp ) );
save.c~:            KEY( "MDeaths", ch->pcdata->mdeaths, fread_number( fp ) );
save.c~:            KEY( "Mentalstate", ch->mental_state, fread_number( fp ) );
save.c~:            KEY( "MGlory", ch->pcdata->quest_accum, fread_number( fp ) );
save.c~:            KEY( "Minsnoop", ch->pcdata->min_snoop, fread_number( fp ) );
save.c~:            KEY( "MKills", ch->pcdata->mkills, fread_number( fp ) );
save.c~:            KEY( "Mobinvis", ch->mobinvis, fread_number( fp ) );
save.c~:               ch->pcdata->m_range_lo = fread_number( fp );
save.c~:               ch->pcdata->m_range_hi = fread_number( fp );
save.c~:            KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c~:               ch->pcdata->o_range_lo = fread_number( fp );
save.c~:               ch->pcdata->o_range_hi = fread_number( fp );
save.c~:            KEY( "Pagerlen", ch->pcdata->pagerlen, fread_number( fp ) );
save.c~:            KEY( "Password", ch->pcdata->pwd, fread_string_nohash( fp ) );
save.c~:            KEY( "PDeaths", ch->pcdata->pdeaths, fread_number( fp ) );
save.c~:            KEY( "PKills", ch->pcdata->pkills, fread_number( fp ) );
save.c~:            KEY( "Played", ch->played, fread_number( fp ) );
save.c~:            KEY( "Position", ch->position, fread_number( fp ) );
save.c~:            KEY( "Prompt", ch->pcdata->prompt, fread_string( fp ) );
save.c~:            KEY( "PilotPrompt", ch->pcdata->pilotprompt, fread_string( fp ) );
save.c~:               ch->plr_home = get_room_index( fread_number( fp ) );
save.c~:               if( !ch->plr_home )
save.c~:                  ch->plr_home = NULL;
save.c~:            KEY( "Race", ch->race, fread_number( fp ) );
save.c~:            KEY( "Rank", ch->pcdata->rank, fread_string_nohash( fp ) );
save.c~:            KEY( "Resistant", ch->resistant, fread_number( fp ) );
save.c~:            KEY( "Restore_time", ch->pcdata->restore_time, fread_number( fp ) );
save.c~:               ch->in_room = get_room_index( fread_number( fp ) );
save.c~:               if( !ch->in_room )
save.c~:                  ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c~:               ch->pcdata->r_range_lo = fread_number( fp );
save.c~:               ch->pcdata->r_range_hi = fread_number( fp );
save.c~:            KEY( "Sex", ch->sex, fread_number( fp ) );
save.c~:            KEY( "ShortDescr", ch->short_descr, fread_string( fp ) );
save.c~:            KEY( "Susceptible", ch->susceptible, fread_number( fp ) );
save.c~:               ch->saving_wand = fread_number( fp );
save.c~:               ch->saving_poison_death = ch->saving_wand;
save.c~:               ch->saving_para_petri = ch->saving_wand;
save.c~:               ch->saving_breath = ch->saving_wand;
save.c~:               ch->saving_spell_staff = ch->saving_wand;
save.c~:               ch->saving_poison_death = fread_number( fp );
save.c~:               ch->saving_wand = fread_number( fp );
save.c~:               ch->saving_para_petri = fread_number( fp );
save.c~:               ch->saving_breath = fread_number( fp );
save.c~:               ch->saving_spell_staff = fread_number( fp );
save.c~:                     sn = bsearch_skill_exact( fread_word( fp ), gsn_first_skill, gsn_first_weapon - 1 );
save.c~:                     ch->pcdata->learned[sn] = value;
save.c~:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_spell, gsn_first_skill - 1 );
save.c~:                     ch->pcdata->learned[sn] = value;
save.c~:               if( !ch->short_descr )
save.c~:                  ch->short_descr = STRALLOC( "" );
save.c~:               if( !ch->long_descr )
save.c~:                  ch->long_descr = STRALLOC( "" );
save.c~:               if( !ch->description )
save.c~:                  ch->description = STRALLOC( "" );
save.c~:               if( !ch->pcdata->pwd )
save.c~:                  ch->pcdata->pwd = str_dup( "" );
save.c~:               if( !ch->pcdata->email )
save.c~:                  ch->pcdata->email = str_dup( "" );
save.c~:               if( !ch->pcdata->bamfin )
save.c~:                  ch->pcdata->bamfin = str_dup( "" );
save.c~:               if( !ch->pcdata->bamfout )
save.c~:                  ch->pcdata->bamfout = str_dup( "" );
save.c~:               if( !ch->pcdata->bio )
save.c~:                  ch->pcdata->bio = STRALLOC( "" );
save.c~:               if( !ch->pcdata->rank )
save.c~:                  ch->pcdata->rank = str_dup( "" );
save.c~:               if( !ch->pcdata->bestowments )
save.c~:                  ch->pcdata->bestowments = str_dup( "" );
save.c~:               if( !ch->pcdata->title )
save.c~:                  ch->pcdata->title = STRALLOC( "" );
save.c~:               if( !ch->pcdata->homepage )
save.c~:                  ch->pcdata->homepage = str_dup( "" );
save.c~:               if( !ch->pcdata->authed_by )
save.c~:                  ch->pcdata->authed_by = STRALLOC( "" );
save.c~:               if( !ch->pcdata->prompt )
save.c~:                  ch->pcdata->prompt = STRALLOC( "" );
save.c~:               ch->editor = NULL;
save.c~:               killcnt = URANGE( 2, ( ( ch->top_level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c~:                  ch->pcdata->killed[killcnt].vnum = 0;
save.c~:                     if( ch->skill_level[ability] == 0 )
save.c~:                        ch->skill_level[ability] = 1;
save.c~:               if( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c~:                   * ch->speaking = LANG_COMMON;      
save.c~:                  ch->speaking = race_table[ch->race].language;
save.c~:                  ch->speaks = ~0;
save.c~:                  if( ch->speaking == 0 )
save.c~:                     ch->speaking = ~0;
save.c~:               if( !ch->pcdata->prompt )
save.c~:                  ch->pcdata->prompt = STRALLOC( "" );
save.c~:                  hitgain = ( ( int )( current_time - lastplayed ) / 60 );
save.c~:                  ch->hit = URANGE( 1, ch->hit + hitgain, ch->max_hit );
save.c~:                  ch->move = URANGE( 1, ch->move + hitgain, ch->max_move );
save.c~:                  if( ch->skill_level[FORCE_ABILITY] > 1 )
save.c~:                     ch->mana = URANGE( 0, ch->mana + hitgain, ch->max_mana );
save.c~:                  if( !skill_table[sn]->name )
save.c~:                  if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
save.c~:                  if( ch->pcdata->learned[sn] > 0 && ch->skill_level[skill_table[sn]->guild] < skill_table[sn]->min_level )
save.c~:                     ch->pcdata->learned[sn] = 0;
save.c~:            KEY( "Email", ch->pcdata->email, fread_string_nohash( fp ) );
save.c~:            KEY( "Toplevel", ch->top_level, fread_number( fp ) );
save.c~:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_tongue, gsn_top_sn - 1 );
save.c~:                     ch->pcdata->learned[sn] = value;
save.c~:            KEY( "Trust", ch->trust, fread_number( fp ) );
save.c~:            KEY( "Textcolor", ch->textcolor, fread_number( fp ) );
save.c~:             * Let no character be trusted higher than one below maxlevel -- Narn 
save.c~:            ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c~:               ch->pcdata->title = fread_string( fp );
save.c~:               if( isalpha( ch->pcdata->title[0] ) || isdigit( ch->pcdata->title[0] ) )
save.c~:                  sprintf( buf, " %s", ch->pcdata->title );
save.c~:                  if( ch->pcdata->title )
save.c~:                     STRFREE( ch->pcdata->title );
save.c~:                  ch->pcdata->title = STRALLOC( buf );
save.c~:                  sn = bsearch_skill_exact( fread_word( fp ), gsn_first_weapon, gsn_first_tongue - 1 );
save.c~:                     ch->pcdata->learned[sn] = value;
save.c~:            KEY( "Wimpy", ch->wimpy, fread_number( fp ) );
save.c~:            KEY( "WizInvis", ch->pcdata->wizinvis, fread_number( fp ) );
save.c~:            KEY( "Wanted", ch->pcdata->wanted_flags, fread_number( fp ) );
save.c~:      room = ch->in_room;
save.c~:      if( ch->tempnum == -9999 )
save.c~:   obj->count = 1;
save.c~:   obj->wear_loc = -1;
save.c~:   obj->weight = 1;
save.c~:                  paf->type = fread_number( fp );
save.c~:                     paf->type = sn;
save.c~:               paf->duration = fread_number( fp );
save.c~:               paf->location = fread_number( fp );
save.c~:               paf->bitvector = fread_number( fp );
save.c~:               if( paf->location == APPLY_WEAPONSPELL
save.c~:                   || paf->location == APPLY_WEARSPELL || paf->location == APPLY_REMOVESPELL )
save.c~:                  paf->modifier = slot_lookup( pafmod );
save.c~:                  paf->modifier = pafmod;
save.c~:               LINK( paf, obj->first_affect, obj->last_affect, next, prev );
save.c~:            KEY( "Actiondesc", obj->action_desc, fread_string( fp ) );
save.c~:            KEY( "Cost", obj->cost, fread_number( fp ) );
save.c~:            KEY( "Count", obj->count, fread_number( fp ) );
save.c~:            KEY( "Description", obj->description, fread_string( fp ) );
save.c~:            KEY( "ExtraFlags", obj->extra_flags, fread_number( fp ) );
save.c~:               ed->keyword = fread_string( fp );
save.c~:               ed->description = fread_string( fp );
save.c~:               LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c~:                  if( obj->name )
save.c~:                     bug( "%s: %s incomplete object.", __FUNCTION__, obj->name );
save.c~:                  short wear_loc = obj->wear_loc;
save.c~:                  if( !obj->name )
save.c~:                     obj->name = QUICKLINK( obj->pIndexData->name );
save.c~:                  if( !obj->description )
save.c~:                     obj->description = QUICKLINK( obj->pIndexData->description );
save.c~:                  if( !obj->short_descr )
save.c~:                     obj->short_descr = QUICKLINK( obj->pIndexData->short_descr );
save.c~:                  if( !obj->action_desc )
save.c~:                     obj->action_desc = QUICKLINK( obj->pIndexData->action_desc );
save.c~:                  obj->pIndexData->count += obj->count;
save.c~:                  if( !obj->serial )
save.c~:                     cur_obj_serial = UMAX( ( cur_obj_serial + 1 ) & ( BV30 - 1 ), 1 );
save.c~:                     obj->serial = obj->pIndexData->serial = cur_obj_serial;
save.c~:                  numobjsloaded += obj->count;
save.c~:                  if( file_ver > 1 || obj->wear_loc < -1 || obj->wear_loc >= MAX_WEAR )
save.c~:                     obj->wear_loc = -1;
save.c~:                   * Corpse saving. -- Altrag 
save.c~:                     if( file_ver > 1 && wear_loc > -1 && wear_loc < MAX_WEAR )
save.c~:                     if( rgObjNest[iNest - 1] )
save.c~:                        separate_obj( rgObjNest[iNest - 1] );
save.c~:                        obj = obj_to_obj( obj, rgObjNest[iNest - 1] );
save.c~:                        bug( "Fread_obj: nest layer missing %d", iNest - 1 );
save.c~:            KEY( "ItemType", obj->item_type, fread_number( fp ) );
save.c~:            KEY( "Level", obj->level, fread_number( fp ) );
save.c~:            KEY( "Name", obj->name, fread_string( fp ) );
save.c~:            KEY( "Rvnum", obj->room_vnum, fread_number( fp ) );
save.c~:            KEY( "ShortDescr", obj->short_descr, fread_string( fp ) );
save.c~:                  obj->value[iValue] = sn;
save.c~:            KEY( "Timer", obj->timer, fread_number( fp ) );
save.c~:               obj->value[0] = x1;
save.c~:               obj->value[1] = x2;
save.c~:               obj->value[2] = x3;
save.c~:               obj->value[3] = x4;
save.c~:               obj->value[4] = x5;
save.c~:               obj->value[5] = x6;
save.c~:               if( ( obj->pIndexData = get_obj_index( vnum ) ) == NULL )
save.c~:                  obj->cost = obj->pIndexData->cost;
save.c~:                  obj->weight = obj->pIndexData->weight;
save.c~:                  obj->item_type = obj->pIndexData->item_type;
save.c~:                  obj->wear_flags = obj->pIndexData->wear_flags;
save.c~:                  obj->extra_flags = obj->pIndexData->extra_flags;
save.c~:            KEY( "WearFlags", obj->wear_flags, fread_number( fp ) );
save.c~:            KEY( "WearLoc", obj->wear_loc, fread_number( fp ) );
save.c~:            KEY( "Weight", obj->weight, fread_number( fp ) );
save.c~:         if( obj->name )
save.c~:            STRFREE( obj->name );
save.c~:         if( obj->description )
save.c~:            STRFREE( obj->description );
save.c~:         if( obj->short_descr )
save.c~:            STRFREE( obj->short_descr );
save.c~:         while( ( ed = obj->first_extradesc ) != NULL )
save.c~:            STRFREE( ed->keyword );
save.c~:            STRFREE( ed->description );
save.c~:            UNLINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c~:         while( ( paf = obj->first_affect ) != NULL )
save.c~:            UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
save.c~: * Based on last time modified, show when a player was last on	-Thoric
save.c~:   if( stat( buf, &fst ) != -1 && check_parse_name( capitalize( name ) ) )
save.c~:      name = ch->name;
save.c~:    * Go by vnum, less chance of screwups. -- Altrag 
save.c~:   for( corpse = first_object; corpse; corpse = corpse->next )
save.c~:      if( corpse->pIndexData->vnum == OBJ_VNUM_CORPSE_PC &&
save.c~:          corpse->in_room != NULL && !str_cmp( corpse->short_descr + 14, name ) )
save.c~:      if( de->d_name[0] != '.' )
save.c~:         sprintf( strArea, "%s%s", CORPSE_DIR, de->d_name );
save.c~:         fprintf( stderr, "Corpse -> %s\n", strArea );
save.c~:    ROOM_INDEX_DATA *storeroom = ch->plr_home;
save.c~:    if( IS_NPC( ch ) || ch->plr_home == NULL )
save.c~:    for( obj = storeroom->first_content; obj; obj = obj_next )
save.c~:        obj_next = obj->next_content;
save.c~:    sprintf( filename, "%s%c/%s.home", PLAYER_DIR, tolower( ch->name[0] ), capitalize( ch->name ) );
save.c~:                bug( ch->name, 0 );
save.c~:                bug( ch->name, 0 );
save.c~:        for( tobj = supermob->first_carrying; tobj; tobj = tobj_next )
save.c~:            tobj_next = tobj->next_content;
sha256.c:/*-
sha256.c:/* Copy a vector of big-endian int into a vector of bytes */
sha256.c:/* Copy a vector of bytes into a vector of big-endian int */
sha256.c: * (unsigned char) in big-endian form.  Assumes len is a multiple of 4.
sha256.c: * Decode a big-endian length len vector of (unsigned char) into a length
sha256.c:#define ROTR(x, n)	((x >> n) | (x << (32 - n)))
sha256.c:	RND(S[(64 - i) % 8], S[(65 - i) % 8],	\
sha256.c:	    S[(66 - i) % 8], S[(67 - i) % 8],	\
sha256.c:	    S[(68 - i) % 8], S[(69 - i) % 8],	\
sha256.c:	    S[(70 - i) % 8], S[(71 - i) % 8],	\
sha256.c: * SHA256 block compression function.  The 256-bit state is transformed via
sha256.c: * the 512-bit input block to produce a new state.
sha256.c:		W[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];
sha256.c:/* Add padding and terminating bit-count. */
sha256.c:	 * Convert length to a vector of bytes -- we do this now rather
sha256.c:	be32enc_vect(len, ctx->count, 8);
sha256.c:	/* Add 1--64 bytes so that the resulting length is 56 mod 64 */
sha256.c:	r = (ctx->count[1] >> 3) & 0x3f;
sha256.c:	plen = (r < 56) ? (56 - r) : (120 - r);
sha256.c:	/* Add the terminating bit-count */
sha256.c:/* SHA-256 initialization.  Begins a SHA-256 operation. */
sha256.c:	ctx->count[0] = ctx->count[1] = 0;
sha256.c:	ctx->state[0] = 0x6A09E667;
sha256.c:	ctx->state[1] = 0xBB67AE85;
sha256.c:	ctx->state[2] = 0x3C6EF372;
sha256.c:	ctx->state[3] = 0xA54FF53A;
sha256.c:	ctx->state[4] = 0x510E527F;
sha256.c:	ctx->state[5] = 0x9B05688C;
sha256.c:	ctx->state[6] = 0x1F83D9AB;
sha256.c:	ctx->state[7] = 0x5BE0CD19;
sha256.c:	r = (ctx->count[1] >> 3) & 0x3f;
sha256.c:	if ((ctx->count[1] += bitlen[1]) < bitlen[1])
sha256.c:		ctx->count[0]++;
sha256.c:	ctx->count[0] += bitlen[0];
sha256.c:	if (len < 64 - r) {
sha256.c:		memcpy(&ctx->buf[r], src, len);
sha256.c:	memcpy(&ctx->buf[r], src, 64 - r);
sha256.c:	SHA256_Transform(ctx->state, ctx->buf);
sha256.c:	src += 64 - r;
sha256.c:	len -= 64 - r;
sha256.c:		SHA256_Transform(ctx->state, src);
sha256.c:		len -= 64;
sha256.c:	memcpy(ctx->buf, src, len);
sha256.c: * SHA-256 finalization.  Pads the input data, exports the hash value,
sha256.c:	be32enc_vect(digest, ctx->state, 32);
sha256.h:/*-
shops.c:*--------------------------------------------------------------------------*
shops.c:* -------------------------------------------------------------------------*
shops.c:*--------------------------------------------------------------------------*
shops.c:* ------------------------------------------------------------------------ *
shops.c:* ------------------------------------------------------------------------ *
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:      if( IS_NPC( keeper ) && ( pShop = keeper->pIndexData->pShop ) != NULL )
shops.c:   if( time_info.hour < pShop->open_hour )
shops.c:   if( time_info.hour > pShop->close_hour )
shops.c:   if( !knows_language( keeper, ch->speaking, ch ) )
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:      if( IS_NPC( keeper ) && ( rShop = keeper->pIndexData->rShop ) != NULL )
shops.c:   if( time_info.hour < rShop->open_hour )
shops.c:   if( time_info.hour > rShop->close_hour )
shops.c:   if( !knows_language( keeper, ch->speaking, ch ) )
shops.c:   if( !obj || ( pShop = keeper->pIndexData->pShop ) == NULL )
shops.c:   if( ch->gold > ( ch->top_level * ch->top_level * 1000 ) )
shops.c:      cost = ( int )( cost * ( 80 + UMIN( ch->top_level, LEVEL_AVATAR ) ) ) / 100;
shops.c:      profitmod = 13 - get_curr_cha( ch ) + ( richcustomer ? 15 : 0 )
shops.c:         + ( ( URANGE( 5, ch->top_level, LEVEL_AVATAR ) - 20 ) / 2 );
shops.c:      cost = ( int )( obj->cost * UMAX( ( pShop->profit_sell + 1 ), pShop->profit_buy + profitmod ) ) / 100;
shops.c:      profitmod = get_curr_cha( ch ) - 13 - ( richcustomer ? 15 : 0 );
shops.c:         if( obj->item_type == pShop->buy_type[itype] )
shops.c:            cost = ( int )( obj->cost * UMIN( ( pShop->profit_buy - 1 ), pShop->profit_sell + profitmod ) ) / 100;
shops.c:      for( obj2 = keeper->first_carrying; obj2; obj2 = obj2->next_content )
shops.c:         if( obj->pIndexData == obj2->pIndexData )
shops.c:            cost /= ( obj2->count + 1 );
shops.c:   if( obj->item_type == ITEM_DEVICE )
shops.c:      cost = ( int )( cost * obj->value[2] / obj->value[1] );
shops.c:   if( !obj || ( rShop = keeper->pIndexData->rShop ) == NULL )
shops.c:      if( obj->item_type == rShop->fix_type[itype] )
shops.c:         cost = ( int )( obj->cost * rShop->profit_fix / 1000 );
shops.c:      cost = -1;
shops.c:      switch ( obj->item_type )
shops.c:            if( obj->value[0] >= obj->value[1] )
shops.c:               cost = -2;
shops.c:               cost *= ( obj->value[1] - obj->value[0] );
shops.c:            if( INIT_WEAPON_CONDITION == obj->value[0] )
shops.c:               cost = -2;
shops.c:               cost *= ( INIT_WEAPON_CONDITION - obj->value[0] );
shops.c:            if( obj->value[2] >= obj->value[1] )
shops.c:               cost = -2;
shops.c:               cost *= ( obj->value[1] - obj->value[2] );
shops.c:   if( IS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      in_room = ch->in_room;
shops.c:      ch->in_room = pRoomIndexNext;
shops.c:      ch->in_room = in_room;
shops.c:      if( pet == NULL || !IS_NPC( pet ) || !IS_SET( pet->act, ACT_PET ) )
shops.c:      if( IS_SET( ch->act, PLR_BOUGHT_PET ) )
shops.c:      if( ch->gold < 10 * pet->top_level * pet->top_level )
shops.c:      if( ch->top_level < pet->top_level )
shops.c:      maxgold = 10 * pet->top_level * pet->top_level;
shops.c:      ch->gold -= maxgold;
shops.c:      boost_economy( ch->in_room->area, maxgold );
shops.c:      pet = create_mobile( pet->pIndexData );
shops.c:      SET_BIT( ch->act, PLR_BOUGHT_PET );
shops.c:      SET_BIT( pet->act, ACT_PET );
shops.c:      SET_BIT( pet->affected_by, AFF_CHARM );
shops.c:         sprintf( buf, "%s %s", pet->name, arg );
shops.c:         STRFREE( pet->name );
shops.c:         pet->name = STRALLOC( buf );
shops.c:      sprintf( buf, "%sA neck tag says 'I belong to %s'.\r\n", pet->description, ch->name );
shops.c:      STRFREE( pet->description );
shops.c:      pet->description = STRALLOC( buf );
shops.c:      char_to_room( pet, ch->in_room );
shops.c:      maxgold = keeper->top_level * 10;
shops.c:            ch->reply = keeper;
shops.c:         for( obj = keeper->last_carrying; obj; obj = obj->prev_content )
shops.c:            if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
shops.c:         act( AT_TELL, "$n tells you 'I don't sell that -- try 'list'.'", keeper, NULL, ch, TO_VICT );
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->gold < cost )
shops.c:         ch->reply = keeper;
shops.c:      if( IS_SET( obj->extra_flags, ITEM_PROTOTYPE ) && get_trust( ch ) < LEVEL_IMMORTAL )
shops.c:         ch->reply = keeper;
shops.c:      if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:      if( ch->carry_weight + ( get_obj_weight( obj ) * noi ) + ( noi > 1 ? 2 : 0 ) > can_carry_w( ch ) )
shops.c:         sprintf( arg, "$n buys %d $p%s.", noi, ( obj->short_descr[strlen( obj->short_descr ) - 1] == 's' ? "" : "s" ) );
shops.c:         sprintf( arg, "You buy %d $p%s.", noi, ( obj->short_descr[strlen( obj->short_descr ) - 1] == 's' ? "" : "s" ) );
shops.c:      ch->gold -= cost;
shops.c:      keeper->gold += cost;
shops.c:      if( keeper->gold > maxgold )
shops.c:         boost_economy( keeper->in_room->area, keeper->gold - maxgold / 2 );
shops.c:         keeper->gold = maxgold / 2;
shops.c:         buy_obj = create_object( obj->pIndexData, obj->level );
shops.c:          * The shopkeeper gives you a bag with multiple-buy,
shops.c:          * set to the number bought.    -Thoric
shops.c:            bag->value[0] = bag->weight + ( buy_obj->weight * noi );
shops.c:            buy_obj->count = noi;
shops.c:            obj->pIndexData->count += ( noi - 1 );
shops.c:            numobjsloaded += ( noi - 1 );
shops.c:   if( IS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      for( pet = pRoomIndexNext->first_person; pet; pet = pet->next_in_room )
shops.c:         if( IS_SET( pet->act, ACT_PET ) && IS_NPC( pet ) )
shops.c:            ch_printf( ch, "[%2d] %8d - %s\r\n", pet->top_level, 10 * pet->top_level * pet->top_level, pet->short_descr );
shops.c:      for( obj = keeper->last_carrying; obj; obj = obj->prev_content )
shops.c:         if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
shops.c:            if( ( cost = get_cost( ch, keeper, obj, TRUE ) ) > 0 && ( arg[0] == '\0' || nifty_is_name( arg, obj->name ) ) )
shops.c:                          cost, oref, capitalize( obj->short_descr ),
shops.c:                          IS_SET( obj->extra_flags, ITEM_HUTT_SIZE ) ? " (hutt size)" :
shops.c:                          ( IS_SET( obj->extra_flags, ITEM_LARGE_SIZE ) ? " (large)" :
shops.c:                            ( IS_SET( obj->extra_flags, ITEM_HUMAN_SIZE ) ? " (medium)" :
shops.c:                              ( IS_SET( obj->extra_flags, ITEM_SMALL_SIZE ) ? " (small)" : "" ) ) ) );
shops.c:      ch->reply = keeper;
shops.c:   if( obj->timer > 0 )
shops.c:   if( cost > keeper->gold )
shops.c:      lower_economy( ch->in_room->area, cost - keeper->gold );
shops.c:   ch->gold += cost;
shops.c:   keeper->gold -= cost;
shops.c:   if( keeper->gold < 0 )
shops.c:      keeper->gold = 0;
shops.c:   if( obj->item_type == ITEM_TRASH )
shops.c:   else if( IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
shops.c:         UMIN( obj->cost * 10,
shops.c:               ( exp_level( ch->skill_level[SMUGGLING_ABILITY] + 1 ) -
shops.c:                 exp_level( ch->skill_level[SMUGGLING_ABILITY] ) ) / 10 );
shops.c:      if( obj->item_type == ITEM_SPICE || obj->item_type == ITEM_RAWSPICE )
shops.c:         REMOVE_BIT( obj->extra_flags, ITEM_CONTRABAND );
shops.c:   else if( obj->item_type == ITEM_SPICE || obj->item_type == ITEM_RAWSPICE )
shops.c:      ch->reply = keeper;
shops.c:   ch->reply = keeper;
shops.c: * Repair a single object. Used when handling "repair all" - Gorog
shops.c:      ch_printf( ch, "You can't let go of %s.\r\n", obj->name );
shops.c:      if( cost != -2 )
shops.c:    * "repair all" gets a 10% surcharge - Gorog 
shops.c:   else if( ( cost = strcmp( "all", arg ) ? cost : 11 * cost / 10 ) > ch->gold )
shops.c:      sprintf( buf, "$N tells you, 'It will cost %d credit%s to %s %s...'", cost, cost == 1 ? "" : "s", fixstr, obj->name );
shops.c:      ch->gold -= cost;
shops.c:      keeper->gold += cost;
shops.c:      if( keeper->gold < 0 )
shops.c:         keeper->gold = 0;
shops.c:      else if( keeper->gold > maxgold )
shops.c:         boost_economy( keeper->in_room->area, keeper->gold - maxgold / 2 );
shops.c:         keeper->gold = maxgold / 2;
shops.c:      switch ( obj->item_type )
shops.c:            obj->value[0] = obj->value[1];
shops.c:            obj->value[0] = INIT_WEAPON_CONDITION;
shops.c:            obj->value[2] = obj->value[1];
shops.c:   maxgold = keeper->top_level * 10;
shops.c:   switch ( keeper->pIndexData->rShop->shop_type )
shops.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
shops.c:         if( obj->wear_loc == WEAR_NONE
shops.c:             && ( obj->item_type == ITEM_ARMOR || obj->item_type == ITEM_WEAPON || obj->item_type == ITEM_DEVICE ) )
shops.c:      ch->reply = keeper;
shops.c:   for( obj = ch->first_carrying; obj != NULL; obj = obj->next_content )
shops.c:      if( obj->wear_loc == WEAR_NONE
shops.c:          && ( obj->item_type == ITEM_ARMOR || obj->item_type == ITEM_WEAPON || obj->item_type == ITEM_DEVICE ) )
shops.c:            ch_printf( ch, "You can't let go of %s.\r\n", obj->name );
shops.c:            if( cost != -2 )
shops.c:                     "$N tells you, 'It will cost %d credit%s to %s %s'", cost, cost == 1 ? "" : "s", fixstr, obj->name );
shops.c:   switch ( keeper->pIndexData->rShop->shop_type )
shops.c:      ch->reply = keeper;
shops.c:      if( cost != -2 )
shops.c:   if( cost > ch->gold )
shops.c:/* ------------------ Shop Building and Editing Section ----------------- */
shops.c:   if( mob->pShop )
shops.c:   shop->keeper = vnum;
shops.c:   shop->profit_buy = 120;
shops.c:   shop->profit_sell = 90;
shops.c:   shop->open_hour = 0;
shops.c:   shop->close_hour = 23;
shops.c:   mob->pShop = shop;
shops.c:   if( !mob->pShop )
shops.c:   shop = mob->pShop;
shops.c:      shop->buy_type[0] = value;
shops.c:      shop->buy_type[1] = value;
shops.c:      shop->buy_type[2] = value;
shops.c:      shop->buy_type[3] = value;
shops.c:      shop->buy_type[4] = value;
shops.c:      if( value <= ( shop->profit_sell + 5 ) || value > 1000 )
shops.c:      shop->profit_buy = value;
shops.c:      if( value < 0 || value >= ( shop->profit_buy - 5 ) )
shops.c:      shop->profit_sell = value;
shops.c:      shop->open_hour = value;
shops.c:      shop->close_hour = value;
shops.c:      if( mob2->pShop )
shops.c:      mob->pShop = NULL;
shops.c:      mob2->pShop = shop;
shops.c:      shop->keeper = value;
shops.c:   if( !mob->pShop )
shops.c:   shop = mob->pShop;
shops.c:   ch_printf( ch, "Keeper: %d  %s\r\n", shop->keeper, mob->short_descr );
shops.c:              o_types[shop->buy_type[0]],
shops.c:              o_types[shop->buy_type[1]],
shops.c:              o_types[shop->buy_type[2]], o_types[shop->buy_type[3]], o_types[shop->buy_type[4]] );
shops.c:   ch_printf( ch, "Profit:  buy %3d%%  sell %3d%%\r\n", shop->profit_buy, shop->profit_sell );
shops.c:   ch_printf( ch, "Hours:   open %2d  close %2d\r\n", shop->open_hour, shop->close_hour );
shops.c:   for( shop = first_shop; shop; shop = shop->next )
shops.c:                 shop->keeper, shop->profit_buy, shop->profit_sell,
shops.c:                 shop->open_hour, shop->close_hour,
shops.c:                 shop->buy_type[0], shop->buy_type[1], shop->buy_type[2], shop->buy_type[3], shop->buy_type[4] );
shops.c:/* -------------- Repair Shop Building and Editing Section -------------- */
shops.c:   if( mob->rShop )
shops.c:   repair->keeper = vnum;
shops.c:   repair->profit_fix = 100;
shops.c:   repair->shop_type = SHOP_FIX;
shops.c:   repair->open_hour = 0;
shops.c:   repair->close_hour = 23;
shops.c:   mob->rShop = repair;
shops.c:   if( !mob->rShop )
shops.c:   repair = mob->rShop;
shops.c:      repair->fix_type[0] = value;
shops.c:      repair->fix_type[1] = value;
shops.c:      repair->fix_type[2] = value;
shops.c:      repair->profit_fix = value;
shops.c:      repair->shop_type = value;
shops.c:      repair->open_hour = value;
shops.c:      repair->close_hour = value;
shops.c:      if( mob2->rShop )
shops.c:      mob->rShop = NULL;
shops.c:      mob2->rShop = repair;
shops.c:      repair->keeper = value;
shops.c:   if( !mob->rShop )
shops.c:   repair = mob->rShop;
shops.c:   ch_printf( ch, "Keeper: %d  %s\r\n", repair->keeper, mob->short_descr );
shops.c:              o_types[repair->fix_type[0]], o_types[repair->fix_type[1]], o_types[repair->fix_type[2]] );
shops.c:   ch_printf( ch, "Profit: %3d%%  Type: %d\r\n", repair->profit_fix, repair->shop_type );
shops.c:   ch_printf( ch, "Hours:   open %2d  close %2d\r\n", repair->open_hour, repair->close_hour );
shops.c:   for( repair = first_repair; repair; repair = repair->next )
shops.c:                 repair->keeper, repair->profit_fix, repair->shop_type,
shops.c:                 repair->open_hour, repair->close_hour, repair->fix_type[0], repair->fix_type[1], repair->fix_type[2] );
skills.c:*--------------------------------------------------------------------------*
skills.c:* -------------------------------------------------------------------------*
skills.c:*--------------------------------------------------------------------------*
skills.c:* ------------------------------------------------------------------------ *
skills.c:* ------------------------------------------------------------------------ *
skills.c:  return -1;
skills.c:  return -1;
skills.c:  return -1;
skills.c:  return -1;
skills.c:  return -1;
skills.c:  return -1;
skills.c:  return -1;
skills.c: * Only match skills player knows				-Thoric
skills.c:   int top = gsn_first_weapon - 1;
skills.c:      if( LOWER( command[0] ) == LOWER( skill_table[sn]->name[0] )
skills.c:          && !str_prefix( command, skill_table[sn]->name )
skills.c:          && ( skill_table[sn]->skill_fun || skill_table[sn]->spell_fun != spell_null )
skills.c:          && ( IS_NPC( ch ) || ( ch->pcdata->learned[sn] > 0 ) ) )
skills.c:      if( strcasecmp( command, skill_table[sn]->name ) < 1 )
skills.c:         top = sn - 1;
skills.c:   if( !check_pos( ch, skill_table[sn]->minimum_position ) )
skills.c:   if( skill_table[sn]->min_mana )
skills.c:      mana = IS_NPC( ch ) ? 0 : skill_table[sn]->min_mana;
skills.c:      if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:    * Is this a real do-fun, or a really a spell?
skills.c:   if( !skill_table[sn]->skill_fun )
skills.c:      switch ( skill_table[sn]->target )
skills.c:                  target_name = victim->name;
skills.c:               ch_printf( ch, "%s who?\r\n", capitalize( skill_table[sn]->name ) );
skills.c:      WAIT_STATE( ch, skill_table[sn]->beats );
skills.c:      if( ( number_percent(  ) + skill_table[sn]->difficulty * 5 ) > ( IS_NPC( ch ) ? 75 : ch->pcdata->learned[sn] ) )
skills.c:            ch->mana -= mana / 2;
skills.c:         ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->top_level, ch, vo );
skills.c:      update_userec( &time_used, &skill_table[sn]->userec );
skills.c:      if( skill_table[sn]->target == TAR_CHAR_OFFENSIVE && victim != ch && !char_died( victim ) )
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:            if( victim == vch && !victim->fighting && victim->master != ch )
skills.c:      ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:   ( *skill_table[sn]->skill_fun ) ( ch, argument );
skills.c:   update_userec( &time_used, &skill_table[sn]->userec );
skills.c:      for( sn = 0; sn < top_sn && skill_table[sn] && skill_table[sn]->name; sn++ )
skills.c:         pager_printf( ch, "Sn: %4d Slot: %4d Skill/spell: '%-20s' Damtype: %s\r\n",
skills.c:                       sn, skill_table[sn]->slot, skill_table[sn]->name, spell_damage[SPELL_DAMAGE( skill_table[sn] )] );
skills.c:      for( sn = 0; sn < top_herb && herb_table[sn] && herb_table[sn]->name; sn++ )
skills.c:         pager_printf( ch, "%d) %s\r\n", sn, herb_table[sn]->name );
skills.c:      ch_printf( ch, "Sn: %4d Slot: %4d %s: '%-20s'\r\n", sn, skill->slot, skill_tname[skill->type], skill->name );
skills.c:      if( skill->flags )
skills.c:               strcat( buf, spell_flag[x - 11] );
skills.c:      ch_printf( ch, "Saves: %s\r\n", spell_saves[( int )skill->saves] );
skills.c:      if( skill->difficulty != '\0' )
skills.c:         ch_printf( ch, "Difficulty: %d\r\n", ( int )skill->difficulty );
skills.c:                 skill_tname[skill->type],
skills.c:                 target_type[URANGE( TAR_IGNORE, skill->target, TAR_OBJ_INV )],
skills.c:                 skill->minimum_position, skill->min_mana, skill->beats );
skills.c:                 skill->flags,
skills.c:                 skill->guild, skill->skill_fun ? skill->skill_fun_name : skill->spell_fun_name );
skills.c:      ch_printf( ch, "Dammsg: %s\r\nWearoff: %s\n", skill->noun_damage, skill->msg_off ? skill->msg_off : "(none set)" );
skills.c:      if( skill->dice && skill->dice[0] != '\0' )
skills.c:         ch_printf( ch, "Dice: %s\r\n", skill->dice );
skills.c:      if( skill->teachers && skill->teachers[0] != '\0' )
skills.c:         ch_printf( ch, "Teachers: %s\r\n", skill->teachers );
skills.c:      if( skill->components && skill->components[0] != '\0' )
skills.c:         ch_printf( ch, "Components: %s\r\n", skill->components );
skills.c:      if( skill->participants )
skills.c:         ch_printf( ch, "Participants: %d\r\n", ( int )skill->participants );
skills.c:      if( skill->userec.num_uses )
skills.c:         send_timer( &skill->userec, ch );
skills.c:      for( aff = skill->first_affect; aff; aff = aff->next )
skills.c:         if( aff == skill->first_affect )
skills.c:         if( aff->location )
skills.c:            strcat( buf, a_types[aff->location % REVERSE_APPLY] );
skills.c:            strcat( buf, aff->modifier );
skills.c:            if( aff->bitvector )
skills.c:         if( aff->bitvector )
skills.c:               if( IS_SET( aff->bitvector, 1 << x ) )
skills.c:         if( aff->duration[0] != '\0' && aff->duration[0] != '0' )
skills.c:            strcat( buf, aff->duration );
skills.c:         if( aff->location >= REVERSE_APPLY )
skills.c:         if( !aff->next )
skills.c:      if( skill->hit_char && skill->hit_char[0] != '\0' )
skills.c:         ch_printf( ch, "Hitchar   : %s\r\n", skill->hit_char );
skills.c:      if( skill->hit_vict && skill->hit_vict[0] != '\0' )
skills.c:         ch_printf( ch, "Hitvict   : %s\r\n", skill->hit_vict );
skills.c:      if( skill->hit_room && skill->hit_room[0] != '\0' )
skills.c:         ch_printf( ch, "Hitroom   : %s\r\n", skill->hit_room );
skills.c:      if( skill->miss_char && skill->miss_char[0] != '\0' )
skills.c:         ch_printf( ch, "Misschar  : %s\r\n", skill->miss_char );
skills.c:      if( skill->miss_vict && skill->miss_vict[0] != '\0' )
skills.c:         ch_printf( ch, "Missvict  : %s\r\n", skill->miss_vict );
skills.c:      if( skill->miss_room && skill->miss_room[0] != '\0' )
skills.c:         ch_printf( ch, "Missroom  : %s\r\n", skill->miss_room );
skills.c:      if( skill->die_char && skill->die_char[0] != '\0' )
skills.c:         ch_printf( ch, "Diechar   : %s\r\n", skill->die_char );
skills.c:      if( skill->die_vict && skill->die_vict[0] != '\0' )
skills.c:         ch_printf( ch, "Dievict   : %s\r\n", skill->die_vict );
skills.c:      if( skill->die_room && skill->die_room[0] != '\0' )
skills.c:         ch_printf( ch, "Dieroom   : %s\r\n", skill->die_room );
skills.c:      if( skill->imm_char && skill->imm_char[0] != '\0' )
skills.c:         ch_printf( ch, "Immchar   : %s\r\n", skill->imm_char );
skills.c:      if( skill->imm_vict && skill->imm_vict[0] != '\0' )
skills.c:         ch_printf( ch, "Immvict   : %s\r\n", skill->imm_vict );
skills.c:      if( skill->imm_room && skill->imm_room[0] != '\0' )
skills.c:         ch_printf( ch, "Immroom   : %s\r\n", skill->imm_room );
skills.c:      if( skill->type != SKILL_HERB && skill->guild >= 0 && skill->guild < MAX_ABILITY )
skills.c:                  ability_name[skill->guild], skill->alignment, skill->min_level );
skills.c:         for( max = x = 0; x < top_herb - 1; x++ )
skills.c:            if( herb_table[x] && herb_table[x]->slot > max )
skills.c:               max = herb_table[x]->slot;
skills.c:         skill->slot = max + 1;
skills.c:      skill->name = str_dup( argument );
skills.c:      skill->noun_damage = str_dup( "" );
skills.c:      skill->msg_off = str_dup( "" );
skills.c:      skill->spell_fun = spell_smaug;
skills.c:      skill->type = type;
skills.c:         skill->difficulty = atoi( argument );
skills.c:         skill->participants = atoi( argument );
skills.c:         skill->alignment = atoi( argument );
skills.c:         if( x == -1 )
skills.c:         if( x == -1 )
skills.c:         if( x == -1 )
skills.c:         if( x == -1 )
skills.c:         if( x == -1 )
skills.c:            TOGGLE_BIT( skill->flags, 1 << ( x + 11 ) );
skills.c:         if( x == -1 )
skills.c:            skill->saves = x;
skills.c:	       skill->skill_fun = dofun;
skills.c:	       skill->spell_fun = NULL;
skills.c:	       DISPOSE( skill->skill_fun_name );
skills.c:	       skill->skill_fun_name = str_dup( argument );
skills.c:	       skill->spell_fun = spellfun;
skills.c:	       skill->skill_fun = NULL;
skills.c:	       DISPOSE( skill->skill_fun_name );
skills.c:	       skill->spell_fun_name = str_dup( argument );
skills.c:         if( x == -1 )
skills.c:            skill->target = x;
skills.c:         skill->minimum_position = URANGE( POS_DEAD, atoi( argument ), POS_DRAG );
skills.c:         skill->min_level = URANGE( 1, atoi( argument ), MAX_LEVEL );
skills.c:         skill->slot = URANGE( 0, atoi( argument ), 30000 );
skills.c:         skill->min_mana = URANGE( 0, atoi( argument ), 2000 );
skills.c:         skill->beats = URANGE( 0, atoi( argument ), 120 );
skills.c:         skill->guild = atoi( argument );
skills.c:         skill->value = atoi( argument );
skills.c:         skill->type = get_skill( argument );
skills.c:         if( !skill->first_affect )
skills.c:         for( aff = skill->first_affect; aff; aff = aff_next )
skills.c:            aff_next = aff->next;
skills.c:               UNLINK( aff, skill->first_affect, skill->last_affect, next, prev );
skills.c:               DISPOSE( aff->duration );
skills.c:               DISPOSE( aff->modifier );
skills.c:            if( ( tmpbit = get_aflag( bitvector ) ) == -1 )
skills.c:         aff->duration = str_dup( duration );
skills.c:         aff->location = loc;
skills.c:            /* Sanitize the flag input for the modifier if needed -- Samson */
skills.c:         aff->modifier = str_dup( modifier );
skills.c:         aff->bitvector = bit;
skills.c:         LINK( aff, skill->first_affect, skill->last_affect, next, prev );
skills.c:         skill->min_level = URANGE( 1, atoi( argument ), MAX_LEVEL );
skills.c:         DISPOSE( skill->name );
skills.c:         skill->name = str_dup( argument );
skills.c:         DISPOSE( skill->noun_damage );
skills.c:            skill->noun_damage = str_dup( "" );
skills.c:            skill->noun_damage = str_dup( argument );
skills.c:         DISPOSE( skill->msg_off );
skills.c:            skill->msg_off = str_dup( argument );
skills.c:         if( skill->hit_char )
skills.c:            DISPOSE( skill->hit_char );
skills.c:            skill->hit_char = str_dup( argument );
skills.c:         if( skill->hit_vict )
skills.c:            DISPOSE( skill->hit_vict );
skills.c:            skill->hit_vict = str_dup( argument );
skills.c:         if( skill->hit_room )
skills.c:            DISPOSE( skill->hit_room );
skills.c:            skill->hit_room = str_dup( argument );
skills.c:         if( skill->miss_char )
skills.c:            DISPOSE( skill->miss_char );
skills.c:            skill->miss_char = str_dup( argument );
skills.c:         if( skill->miss_vict )
skills.c:            DISPOSE( skill->miss_vict );
skills.c:            skill->miss_vict = str_dup( argument );
skills.c:         if( skill->miss_room )
skills.c:            DISPOSE( skill->miss_room );
skills.c:            skill->miss_room = str_dup( argument );
skills.c:         if( skill->die_char )
skills.c:            DISPOSE( skill->die_char );
skills.c:            skill->die_char = str_dup( argument );
skills.c:         if( skill->die_vict )
skills.c:            DISPOSE( skill->die_vict );
skills.c:            skill->die_vict = str_dup( argument );
skills.c:         if( skill->die_room )
skills.c:            DISPOSE( skill->die_room );
skills.c:            skill->die_room = str_dup( argument );
skills.c:         if( skill->imm_char )
skills.c:            DISPOSE( skill->imm_char );
skills.c:            skill->imm_char = str_dup( argument );
skills.c:         if( skill->imm_vict )
skills.c:            DISPOSE( skill->imm_vict );
skills.c:            skill->imm_vict = str_dup( argument );
skills.c:         if( skill->imm_room )
skills.c:            DISPOSE( skill->imm_room );
skills.c:            skill->imm_room = str_dup( argument );
skills.c:         if( skill->dice )
skills.c:            DISPOSE( skill->dice );
skills.c:            skill->dice = str_dup( argument );
skills.c:         if( skill->components )
skills.c:            DISPOSE( skill->components );
skills.c:            skill->components = str_dup( argument );
skills.c:         if( skill->teachers )
skills.c:            DISPOSE( skill->teachers );
skills.c:            skill->teachers = str_dup( argument );
skills.c:         if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
skills.c:         if( skill_table[sn]->name
skills.c:             && ( victim->skill_level[skill_table[sn]->guild] >= skill_table[sn]->min_level || value == 0 ) )
skills.c:            victim->pcdata->learned[sn] = value;
skills.c:      victim->pcdata->learned[sn] = value;
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] == 0 )
skills.c:   if( sn == skill_lookup( "meditate" ) && ch->skill_level[FORCE_ABILITY] < 2 )
skills.c:   sklvl = skill_table[sn]->min_level;
skills.c:   if( skill_table[sn]->guild < 0 || skill_table[sn]->guild >= MAX_ABILITY )
skills.c:   adept = ( ch->skill_level[skill_table[sn]->guild] - skill_table[sn]->min_level ) * 5 + 50;
skills.c:   if( ch->pcdata->learned[sn] >= adept )
skills.c:   if( sklvl == 0 || sklvl > ch->skill_level[skill_table[sn]->guild] )
skills.c:      sklvl = ch->skill_level[skill_table[sn]->guild];
skills.c:   if( ch->pcdata->learned[sn] < 100 )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      else if( schance - percent > 25 )
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == 100 )   /* fully learned! */
skills.c:         ch_printf( ch, "You are now an adept of %s!  You gain %d bonus experience!\r\n", skill_table[sn]->name, gain );
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:      gain_exp( ch, gain, skill_table[sn]->guild );
skills.c:   if( !IS_NPC( ch ) && !ch->pcdata->learned[gsn_gouge] )
skills.c:   if( ch->mount )
skills.c:   percent = number_percent(  ) - ( get_curr_lck( ch ) - 13 );
skills.c:   if( IS_NPC( ch ) || percent < ch->pcdata->learned[gsn_gouge] )
skills.c:      dam = number_range( 1, ch->skill_level[COMBAT_ABILITY] );
skills.c:            af.modifier = -6;
skills.c:            af.duration = 3 + ( ch->skill_level[COMBAT_ABILITY] / 20 );
skills.c:          * Taken out by request - put back in by Thoric
skills.c:      WAIT_STATE( ch, skill_table[gsn_gouge]->beats );
skills.c:   switch ( ch->substate )
skills.c:         if( !IS_NPC( ch ) && !ch->pcdata->learned[gsn_detrap] )
skills.c:         if( ch->mount )
skills.c:         if( !ch->in_room->first_content )
skills.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:            if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
skills.c:         ch->dest_buf = str_dup( obj->name );
skills.c:/*	    WAIT_STATE( ch, skill_table[gsn_detrap]->beats ); */
skills.c:         if( !ch->dest_buf )
skills.c:            bug( "do_detrap: ch->dest_buf NULL!", 0 );
skills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         ch->dest_buf = NULL;
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         ch->substate = SUB_NONE;
skills.c:   if( !ch->in_room->first_content )
skills.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
skills.c:   percent = number_percent(  ) - ( ch->skill_level[SMUGGLING_ABILITY] / 20 ) - ( get_curr_lck( ch ) - 16 );
skills.c:   if( !IS_NPC( ch ) || percent > ch->pcdata->learned[gsn_detrap] )
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:            if( ( pexit = find_door( ch, arg, TRUE ) ) == NULL && get_dir( arg ) == -1 )
skills.c:               if( !IS_SET( pexit->exit_info, EX_DIG ) && !IS_SET( pexit->exit_info, EX_CLOSED ) )
skills.c:            switch ( ch->in_room->sector_type )
skills.c:         add_timer( ch, TIMER_DO_FUN, UMIN( skill_table[gsn_dig]->beats / 10, 3 ), do_dig, 1 );
skills.c:         ch->dest_buf = str_dup( arg );
skills.c:         if( !ch->dest_buf )
skills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:      if( obj->item_type == ITEM_SHOVEL )
skills.c:          && IS_SET( pexit->exit_info, EX_DIG ) && IS_SET( pexit->exit_info, EX_CLOSED ) )
skills.c:         if( ( number_percent(  ) * ( shovel ? 1 : 4 ) ) < ( IS_NPC( ch ) ? 80 : ch->pcdata->learned[gsn_dig] ) )
skills.c:            REMOVE_BIT( pexit->exit_info, EX_CLOSED );
skills.c:   startobj = ch->in_room->first_content;
skills.c:   for( obj = startobj; obj; obj = obj->next_content )
skills.c:          && ( number_percent(  ) * ( shovel ? 1 : 2 ) ) < ( IS_NPC( ch ) ? 80 : ch->pcdata->learned[gsn_dig] ) )
skills.c:   REMOVE_BIT( obj->extra_flags, ITEM_BURRIED );
skills.c:   door = -1;
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         if( arg[0] != '\0' && ( door = get_door( arg ) ) == -1 )
skills.c:            if( container->item_type != ITEM_CONTAINER )
skills.c:            if( IS_SET( container->value[1], CONT_CLOSED ) )
skills.c:         add_timer( ch, TIMER_DO_FUN, UMIN( skill_table[gsn_search]->beats / 10, 3 ), do_search, 1 );
skills.c:         ch->dest_buf = str_dup( arg );
skills.c:         if( !ch->dest_buf )
skills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         DISPOSE( ch->dest_buf );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:      startobj = ch->in_room->first_content;
skills.c:      if( ( door = get_door( arg ) ) != -1 )
skills.c:         startobj = container->first_content;
skills.c:   if( ( !startobj && door == -1 ) || IS_NPC( ch ) )
skills.c:   if( door != -1 )
skills.c:      if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
skills.c:          && IS_SET( pexit->exit_info, EX_SECRET )
skills.c:          && IS_SET( pexit->exit_info, EX_xSEARCHABLE )
skills.c:          && percent < ( IS_NPC( ch ) ? 80 : ch->pcdata->learned[gsn_search] ) )
skills.c:         act( AT_SKILL, "Your search reveals the $d!", ch, NULL, pexit->keyword, TO_CHAR );
skills.c:         act( AT_SKILL, "$n finds the $d!", ch, NULL, pexit->keyword, TO_ROOM );
skills.c:         REMOVE_BIT( pexit->exit_info, EX_SECRET );
skills.c:      for( obj = startobj; obj; obj = obj->next_content )
skills.c:         if( IS_OBJ_STAT( obj, ITEM_HIDDEN ) && percent < ch->pcdata->learned[gsn_search] )
skills.c:   REMOVE_BIT( obj->extra_flags, ITEM_HIDDEN );
skills.c:   if( ch->mount )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   WAIT_STATE( ch, skill_table[gsn_steal]->beats );
skills.c:   percent = number_percent(  ) + ( IS_AWAKE( victim ) ? 10 : -50 )
skills.c:      - ( get_curr_lck( ch ) - 15 ) + ( get_curr_lck( victim ) - 13 ) + times_killed( ch, victim ) * 7;
skills.c:   if( victim->position == POS_FIGHTING || percent > ( IS_NPC( ch ) ? 90 : ch->pcdata->learned[gsn_steal] ) )
skills.c:      sprintf( buf, "%s is a bloody thief!", ch->name );
skills.c:               if( ( mst = ch->master ) == NULL )
skills.c:      amount = ( int )( victim->gold * number_range( 1, 10 ) / 100 );
skills.c:      ch->gold += amount;
skills.c:      victim->gold -= amount;
skills.c:                  ( exp_level( ch->skill_level[SMUGGLING_ABILITY] + 1 ) -
skills.c:                    exp_level( ch->skill_level[SMUGGLING_ABILITY] ) ) / 35 );
skills.c:      if( victim->position <= POS_SLEEPING )
skills.c:            if( ( obj_next = get_eq_char( victim, obj->wear_loc ) ) != obj )
skills.c:               ch_printf( ch, "They are wearing %s on top of %s.\r\n", obj_next->short_descr, obj->short_descr );
skills.c:   if( ch->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( ch ) )
skills.c:   if( ch->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( ch ) )
skills.c:         UMIN( obj->cost * 10,
skills.c:               ( exp_level( ch->skill_level[SMUGGLING_ABILITY] + 1 ) -
skills.c:                 exp_level( ch->skill_level[SMUGGLING_ABILITY] ) ) / 10 );
skills.c:   if( ch->mount )
skills.c:    * Added stabbing weapon. -Narn 
skills.c:   if( ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL || ( obj->value[3] != WEAPON_VIBRO_BLADE ) )
skills.c:   if( victim->fighting )
skills.c:    * Can backstab a char even if it's hurt as long as it's sleeping. -Narn 
skills.c:   if( victim->hit < victim->max_hit && IS_AWAKE( victim ) )
skills.c:   percent = number_percent(  ) - ( get_curr_lck( ch ) - 14 ) + ( get_curr_lck( victim ) - 13 );
skills.c:   WAIT_STATE( ch, skill_table[gsn_backstab]->beats );
skills.c:   if( !IS_AWAKE( victim ) || IS_NPC( ch ) || percent < ch->pcdata->learned[gsn_backstab] )
skills.c:   if( ch->mount )
skills.c:   ch->alignment = ch->alignment + 5;
skills.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:   percent = number_percent(  ) - ( get_curr_lck( ch ) - 14 ) - ( get_curr_lck( victim ) - 16 );
skills.c:   WAIT_STATE( ch, skill_table[gsn_rescue]->beats );
skills.c:   if( !IS_NPC( ch ) && percent > ch->pcdata->learned[gsn_rescue] )
skills.c:   ch->alignment = ch->alignment + 50;
skills.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:   if( ch->fighting )
skills.c:   WAIT_STATE( ch, skill_table[gsn_kick]->beats );
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_kick] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->skill_level[COMBAT_ABILITY] ), gsn_kick );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_punch] <= 0 )
skills.c:   WAIT_STATE( ch, skill_table[gsn_punch]->beats );
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_punch] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->skill_level[COMBAT_ABILITY] ), gsn_punch );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_bash] <= 0 )
skills.c:                 - ( get_curr_dex( ch ) + get_curr_str( ch ) ) ) * 10 ) + 10;
skills.c:   if( victim->fighting && victim->fighting->who != ch )
skills.c:   WAIT_STATE( ch, skill_table[gsn_bash]->beats );
skills.c:   if( IS_NPC( ch ) || ( number_percent(  ) + schance ) < ch->pcdata->learned[gsn_bash] )
skills.c:       * do not change anything here!  -Thoric 
skills.c:      victim->position = POS_SITTING;
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->skill_level[COMBAT_ABILITY] ), gsn_bash );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_stun] <= 0 )
skills.c:   if( ch->move < 16 )
skills.c:   WAIT_STATE( ch, skill_table[gsn_stun]->beats );
skills.c:   schance = ris_save( victim, ch->skill_level[COMBAT_ABILITY], RIS_PARALYSIS );
skills.c:                 - ( get_curr_dex( ch ) + get_curr_str( ch ) ) ) * 10 ) + 10;
skills.c:   if( !fail && ( IS_NPC( ch ) || ( number_percent(  ) + schance ) < ch->pcdata->learned[gsn_stun] ) )
skills.c:       * DO *NOT* CHANGE!    -Thoric    
skills.c:      ch->move -= 15;
skills.c:      ch->move -= 5;
skills.c: * Check for loyalty flag (weapon disarms to inventory) for pkillers -Blodkai
skills.c:      tmpobj->wear_loc = WEAR_WIELD;
skills.c:   obj_to_room( obj, victim->in_room );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_disarm] <= 0 )
skills.c:   WAIT_STATE( ch, skill_table[gsn_disarm]->beats );
skills.c:   percent = number_percent(  ) + victim->skill_level[COMBAT_ABILITY] - ch->skill_level[COMBAT_ABILITY]
skills.c:      - ( get_curr_lck( ch ) - 15 ) + ( get_curr_lck( victim ) - 15 );
skills.c:   if( IS_NPC( ch ) || percent < ch->pcdata->learned[gsn_disarm] * 2 / 3 )
skills.c:   if( victim->mount )
skills.c:      if( IS_AFFECTED( victim->mount, AFF_FLYING ) || IS_AFFECTED( victim->mount, AFF_FLOATING ) )
skills.c:      REMOVE_BIT( victim->mount->act, ACT_MOUNTED );
skills.c:      victim->mount = NULL;
skills.c:      victim->position = POS_RESTING;
skills.c:   if( victim->wait == 0 )
skills.c:      victim->position = POS_RESTING;
skills.c:   if( ch->mount )
skills.c:   WAIT_STATE( ch, skill_table[gsn_pick_lock]->beats );
skills.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:      if( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->skill_level[SMUGGLING_ABILITY] < gch->top_level )
skills.c:      if( !IS_SET( pexit->exit_info, EX_CLOSED ) )
skills.c:      if( pexit->key < 0 )
skills.c:      if( !IS_SET( pexit->exit_info, EX_LOCKED ) )
skills.c:      if( IS_SET( pexit->exit_info, EX_PICKPROOF ) )
skills.c:         check_room_for_traps( ch, TRAP_PICK | trap_door[pexit->vdir] );
skills.c:      if( !IS_NPC( ch ) && number_percent(  ) > ch->pcdata->learned[gsn_pick_lock] )
skills.c:      REMOVE_BIT( pexit->exit_info, EX_LOCKED );
skills.c:      act( AT_ACTION, "$n picks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:         REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
skills.c:      check_room_for_traps( ch, TRAP_PICK | trap_door[pexit->vdir] );
skills.c:      if( obj->item_type != ITEM_CONTAINER )
skills.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
skills.c:      if( obj->value[2] < 0 )
skills.c:      if( !IS_SET( obj->value[1], CONT_LOCKED ) )
skills.c:      if( IS_SET( obj->value[1], CONT_PICKPROOF ) )
skills.c:      if( !IS_NPC( ch ) && number_percent(  ) > ch->pcdata->learned[gsn_pick_lock] )
skills.c:      REMOVE_BIT( obj->value[1], CONT_LOCKED );
skills.c:   if( ( ship = ship_in_room( ch->in_room, arg ) ) != NULL )
skills.c:      if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
skills.c:      WAIT_STATE( ch, skill_table[gsn_pickshiplock]->beats );
skills.c:      if( IS_NPC( ch ) || !ch->pcdata || number_percent(  ) > ch->pcdata->learned[gsn_pickshiplock] )
skills.c:         sprintf( buf, "[ALARM] %s attempting to pick %s.", ch->name, ship->name );
skills.c:      if( !ship->hatchopen )
skills.c:         ship->hatchopen = TRUE;
skills.c:         act( AT_PLAIN, "You pick the lock and open the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
skills.c:         act( AT_PLAIN, "$n picks open the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
skills.c:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch opens from the outside." );
skills.c:   if( ch->mount )
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_sneak] )
skills.c:      af.duration = ( int )( ch->skill_level[SMUGGLING_ABILITY] * DUR_CONV );
skills.c:   if( ch->mount )
skills.c:      REMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_hide] )
skills.c:      SET_BIT( ch->affected_by, AFF_HIDE );
skills.c:   REMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:   if( ch->race != RACE_DEFEL )  /* Defel has perm invis */
skills.c:      REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
skills.c:   if( ch->race != RACE_NOGHRI ) /* Noghri has perm sneak */
skills.c:      REMOVE_BIT( ch->affected_by, AFF_SNEAK );
skills.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
skills.c:      if( ch->in_room->vnum < pArea->low_r_vnum || ch->in_room->vnum > pArea->hi_r_vnum )
skills.c:   if( ch->in_room == location )
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
skills.c:   if( IS_SET( ch->affected_by, AFF_CURSE ) )
skills.c:   if( ch->mount )
skills.c:      char_from_room( ch->mount );
skills.c:      char_to_room( ch->mount, location );
skills.c:   if( ch->mount )
skills.c:   if( victim->position > POS_STUNNED )
skills.c:   if( victim->hit <= -400 )
skills.c:   ch->alignment = ch->alignment + 20;
skills.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:   percent = number_percent(  ) - ( get_curr_lck( ch ) - 13 );
skills.c:   WAIT_STATE( ch, skill_table[gsn_aid]->beats );
skills.c:   if( !IS_NPC( ch ) && percent > ch->pcdata->learned[gsn_aid] )
skills.c:   ch->alignment = ch->alignment + 20;
skills.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
skills.c:   if( victim->hit < 1 )
skills.c:      victim->hit = 1;
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_mount] <= 0 )
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( victim ) || !IS_SET( victim->act, ACT_MOUNTABLE ) )
skills.c:   if( IS_SET( victim->act, ACT_MOUNTED ) )
skills.c:   if( victim->position < POS_STANDING )
skills.c:   if( victim->position == POS_FIGHTING || victim->fighting )
skills.c:   WAIT_STATE( ch, skill_table[gsn_mount]->beats );
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_mount] )
skills.c:      SET_BIT( victim->act, ACT_MOUNTED );
skills.c:      ch->mount = victim;
skills.c:      ch->position = POS_MOUNTED;
skills.c:   if( ( victim = ch->mount ) == NULL )
skills.c:   WAIT_STATE( ch, skill_table[gsn_mount]->beats );
skills.c:   if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_mount] )
skills.c:      REMOVE_BIT( victim->act, ACT_MOUNTED );
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_STANDING;
skills.c:      REMOVE_BIT( victim->act, ACT_MOUNTED );
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_SITTING;
skills.c:   if( IS_NPC( victim ) && !IS_SET( victim->defenses, DFND_PARRY ) )
skills.c:      chances = UMIN( 60, victim->skill_level[COMBAT_ABILITY] );
skills.c:      if( ( wield = get_eq_char( victim, WEAR_WIELD ) ) == NULL || ( wield->value[3] != WEAPON_LIGHTSABER ) )
skills.c:         if( ( wield = get_eq_char( victim, WEAR_DUAL_WIELD ) ) == NULL || ( wield->value[3] != WEAPON_LIGHTSABER ) )
skills.c:      chances = ( int )( victim->pcdata->learned[gsn_parry] );
skills.c:   if( !IS_NPC( victim ) && !IS_SET( victim->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )   /* SB */
skills.c:   if( IS_NPC( victim ) && !IS_SET( victim->defenses, DFND_DODGE ) )
skills.c:      chances = UMIN( 60, victim->top_level );
skills.c:      chances = ( int )( victim->pcdata->learned[gsn_dodge] / 2 );
skills.c:   if( !IS_NPC( victim ) && !IS_SET( victim->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_poison_weapon] <= 0 )
skills.c:   if( ch->fighting )
skills.c:   if( obj->item_type != ITEM_WEAPON )
skills.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:      if( pobj->pIndexData->vnum == OBJ_VNUM_BLACK_POWDER )
skills.c:   for( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:      if( wobj->item_type == ITEM_DRINK_CON && wobj->value[1] > 0 && wobj->value[2] == 0 )
skills.c:   if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_DRUNK] > 0 ) )
skills.c:   WAIT_STATE( ch, skill_table[gsn_poison_weapon]->beats );
skills.c:   percent = ( number_percent(  ) - get_curr_lck( ch ) - 14 );
skills.c:   if( !IS_NPC( ch ) && percent > ch->pcdata->learned[gsn_poison_weapon] )
skills.c:      damage( ch, ch, ch->skill_level[HUNTING_ABILITY], gsn_poison_weapon );
skills.c:   SET_BIT( obj->extra_flags, ITEM_POISONED );
skills.c:   obj->cost *= ch->skill_level[HUNTING_ABILITY] / 2;
skills.c:   obj->timer = 10 + ch->skill_level[HUNTING_ABILITY];
skills.c:      obj->timer *= 2;
skills.c:      obj->timer *= 2;
skills.c:   if( IS_NPC( victim ) && !IS_SET( victim->defenses, DFND_GRIP ) )
skills.c:      schance = UMIN( 60, 2 * victim->top_level );
skills.c:      schance = ( int )( victim->pcdata->learned[gsn_grip] / 2 );
skills.c:   schance += ( 2 * ( get_curr_lck( victim ) - 13 ) );
skills.c:   if( number_percent(  ) >= schance + victim->top_level - ch->top_level )
skills.c:   if( ch->mount )
skills.c:   if( ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL || ( obj->value[3] != 11 && obj->value[3] != 2 ) )
skills.c:   if( !ch->fighting )
skills.c:   if( !victim->fighting )
skills.c:   if( victim->num_fighting < 2 )
skills.c:   percent = number_percent(  ) - ( get_curr_lck( ch ) - 16 ) + ( get_curr_lck( victim ) - 13 );
skills.c:   WAIT_STATE( ch, skill_table[gsn_circle]->beats );
skills.c:   if( percent < ( IS_NPC( ch ) ? ( ch->skill_level[HUNTING_ABILITY] * 1.5 ) : ch->pcdata->learned[gsn_circle] ) )
skills.c:/* Berserk and HitAll. -- Altrag */
skills.c:   if( !ch->fighting )
skills.c:   percent = IS_NPC( ch ) ? 80 : ch->pcdata->learned[gsn_berserk];
skills.c:   WAIT_STATE( ch, skill_table[gsn_berserk]->beats );
skills.c:    * Hmmm.. 10-20 combat rounds at level 50.. good enough for most mobs,
skills.c:    * too high. -- Altrag 
skills.c:   af.duration = number_range( ch->top_level / 5, ch->top_level * 2 / 5 );
skills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( !ch->in_room->first_person )
skills.c:   percent = IS_NPC( ch ) ? 80 : ch->pcdata->learned[gsn_hitall];
skills.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:      vch_next = vch->next_in_room;
skills.c:      if( ++nvict > ch->skill_level[COMBAT_ABILITY] / 5 )
skills.c:       * Fireshield, etc. could kill ch too.. :>.. -- Altrag 
skills.c:   ch->move = UMAX( 0, ch->move - nvict * 3 + nhit );
skills.c:   short dir = -1;
skills.c:    ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_HOLYLIGHT ) ) ) )
skills.c:   if( ( dir = get_door( argument ) ) == -1 )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( IS_NPC( ch ) || ( number_percent(  ) > ch->pcdata->learned[gsn_scan] ) )
skills.c:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   if( ch->top_level < 50 )
skills.c:      max_dist--;
skills.c:   if( ch->top_level < 20 )
skills.c:      max_dist--;
skills.c:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
skills.c:         if( IS_SET( pexit->exit_info, EX_SECRET ) )
skills.c:      if( pexit->distance > 1 )
skills.c:         to_room = generate_exit( ch->in_room, &pexit );
skills.c:         to_room = pexit->to_room;
skills.c:      send_to_char( ch->in_room->name, ch );
skills.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:      show_char_to_char( ch->in_room->first_person, ch );
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
space.c:*--------------------------------------------------------------------------*
space.c:* -------------------------------------------------------------------------*
space.c:*--------------------------------------------------------------------------*
space.c:* ------------------------------------------------------------------------ *
space.c:* ------------------------------------------------------------------------ *
space.c:   for( vic = room->first_person; vic; vic = vic->next_in_room )
space.c:	return sqrt( pow( shipA->vx - shipB->vx , 2 ) + pow( shipA->vy - shipB->vy , 2 ) );
space.c:	return sqrt ( pow ( x1 - x2 , 2 ) + pow ( y1 - y2 , 2 ) );	
space.c:	if( ship->ship_class == FIGHTER_SHIP )
space.c:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] )/100.0);
space.c:	if( ship->ship_class == MIDSIZE_SHIP )
space.c:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] )/100.0);
space.c:	if( ship->ship_class == CAPITAL_SHIP )
space.c:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] )/100.0);
space.c:	pilotmodifier *= 1.75 - (ch->perm_dex/25.00);
space.c:	pilotmodifier *= 1.50 - (ch->perm_lck/18.00); //luck is a 50 50
space.c:	pilotmodifier *= 1.10 - (ch->perm_frc/18.00);
space.c:	if( ship->track0 != NULL )
space.c:		if( ship->track0->pilotpilotch != NULL )
space.c:			tempdouble *= 1.10 + (ship->track0->pilotpilotch->perm_frc/18.00);
space.c:		if( ship->track0->copilotch != NULL && ship->track0->copilotch != ship->track0->pilotpilotch )
space.c:			tempdouble *= 1.10 + (ship->track0->pilotpilotch->perm_frc/18.00);
space.c:			x1 = 2.0 * ranf() - 1.0;
space.c:			x2 = 2.0 * ranf() - 1.0;
space.c:		w = sqrt( (-2.0 * log( w ) ) / w );
space.c:		*heading -= 2*PI;
space.c:	xdiff = x2 - x1;
space.c:	ydiff = y2 - y1;
space.c:	angle = PI/2 - angle;
space.c:	bearing = coordpairtoheading(x1,y1,x2,y2) - heading;
space.c:	//if (abs(bearing - 2 * PI) < PI/180)
space.c:		bearing -= 2*PI;
space.c:	if (bearing < -PI )
space.c:	return getbearing(shipA->heading,shipA->vx,shipA->vy,shipB->vx,shipB->vy);
space.c:   ship->location = destination;
space.c:   ship->lastdoc = ship->location;
space.c:   ship->shipstate = SHIP_DOCKED;
space.c:   if( ship->starsystem )
space.c:      ship_from_starsystem( ship, ship->starsystem );
space.c:   sprintf( buf, "%s lands on the platform.", ship->name );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:   sprintf( buf, "The hatch on %s opens.", ship->name );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch opens." );
space.c:   ship->hatchopen = TRUE;
space.c:   sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:   sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:   sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:   sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:   sprintf( buf, "The hatch on %s closes and it begins to launch.", ship->name );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
space.c:   ship->hatchopen = FALSE;
space.c:   ship->location = 0;
space.c:   ship->shipstate = SHIP_READY;
space.c:      echo_to_room( AT_YELLOW, get_room_index( turbocar->location ), buf );
space.c:      turbocar->location = 0;
space.c:      turbocar->location = station_vnum[turbocar_stop];
space.c:      turbocar->lastdoc = turbocar->location;
space.c:      turbocar->shipstate = SHIP_DOCKED;
space.c:      if( turbocar->starsystem )
space.c:         ship_from_starsystem( turbocar, turbocar->starsystem );
space.c:      echo_to_room( AT_YELLOW, get_room_index( turbocar->location ), buf );
space.c:      turbocar->hatchopen = TRUE;
space.c:         if( target != NULL && !target->starsystem )
space.c:         if( target != NULL && !target->starsystem )
space.c:        m_next = missile->next;
space.c:        ship = missile->fired_from;
space.c:	if(missile->target != NULL)
space.c:		  if (missile->target->starsystem == NULL || fabs(getbearing(missile->heading,missile->mx,missile->my,missile->target->vx,missile->target->vy)) > PI / 12)
space.c:		  	sprintf( buf, "The missile fired from %s veers off to seek a new target!", missile->fired_from->name );
space.c:		  	echo_to_system( AT_ORANGE, missile->fired_from, buf, NULL );
space.c:		  	echo_to_cockpit( AT_ORANGE, missile->fired_from, buf );
space.c:		  	missile->target = NULL;
space.c:	if(missile->target == NULL )
space.c:		for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:			range = sqrt(pow(missile->mx-target->vx,2)+pow(missile->my-target->vy,2) );
space.c:			bearing = fabs(getbearing(missile->heading,missile->mx,missile->my,target->vx,target->vy));		
space.c:			theta = atan( ((double)(target->ship_class+0.25*20))/range)*2;
space.c:		target = missile->target;	
space.c:	if(missile->target == NULL && target != NULL)
space.c:		missile->target = target;
space.c:		sprintf( buf, "MISSILE WARNING: A missile fired from %s has locked its tracking radar onto you!", ship->name );
space.c:		sprintf( buf, "A missile fired from %s locks course on %s", ship->name,target->name );
space.c:      if( target != NULL && target->starsystem && target->starsystem == missile->starsystem )
space.c:		trackbearing = getbearing(missile->heading,missile->mx,missile->my,target->vx,target->vy);
space.c:		missile->turnarc = trackbearing;
space.c:		turnvelocity = missile->turnvelocity * (4.00/PULSE_PER_SECOND);
space.c:		if ( fabs(missile->turnarc) > turnvelocity )
space.c:			if ( missile->turnarc >= 0 )
space.c:				missile->turnarc -= turnvelocity;
space.c:				missile->heading += turnvelocity;
space.c:				fixheading(&missile->heading);
space.c:				missile->turnarc += turnvelocity;
space.c:				missile->heading -= turnvelocity;
space.c:				fixheading(&missile->heading);
space.c:			missile->heading += missile->turnarc;
space.c:			fixheading(&missile->heading);
space.c:			/*sprintf( buf, "Missile adjusts heading %0.2f degrees", radianstodegrees(missile->turnarc));
space.c:			missile->turnarc = 0;
space.c:	missile->my += missile->speed/5.00 * (4.00/PULSE_PER_SECOND) *  cos( missile->heading );
space.c:	missile->mx += missile->speed/5.00 * (4.00/PULSE_PER_SECOND) * sin( missile->heading );	
space.c:      if( target != NULL && target->starsystem && target->starsystem == missile->starsystem )
space.c:	  if( pointdistance(target->vx,target->vy,missile->mx,missile->my) < 50 )
space.c:	      if( target->chaff_released <= 0 )
space.c:		  echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ), "Your missile hits its target dead on!" );
space.c:		  sprintf( buf, "You see a small explosion as %s is hit by a missile", target->name );
space.c:		  for( ch = first_char; ch; ch = ch->next )
space.c:		    if( !IS_NPC( ch ) && nifty_is_name( missile->fired_by, ch->name ) )
space.c:			damage_ship_ch( target, 35 + missile->missiletype * missile->missiletype * 20,
space.c:					45 + missile->missiletype * missile->missiletype * missile->missiletype * 30, ch );
space.c:		    damage_ship( target, 35 + missile->missiletype * missile->missiletype * 20,
space.c:				 45 + missile->missiletype * missile->missiletype * ship->missiletype * 30 );
space.c:		  echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ),
space.c:	   else if( pointdistance(target->vx,target->vy,missile->mx,missile->my) < 200 )
space.c:      missile->age++;
space.c:      if( missile->age >= 50 )
space.c:	  sprintf( buf, "A missile fired from %s runs out of fuel and self destructs", missile->fired_from->name );
space.c:	  echo_to_system( AT_ORANGE, missile->fired_from, buf, NULL );
space.c:  for( ship = first_ship; ship; ship = ship->next )
space.c:      if( !ship->starsystem )
space.c:      if( ship->currspeed > 0 )
space.c:	  //change = sqrt( ship->hx * ship->hx + ship->hy * ship->hy );
space.c:	     // dx = ship->hx / change;
space.c:	      //dy = ship->hy / change;
space.c:	      ///dz = ship->hz / change;
space.c:	      //ship->vx += ( dx * ship->currspeed / 5 );
space.c:	      //ship->vy += ( dy * ship->currspeed / 5 );
space.c:	     // ship->vz += ( dz * ship->currspeed / 5 );
space.c:	   /*   if (ship->heading > PI / 2 && ship->heading <= 3*PI/2 ) 
space.c:	      	      ship->vy += ship->currspeed/5 *  sin( ship->heading );
space.c:		      ship->vx += ship->currspeed/5 *  cos( ship->heading );	
space.c:		ship->vy += ship->currspeed/5.00 * (4.00/PULSE_PER_SECOND) * cos( ship->heading );
space.c:		ship->vx += ship->currspeed/5.00 * (4.00/PULSE_PER_SECOND) * sin( ship->heading );	
space.c:		tempdouble = (double)ship->ship_class * 25;
space.c:		sigma = 2 * (((double)ship->manuever)/((double)100)) 
space.c:  			  * MAX(((double)(100.0-tempdouble))/100.00,0.10)
space.c:		if( ship->pilotpilotch == NULL && ship->copilotch == NULL )
space.c:			if(ship->pilotpilotch != NULL)
space.c:				pilotmodifier = getPilotErrorModifier(ship,ship->pilotpilotch);
space.c:			if(ship->copilotch != NULL && ship->copilotch != ship->pilotpilotch)
space.c:				pilotmodifier += getPilotErrorModifier(ship,ship->pilotpilotch);
space.c:	if(!finite(ship->turnarc))
space.c:		ship->turnarc = 0;
space.c:		tempdouble = (double)ship->ship_class * 25;
space.c:				* (((double)ship->manuever)/((double)100)) 
space.c:				* MAX(((double)(100.0-tempdouble))/100.00,0.10)
space.c:	if ( ship->turnarc != 0 )
space.c:		ship->prevheading = ship->heading;		  
space.c:		if(IS_SET(ship->flightflags,SHIP_AUTOMANEUVER) && ship->track0 != NULL && ship->turnarc > PI/8 )
space.c:			sprintf( buf, "%s adjusts its course attempting to match that of %s.", ship->name,ship->track0->name );
space.c:			echo_to_system( AT_ORANGE, ship, buf, ship->track0 );
space.c:		 	sprintf( buf, "%s attempts to match your maneuver.",ship->name);
space.c:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c:		if ( fabs(ship->turnarc) > turnvelocity )
space.c:			if ( ship->turnarc >= 0 )
space.c:				ship->turnarc -= turnvelocity;
space.c:				ship->heading += turnvelocity;
space.c:				fixheading(&ship->heading);
space.c:				ship->turnarc += turnvelocity;
space.c:				ship->heading -= turnvelocity;
space.c:				fixheading(&ship->heading);
space.c:			ship->heading += ship->turnarc;
space.c:			fixheading(&ship->heading);
space.c:			ship->turnarc = 0;
space.c:			ship->heading += flighterror;
space.c:			if(!IS_SET(ship->flightflags,SHIP_AUTOMANEUVER))
space.c:		        	echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c:		 		sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c:				//ch_printf( ch, "&GNew heading %0.4f degrees.\r\n",radianstodegrees(ship->heading));
space.c:		ship->heading += flighterror;
space.c:	if(ship->track0 == NULL && IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c:		for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c:			theta = atan( ((double)(target->ship_class+0.25*20))/range)*2;
space.c:			ship->track0 = besttarget;
space.c:			sprintf( buf, "Tracking radar auto acquiring new objective %s\n\r",ship->track0->name);
space.c:			sprintf( buf, "You are being painted by %s's tracking radar!\n\r", ship->name);
space.c:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c:	if( ship->track0 != NULL )
space.c:		trackbearing = s2sbearing(ship,ship->track0);
space.c:		trackrange = ship2shipdist(ship,ship->track0);
space.c:		if(ship->track0->starsystem == NULL)
space.c:			sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c:			ship->track0 = NULL;
space.c:			ship->turnarc = 0;
space.c:			if(trackrange > 500 && dice < (5000-trackrange))
space.c:					sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c:					echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c:					ship->track0 = NULL;
space.c:					//ship->turnarc = 0;
space.c:				if(trackbearing > PI/4 || trackbearing < - PI/4 )
space.c:					if( fabs(trackbearing) > PI/2  && trackrange < 150 && ship->currspeed > 0)
space.c:						sprintf( buf, "You fly right past %s!\n\r",ship->track0->name);
space.c:						sprintf( buf, "%s flies right past you!\n\r", ship->name);
space.c:						echo_to_cockpit( AT_YELLOW, ship->track0, buf );		
space.c:					sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c:					echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c:					ship->track0 = NULL;
space.c:					//ship->turnarc = 0;
space.c:					if(ship->turnarc == 0 )
space.c:						if(ship->pilotpilotch != NULL)
space.c:							if(IS_SET(ship->flightflags,SHIP_AUTOMANEUVER) 
space.c:							&& (ship->ship_class == FIGHTER_SHIP || ship->ship_class == MIDSIZE_SHIP) 
space.c:							&& ship->pilotpilotch->pcdata->learned[gsn_starfighters] == 100 
space.c:							&& (ship->track0->ship_class == FIGHTER_SHIP || ship->track0->ship_class == MIDSIZE_SHIP))
space.c:								if(ship->pilotpilotch->pcdata->learned[gsn_spacecombat] != 100 
space.c:								   && fabs(ship->prevheading - ship->heading) >= MAX(((double)ship->pilotpilotch->pcdata->learned[gsn_spacecombat])/100.00*(2*turnvelocity/6.00) ,PI/45.00)
space.c:								   && ship->track0->currspeed >= ship->track0->realspeed*0.25)
space.c:									learn_from_success( ship->pilotpilotch, gsn_spacecombat );
space.c:								else if(ship->pilotpilotch->pcdata->learned[gsn_spacecombat] == 100
space.c:								        && fabs(ship->prevheading - ship->heading) >= 3/5.00 * turnvelocity 
space.c:								        && ship->track0->currspeed >= ship->track0->realspeed*0.5 
space.c:									&& ship->ship_class != MIDSIZE_SHIP 
space.c:									&& ship->track0->ship_class != MIDSIZE_SHIP)
space.c:										learn_from_success( ship->pilotpilotch, gsn_spacecombat2 );								
space.c:								else if(fabs(ship->prevheading - ship->heading) >= 4/5.00 * turnvelocity 
space.c:									&& ship->pilotpilotch->pcdata->learned[gsn_spacecombat] == 100
space.c:									&& ship->pilotpilotch->pcdata->learned[gsn_spacecombat2] == 100
space.c:									&& ship->track0->currspeed == ship->track0->realspeed 
space.c:									&& ship->ship_class != MIDSIZE_SHIP 
space.c:									&& ship->track0->ship_class != MIDSIZE_SHIP)
space.c:										learn_from_success( ship->pilotpilotch, gsn_spacecombat3 );
space.c:							ship->turnarc = trackbearing * MAX(0.025,(0.45 * (ship->pilotpilotch->pcdata->learned[gsn_spacecombat]/100.00) + 0.30 *(ship->pilotpilotch->pcdata->learned[gsn_spacecombat2]/100.00) + 0.25 *(ship->pilotpilotch->pcdata->learned[gsn_spacecombat2]/100.00))); //other flight commands override
space.c:							ship->turnarc = trackbearing * 0.90;  //human can be better
space.c:						SET_BIT(ship->flightflags,SHIP_AUTOMANEUVER);
space.c:		if(ship->track0 == NULL && IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c:          if ( ship->class != SHIP_PLATFORM && !autofly(ship) )
space.c:            if ( ship->starsystem->star1 && strcmp(ship->starsystem->star1,"") )
space.c:              if (ship->vx >= ship->starsystem->s1x + 1 || ship->vx <= ship->starsystem->s1x - 1 )
space.c:                ship->vx -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vx - ship->starsystem->s1x)/2,3);
space.c:              if (ship->vy >= ship->starsystem->s1y + 1 || ship->vy <= ship->starsystem->s1y - 1 )
space.c:                ship->vy -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vy - ship->starsystem->s1y)/2,3);
space.c:              if (ship->vz >= ship->starsystem->s1z + 1 || ship->vz <= ship->starsystem->s1z - 1 )
space.c:                ship->vz -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vz - ship->starsystem->s1z)/2,3);
space.c:            if ( ship->starsystem->star2 && strcmp(ship->starsystem->star2,"") )
space.c:              if (ship->vx >= ship->starsystem->s2x + 1 || ship->vx <= ship->starsystem->s2x - 1 )
space.c:                ship->vx -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vx - ship->starsystem->s2x)/2,3);
space.c:              if (ship->vy >= ship->starsystem->s2y + 1 || ship->vy <= ship->starsystem->s2y - 1 )
space.c:                ship->vy -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vy - ship->starsystem->s2y)/2,3);
space.c:              if (ship->vz >= ship->starsystem->s2z + 1 || ship->vz <= ship->starsystem->s2z - 1 )
space.c:                ship->vz -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vz - ship->starsystem->s2z)/2,3);
space.c:            if ( ship->starsystem->planet1 && strcmp(ship->starsystem->planet1,"") )
space.c:              if (ship->vx >= ship->starsystem->p1x + 1 || ship->vx <= ship->starsystem->p1x - 1 )
space.c:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vx - ship->starsystem->p1x)/2,3);
space.c:              if (ship->vy >= ship->starsystem->p1y + 1 || ship->vy <= ship->starsystem->p1y - 1 )
space.c:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vy - ship->starsystem->p1y)/2,3);
space.c:              if (ship->vz >= ship->starsystem->p1z + 1 || ship->vz <= ship->starsystem->p1z - 1 )
space.c:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vz - ship->starsystem->p1z)/2,3);
space.c:            if ( ship->starsystem->planet2 && strcmp(ship->starsystem->planet2,"") )
space.c:              if (ship->vx >= ship->starsystem->p2x + 1 || ship->vx <= ship->starsystem->p2x - 1 )
space.c:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vx - ship->starsystem->p2x)/2,3);
space.c:              if (ship->vy >= ship->starsystem->p2y + 1 || ship->vy <= ship->starsystem->p2y - 1 )
space.c:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vy - ship->starsystem->p2y)/2,3);
space.c:              if (ship->vz >= ship->starsystem->p2z + 1 || ship->vz <= ship->starsystem->p2z - 1 )
space.c:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vz - ship->starsystem->p2z)/2,3);
space.c:            if ( ship->starsystem->planet3 && strcmp(ship->starsystem->planet3,"") )
space.c:              if (ship->vx >= ship->starsystem->p3x + 1 || ship->vx <= ship->starsystem->p3x - 1 )
space.c:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vx - ship->starsystem->p3x)/2,3);
space.c:              if (ship->vy >= ship->starsystem->p3y + 1 || ship->vy <= ship->starsystem->p3y - 1 )
space.c:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vy - ship->starsystem->p3y)/2,3);
space.c:              if (ship->vz >= ship->starsystem->p3z + 1 || ship->vz <= ship->starsystem->p3z - 1 )
space.c:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vz - ship->starsystem->p3z)/2,3);
space.c:          for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem)
space.c:                    abs(ship->vx - target->vx) < 1 &&
space.c:                    abs(ship->vy - target->vy) < 1 &&
space.c:                    abs(ship->vz - target->vz) < 1 )
space.c:                    ship->collision = target->maxhull;
space.c:                    target->collision = ship->maxhull;
space.c:      if( ship->starsystem->star1 && strcmp( ship->starsystem->star1, "" )
space.c:	  && pointdistance(ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y) < 100)
space.c:	  sprintf( buf, "%s flys directly into %s!", ship->name, ship->starsystem->star1 );
space.c:      if( ship->starsystem->star2 && strcmp( ship->starsystem->star2, "" )
space.c:	  && pointdistance(ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y) < 100)
space.c:	  sprintf( buf, "%s flys directly into %s!", ship->name, ship->starsystem->star2 );
space.c:      if( ship->currspeed > 0 )
space.c:	  if( ship->starsystem->planet1 && strcmp( ship->starsystem->planet1, "" )
space.c:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y) < 10
space.c:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y) - ship->heading < PI/4 
space.c:		   || (ship->vx == ship->starsystem->p1x && ship->vy == ship->starsystem->p1y)))
space.c:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet1 );
space.c:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet1 );
space.c:	      ship->vx = ship->starsystem->p1x;
space.c:	      ship->vy = ship->starsystem->p1y;
space.c:	      ship->currspeed = 0;
space.c:	  if( ship->starsystem->planet2 && strcmp( ship->starsystem->planet2, "" )
space.c:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p2x,ship->starsystem->p2y) < 10
space.c:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p2x,ship->starsystem->p2y) - ship->heading < PI/4
space.c:		|| (ship->vx == ship->starsystem->p2x && ship->vy == ship->starsystem->p2y)))
space.c:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet2 );
space.c:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet2 );
space.c:	      ship->vx = ship->starsystem->p2x;
space.c:	      ship->vy = ship->starsystem->p2y;
space.c:	      ship->currspeed = 0;
space.c:	  if( ship->starsystem->planet3 && strcmp( ship->starsystem->planet3, "" )
space.c:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p3x,ship->starsystem->p3y) < 10
space.c:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p3x,ship->starsystem->p3y) - ship->heading < PI/4
space.c:		|| (ship->vx == ship->starsystem->p3x && ship->vy == ship->starsystem->p3y)))
space.c:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet3 );
space.c:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet3 );
space.c:	      ship->vx = ship->starsystem->p3x;
space.c:	      ship->vy = ship->starsystem->p3y;
space.c:	      ship->currspeed = 0;
space.c:  for( ship = first_ship; ship; ship = ship->next )
space.c:    if( ship->collision )
space.c:	damage_ship( ship, ship->collision, ship->collision );
space.c:	ship->collision = 0;
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->statet0 > 0 )
space.c:         ship->energy -= ship->statet0;
space.c:         ship->statet0 = 0;
space.c:      if( ship->statet1 > 0 )
space.c:         ship->energy -= ship->statet1;
space.c:         ship->statet1 = 0;
space.c:      if( ship->statet2 > 0 )
space.c:         ship->energy -= ship->statet2;
space.c:         ship->statet2 = 0;
space.c:      if( ship->missilestate == MISSILE_RELOAD_2 )
space.c:         ship->missilestate = MISSILE_READY;
space.c:         if( ship->missiles > 0 )
space.c:            echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ), "Missile launcher reloaded." );
space.c:      if( ship->missilestate == MISSILE_RELOAD )
space.c:         ship->missilestate = MISSILE_RELOAD_2;
space.c:      if( ship->missilestate == MISSILE_FIRED )
space.c:         ship->missilestate = MISSILE_RELOAD;
space.c:         if( ship->starsystem )
space.c:            if( ship->target0 && ship->statet0 != LASER_DAMAGED )
space.c:               SHIP_DATA *target = ship->target0;
space.c:               for( shots = 0; shots <= ship->lasers; shots++ )
space.c:                  if( ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
space.c:                      && ship->target0->starsystem == ship->starsystem
space.c:		      && ship->statet0 < ship->lasers )
space.c:                     if( ship->ship_class > 1 || is_facing( ship, target ) )
space.c:                        schance += target->ship_class * 25;
space.c:                        schance -= target->manuever / 10;
space.c:                        schance -= target->currspeed / 20;
space.c:                        schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c:                        schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c:                           sprintf( buf, "%s fires at you but misses.", ship->name );
space.c:                           sprintf( buf, "Laserfire from %s barely misses %s.", ship->name, target->name );
space.c:                           sprintf( buf, "Laserfire from %s hits %s.", ship->name, target->name );
space.c:                           sprintf( buf, "You are hit by lasers from %s!", ship->name );
space.c:                        ship->statet0++;
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->starsystem )
space.c:         if( ship->energy > 0 && ship->shipstate == SHIP_DISABLED
space.c:	     && ship->ship_class != SHIP_PLATFORM )
space.c:            ship->energy -= 100;
space.c:         else if( ship->energy > 0 )
space.c:            ship->energy += ( 5 + ship->ship_class * 5 );
space.c:      if( ship->chaff_released > 0 )
space.c:         ship->chaff_released--;
space.c:      if( ship->shipstate == SHIP_HYPERSPACE )
space.c:         ship->hyperdistance -= ship->hyperspeed * 2;
space.c:         if( ship->hyperdistance <= 0 )
space.c:            ship_to_starsystem( ship, ship->currjump );
space.c:            if( ship->starsystem == NULL )
space.c:               echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Hyperjump complete." );
space.c:               sprintf( buf, "%s enters the starsystem at %.0f %.0f", ship->name, ship->vx, ship->vy);
space.c:               ship->shipstate = SHIP_READY;
space.c:               STRFREE( ship->home );
space.c:               ship->home = STRALLOC( ship->starsystem->name );
space.c:               if( str_cmp( "Public", ship->owner ) )
space.c:            sprintf( buf, "%d", ship->hyperdistance );
space.c:            echo_to_room_dnr( AT_YELLOW, get_room_index( ship->pilotseat ), "Remaining jump distance: " );
space.c:            echo_to_room( AT_WHITE, get_room_index( ship->pilotseat ), buf );
space.c:      if( ship->shipstate == SHIP_BUSY_3 )
space.c:         echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c:         ship->shipstate = SHIP_READY;
space.c:      if( ship->shipstate == SHIP_BUSY_2 )
space.c:         ship->shipstate = SHIP_BUSY_3;
space.c:      if( ship->shipstate == SHIP_BUSY )
space.c:         ship->shipstate = SHIP_BUSY_2;
space.c:      if( ship->shipstate == SHIP_LAND_2 )
space.c:         landship( ship, ship->dest );
space.c:      if( ship->shipstate == SHIP_LAND )
space.c:         ship->shipstate = SHIP_LAND_2;
space.c:      if( ship->shipstate == SHIP_LAUNCH_2 )
space.c:      if( ship->shipstate == SHIP_LAUNCH )
space.c:         ship->shipstate = SHIP_LAUNCH_2;
space.c:      ship->shield = UMAX( 0, ship->shield - 1 - ship->ship_class );
space.c:      if( ship->autorecharge && ship->maxshield > ship->shield && ship->energy > 100 )
space.c:         recharge = UMIN( ship->maxshield - ship->shield, 10 + ship->ship_class * 10 );
space.c:         recharge = UMIN( recharge, ship->energy / 2 - 100 );
space.c:         ship->shield += recharge;
space.c:         ship->energy -= recharge;
space.c:      if( ship->shield > 0 )
space.c:         if( ship->energy < 200 )
space.c:            ship->shield = 0;
space.c:            ship->autorecharge = FALSE;
space.c:      if( ship->starsystem && ship->currspeed > 0 )
space.c:         sprintf( buf, "%d", ship->currspeed );
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->pilotseat ), "Speed: " );
space.c:         echo_to_room_dnr( AT_LBLUE, get_room_index( ship->pilotseat ), buf );
space.c:         sprintf( buf, "%.0f %.0f", ship->vx, ship->vy);
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->pilotseat ), "  Coords: " );
space.c:         echo_to_room( AT_LBLUE, get_room_index( ship->pilotseat ), buf );
space.c:         if( ship->pilotseat != ship->coseat )
space.c:            sprintf( buf, "%d", ship->currspeed );
space.c:            echo_to_room_dnr( AT_BLUE, get_room_index( ship->coseat ), "Speed: " );
space.c:            echo_to_room_dnr( AT_LBLUE, get_room_index( ship->coseat ), buf );
space.c:            sprintf( buf, "%.0f %.0f", ship->vx, ship->vy);
space.c:            echo_to_room_dnr( AT_BLUE, get_room_index( ship->coseat ), "  Coords: " );
space.c:            echo_to_room( AT_LBLUE, get_room_index( ship->coseat ), buf );
space.c:      if( ship->starsystem )
space.c:         too_close = ship->currspeed + 50;
space.c:         for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:            target_too_close = too_close + target->currspeed;
space.c:		&& abs( ( int )( ship->vx - target->vx ) ) < target_too_close
space.c:		&& abs( ( int )( ship->vy - target->vy ) ) < target_too_close)
space.c:               sprintf( buf, "Proximity alert: %s  %.0f %.0f", target->name, target->vx, target->vy );
space.c:               echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:         too_close = ship->currspeed + 100;
space.c:         if( ship->starsystem->star1 && strcmp( ship->starsystem->star1, "" )
space.c:	     && abs( ( int )( ship->vx - ship->starsystem->s1x ) ) < too_close
space.c:	     && abs( ( int )( ship->vy - ship->starsystem->s1y ) ) < too_close)
space.c:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->star1,
space.c:                     ship->starsystem->s1x, ship->starsystem->s1y);
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:         if( ship->starsystem->star2 && strcmp( ship->starsystem->star2, "" )
space.c:	     && abs( ( int )( ship->vx - ship->starsystem->s2x ) ) < too_close
space.c:	     && abs( ( int )( ship->vy - ship->starsystem->s2y ) ) < too_close)
space.c:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->star2,
space.c:                     ship->starsystem->s2x, ship->starsystem->s2y );
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:         if( ship->starsystem->planet1
space.c:	     && strcmp( ship->starsystem->planet1, "" )
space.c:	     && abs( ( int )( ship->vx - ship->starsystem->p1x ) ) < too_close
space.c:	     && abs( ( int )( ship->vy - ship->starsystem->p1y ) ) < too_close)
space.c:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet1,
space.c:                     ship->starsystem->p1x, ship->starsystem->p1y);
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:         if( ship->starsystem->planet2
space.c:	     && strcmp( ship->starsystem->planet2, "" )
space.c:	     && abs( ( int )( ship->vx - ship->starsystem->p2x ) ) < too_close
space.c:	     && abs( ( int )( ship->vy - ship->starsystem->p2y ) ) < too_close)
space.c:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet2,
space.c:                     ship->starsystem->p2x, ship->starsystem->p2y );
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:         if( ship->starsystem->planet3
space.c:	     && strcmp( ship->starsystem->planet3, "" )
space.c:	     && abs( ( int )( ship->vx - ship->starsystem->p3x ) ) < too_close
space.c:	     && abs( ( int )( ship->vy - ship->starsystem->p3y ) ) < too_close)
space.c:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet3,
space.c:                     ship->starsystem->p3x, ship->starsystem->p3y );
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c:      if( ship->target0 )
space.c:         sprintf( buf, "%s   %.0f %.0f", ship->target0->name, ship->target0->vx, ship->target0->vy );
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->gunseat ), "Target: " );
space.c:         echo_to_room( AT_LBLUE, get_room_index( ship->gunseat ), buf );
space.c:	 range = sqrt(pow(ship->vx-ship->target0->vx,2)+pow(ship->vy-ship->target0->vy,2) );
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->gunseat ), "Range: " );
space.c:         echo_to_room( AT_LBLUE, get_room_index( ship->gunseat ), buf );
space.c:         if( ship->starsystem != ship->target0->starsystem )
space.c:            ship->target0 = NULL;
space.c:      if( ship->target1 )
space.c:         sprintf( buf, "%s   %.0f %.0f", ship->target1->name, ship->target1->vx, ship->target1->vy);
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->turret1 ), "Target: " );
space.c:         echo_to_room( AT_LBLUE, get_room_index( ship->turret1 ), buf );
space.c:         if( ship->starsystem != ship->target1->starsystem )
space.c:            ship->target1 = NULL;
space.c:      if( ship->target2 )
space.c:         sprintf( buf, "%s   %.0f %.0f", ship->target2->name, ship->target2->vx, ship->target2->vy);
space.c:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->turret2 ), "Target: " );
space.c:         echo_to_room( AT_LBLUE, get_room_index( ship->turret2 ), buf );
space.c:         if( ship->starsystem != ship->target2->starsystem )
space.c:            ship->target2 = NULL;
space.c:      if( ship->energy < 100 && ship->starsystem )
space.c:      ship->energy = URANGE( 0, ship->energy, ship->maxenergy );
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->autotrack && ship->target0 && ship->ship_class < 3 )
space.c:         target = ship->target0;
space.c:         too_close = ship->currspeed + 10;
space.c:         target_too_close = too_close + target->currspeed;
space.c:         if( target != ship && ship->shipstate == SHIP_READY
space.c:	     && abs( ( int )( ship->vx - target->vx ) ) < target_too_close
space.c:	     && abs( ( int )( ship->vy - target->vy ) ) < target_too_close)
space.c:            ship->hx = 0 - ( ship->target0->vx - ship->vx );
space.c:            ship->hy = 0 - ( ship->target0->vy - ship->vy );
space.c:            ship->energy -= ship->currspeed / 10;
space.c:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), "Autotrack: Evading to avoid collision!\r\n" );
space.c:            if( ship->ship_class == FIGHTER_SHIP
space.c:		|| ( ship->ship_class == MIDSIZE_SHIP
space.c:		     && ship->manuever > 50 ) )
space.c:               ship->shipstate = SHIP_BUSY_3;
space.c:            else if( ship->ship_class == MIDSIZE_SHIP
space.c:		     || ( ship->ship_class == CAPITAL_SHIP
space.c:			  && ship->manuever > 50 ) )
space.c:               ship->shipstate = SHIP_BUSY_2;
space.c:               ship->shipstate = SHIP_BUSY;
space.c:         else if( !is_facing( ship, ship->target0 ) )
space.c:            ship->hx = ship->target0->vx - ship->vx;
space.c:            ship->hy = ship->target0->vy - ship->vy;
space.c:            ship->energy -= ship->currspeed / 10;
space.c:            echo_to_room( AT_BLUE, get_room_index( ship->pilotseat ), "Autotracking target ... setting new course.\r\n" );
space.c:            if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c:               ship->shipstate = SHIP_BUSY_3;
space.c:            else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c:               ship->shipstate = SHIP_BUSY_2;
space.c:               ship->shipstate = SHIP_BUSY;
space.c:         if( ship->starsystem )
space.c:            if( ship->target0 )
space.c:               for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:                     if( !str_cmp( target->owner, ship->owner ) && target != ship )
space.c:                        if( target->target0 == NULL && ship->target0 != target )
space.c:                           target->target0 = ship->target0;
space.c:                           sprintf( buf, "You are being targetted by %s.", target->name );
space.c:                           echo_to_cockpit( AT_BLOOD, target->target0, buf );
space.c:               target = ship->target0;
space.c:               ship->autotrack = TRUE;
space.c:               if( ship->ship_class != SHIP_PLATFORM )
space.c:                  ship->currspeed = ship->realspeed;
space.c:               if( ship->energy > 200 )
space.c:                  ship->autorecharge = TRUE;
space.c:               if( ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
space.c:                   && ship->missilestate == MISSILE_READY && ship->target0->starsystem == ship->starsystem
space.c:		   && ship->missiles > 0 )
space.c:                  if( ship->ship_class > 1 || is_facing( ship, target ) )
space.c:                     schance -= target->manuever / 5;
space.c:                     schance -= target->currspeed / 20;
space.c:                     schance += target->ship_class * target->ship_class * 25;
space.c:                     schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c:                     schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c:                        ship->missiles--;
space.c:                        sprintf( buf, "Incoming missile from %s.", ship->name );
space.c:                        sprintf( buf, "%s fires a missile towards %s.", ship->name, target->name );
space.c:                        if( ship->ship_class == CAPITAL_SHIP
space.c:			    || ship->ship_class == SHIP_PLATFORM )
space.c:                           ship->missilestate = MISSILE_RELOAD_2;
space.c:                           ship->missilestate = MISSILE_FIRED;
space.c:               if( ship->missilestate == MISSILE_DAMAGED )
space.c:                  ship->missilestate = MISSILE_READY;
space.c:               if( ship->statet0 == LASER_DAMAGED )
space.c:                  ship->statet0 = LASER_READY;
space.c:               if( ship->shipstate == SHIP_DISABLED )
space.c:                  ship->shipstate = SHIP_READY;
space.c:               if( !str_cmp( ship->owner, "The Empire" ) )
space.c:                  for( target = first_ship; target; target = target->next )
space.c:                     if( ship->starsystem == target->starsystem )
space.c:                        if( !str_cmp( target->owner, "The New Republic" ) )
space.c:                           ship->target0 = target;
space.c:                           sprintf( buf, "You are being targetted by %s.", ship->name );
space.c:               if( !str_cmp( ship->owner, "The New Republic" ) )
space.c:                  for( target = first_ship; target; target = target->next )
space.c:                     if( ship->starsystem == target->starsystem )
space.c:                        if( !str_cmp( target->owner, "The Empire" ) )
space.c:                           sprintf( buf, "You are being targetted by %s.", ship->name );
space.c:                           ship->target0 = target;
space.c:               if( !str_cmp( ship->owner, "Pirates" ) )
space.c:                  for( target = first_ship; target; target = target->next )
space.c:                     if( ship->starsystem == target->starsystem )
space.c:                        sprintf( buf, "You are being targetted by %s.", ship->name );
space.c:                        ship->target0 = target;
space.c:               ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c:               ship->vx = number_range( -5000, 5000 );
space.c:               ship->vy = number_range( -5000, 5000 );
space.c:               ship->hx = 1;
space.c:               ship->hy = 1;
space.c:      if( ( ship->ship_class == CAPITAL_SHIP
space.c:	    || ship->ship_class == SHIP_PLATFORM ) && ship->target0 == NULL )
space.c:         if( ship->missiles < ship->maxmissiles )
space.c:            ship->missiles++;
space.c:         if( ship->torpedos < ship->maxtorpedos )
space.c:            ship->torpedos++;
space.c:         if( ship->rockets < ship->maxrockets )
space.c:            ship->rockets++;
space.c:   for( tstarsystem = first_starsystem; tstarsystem; tstarsystem = tstarsystem->next )
space.c:      fprintf( fpout, "%s\n", tstarsystem->filename );
space.c:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c:      if( !str_cmp( name, starsystem->name ) )
space.c:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c:      if( !str_prefix( name, starsystem->name ) )
space.c:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c:      if( vnum == starsystem->doc1a || vnum == starsystem->doc2a || vnum == starsystem->doc3a ||
space.c:          vnum == starsystem->doc1b || vnum == starsystem->doc2b || vnum == starsystem->doc3b ||
space.c:          vnum == starsystem->doc1c || vnum == starsystem->doc2c || vnum == starsystem->doc3c )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->hanger )
space.c:         return ship->starsystem;
space.c:   if( !starsystem->filename || starsystem->filename[0] == '\0' )
space.c:      sprintf( buf, "save_starsystem: %s has no filename", starsystem->name );
space.c:   sprintf( filename, "%s%s", SPACE_DIR, starsystem->filename );
space.c:      fprintf( fp, "Name         %s~\n", starsystem->name );
space.c:      fprintf( fp, "Filename     %s~\n", starsystem->filename );
space.c:      fprintf( fp, "Planet1      %s~\n", starsystem->planet1 );
space.c:      fprintf( fp, "Planet2      %s~\n", starsystem->planet2 );
space.c:      fprintf( fp, "Planet3      %s~\n", starsystem->planet3 );
space.c:      fprintf( fp, "Star1        %s~\n", starsystem->star1 );
space.c:      fprintf( fp, "Star2        %s~\n", starsystem->star2 );
space.c:      fprintf( fp, "Location1a      %s~\n", starsystem->location1a );
space.c:      fprintf( fp, "Location1b      %s~\n", starsystem->location1b );
space.c:      fprintf( fp, "Location1c      %s~\n", starsystem->location1c );
space.c:      fprintf( fp, "Location2a       %s~\n", starsystem->location2a );
space.c:      fprintf( fp, "Location2b      %s~\n", starsystem->location2b );
space.c:      fprintf( fp, "Location2c      %s~\n", starsystem->location2c );
space.c:      fprintf( fp, "Location3a      %s~\n", starsystem->location3a );
space.c:      fprintf( fp, "Location3b      %s~\n", starsystem->location3b );
space.c:      fprintf( fp, "Location3c      %s~\n", starsystem->location3c );
space.c:      fprintf( fp, "Doc1a          %d\n", starsystem->doc1a );
space.c:      fprintf( fp, "Doc2a          %d\n", starsystem->doc2a );
space.c:      fprintf( fp, "Doc3a          %d\n", starsystem->doc3a );
space.c:      fprintf( fp, "Doc1b          %d\n", starsystem->doc1b );
space.c:      fprintf( fp, "Doc2b          %d\n", starsystem->doc2b );
space.c:      fprintf( fp, "Doc3b          %d\n", starsystem->doc3b );
space.c:      fprintf( fp, "Doc1c          %d\n", starsystem->doc1c );
space.c:      fprintf( fp, "Doc2c          %d\n", starsystem->doc2c );
space.c:      fprintf( fp, "Doc3c          %d\n", starsystem->doc3c );
space.c:      fprintf( fp, "P1x          %d\n", starsystem->p1x );
space.c:      fprintf( fp, "P1y          %d\n", starsystem->p1y );
space.c:      fprintf( fp, "P1z          %d\n", starsystem->p1z );
space.c:      fprintf( fp, "P2x          %d\n", starsystem->p2x );
space.c:      fprintf( fp, "P2y          %d\n", starsystem->p2y );
space.c:      fprintf( fp, "P2z          %d\n", starsystem->p2z );
space.c:      fprintf( fp, "P3x          %d\n", starsystem->p3x );
space.c:      fprintf( fp, "P3y          %d\n", starsystem->p3y );
space.c:      fprintf( fp, "P3z          %d\n", starsystem->p3z );
space.c:      fprintf( fp, "S1x          %d\n", starsystem->s1x );
space.c:      fprintf( fp, "S1y          %d\n", starsystem->s1y );
space.c:      fprintf( fp, "S1z          %d\n", starsystem->s1z );
space.c:      fprintf( fp, "S2x          %d\n", starsystem->s2x );
space.c:      fprintf( fp, "S2y          %d\n", starsystem->s2y );
space.c:      fprintf( fp, "S2z          %d\n", starsystem->s2z );
space.c:      fprintf( fp, "Gravitys1     %d\n", starsystem->gravitys1 );
space.c:      fprintf( fp, "Gravitys2     %d\n", starsystem->gravitys2 );
space.c:      fprintf( fp, "Gravityp1     %d\n", starsystem->gravityp1 );
space.c:      fprintf( fp, "Gravityp2     %d\n", starsystem->gravityp2 );
space.c:      fprintf( fp, "Gravityp3     %d\n", starsystem->gravityp3 );
space.c:      fprintf( fp, "Xpos          %d\n", starsystem->xpos );
space.c:      fprintf( fp, "Ypos          %d\n", starsystem->ypos );
space.c:            KEY( "Doc1a", starsystem->doc1a, fread_number( fp ) );
space.c:            KEY( "Doc2a", starsystem->doc2a, fread_number( fp ) );
space.c:            KEY( "Doc3a", starsystem->doc3a, fread_number( fp ) );
space.c:            KEY( "Doc1b", starsystem->doc1b, fread_number( fp ) );
space.c:            KEY( "Doc2b", starsystem->doc2b, fread_number( fp ) );
space.c:            KEY( "Doc3b", starsystem->doc3b, fread_number( fp ) );
space.c:            KEY( "Doc1c", starsystem->doc1c, fread_number( fp ) );
space.c:            KEY( "Doc2c", starsystem->doc2c, fread_number( fp ) );
space.c:            KEY( "Doc3c", starsystem->doc3c, fread_number( fp ) );
space.c:               if( !starsystem->name )
space.c:                  starsystem->name = STRALLOC( "" );
space.c:               if( !starsystem->location1a )
space.c:                  starsystem->location1a = STRALLOC( "" );
space.c:               if( !starsystem->location2a )
space.c:                  starsystem->location2a = STRALLOC( "" );
space.c:               if( !starsystem->location3a )
space.c:                  starsystem->location3a = STRALLOC( "" );
space.c:               if( !starsystem->location1b )
space.c:                  starsystem->location1b = STRALLOC( "" );
space.c:               if( !starsystem->location2b )
space.c:                  starsystem->location2b = STRALLOC( "" );
space.c:               if( !starsystem->location3b )
space.c:                  starsystem->location3b = STRALLOC( "" );
space.c:               if( !starsystem->location1c )
space.c:                  starsystem->location1c = STRALLOC( "" );
space.c:               if( !starsystem->location2c )
space.c:                  starsystem->location2c = STRALLOC( "" );
space.c:               if( !starsystem->location3c )
space.c:                  starsystem->location3c = STRALLOC( "" );
space.c:               if( !starsystem->planet1 )
space.c:                  starsystem->planet1 = STRALLOC( "" );
space.c:               if( !starsystem->planet2 )
space.c:                  starsystem->planet2 = STRALLOC( "" );
space.c:               if( !starsystem->planet3 )
space.c:                  starsystem->planet3 = STRALLOC( "" );
space.c:               if( !starsystem->star1 )
space.c:                  starsystem->star1 = STRALLOC( "" );
space.c:               if( !starsystem->star2 )
space.c:                  starsystem->star2 = STRALLOC( "" );
space.c:            KEY( "Filename", starsystem->filename, fread_string_nohash( fp ) );
space.c:            KEY( "Gravitys1", starsystem->gravitys1, fread_number( fp ) );
space.c:            KEY( "Gravitys2", starsystem->gravitys2, fread_number( fp ) );
space.c:            KEY( "Gravityp1", starsystem->gravityp1, fread_number( fp ) );
space.c:            KEY( "Gravityp2", starsystem->gravityp2, fread_number( fp ) );
space.c:            KEY( "Gravityp3", starsystem->gravityp3, fread_number( fp ) );
space.c:            KEY( "Location1a", starsystem->location1a, fread_string( fp ) );
space.c:            KEY( "Location2a", starsystem->location2a, fread_string( fp ) );
space.c:            KEY( "Location3a", starsystem->location3a, fread_string( fp ) );
space.c:            KEY( "Location1b", starsystem->location1b, fread_string( fp ) );
space.c:            KEY( "Location2b", starsystem->location2b, fread_string( fp ) );
space.c:            KEY( "Location3b", starsystem->location3b, fread_string( fp ) );
space.c:            KEY( "Location1c", starsystem->location1c, fread_string( fp ) );
space.c:            KEY( "Location2c", starsystem->location2c, fread_string( fp ) );
space.c:            KEY( "Location3c", starsystem->location3c, fread_string( fp ) );
space.c:            KEY( "Name", starsystem->name, fread_string( fp ) );
space.c:            KEY( "Planet1", starsystem->planet1, fread_string( fp ) );
space.c:            KEY( "Planet2", starsystem->planet2, fread_string( fp ) );
space.c:            KEY( "Planet3", starsystem->planet3, fread_string( fp ) );
space.c:            KEY( "P1x", starsystem->p1x, fread_number( fp ) );
space.c:            KEY( "P1y", starsystem->p1y, fread_number( fp ) );
space.c:            KEY( "P1z", starsystem->p1z, fread_number( fp ) );
space.c:            KEY( "P2x", starsystem->p2x, fread_number( fp ) );
space.c:            KEY( "P2y", starsystem->p2y, fread_number( fp ) );
space.c:            KEY( "P2z", starsystem->p2z, fread_number( fp ) );
space.c:            KEY( "P3x", starsystem->p3x, fread_number( fp ) );
space.c:            KEY( "P3y", starsystem->p3y, fread_number( fp ) );
space.c:            KEY( "P3z", starsystem->p3z, fread_number( fp ) );
space.c:            KEY( "Star1", starsystem->star1, fread_string( fp ) );
space.c:            KEY( "Star2", starsystem->star2, fread_string( fp ) );
space.c:            KEY( "S1x", starsystem->s1x, fread_number( fp ) );
space.c:            KEY( "S1y", starsystem->s1y, fread_number( fp ) );
space.c:            KEY( "S1z", starsystem->s1z, fread_number( fp ) );
space.c:            KEY( "S2x", starsystem->s2x, fread_number( fp ) );
space.c:            KEY( "S2y", starsystem->s2y, fread_number( fp ) );
space.c:            KEY( "S2z", starsystem->s2z, fread_number( fp ) );
space.c:            KEY( "Xpos", starsystem->xpos, fread_number( fp ) );
space.c:            KEY( "Ypos", starsystem->ypos, fread_number( fp ) );
space.c:      starsystem->doc1a = atoi( argument );
space.c:      starsystem->doc1b = atoi( argument );
space.c:      starsystem->doc1c = atoi( argument );
space.c:      starsystem->doc2a = atoi( argument );
space.c:      starsystem->doc2b = atoi( argument );
space.c:      starsystem->doc2c = atoi( argument );
space.c:      starsystem->doc3a = atoi( argument );
space.c:      starsystem->doc3b = atoi( argument );
space.c:      starsystem->doc3c = atoi( argument );
space.c:      starsystem->s1x = atoi( argument );
space.c:      starsystem->s1y = atoi( argument );
space.c:      starsystem->s1z = atoi( argument );
space.c:      starsystem->s2x = atoi( argument );
space.c:      starsystem->s2y = atoi( argument );
space.c:      starsystem->s2z = atoi( argument );
space.c:      starsystem->p1x = atoi( argument );
space.c:      starsystem->p1y = atoi( argument );
space.c:      starsystem->p1z = atoi( argument );
space.c:      starsystem->p2x = atoi( argument );
space.c:      starsystem->p2y = atoi( argument );
space.c:      starsystem->p2z = atoi( argument );
space.c:      starsystem->p3x = atoi( argument );
space.c:      starsystem->p3y = atoi( argument );
space.c:      starsystem->p3z = atoi( argument );
space.c:      starsystem->xpos = atoi( argument );
space.c:      starsystem->ypos = atoi( argument );
space.c:      starsystem->gravitys1 = atoi( argument );
space.c:      starsystem->gravitys2 = atoi( argument );
space.c:      starsystem->gravityp1 = atoi( argument );
space.c:      starsystem->gravityp2 = atoi( argument );
space.c:      starsystem->gravityp3 = atoi( argument );
space.c:      STRFREE( starsystem->name );
space.c:      starsystem->name = STRALLOC( argument );
space.c:      STRFREE( starsystem->star1 );
space.c:      starsystem->star1 = STRALLOC( argument );
space.c:      STRFREE( starsystem->star2 );
space.c:      starsystem->star2 = STRALLOC( argument );
space.c:      STRFREE( starsystem->planet1 );
space.c:      starsystem->planet1 = STRALLOC( argument );
space.c:      STRFREE( starsystem->planet2 );
space.c:      starsystem->planet2 = STRALLOC( argument );
space.c:      STRFREE( starsystem->planet3 );
space.c:      starsystem->planet3 = STRALLOC( argument );
space.c:      STRFREE( starsystem->location1a );
space.c:      starsystem->location1a = STRALLOC( argument );
space.c:      STRFREE( starsystem->location1b );
space.c:      starsystem->location1b = STRALLOC( argument );
space.c:      STRFREE( starsystem->location1c );
space.c:      starsystem->location1c = STRALLOC( argument );
space.c:      STRFREE( starsystem->location2a );
space.c:      starsystem->location2a = STRALLOC( argument );
space.c:      STRFREE( starsystem->location2a );
space.c:      starsystem->location2b = STRALLOC( argument );
space.c:      STRFREE( starsystem->location2c );
space.c:      starsystem->location2c = STRALLOC( argument );
space.c:      STRFREE( starsystem->location3a );
space.c:      starsystem->location3a = STRALLOC( argument );
space.c:      STRFREE( starsystem->location3b );
space.c:      starsystem->location3b = STRALLOC( argument );
space.c:      STRFREE( starsystem->location3c );
space.c:      starsystem->location3c = STRALLOC( argument );
space.c:              starsystem->name, starsystem->filename, starsystem->xpos, starsystem->ypos );
space.c:              starsystem->star1, starsystem->gravitys1, starsystem->s1x, starsystem->s1y, starsystem->s1z );
space.c:              starsystem->star2, starsystem->gravitys2, starsystem->s2x, starsystem->s2y, starsystem->s2z );
space.c:              starsystem->planet1, starsystem->gravityp1, starsystem->p1x, starsystem->p1y, starsystem->p1z );
space.c:   ch_printf( ch, "     Doc1a: %5d (%s)\r\n", starsystem->doc1a, starsystem->location1a );
space.c:   ch_printf( ch, "     Doc1b: %5d (%s)\r\n", starsystem->doc1b, starsystem->location1b );
space.c:   ch_printf( ch, "     Doc1c: %5d (%s)\r\n", starsystem->doc1c, starsystem->location1c );
space.c:              starsystem->planet2, starsystem->gravityp2, starsystem->p2x, starsystem->p2y, starsystem->p2z );
space.c:   ch_printf( ch, "     Doc2a: %5d (%s)\r\n", starsystem->doc2a, starsystem->location2a );
space.c:   ch_printf( ch, "     Doc2b: %5d (%s)\r\n", starsystem->doc2b, starsystem->location2b );
space.c:   ch_printf( ch, "     Doc2c: %5d (%s)\r\n", starsystem->doc2c, starsystem->location2c );
space.c:              starsystem->planet3, starsystem->gravityp3, starsystem->p3x, starsystem->p3y, starsystem->p3z );
space.c:   ch_printf( ch, "     Doc3a: %5d (%s)\r\n", starsystem->doc3a, starsystem->location3a );
space.c:   ch_printf( ch, "     Doc3b: %5d (%s)\r\n", starsystem->doc3b, starsystem->location3b );
space.c:   ch_printf( ch, "     Doc3c: %5d (%s)\r\n", starsystem->doc3c, starsystem->location3c );
space.c:   starsystem->name = STRALLOC( argument );
space.c:   starsystem->location1a = STRALLOC( "" );
space.c:   starsystem->location2a = STRALLOC( "" );
space.c:   starsystem->location3a = STRALLOC( "" );
space.c:   starsystem->location1b = STRALLOC( "" );
space.c:   starsystem->location2b = STRALLOC( "" );
space.c:   starsystem->location3b = STRALLOC( "" );
space.c:   starsystem->location1c = STRALLOC( "" );
space.c:   starsystem->location2c = STRALLOC( "" );
space.c:   starsystem->location3c = STRALLOC( "" );
space.c:   starsystem->planet1 = STRALLOC( "" );
space.c:   starsystem->planet2 = STRALLOC( "" );
space.c:   starsystem->planet3 = STRALLOC( "" );
space.c:   starsystem->star1 = STRALLOC( "" );
space.c:   starsystem->star2 = STRALLOC( "" );
space.c:   starsystem->filename = str_dup( filename );
space.c:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c:      ch_printf( ch, "%s\r\n", starsystem->name );
space.c:   for( room = ship->firstroom; room <= ship->lastroom; room++ )
space.c:   for( roomnum = ship->firstroom; roomnum <= ship->lastroom; roomnum++ )
space.c:      for( vic = room->first_person; vic; vic = vic->next_in_room )
space.c:         if( !IS_NPC( vic ) && IS_SET( vic->act, PLR_SOUND ) )
space.c:   for( room = ship->firstroom; room <= ship->lastroom; room++ )
space.c:      if( room == ship->cockpit || room == ship->navseat
space.c:          || room == ship->pilotseat || room == ship->coseat
space.c:          || room == ship->gunseat || room == ship->engineroom || room == ship->turret1 || room == ship->turret2 )
space.c:   if( !ship->starsystem )
space.c:   for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:     headingtotarget = coordpairtoheading(ship->vx,ship->vy,target->vx,target->vy);
space.c:     if( abs( headingtotarget - ship->heading ) <  PI / 2) //180 degrees
space.c:   hx = ship->hx;
space.c:   hy = ship->hy;
space.c:   dx = target->vx - ship->vx;
space.c:   dy = target->vy - ship->vy;
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   else if( ship->ship_class == MIDSIZE_SHIP )
space.c:   else if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ship->ship_class <= CAPITAL_SHIP )
space.c:      price += ( ship->manuever * 100 * ( 1 + ship->ship_class ) );
space.c:   price += ( ship->tractorbeam * 100 );
space.c:   price += ( ship->realspeed * 10 );
space.c:   price += ( ship->astro_array * 5 );
space.c:   price += ( 5 * ship->maxhull );
space.c:   price += ( 2 * ship->maxenergy );
space.c:   price += ( 100 * ship->maxchaff );
space.c:   if( ship->maxenergy > 5000 )
space.c:      price += ( ( ship->maxenergy - 5000 ) * 20 );
space.c:   if( ship->maxenergy > 10000 )
space.c:      price += ( ( ship->maxenergy - 10000 ) * 50 );
space.c:   if( ship->maxhull > 1000 )
space.c:      price += ( ( ship->maxhull - 1000 ) * 10 );
space.c:   if( ship->maxhull > 10000 )
space.c:      price += ( ( ship->maxhull - 10000 ) * 20 );
space.c:   if( ship->maxshield > 200 )
space.c:      price += ( ( ship->maxshield - 200 ) * 50 );
space.c:   if( ship->maxshield > 1000 )
space.c:      price += ( ( ship->maxshield - 1000 ) * 100 );
space.c:   if( ship->realspeed > 100 )
space.c:      price += ( ( ship->realspeed - 100 ) * 500 );
space.c:   if( ship->lasers > 5 )
space.c:      price += ( ( ship->lasers - 5 ) * 500 );
space.c:   if( ship->maxshield )
space.c:      price += ( 1000 + 10 * ship->maxshield );
space.c:   if( ship->lasers )
space.c:      price += ( 500 + 500 * ship->lasers );
space.c:   if( ship->maxmissiles )
space.c:      price += ( 1000 + 100 * ship->maxmissiles );
space.c:   if( ship->maxrockets )
space.c:      price += ( 2000 + 200 * ship->maxmissiles );
space.c:   if( ship->maxtorpedos )
space.c:      price += ( 1500 + 150 * ship->maxmissiles );
space.c:   if( ship->missiles )
space.c:      price += ( 250 * ship->missiles );
space.c:   else if( ship->torpedos )
space.c:      price += ( 500 * ship->torpedos );
space.c:   else if( ship->rockets )
space.c:      price += ( 1000 * ship->rockets );
space.c:   if( ship->turret1 )
space.c:   if( ship->turret2 )
space.c:   if( ship->hyperspeed )
space.c:      price += ( 1000 + ship->hyperspeed * 10 );
space.c:   if( ship->hanger )
space.c:      price += ( ship->ship_class == MIDSIZE_SHIP ? 50000 : 100000 );
space.c:   for( tship = first_ship; tship; tship = tship->next )
space.c:      fprintf( fpout, "%s\n", tship->filename );
space.c:   for( ship = room->first_ship; ship; ship = ship->next_in_room )
space.c:      if( !str_cmp( name, ship->name ) )
space.c:   for( ship = room->first_ship; ship; ship = ship->next_in_room )
space.c:      if( nifty_is_name_prefix( name, ship->name ) )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( !str_cmp( name, ship->name ) )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( nifty_is_name_prefix( name, ship->name ) )
space.c:   for( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
space.c:      if( !str_cmp( name, ship->name ) )
space.c:   for( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
space.c:      if( nifty_is_name_prefix( name, ship->name ) )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( !str_cmp( name, ship->pilot ) )
space.c:   if( !str_cmp( name, ship->copilot ) )
space.c:   if( !str_cmp( name, ship->owner ) )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->cockpit || vnum == ship->turret1 || vnum == ship->turret2
space.c:          || vnum == ship->pilotseat || vnum == ship->coseat || vnum == ship->navseat
space.c:          || vnum == ship->gunseat || vnum == ship->engineroom )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->pilotseat )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->coseat )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->navseat )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->gunseat )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->engineroom )
space.c:         if( vnum == ship->engineroom )
space.c:         if( vnum == ship->cockpit )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->gunseat || vnum == ship->turret1 || vnum == ship->turret2 )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->entrance )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( vnum == ship->hanger )
space.c:   if( !ship->filename || ship->filename[0] == '\0' )
space.c:      sprintf( buf, "save_ship: %s has no filename", ship->name );
space.c:   sprintf( filename, "%s%s", SHIP_DIR, ship->filename );
space.c:      fprintf( fp, "Name         %s~\n", ship->name );
space.c:      fprintf( fp, "Filename     %s~\n", ship->filename );
space.c:      fprintf( fp, "Description  %s~\n", ship->description );
space.c:      fprintf( fp, "Owner        %s~\n", ship->owner );
space.c:      fprintf( fp, "Pilot        %s~\n", ship->pilot );
space.c:      fprintf( fp, "Copilot      %s~\n", ship->copilot );
space.c:      fprintf( fp, "Class        %d\n", ship->ship_class );
space.c:      fprintf( fp, "Tractorbeam  %d\n", ship->tractorbeam );
space.c:      fprintf( fp, "Shipyard     %d\n", ship->shipyard );
space.c:      fprintf( fp, "Hanger       %d\n", ship->hanger );
space.c:      fprintf( fp, "Turret1      %d\n", ship->turret1 );
space.c:      fprintf( fp, "Turret2      %d\n", ship->turret2 );
space.c:      fprintf( fp, "Statet0      %d\n", ship->statet0 );
space.c:      fprintf( fp, "Statet1      %d\n", ship->statet1 );
space.c:      fprintf( fp, "Statet2      %d\n", ship->statet2 );
space.c:      fprintf( fp, "Lasers       %d\n", ship->lasers );
space.c:      fprintf( fp, "Missiles     %d\n", ship->missiles );
space.c:      fprintf( fp, "Maxmissiles  %d\n", ship->maxmissiles );
space.c:      fprintf( fp, "Rockets     %d\n", ship->rockets );
space.c:      fprintf( fp, "Maxrockets  %d\n", ship->maxrockets );
space.c:      fprintf( fp, "Torpedos     %d\n", ship->torpedos );
space.c:      fprintf( fp, "Maxtorpedos  %d\n", ship->maxtorpedos );
space.c:      fprintf( fp, "Lastdoc      %d\n", ship->lastdoc );
space.c:      fprintf( fp, "Firstroom    %d\n", ship->firstroom );
space.c:      fprintf( fp, "Lastroom     %d\n", ship->lastroom );
space.c:      fprintf( fp, "Shield       %d\n", ship->shield );
space.c:      fprintf( fp, "Maxshield    %d\n", ship->maxshield );
space.c:      fprintf( fp, "Hull         %d\n", ship->hull );
space.c:      fprintf( fp, "Maxhull      %d\n", ship->maxhull );
space.c:      fprintf( fp, "Maxenergy    %d\n", ship->maxenergy );
space.c:      fprintf( fp, "Hyperspeed   %d\n", ship->hyperspeed );
space.c:      fprintf( fp, "Comm         %d\n", ship->comm );
space.c:      fprintf( fp, "Chaff        %d\n", ship->chaff );
space.c:      fprintf( fp, "Maxchaff     %d\n", ship->maxchaff );
space.c:      fprintf( fp, "Sensor       %d\n", ship->sensor );
space.c:      fprintf( fp, "Astro_array  %d\n", ship->astro_array );
space.c:      fprintf( fp, "Realspeed    %d\n", ship->realspeed );
space.c:      fprintf( fp, "Type         %d\n", ship->type );
space.c:      fprintf( fp, "Cockpit      %d\n", ship->cockpit );
space.c:      fprintf( fp, "Coseat       %d\n", ship->coseat );
space.c:      fprintf( fp, "Pilotseat    %d\n", ship->pilotseat );
space.c:      fprintf( fp, "Gunseat      %d\n", ship->gunseat );
space.c:      fprintf( fp, "Navseat      %d\n", ship->navseat );
space.c:      fprintf( fp, "Engineroom   %d\n", ship->engineroom );
space.c:      fprintf( fp, "Entrance     %d\n", ship->entrance );
space.c:      fprintf( fp, "Shipstate    %d\n", ship->shipstate );
space.c:      fprintf( fp, "Missilestate %d\n", ship->missilestate );
space.c:      fprintf( fp, "Energy       %d\n", ship->energy );
space.c:      fprintf( fp, "Manuever     %d\n", ship->manuever );
space.c:      fprintf( fp, "Home         %s~\n", ship->home );
space.c:            KEY( "Astro_array", ship->astro_array, fread_number( fp ) );
space.c:            KEY( "Cockpit", ship->cockpit, fread_number( fp ) );
space.c:            KEY( "Coseat", ship->coseat, fread_number( fp ) );
space.c:            KEY( "Class", ship->ship_class, fread_number( fp ) );
space.c:            KEY( "Copilot", ship->copilot, fread_string( fp ) );
space.c:            KEY( "Comm", ship->comm, fread_number( fp ) );
space.c:            KEY( "Chaff", ship->chaff, fread_number( fp ) );
space.c:            KEY( "Description", ship->description, fread_string( fp ) );
space.c:            KEY( "Engineroom", ship->engineroom, fread_number( fp ) );
space.c:            KEY( "Entrance", ship->entrance, fread_number( fp ) );
space.c:            KEY( "Energy", ship->energy, fread_number( fp ) );
space.c:               if( !ship->home )
space.c:                  ship->home = STRALLOC( "" );
space.c:               if( !ship->name )
space.c:                  ship->name = STRALLOC( "" );
space.c:               if( !ship->owner )
space.c:                  ship->owner = STRALLOC( "" );
space.c:               if( !ship->description )
space.c:                  ship->description = STRALLOC( "" );
space.c:               if( !ship->copilot )
space.c:                  ship->copilot = STRALLOC( "" );
space.c:               if( !ship->pilot )
space.c:                  ship->pilot = STRALLOC( "" );
space.c:               if( ship->shipstate != SHIP_DISABLED )
space.c:                  ship->shipstate = SHIP_DOCKED;
space.c:               if( ship->statet0 != LASER_DAMAGED )
space.c:                  ship->statet0 = LASER_READY;
space.c:               if( ship->statet1 != LASER_DAMAGED )
space.c:                  ship->statet1 = LASER_READY;
space.c:               if( ship->statet2 != LASER_DAMAGED )
space.c:                  ship->statet2 = LASER_READY;
space.c:               if( ship->missilestate != MISSILE_DAMAGED )
space.c:                  ship->missilestate = MISSILE_READY;
space.c:               if( ship->shipyard <= 0 )
space.c:                  ship->shipyard = ROOM_LIMBO_SHIPYARD;
space.c:               if( ship->lastdoc <= 0 )
space.c:                  ship->lastdoc = ship->shipyard;
space.c:               ship->bayopen = TRUE;
space.c:               ship->autopilot = FALSE;
space.c:               ship->hatchopen = FALSE;
space.c:               if( ship->navseat <= 0 )
space.c:                  ship->navseat = ship->cockpit;
space.c:               if( ship->gunseat <= 0 )
space.c:                  ship->gunseat = ship->cockpit;
space.c:               if( ship->coseat <= 0 )
space.c:                  ship->coseat = ship->cockpit;
space.c:               if( ship->pilotseat <= 0 )
space.c:                  ship->pilotseat = ship->cockpit;
space.c:               if( ship->missiletype == 1 )
space.c:                  ship->torpedos = ship->missiles; /* for back compatability */
space.c:                  ship->missiles = 0;
space.c:               ship->starsystem = NULL;
space.c:               ship->energy = ship->maxenergy;
space.c:               ship->hull = ship->maxhull;
space.c:               ship->in_room = NULL;
space.c:               ship->next_in_room = NULL;
space.c:               ship->prev_in_room = NULL;
space.c:            KEY( "Filename", ship->filename, fread_string_nohash( fp ) );
space.c:            KEY( "Firstroom", ship->firstroom, fread_number( fp ) );
space.c:            KEY( "Gunseat", ship->gunseat, fread_number( fp ) );
space.c:            KEY( "Home", ship->home, fread_string( fp ) );
space.c:            KEY( "Hyperspeed", ship->hyperspeed, fread_number( fp ) );
space.c:            KEY( "Hull", ship->hull, fread_number( fp ) );
space.c:            KEY( "Hanger", ship->hanger, fread_number( fp ) );
space.c:            KEY( "Laserstr", ship->lasers, ( short )( fread_number( fp ) / 10 ) );
space.c:            KEY( "Lasers", ship->lasers, fread_number( fp ) );
space.c:            KEY( "Lastdoc", ship->lastdoc, fread_number( fp ) );
space.c:            KEY( "Lastroom", ship->lastroom, fread_number( fp ) );
space.c:            KEY( "Manuever", ship->manuever, fread_number( fp ) );
space.c:            KEY( "Maxmissiles", ship->maxmissiles, fread_number( fp ) );
space.c:            KEY( "Maxtorpedos", ship->maxtorpedos, fread_number( fp ) );
space.c:            KEY( "Maxrockets", ship->maxrockets, fread_number( fp ) );
space.c:            KEY( "Missiles", ship->missiles, fread_number( fp ) );
space.c:            KEY( "Missiletype", ship->missiletype, fread_number( fp ) );
space.c:            KEY( "Maxshield", ship->maxshield, fread_number( fp ) );
space.c:            KEY( "Maxenergy", ship->maxenergy, fread_number( fp ) );
space.c:            KEY( "Missilestate", ship->missilestate, fread_number( fp ) );
space.c:            KEY( "Maxhull", ship->maxhull, fread_number( fp ) );
space.c:            KEY( "Maxchaff", ship->maxchaff, fread_number( fp ) );
space.c:            KEY( "Name", ship->name, fread_string( fp ) );
space.c:            KEY( "Navseat", ship->navseat, fread_number( fp ) );
space.c:            KEY( "Owner", ship->owner, fread_string( fp ) );
space.c:            KEY( "Pilot", ship->pilot, fread_string( fp ) );
space.c:            KEY( "Pilotseat", ship->pilotseat, fread_number( fp ) );
space.c:            KEY( "Realspeed", ship->realspeed, fread_number( fp ) );
space.c:            KEY( "Rockets", ship->rockets, fread_number( fp ) );
space.c:            KEY( "Shipyard", ship->shipyard, fread_number( fp ) );
space.c:            KEY( "Sensor", ship->sensor, fread_number( fp ) );
space.c:            KEY( "Shield", ship->shield, fread_number( fp ) );
space.c:            KEY( "Shipstate", ship->shipstate, fread_number( fp ) );
space.c:            KEY( "Statet0", ship->statet0, fread_number( fp ) );
space.c:            KEY( "Statet1", ship->statet1, fread_number( fp ) );
space.c:            KEY( "Statet2", ship->statet2, fread_number( fp ) );
space.c:            KEY( "Type", ship->type, fread_number( fp ) );
space.c:            KEY( "Tractorbeam", ship->tractorbeam, fread_number( fp ) );
space.c:            KEY( "Turret1", ship->turret1, fread_number( fp ) );
space.c:            KEY( "Turret2", ship->turret2, fread_number( fp ) );
space.c:            KEY( "Torpedos", ship->torpedos, fread_number( fp ) );
space.c:      if( !str_cmp( "Public", ship->owner ) || ship->type == MOB_SHIP )
space.c:	if( ship->ship_class != SHIP_PLATFORM && ship->type != MOB_SHIP && ship->ship_class != CAPITAL_SHIP )
space.c:            ship_to_room( ship, ship->shipyard );
space.c:            ship->location = ship->shipyard;
space.c:            ship->lastdoc = ship->shipyard;
space.c:            ship->shipstate = SHIP_DOCKED;
space.c:         ship->currspeed = 0;
space.c:         ship->energy = ship->maxenergy;
space.c:         ship->chaff = ship->maxchaff;
space.c:         ship->hull = ship->maxhull;
space.c:         ship->shield = 0;
space.c:         ship->statet1 = LASER_READY;
space.c:         ship->statet2 = LASER_READY;
space.c:         ship->statet0 = LASER_READY;
space.c:         ship->missilestate = LASER_READY;
space.c:         ship->currjump = NULL;
space.c:         ship->target0 = NULL;
space.c:         ship->target1 = NULL;
space.c:         ship->target2 = NULL;
space.c:	 ship->track0  = NULL;
space.c:         ship->hatchopen = FALSE;
space.c:         ship->bayopen = TRUE;
space.c:         ship->missiles = ship->maxmissiles;
space.c:         ship->torpedos = ship->maxtorpedos;
space.c:         ship->rockets = ship->maxrockets;
space.c:         ship->autorecharge = FALSE;
space.c:         ship->autotrack = FALSE;
space.c:         ship->autospeed = FALSE;
space.c:	 ship->flightflags = 0;
space.c:      else if( ship->cockpit == ROOM_SHUTTLE_BUS ||
space.c:               ship->cockpit == ROOM_SHUTTLE_BUS_2 ||
space.c:               ship->cockpit == ROOM_SENATE_SHUTTLE ||
space.c:               ship->cockpit == ROOM_CORUSCANT_TURBOCAR || ship->cockpit == ROOM_CORUSCANT_SHUTTLE )
space.c:      else if( ( pRoomIndex = get_room_index( ship->lastdoc ) ) != NULL
space.c:               && ship->ship_class != CAPITAL_SHIP
space.c:	       && ship->ship_class != SHIP_PLATFORM )
space.c:         LINK( ship, pRoomIndex->first_ship, pRoomIndex->last_ship, next_in_room, prev_in_room );
space.c:         ship->in_room = pRoomIndex;
space.c:         ship->location = ship->lastdoc;
space.c:      if( ship->ship_class == SHIP_PLATFORM
space.c:	  || ship->type == MOB_SHIP || ship->ship_class == CAPITAL_SHIP )
space.c:         ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c:         ship->vx = number_range( -5000, 5000 );
space.c:         ship->vy = number_range( -5000, 5000 );
space.c:         ship->hx = 1;
space.c:         ship->hy = 1;
space.c:	 ship->heading = 0;
space.c:	 ship->prevheading = 0;
space.c:	 ship->turnarc = 0;
space.c:         ship->shipstate = SHIP_READY;
space.c:         ship->autopilot = TRUE;
space.c:         ship->autorecharge = TRUE;
space.c:         ship->shield = ship->maxshield;
space.c:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c:	if( ship->ship_class <= SHIP_PLATFORM )
space.c:            clan->spacecraft++;
space.c:            clan->vehicles++;
space.c:   ship->shipstate = SHIP_READY;
space.c:   if( ship->ship_class != SHIP_PLATFORM && ship->type != MOB_SHIP )
space.c:      ship_to_room( ship, ship->shipyard );
space.c:      ship->location = ship->shipyard;
space.c:      ship->lastdoc = ship->shipyard;
space.c:      ship->shipstate = SHIP_DOCKED;
space.c:   if( ship->starsystem )
space.c:      ship_from_starsystem( ship, ship->starsystem );
space.c:   ship->currspeed = 0;
space.c:   ship->energy = ship->maxenergy;
space.c:   ship->chaff = ship->maxchaff;
space.c:   ship->hull = ship->maxhull;
space.c:   ship->shield = 0;
space.c:   ship->statet1 = LASER_READY;
space.c:   ship->statet2 = LASER_READY;
space.c:   ship->statet0 = LASER_READY;
space.c:   ship->missilestate = LASER_READY;
space.c:   ship->currjump = NULL;
space.c:   ship->target0 = NULL;
space.c:   ship->target1 = NULL;
space.c:   ship->target2 = NULL;
space.c:   ship->track0 = NULL;
space.c:   ship->heading = 0;
space.c:   ship->prevheading = 0;
space.c:   ship->turnarc = 0;
space.c:   ship->hatchopen = FALSE;
space.c:   ship->bayopen = TRUE;
space.c:   ship->missiles = ship->maxmissiles;
space.c:   ship->torpedos = ship->maxtorpedos;
space.c:   ship->rockets = ship->maxrockets;
space.c:   ship->autorecharge = FALSE;
space.c:   ship->autotrack = FALSE;
space.c:   ship->autospeed = FALSE;
space.c:   ship->flightflags = 0;
space.c:   if( str_cmp( "Public", ship->owner ) && ship->type != MOB_SHIP )
space.c:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c:	if( ship->ship_class <= SHIP_PLATFORM )
space.c:	  clan->spacecraft--;
space.c:	  clan->vehicles--;
space.c:      STRFREE( ship->owner );
space.c:      ship->owner = STRALLOC( "" );
space.c:      STRFREE( ship->pilot );
space.c:      ship->pilot = STRALLOC( "" );
space.c:      STRFREE( ship->copilot );
space.c:      ship->copilot = STRALLOC( "" );
space.c:   if( ship->type == SHIP_REPUBLIC || ( ship->type == MOB_SHIP && !str_cmp( ship->owner, "the new republic" ) ) )
space.c:      STRFREE( ship->home );
space.c:      ship->home = STRALLOC( "coruscant" );
space.c:   else if( ship->type == SHIP_IMPERIAL || ( ship->type == MOB_SHIP && !str_cmp( ship->owner, "the empire" ) ) )
space.c:      STRFREE( ship->home );
space.c:      ship->home = STRALLOC( "byss" );
space.c:   else if( ship->type == SHIP_CIVILIAN )
space.c:      STRFREE( ship->home );
space.c:      ship->home = STRALLOC( "corperate" );
space.c:   if( ( ship->ship_class == SHIP_PLATFORM || ship->type == MOB_SHIP || ship->ship_class == CAPITAL_SHIP ) && ship->home )
space.c:      ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c:      ship->vx = number_range( -5000, 5000 );
space.c:      ship->vy = number_range( -5000, 5000 );
space.c:      ship->shipstate = SHIP_READY;
space.c:      ship->autopilot = TRUE;
space.c:      ship->autorecharge = TRUE;
space.c:      ship->shield = ship->maxshield;
space.c:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c:	if( ship->ship_class <= SHIP_PLATFORM )
space.c:	  clan->spacecraft--;
space.c:	  clan->vehicles--;
space.c:      STRFREE( ship->owner );
space.c:      ship->owner = STRALLOC( argument );
space.c:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c:	if( ship->ship_class <= SHIP_PLATFORM )
space.c:	  clan->spacecraft++;
space.c:	  clan->vehicles++;
space.c:      STRFREE( ship->home );
space.c:      ship->home = STRALLOC( argument );
space.c:      STRFREE( ship->pilot );
space.c:      ship->pilot = STRALLOC( argument );
space.c:      STRFREE( ship->copilot );
space.c:      ship->copilot = STRALLOC( argument );
space.c:      ship->firstroom = tempnum;
space.c:      ship->lastroom = tempnum;
space.c:      ship->cockpit = tempnum;
space.c:      ship->coseat = tempnum;
space.c:      ship->pilotseat = tempnum;
space.c:      ship->gunseat = tempnum;
space.c:      ship->navseat = tempnum;
space.c:      ship->entrance = tempnum;
space.c:      ship->turret1 = 0;
space.c:      ship->turret2 = 0;
space.c:      ship->hanger = 0;
space.c:      if( tempnum < ship->firstroom )
space.c:      if( ship->ship_class == FIGHTER_SHIP
space.c:	  && ( tempnum - ship->firstroom ) > 5 )
space.c:      if( ship->ship_class == MIDSIZE_SHIP
space.c:	  && ( tempnum - ship->firstroom ) > 25 )
space.c:      if( ship->ship_class == CAPITAL_SHIP
space.c:	  && ( tempnum - ship->firstroom ) > 100 )
space.c:      ship->lastroom = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->cockpit = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->pilotseat = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->coseat = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->navseat = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->gunseat = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      ship->entrance = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c:          tempnum == ship->turret2 || tempnum == ship->hanger || tempnum == ship->engineroom )
space.c:      ship->turret1 = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c:          tempnum == ship->turret1 || tempnum == ship->hanger || tempnum == ship->engineroom )
space.c:      ship->turret2 = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c:          tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->engineroom )
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      ship->hanger = tempnum;
space.c:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c:          tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c:      ship->engineroom = tempnum;
space.c:      ship->shipyard = tempnum;
space.c:         ship->type = SHIP_REPUBLIC;
space.c:         ship->type = SHIP_IMPERIAL;
space.c:         ship->type = SHIP_CIVILIAN;
space.c:         ship->type = MOB_SHIP;
space.c:      STRFREE( ship->name );
space.c:      ship->name = STRALLOC( argument );
space.c:      DISPOSE( ship->filename );
space.c:      ship->filename = str_dup( argument );
space.c:      STRFREE( ship->description );
space.c:      ship->description = STRALLOC( argument );
space.c:      ship->manuever = URANGE( 0, atoi( argument ), 120 );
space.c:      ship->lasers = URANGE( 0, atoi( argument ), 10 );
space.c:     ship->ship_class = URANGE( 0, atoi( argument ), 9 );
space.c:      ship->maxmissiles = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->missiles = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->maxtorpedos = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->torpedos = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->maxrockets = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->rockets = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->realspeed = URANGE( 0, atoi( argument ), 150 );
space.c:      ship->tractorbeam = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->hyperspeed = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->maxshield = URANGE( 0, atoi( argument ), 1000 );
space.c:      ship->hull = URANGE( 1, atoi( argument ), 20000 );
space.c:      ship->maxhull = URANGE( 1, atoi( argument ), 20000 );
space.c:      ship->energy = URANGE( 1, atoi( argument ), 30000 );
space.c:      ship->maxenergy = URANGE( 1, atoi( argument ), 30000 );
space.c:      ship->sensor = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->astro_array = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->comm = URANGE( 0, atoi( argument ), 255 );
space.c:      ship->chaff = URANGE( 0, atoi( argument ), 25 );
space.c:      ship->maxchaff = URANGE( 0, atoi( argument ), 25 );
space.c:              ship->type == SHIP_REPUBLIC ? "New Republic" :
space.c:              ( ship->type == SHIP_IMPERIAL ? "Imperial" :
space.c:                ( ship->type == SHIP_CIVILIAN ? "Civilian" : "Mob" ) ),
space.c:              ship->ship_class == FIGHTER_SHIP ? "Starfighter" :
space.c:              ( ship->ship_class == MIDSIZE_SHIP ? "Midship" :
space.c:                ( ship->ship_class == CAPITAL_SHIP ? "Capital Ship" :
space.c:                  ( ship->ship_class == SHIP_PLATFORM ? "Platform" :
space.c:                    ( ship->ship_class == CLOUD_CAR ? "Cloudcar" :
space.c:                      ( ship->ship_class == OCEAN_SHIP ? "Boat" :
space.c:                        ( ship->ship_class == LAND_SPEEDER ? "Speeder" :
space.c:                          ( ship->ship_class == WHEELED ? "Wheeled Transport" :
space.c:                            ( ship->ship_class == LAND_CRAWLER ? "Crawler" :
space.c:                              ( ship->ship_class == WALKER ? "Walker" : "Unknown" ) ) ) ) ) ) ) ) ), ship->name, ship->filename );
space.c:              ship->home, ship->description, ship->owner, ship->pilot, ship->copilot );
space.c:   ch_printf( ch, "Firstroom: %d   Lastroom: %d", ship->firstroom, ship->lastroom );
space.c:              ship->cockpit, ship->entrance, ship->hanger, ship->engineroom );
space.c:              ship->pilotseat, ship->coseat, ship->navseat, ship->gunseat );
space.c:   ch_printf( ch, "Location: %d   Lastdoc: %d   Shipyard: %d\r\n", ship->location, ship->lastdoc, ship->shipyard );
space.c:              ship->tractorbeam, ship->comm, ship->sensor, ship->astro_array );
space.c:   ch_printf( ch, "Lasers: %d  Laser Condition: %s\r\n", ship->lasers, ship->statet0 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c:   ch_printf( ch, "Turret One: %d  Condition: %s\r\n", ship->turret1, ship->statet1 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c:   ch_printf( ch, "Turret Two: %d  Condition: %s\r\n", ship->turret2, ship->statet2 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c:              ship->missiles,
space.c:              ship->maxmissiles,
space.c:              ship->torpedos,
space.c:              ship->maxtorpedos,
space.c:              ship->rockets, ship->maxrockets, ship->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good" );
space.c:              ship->hull, ship->maxhull, ship->shipstate == SHIP_DISABLED ? "Disabled" : "Running" );
space.c:              ship->shield, ship->maxshield, ship->energy, ship->maxenergy, ship->chaff, ship->maxchaff );
space.c:   ch_printf( ch, "Current Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy );
space.c:   ch_printf( ch, "Current Heading: %.0f %.0f\r\n", ship->hx, ship->hy );
space.c:              ship->currspeed, ship->realspeed, ship->hyperspeed, ship->manuever );
space.c:   ship->name = STRALLOC( argument );
space.c:   ship->description = STRALLOC( "" );
space.c:   ship->owner = STRALLOC( "" );
space.c:   ship->copilot = STRALLOC( "" );
space.c:   ship->pilot = STRALLOC( "" );
space.c:   ship->home = STRALLOC( "" );
space.c:   ship->type = SHIP_CIVILIAN;
space.c:   ship->starsystem = NULL;
space.c:   ship->energy = ship->maxenergy;
space.c:   ship->hull = ship->maxhull;
space.c:   ship->in_room = NULL;
space.c:   ship->next_in_room = NULL;
space.c:   ship->prev_in_room = NULL;
space.c:   ship->currjump = NULL;
space.c:   ship->target0 = NULL;
space.c:   ship->target1 = NULL;
space.c:   ship->target2 = NULL;
space.c:   ship->filename = str_dup( arg );
space.c:   ship->name = STRALLOC( argument );
space.c:   ship->description = STRALLOC( "" );
space.c:   ship->owner = STRALLOC( "" );
space.c:   ship->copilot = STRALLOC( "" );
space.c:   ship->pilot = STRALLOC( "" );
space.c:   ship->home = STRALLOC( "" );
space.c:   ship->type = old->type;
space.c:   ship->ship_class = old->ship_class;
space.c:   ship->lasers = old->lasers;
space.c:   ship->maxmissiles = old->maxmissiles;
space.c:   ship->maxrockets = old->maxrockets;
space.c:   ship->maxtorpedos = old->maxtorpedos;
space.c:   ship->maxshield = old->maxshield;
space.c:   ship->maxhull = old->maxhull;
space.c:   ship->maxenergy = old->maxenergy;
space.c:   ship->hyperspeed = old->hyperspeed;
space.c:   ship->maxchaff = old->maxchaff;
space.c:   ship->realspeed = old->realspeed;
space.c:   ship->manuever = old->manuever;
space.c:   ship->in_room = NULL;
space.c:   ship->next_in_room = NULL;
space.c:   ship->prev_in_room = NULL;
space.c:   ship->currjump = NULL;
space.c:   ship->target0 = NULL;
space.c:   ship->target1 = NULL;
space.c:   ship->target2 = NULL;
space.c:   ship->filename = str_dup( arg2 );
space.c:      for( ship = first_ship; ship; ship = ship->next )
space.c:         if( str_cmp( ship->owner, ch->name ) )
space.c:            if( !ch->pcdata || !ch->pcdata->clan || str_cmp( ship->owner, ch->pcdata->clan->name )
space.c:                || ship->ship_class > SHIP_PLATFORM )
space.c:         if( ship->type == MOB_SHIP )
space.c:         else if( ship->type == SHIP_REPUBLIC )
space.c:         else if( ship->type == SHIP_IMPERIAL )
space.c:         if( ship->in_room )
space.c:            ch_printf( ch, "%s (%s) - %s\r\n", ship->name, ship->in_room->name );
space.c:            ch_printf( ch, "%s (%s)\r\n", ship->name );
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->location != ch->in_room->vnum
space.c:	  || ship->ship_class > SHIP_PLATFORM )
space.c:      if( ship->type == MOB_SHIP )
space.c:      else if( ship->type == SHIP_REPUBLIC )
space.c:      else if( ship->type == SHIP_IMPERIAL )
space.c:      ch_printf( ch, "%-35s %-15s", ship->name, ship->owner );
space.c:      if( ship->type == MOB_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c:      if( !str_cmp( ship->owner, "Public" ) )
space.c:      else if( str_cmp( ship->owner, "" ) )
space.c:      for( ship = first_ship; ship; ship = ship->next )
space.c:         if( str_cmp( ship->owner, ch->name ) )
space.c:            if( !ch->pcdata || !ch->pcdata->clan || str_cmp( ship->owner, ch->pcdata->clan->name )
space.c:                || ship->ship_class <= SHIP_PLATFORM )
space.c:         if( ship->location != ch->in_room->vnum
space.c:	     || ship->ship_class <= SHIP_PLATFORM )
space.c:         if( ship->type == MOB_SHIP )
space.c:         else if( ship->type == SHIP_REPUBLIC )
space.c:         else if( ship->type == SHIP_IMPERIAL )
space.c:         ch_printf( ch, "%-35s %-15s\r\n", ship->name, ship->owner );
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->location != ch->in_room->vnum
space.c:	  || ship->ship_class <= SHIP_PLATFORM )
space.c:      if( ship->type == MOB_SHIP )
space.c:      else if( ship->type == SHIP_REPUBLIC )
space.c:      else if( ship->type == SHIP_IMPERIAL )
space.c:      ch_printf( ch, "%-35s %-15s", ship->name, ship->owner );
space.c:      if( !str_cmp( ship->owner, "Public" ) )
space.c:      else if( str_cmp( ship->owner, "" ) )
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:      if( ship->ship_class <= SHIP_PLATFORM )
space.c:      if( ship->type == MOB_SHIP )
space.c:      else if( ship->type == SHIP_REPUBLIC )
space.c:      else if( ship->type == SHIP_IMPERIAL )
space.c:      ch_printf( ch, "%-35s %-15s ", ship->name, ship->owner );
space.c:      if( !str_cmp( ship->owner, "Public" ) )
space.c:      else if( str_cmp( ship->owner, "" ) )
space.c:      for( ship = first_ship; ship; ship = ship->next )
space.c:         if( ship->type == MOB_SHIP )
space.c:            ch_printf( ch, "&w%-35s %-15s\r\n", ship->name, ship->owner );
space.c:   for( ship = first_ship; ship; ship = ship->next )
space.c:     if( ship->ship_class > SHIP_PLATFORM )
space.c:      if( ship->type == MOB_SHIP )
space.c:      else if( ship->type == SHIP_REPUBLIC )
space.c:      else if( ship->type == SHIP_IMPERIAL )
space.c:      ch_printf( ch, "%-35s %-15s ", ship->name, ship->owner );
space.c:      if( ship->type == MOB_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c:      if( !str_cmp( ship->owner, "Public" ) )
space.c:      else if( str_cmp( ship->owner, "" ) )
space.c:   if( starsystem->first_ship == NULL )
space.c:      starsystem->first_ship = ship;
space.c:   if( starsystem->last_ship )
space.c:      starsystem->last_ship->next_in_starsystem = ship;
space.c:      ship->prev_in_starsystem = starsystem->last_ship;
space.c:   starsystem->last_ship = ship;
space.c:   ship->starsystem = starsystem;
space.c:   if( ( starsystem = ship->starsystem ) == NULL )
space.c:   missile->target = target;
space.c:   missile->fired_from = ship;
space.c:      missile->fired_by = STRALLOC( ch->name );
space.c:      missile->fired_by = STRALLOC( "" );
space.c:   missile->missiletype = missiletype;
space.c:   missile->age = 0;
space.c:   if( missile->missiletype == HEAVY_BOMB )
space.c:      missile->speed = 20;
space.c:   }else if( missile->missiletype == PROTON_TORPEDO )
space.c:      missile->speed = 200;
space.c:   }else if( missile->missiletype == CONCUSSION_MISSILE )
space.c:      missile->speed = 500;
space.c:      missile->turnvelocity = PI/(double)120;
space.c:      missile->speed = 50;
space.c:      missile->turnvelocity = PI/(double)24;
space.c:   missile->mx = ( int ) ship->vx;
space.c:   missile->my = ( int ) ship->vy;
space.c:   missile->heading = ship->heading;
space.c:   if( starsystem->first_missile == NULL )
space.c:      starsystem->first_missile = missile;
space.c:   if( starsystem->last_missile )
space.c:      starsystem->last_missile->next_in_starsystem = missile;
space.c:      missile->prev_in_starsystem = starsystem->last_missile;
space.c:   starsystem->last_missile = missile;
space.c:   missile->starsystem = starsystem;
space.c:   if( starsystem->last_ship == ship )
space.c:      starsystem->last_ship = ship->prev_in_starsystem;
space.c:   if( starsystem->first_ship == ship )
space.c:      starsystem->first_ship = ship->next_in_starsystem;
space.c:   if( ship->prev_in_starsystem )
space.c:      ship->prev_in_starsystem->next_in_starsystem = ship->next_in_starsystem;
space.c:   if( ship->next_in_starsystem )
space.c:      ship->next_in_starsystem->prev_in_starsystem = ship->prev_in_starsystem;
space.c:   ship->starsystem = NULL;
space.c:   ship->next_in_starsystem = NULL;
space.c:   ship->prev_in_starsystem = NULL;
space.c:   if( ( starsystem = missile->starsystem ) != NULL )
space.c:      if( starsystem->last_missile == missile )
space.c:         starsystem->last_missile = missile->prev_in_starsystem;
space.c:      if( starsystem->first_missile == missile )
space.c:         starsystem->first_missile = missile->next_in_starsystem;
space.c:      if( missile->prev_in_starsystem )
space.c:         missile->prev_in_starsystem->next_in_starsystem = missile->next_in_starsystem;
space.c:      if( missile->next_in_starsystem )
space.c:         missile->next_in_starsystem->prev_in_starsystem = missile->prev_in_starsystem;
space.c:      missile->starsystem = NULL;
space.c:      missile->next_in_starsystem = NULL;
space.c:      missile->prev_in_starsystem = NULL;
space.c:   missile->target = NULL;
space.c:   missile->fired_from = NULL;
space.c:   if( missile->fired_by )
space.c:      STRFREE( missile->fired_by );
space.c:   if( !str_cmp( "Public", ship->owner ) )
space.c:   if( !str_cmp( ch->name, ship->owner ) || !str_cmp( ch->name, ship->pilot )
space.c:       || !str_cmp( ch->name, ship->copilot ) || !str_cmp( "Public", ship->owner ) )
space.c:   if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan )
space.c:      if( !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c:         if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c:         if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c:         if( ch->pcdata->bestowments && is_name( "pilot", ch->pcdata->bestowments ) )
space.c:   if( ( room = ship->in_room ) != NULL )
space.c:      UNLINK( ship, room->first_ship, room->last_ship, next_in_room, prev_in_room );
space.c:      ship->in_room = NULL;
space.c:   xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) ) / 25;
space.c:   if( ship->shield > 0 )
space.c:      shield_dmg = UMIN( ship->shield, sdamage );
space.c:      sdamage -= shield_dmg;
space.c:      ship->shield -= shield_dmg;
space.c:      if( ship->shield == 0 )
space.c:      if( number_range( 1, 100 ) <= 5 && ship->shipstate != SHIP_DISABLED )
space.c:         ship->shipstate = SHIP_DISABLED;
space.c:      if( number_range( 1, 100 ) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Ships Missile Launcher DAMAGED!" );
space.c:         ship->missilestate = MISSILE_DAMAGED;
space.c:      if( number_range( 1, 100 ) <= 2 && ship->statet0 != LASER_DAMAGED )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Lasers DAMAGED!" );
space.c:         ship->statet1 = LASER_DAMAGED;
space.c:      if( number_range( 1, 100 ) <= 5 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret1 ), "Turret DAMAGED!" );
space.c:         ship->statet1 = LASER_DAMAGED;
space.c:      if( number_range( 1, 100 ) <= 5 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret2 ), "Turret DAMAGED!" );
space.c:         ship->statet2 = LASER_DAMAGED;
space.c:   ship->hull -= sdamage * 5;
space.c:   if( ship->hull <= 0 )
space.c:      xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) );
space.c:   if( ship->hull <= ship->maxhull / 20 )
space.c:   if( ship->shield > 0 )
space.c:      shield_dmg = UMIN( ship->shield, sdamage );
space.c:      sdamage -= shield_dmg;
space.c:      ship->shield -= shield_dmg;
space.c:      if( ship->shield == 0 )
space.c:      if( number_range( 1, 100 ) <= 5 && ship->shipstate != SHIP_DISABLED )
space.c:         ship->shipstate = SHIP_DISABLED;
space.c:      if( number_range( 1, 100 ) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Ships Missile Launcher DAMAGED!" );
space.c:         ship->missilestate = MISSILE_DAMAGED;
space.c:      if( number_range( 1, 100 ) <= 2 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret1 ), "Turret DAMAGED!" );
space.c:         ship->statet1 = LASER_DAMAGED;
space.c:      if( number_range( 1, 100 ) <= 2 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
space.c:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret2 ), "Turret DAMAGED!" );
space.c:         ship->statet2 = LASER_DAMAGED;
space.c:   ship->hull -= sdamage * 5;
space.c:   if( ship->hull <= 0 )
space.c:   if( ship->hull <= ship->maxhull / 20 )
space.c:   sprintf( buf, "%s explodes in a blinding flash of light!", ship->name );
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   for( roomnum = ship->firstroom; roomnum <= ship->lastroom; roomnum++ )
space.c:         rch = room->first_person;
space.c:            rch = room->first_person;
space.c:         for( robj = room->first_content; robj; robj = robj->next_content )
space.c:   LINK( ship, shipto->first_ship, shipto->last_ship, next_in_room, prev_in_room );
space.c:   ship->in_room = shipto;
space.c:   if( ( ship = ship_in_room( ch->in_room, argument ) ) == NULL )
space.c:   if( IS_SET( ch->act, ACT_MOUNTED ) )
space.c:   fromroom = ch->in_room;
space.c:   if( ( toroom = get_room_index( ship->entrance ) ) != NULL )
space.c:      if( !ship->hatchopen )
space.c:      if( toroom->tunnel > 0 )
space.c:         for( ctmp = toroom->first_person; ctmp; ctmp = ctmp->next_in_room )
space.c:            if( ++count >= toroom->tunnel )
space.c:      if( ship->shipstate == SHIP_LAUNCH || ship->shipstate == SHIP_LAUNCH_2 )
space.c:      act( AT_PLAIN, "$n enters $T.", ch, NULL, ship->name, TO_ROOM );
space.c:      act( AT_PLAIN, "You enter $T.", ch, NULL, ship->name, TO_CHAR );
space.c:   if( ch->gold < price )
space.c:   ch->gold -= price;
space.c:   fromroom = ch->in_room;
space.c:   if( ( ship = ship_from_entrance( fromroom->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->lastdoc != ship->location )
space.c:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c:   if( !ship->hatchopen )
space.c:   if( ( toroom = get_room_index( ship->location ) ) != NULL )
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->lastdoc != ship->location )
space.c:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c:         if( ship->ship_class == FIGHTER_SHIP )
space.c:         if( ship->ship_class == MIDSIZE_SHIP )
space.c:         if( ship->ship_class == CAPITAL_SHIP )
space.c:         price += ( ship->maxhull - ship->hull );
space.c:         if( ship->missiles )
space.c:            price += ( 50 * ( ship->maxmissiles - ship->missiles ) );
space.c:         else if( ship->torpedos )
space.c:            price += ( 75 * ( ship->maxtorpedos - ship->torpedos ) );
space.c:         else if( ship->rockets )
space.c:            price += ( 150 * ( ship->maxrockets - ship->rockets ) );
space.c:         if( ship->shipstate == SHIP_DISABLED )
space.c:         if( ship->missilestate == MISSILE_DAMAGED )
space.c:         if( ship->statet0 == LASER_DAMAGED )
space.c:         if( ship->statet1 == LASER_DAMAGED )
space.c:         if( ship->statet2 == LASER_DAMAGED )
space.c:      if( ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c:         if( ch->pcdata->clan->funds < price )
space.c:            ch_printf( ch, "&R%s doesn't have enough funds to prepare this ship for launch.\r\n", ch->pcdata->clan->name );
space.c:         ch->pcdata->clan->funds -= price;
space.c:         ch_printf( ch, "&GIt costs %s %ld credits to ready this ship for launch.\r\n", ch->pcdata->clan->name, price );
space.c:      else if( str_cmp( ship->owner, "Public" ) )
space.c:         if( ch->gold < price )
space.c:         ch->gold -= price;
space.c:      ship->energy = ship->maxenergy;
space.c:      ship->chaff = ship->maxchaff;
space.c:      ship->missiles = ship->maxmissiles;
space.c:      ship->torpedos = ship->maxtorpedos;
space.c:      ship->rockets = ship->maxrockets;
space.c:      ship->shield = 0;
space.c:      ship->autorecharge = FALSE;
space.c:      ship->autotrack = FALSE;
space.c:      ship->autospeed = FALSE;
space.c:      ship->hull = ship->maxhull;
space.c:      ship->missilestate = MISSILE_READY;
space.c:      ship->statet0 = LASER_READY;
space.c:      ship->statet1 = LASER_READY;
space.c:      ship->statet2 = LASER_READY;
space.c:      ship->shipstate = SHIP_DOCKED;
space.c:      if( ship->hatchopen )
space.c:         ship->hatchopen = FALSE;
space.c:         sprintf( buf, "The hatch on %s closes.", ship->name );
space.c:         echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
space.c:         sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:         sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:      sprintf( buf, "%s begins to launch.", ship->name );
space.c:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:      ship->shipstate = SHIP_LAUNCH;
space.c:      ship->currspeed = ship->realspeed;
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( ship->ship_class == MIDSIZE_SHIP )
space.c:      if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:   ship_to_starsystem( ship, starsystem_from_vnum( ship->location ) );
space.c:   if( ship->starsystem == NULL )
space.c:      echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Launch path blocked .. Launch aborted." );
space.c:      sprintf( buf, "%s slowly sets back down.", ship->name );
space.c:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:      ship->shipstate = SHIP_DOCKED;
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      sound_to_room( get_room_index( ship->location ), "!!SOUND(falcon)" );
space.c:   else if( ship->type == SHIP_IMPERIAL )
space.c:      sound_to_room( get_room_index( ship->location ), "!!SOUND(tie)" );
space.c:      sound_to_room( get_room_index( ship->location ), "!!SOUND(xwing)" );
space.c:   ship->location = 0;
space.c:   if( ship->shipstate != SHIP_DISABLED )
space.c:      ship->shipstate = SHIP_READY;
space.c:   plusminus = number_range( -1, 2 );
space.c:      ship->hx = 1;
space.c:      ship->hx = -1;
space.c:   plusminus = number_range( -1, 2 );
space.c:      ship->hy = 1;
space.c:      ship->hy = -1;
space.c:   if( ship->lastdoc == ship->starsystem->doc1a ||
space.c:       ship->lastdoc == ship->starsystem->doc1b || ship->lastdoc == ship->starsystem->doc1c )
space.c:      ship->vx = ship->starsystem->p1x;
space.c:      ship->vy = ship->starsystem->p1y;
space.c:   else if( ship->lastdoc == ship->starsystem->doc2a ||
space.c:            ship->lastdoc == ship->starsystem->doc2b || ship->lastdoc == ship->starsystem->doc2c )
space.c:      ship->vx = ship->starsystem->p2x;
space.c:      ship->vy = ship->starsystem->p2y;
space.c:   else if( ship->lastdoc == ship->starsystem->doc3a ||
space.c:            ship->lastdoc == ship->starsystem->doc3b || ship->lastdoc == ship->starsystem->doc3c )
space.c:      ship->vx = ship->starsystem->p3x;
space.c:      ship->vy = ship->starsystem->p3y;
space.c:      for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:         if( ship->lastdoc == target->hanger )
space.c:            ship->vx = target->vx;
space.c:            ship->vy = target->vy;
space.c:   ship->energy -= ( 100 + 100 * ship->ship_class );
space.c:   ship->vx += ( ship->hx * ship->currspeed * 2 );
space.c:   ship->vy += ( ship->hy * ship->currspeed * 2 );
space.c:   echo_to_room( AT_GREEN, get_room_index( ship->pilotseat ), "Launch complete.\r\n" );
space.c:   sprintf( buf, "%s enters the starsystem at %.0f %.0f", ship->name, ship->vx, ship->vy);
space.c:   sprintf( buf, "%s lifts off into space.", ship->name );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->lastdoc ), buf );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->shipstate != SHIP_READY )
space.c:   if( ship->starsystem == NULL )
space.c:   if( ship->energy < ( 25 + 25 * ship->ship_class ) )
space.c:      if( ship->starsystem->doc1a )
space.c:                    ship->starsystem->location1a,
space.c:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y);
space.c:      if( ship->starsystem->doc1b )
space.c:                    ship->starsystem->location1b,
space.c:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y );
space.c:      if( ship->starsystem->doc1c )
space.c:                    ship->starsystem->location1c,
space.c:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y);
space.c:      if( ship->starsystem->doc2a )
space.c:                    ship->starsystem->location2a,
space.c:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y );
space.c:      if( ship->starsystem->doc2b )
space.c:                    ship->starsystem->location2b,
space.c:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y);
space.c:      if( ship->starsystem->doc2c )
space.c:                    ship->starsystem->location2c,
space.c:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y);
space.c:      if( ship->starsystem->doc3a )
space.c:                    ship->starsystem->location3a,
space.c:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c:      if( ship->starsystem->doc3b )
space.c:                    ship->starsystem->location3b,
space.c:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c:      if( ship->starsystem->doc3c )
space.c:                    ship->starsystem->location3c,
space.c:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c:      for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:         if( target->hanger > 0 && target != ship )
space.c:            ch_printf( ch, "%s    %.0f %.0f\r\n         ", target->name, target->vx, target->vy);
space.c:      ch_printf( ch, "\r\nYour Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy);
space.c:   if( str_prefix( argument, ship->starsystem->location1a ) &&
space.c:       str_prefix( argument, ship->starsystem->location2a ) &&
space.c:       str_prefix( argument, ship->starsystem->location3a ) &&
space.c:       str_prefix( argument, ship->starsystem->location1b ) &&
space.c:       str_prefix( argument, ship->starsystem->location2b ) &&
space.c:       str_prefix( argument, ship->starsystem->location3b ) &&
space.c:       str_prefix( argument, ship->starsystem->location1c ) &&
space.c:       str_prefix( argument, ship->starsystem->location2c ) && str_prefix( argument, ship->starsystem->location3c ) )
space.c:      target = get_ship_here( argument, ship->starsystem );
space.c:      if( !target->hanger )
space.c:      if( ship->ship_class == MIDSIZE_SHIP && target->ship_class == MIDSIZE_SHIP )
space.c:      if( !target->bayopen )
space.c:      if( ( target->vx > ship->vx + 200 ) || ( target->vx < ship->vx - 200 ) ||
space.c:          ( target->vy > ship->vy + 200 ) || ( target->vy < ship->vy - 200 ) )
space.c:      if( !str_prefix( argument, ship->starsystem->location3a ) ||
space.c:          !str_prefix( argument, ship->starsystem->location3b ) || !str_prefix( argument, ship->starsystem->location3c ) )
space.c:         vx = ship->starsystem->p3x;
space.c:         vy = ship->starsystem->p3y;
space.c:      if( !str_prefix( argument, ship->starsystem->location2a ) ||
space.c:          !str_prefix( argument, ship->starsystem->location2b ) || !str_prefix( argument, ship->starsystem->location2c ) )
space.c:         vx = ship->starsystem->p2x;
space.c:         vy = ship->starsystem->p2y;
space.c:      if( !str_prefix( argument, ship->starsystem->location1a ) ||
space.c:          !str_prefix( argument, ship->starsystem->location1b ) || !str_prefix( argument, ship->starsystem->location1c ) )
space.c:         vx = ship->starsystem->p1x;
space.c:         vy = ship->starsystem->p1y;
space.c:      if( ( vx > ship->vx + 200 ) || ( vx < ship->vx - 200 ) ||
space.c:          ( vy > ship->vy + 200 ) || ( vy < ship->vy - 200 ) )
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c:      if(ship->track0 != NULL)
space.c:	    ship->track0 = NULL;
space.c:      ship->dest = STRALLOC( arg );
space.c:      ship->shipstate = SHIP_LAND;
space.c:      ship->currspeed = 0;
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( ship->ship_class == MIDSIZE_SHIP )
space.c:      if( starsystem_from_vnum( ship->lastdoc ) != ship->starsystem )
space.c:         int xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) );
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   if( !str_prefix( arg, ship->starsystem->location3a ) )
space.c:      destination = ship->starsystem->doc3a;
space.c:   if( !str_prefix( arg, ship->starsystem->location3b ) )
space.c:      destination = ship->starsystem->doc3b;
space.c:   if( !str_prefix( arg, ship->starsystem->location3c ) )
space.c:      destination = ship->starsystem->doc3c;
space.c:   if( !str_prefix( arg, ship->starsystem->location2a ) )
space.c:      destination = ship->starsystem->doc2a;
space.c:   if( !str_prefix( arg, ship->starsystem->location2b ) )
space.c:      destination = ship->starsystem->doc2b;
space.c:   if( !str_prefix( arg, ship->starsystem->location2c ) )
space.c:      destination = ship->starsystem->doc2c;
space.c:   if( !str_prefix( arg, ship->starsystem->location1a ) )
space.c:      destination = ship->starsystem->doc1a;
space.c:   if( !str_prefix( arg, ship->starsystem->location1b ) )
space.c:      destination = ship->starsystem->doc1b;
space.c:   if( !str_prefix( arg, ship->starsystem->location1c ) )
space.c:      destination = ship->starsystem->doc1c;
space.c:   target = get_ship_here( arg, ship->starsystem );
space.c:   if( target != ship && target != NULL && target->bayopen
space.c:       && ( ship->ship_class != MIDSIZE_SHIP || target->ship_class != MIDSIZE_SHIP ) )
space.c:      destination = target->hanger;
space.c:      echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Could not complete aproach. Landing aborted." );
space.c:      if( ship->shipstate != SHIP_DISABLED )
space.c:         ship->shipstate = SHIP_READY;
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Landing sequence complete." );
space.c:   sprintf( buf, "%s disapears from your scanner.", ship->name );
space.c:   ship->location = destination;
space.c:   ship->lastdoc = ship->location;
space.c:   if( ship->shipstate != SHIP_DISABLED )
space.c:      ship->shipstate = SHIP_DOCKED;
space.c:   ship_from_starsystem( ship, ship->starsystem );
space.c:   sprintf( buf, "%s lands on the platform.", ship->name );
space.c:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:   ship->energy = ship->energy - 25 - 25 * ship->ship_class;
space.c:   if( !str_cmp( "Public", ship->owner ) )
space.c:      ship->energy = ship->maxenergy;
space.c:      ship->chaff = ship->maxchaff;
space.c:      ship->missiles = ship->maxmissiles;
space.c:      ship->torpedos = ship->maxtorpedos;
space.c:      ship->rockets = ship->maxrockets;
space.c:      ship->shield = 0;
space.c:      ship->autorecharge = FALSE;
space.c:      ship->autotrack = FALSE;
space.c:      ship->autospeed = FALSE;
space.c:      ship->track0 = NULL;
space.c:      ship->heading = 0;
space.c:      ship->prevheading = 0;
space.c:      ship->turnarc = 0;
space.c:      ship->hull = ship->maxhull;
space.c:      ship->flightflags = 0;
space.c:      ship->missilestate = MISSILE_READY;
space.c:      ship->statet0 = LASER_READY;
space.c:      ship->statet1 = LASER_READY;
space.c:      ship->statet2 = LASER_READY;
space.c:      ship->shipstate = SHIP_DOCKED;
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->energy < abs( ( atoi( argument ) - abs( ship->currspeed ) ) / 10 ) )
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( ship->ship_class == MIDSIZE_SHIP )
space.c:      if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( change > ship->currspeed )
space.c:      sprintf( buf, "%s begins to speed up.", ship->name );
space.c:   if( change < ship->currspeed )
space.c:      sprintf( buf, "%s begins to slow down.", ship->name );
space.c:   ship->energy -= abs( ( change - abs( ship->currspeed ) ) / 10 );
space.c:   ship->currspeed = URANGE( 0, change, ship->realspeed );
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->shipstate != SHIP_READY )
space.c:   if( ship->energy < ( ship->currspeed / 10 ) )
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( ship->ship_class == MIDSIZE_SHIP )
space.c:      if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( vx == ship->vx && vy == ship->vy )
space.c:   ship->hx = vx - ship->vx;
space.c:   ship->hy = vy - ship->vy;
space.c:   ship->heading = coordpairtoheading(ship->vx,ship->vy,vx,vy);
space.c:   ship->energy -= ( ship->currspeed / 10 );
space.c:   ch_printf( ch, "&GNew course set aproaching %.0f %.0f, heading %0.f degrees.\r\n", vx, vy,radianstodegrees(ship->heading));
space.c:   sprintf( buf, "%s turns altering its present course.", ship->name );
space.c:   if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c:      ship->shipstate = SHIP_BUSY_3;
space.c:   else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c:      ship->shipstate = SHIP_BUSY_2;
space.c:      ship->shipstate = SHIP_BUSY;
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( IS_NPC( ch ) || !ch->pcdata )
space.c:   ship = ship_in_room( ch->in_room, argument );
space.c:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c:   if( str_cmp( ship->owner, "" ) || ship->type == MOB_SHIP )
space.c:   if( ship->type == SHIP_IMPERIAL )
space.c:      if( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name, "the empire" ) )
space.c:         if( !ch->pcdata->clan || !ch->pcdata->clan->mainclan || str_cmp( ch->pcdata->clan->mainclan->name, "The Empire" ) )
space.c:   else if( ship->type == SHIP_REPUBLIC )
space.c:      if( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name, "the new republic" ) )
space.c:         if( !ch->pcdata->clan || !ch->pcdata->clan->mainclan
space.c:             || str_cmp( ch->pcdata->clan->mainclan->name, "The New Republic" ) )
space.c:      if( ch->pcdata->clan &&
space.c:          ( !str_cmp( ch->pcdata->clan->name, "the new republic" ) ||
space.c:            ( ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, "the new republic" ) ) ) )
space.c:      if( ch->pcdata->clan &&
space.c:          ( !str_cmp( ch->pcdata->clan->name, "the empire" ) ||
space.c:            ( ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, "the empire" ) ) ) )
space.c:   if( ch->gold < price )
space.c:   ch->gold -= price;
space.c:   STRFREE( ship->owner );
space.c:   ship->owner = STRALLOC( ch->name );
space.c:   if( IS_NPC( ch ) || !ch->pcdata )
space.c:   if( !ch->pcdata->clan )
space.c:   clan = ch->pcdata->clan;
space.c:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
space.c:   if( ( ch->pcdata->bestowments
space.c:         && is_name( "clanbuyship", ch->pcdata->bestowments ) ) || !str_cmp( ch->name, clan->leader ) )
space.c:   ship = ship_in_room( ch->in_room, argument );
space.c:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c:   if( str_cmp( ship->owner, "" ) || ship->type == MOB_SHIP )
space.c:   if( str_cmp( mainclan->name, "The Empire" ) && ship->type == SHIP_IMPERIAL )
space.c:   if( str_cmp( mainclan->name, "The New Republic" ) && ship->type == SHIP_REPUBLIC )
space.c:   if( !str_cmp( mainclan->name, "The Empire" ) && ship->type != SHIP_IMPERIAL )
space.c:   if( !str_cmp( mainclan->name, "The New Republic" ) && ship->type != SHIP_REPUBLIC )
space.c:   if( ch->pcdata->clan->funds < price )
space.c:   clan->funds -= price;
space.c:   ch_printf( ch, "&G%s pays %ld credits to purchace the ship.\r\n", clan->name, price );
space.c:   STRFREE( ship->owner );
space.c:   ship->owner = STRALLOC( clan->name );
space.c:   if( ship->ship_class <= SHIP_PLATFORM )
space.c:      clan->spacecraft++;
space.c:      clan->vehicles++;
space.c:   ship = ship_in_room( ch->in_room, argument );
space.c:   if( str_cmp( ship->owner, ch->name ) )
space.c:   ch->gold += ( price - price / 10 );
space.c:   ch_printf( ch, "&GYou receive %ld credits from selling your ship.\r\n", price - price / 10 );
space.c:   STRFREE( ship->owner );
space.c:   ship->owner = STRALLOC( "" );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:      ship = ship_in_room( ch->in_room, argument );
space.c:      target = get_ship_here( argument, ship->starsystem );
space.c:   if( abs( ( int )( target->vx - ship->vx ) ) > 500 + ship->sensor * 2
space.c:       || abs( ( int )( target->vy - ship->vy ) ) > 500 + ship->sensor * 2)
space.c:              target->type == SHIP_REPUBLIC ? "New Republic" :
space.c:              ( target->type == SHIP_IMPERIAL ? "Imperial" : "Civilian" ),
space.c:              target->ship_class == FIGHTER_SHIP ? "Starfighter" :
space.c:              ( target->ship_class == MIDSIZE_SHIP ? "Midtarget" :
space.c:                ( target->ship_class == CAPITAL_SHIP ? "Capital Ship" :
space.c:                  ( ship->ship_class == SHIP_PLATFORM ? "Platform" :
space.c:                    ( ship->ship_class == CLOUD_CAR ? "Cloudcar" :
space.c:                      ( ship->ship_class == OCEAN_SHIP ? "Boat" :
space.c:                        ( ship->ship_class == LAND_SPEEDER ? "Speeder" :
space.c:                          ( ship->ship_class == WHEELED ? "Wheeled Transport" :
space.c:                            ( ship->ship_class == LAND_CRAWLER ? "Crawler" :
space.c:                              ( ship->ship_class == WALKER ? "Walker" : "Unknown" ) ) ) ) ) ) ) ) ),
space.c:              target->name, target->filename );
space.c:              target->description, target->owner, target->pilot, target->copilot );
space.c:   ch_printf( ch, "Laser cannons: %d  ", target->lasers );
space.c:   ch_printf( ch, "Maximum Missiles: %d  ", target->maxmissiles );
space.c:   ch_printf( ch, "Max Chaff: %d\r\n", target->maxchaff );
space.c:   ch_printf( ch, "Max Hull: %d  ", target->maxhull );
space.c:   ch_printf( ch, "Max Shields: %d   Max Energy(fuel): %d\r\n", target->maxshield, target->maxenergy );
space.c:   ch_printf( ch, "Maximum Speed: %d   Hyperspeed: %d\r\n", target->realspeed, target->hyperspeed );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c:      send_to_char( "&RYou must be in the co-pilots seat!\r\n", ch );
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c:      ship->autorecharge = TRUE;
space.c:      ship->autorecharge = FALSE;
space.c:      ship->shield = 0;
space.c:      ship->autorecharge = FALSE;
space.c:      if( ship->autorecharge == TRUE )
space.c:         ship->autorecharge = FALSE;
space.c:         ship->autorecharge = TRUE;
space.c:   if( ship->autorecharge )
space.c:      recharge = URANGE( 1, ship->maxshield - ship->shield, 25 + ship->ship_class * 25 );
space.c:      recharge = UMIN( recharge, ship->energy * 5 + 100 );
space.c:      ship->shield += recharge;
space.c:      ship->energy -= ( recharge * 2 + recharge * ship->ship_class );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->target0 || ship->target1 || ship->target2 )
space.c:   if( ship->autopilot == TRUE )
space.c:      ship->autopilot = FALSE;
space.c:      ship->autopilot = TRUE;
space.c:      ship->autorecharge = TRUE;
space.c:      ship = ship_from_entrance( ch->in_room->vnum );
space.c:         if( !ship->hatchopen )
space.c:            if( ship->ship_class == SHIP_PLATFORM )
space.c:            if( ship->location != ship->lastdoc || ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED ) )
space.c:            ship->hatchopen = TRUE;
space.c:            sprintf( buf, "The hatch on %s opens.", ship->name );
space.c:            echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:            sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:            sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:   ship = ship_in_room( ch->in_room, argument );
space.c:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c:   if( !ship->hatchopen )
space.c:      ship->hatchopen = TRUE;
space.c:      act( AT_PLAIN, "You open the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
space.c:      act( AT_PLAIN, "$n opens the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
space.c:      echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch opens from the outside." );
space.c:      sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:      sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:      ship = ship_from_entrance( ch->in_room->vnum );
space.c:         if( ship->ship_class == SHIP_PLATFORM )
space.c:         if( ship->hatchopen )
space.c:            ship->hatchopen = FALSE;
space.c:            sprintf( buf, "The hatch on %s closes.", ship->name );
space.c:            echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c:            sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:            sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:   ship = ship_in_room( ch->in_room, argument );
space.c:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c:      if( ship->hatchopen )
space.c:         ship->hatchopen = FALSE;
space.c:         act( AT_PLAIN, "You close the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
space.c:         act( AT_PLAIN, "$n closes the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
space.c:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch is closed from outside." );
space.c:         sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c:         sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL || ch->in_room->vnum == ship->engineroom )
space.c:	if( ch->piloting != NULL && ch->piloting == ship)
space.c:		ch->piloting = NULL;
space.c:   	if( ch->in_room->vnum == ship->gunseat )
space.c:		if( ship->gunpilotch != ch && ship->gunpilotch != NULL)
space.c:			ship->gunpilotch = newpilot;
space.c:   	if( ch->in_room->vnum == ship->navseat )
space.c:		if( ship->navpilotch != ch && ship->navpilotch != NULL)
space.c:			ship->navpilotch = newpilot;
space.c:   	if( ch->in_room->vnum == ship->coseat )
space.c:		if( ship->copilotch != ch && ship->copilotch != NULL)
space.c:			ship->copilotch = newpilot;
space.c:   	if( ch->in_room->vnum == ship->pilotseat )
space.c:		if( ship->pilotpilotch != ch && ship->pilotpilotch != NULL)
space.c:			ship->pilotpilotch = newpilot;
space.c:		ch->piloting = ship;
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:      target = get_ship_here( argument, ship->starsystem );
space.c:   if( abs( ( int )( target->vx - ship->vx ) ) > 500 + ship->sensor * 2
space.c:       || abs( ( int )( target->vy - ship->vy ) ) > 500 + ship->sensor * 2)
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c:   ch_printf( ch, "&W%s:\r\n", target->name );
space.c:   ch_printf( ch, "&OCurrent Coordinates:&Y %.0f %.0f\r\n", target->vx, target->vy);
space.c:   ch_printf( ch, "&OCurrent Heading:&Y %.0f %.0f\r\n", target->hx, target->hy);
space.c:   ch_printf( ch, "&OCurrent Heading in Radians: &Y %0.f\r\n", ship->heading);
space.c:   ch_printf( ch, "&OCurrent Heading in Degrees: &Y %0.2f\r\n", radianstodegrees(ship->heading));
space.c:   ch_printf( ch, "&OCurrent Speed:&Y %d&O/%d\r\n", target->currspeed, target->realspeed );
space.c:              target->hull, target->maxhull, target->shipstate == SHIP_DISABLED ? "Disabled" : "Running" );
space.c:              target->shield, target->maxshield, target->energy, target->maxenergy );
space.c:              target->statet0 == LASER_DAMAGED ? "Damaged" : "Good", target->target0 ? target->target0->name : "none" );
space.c:   if( target->turret1 )
space.c:                 target->statet1 == LASER_DAMAGED ? "Damaged" : "Good", target->target1 ? target->target1->name : "none" );
space.c:   if( target->turret2 )
space.c:                 target->statet2 == LASER_DAMAGED ? "Damaged" : "Good", target->target2 ? target->target2->name : "none" );
space.c:              ship->missiles,
space.c:              ship->maxmissiles,
space.c:              ship->torpedos,
space.c:              ship->maxtorpedos,
space.c:              ship->rockets, ship->maxrockets, ship->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good" );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->hyperspeed == 0 )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->shipstate != SHIP_READY )
space.c:   if( !ship->currjump )
space.c:   if( ship->energy < ( 200 + ship->hyperdistance * ( 1 + ship->ship_class ) / 3 ) )
space.c:   if( ship->currspeed <= 0 )
space.c:   for( eShip = ship->starsystem->first_ship; eShip; eShip = eShip->next_in_starsystem )
space.c:         ch_printf( ch, "&RYou are too close to %s to make the jump to lightspeed.\r\n", eShip->name );
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c:      if( ship->ship_class == FIGHTER_SHIP )
space.c:      if( ship->ship_class == MIDSIZE_SHIP )
space.c:      if( ship->ship_class == CAPITAL_SHIP )
space.c:   sprintf( buf, "%s disapears from your scanner.", ship->name );
space.c:   ship_from_starsystem( ship, ship->starsystem );
space.c:   ship->shipstate = SHIP_HYPERSPACE;
space.c:   ship->energy -= ( 100 + ship->hyperdistance * ( 1 + ship->ship_class ) / 3 );
space.c:   ship->vx = ship->jx;
space.c:   ship->vy = ship->jy;
space.c:   if( ship->ship_class == FIGHTER_SHIP )
space.c:   if( ship->ship_class == MIDSIZE_SHIP )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:	if( ship->ship_class > SHIP_PLATFORM )
space.c:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c:	if( !ship->starsystem )
space.c:         if( ship->ship_class > SHIP_PLATFORM )
space.c:        if( ship->shipstate != SHIP_READY)
space.c:	    REMOVE_BIT(ship->flightflags,SHIP_TRACKINGRADAR);
space.c:	    ship->track0 = NULL;
space.c:	if(!IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c:	SET_BIT(ship->flightflags,SHIP_TRACKINGRADAR);
space.c:		 target = get_ship_here( arg, ship->starsystem );
space.c:		if(targetbearing > PI/4 || targetbearing < -PI/4)
space.c:		    send_to_char( "&RThat ship needs to be infront of you! (within -45 to 45 bearing)\r\n", ch );
space.c:		if(ship->turnarc != 0 && ship->track0 == NULL)
space.c:	    		echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c:		 	sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c:			ship->turnarc = 0;
space.c:		ship->track0 = target;
space.c:   switch ( ch->substate )
space.c:         if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c:         if( ship->ship_class > SHIP_PLATFORM )
space.c:         if( ship->shipstate == SHIP_HYPERSPACE )
space.c:         if( !ship->starsystem )
space.c:            if( ch->in_room->vnum == ship->gunseat )
space.c:               ship->target0 = NULL;
space.c:            if( ch->in_room->vnum == ship->turret1 )
space.c:               ship->target1 = NULL;
space.c:            if( ch->in_room->vnum == ship->turret2 )
space.c:               ship->target2 = NULL;
space.c:         target = get_ship_here( arg, ship->starsystem );
space.c:         if( !str_cmp( target->owner, ship->owner ) && str_cmp( target->owner, "" ) )
space.c:         if( abs( ( int )( ship->vx - target->vx ) ) > 5000
space.c:	     || abs( ( int )( ship->vy - target->vy ) ) > 5000)
space.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_weaponsystems] );
space.c:            ch->dest_buf = str_dup( arg );
space.c:         if( !ch->dest_buf )
space.c:         strcpy( arg, ( const char* ) ch->dest_buf );
space.c:         DISPOSE( ch->dest_buf );
space.c:         DISPOSE( ch->dest_buf );
space.c:         ch->substate = SUB_NONE;
space.c:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   ch->substate = SUB_NONE;
space.c:   if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c:   target = get_ship_here( arg, ship->starsystem );
space.c:   if( ch->in_room->vnum == ship->gunseat )
space.c:      ship->target0 = target;
space.c:   if( ch->in_room->vnum == ship->turret1 )
space.c:      ship->target1 = target;
space.c:   if( ch->in_room->vnum == ship->turret2 )
space.c:      ship->target2 = target;
space.c:   sprintf( buf, "You are being targetted by %s.", ship->name );
space.c:   sound_to_room( ch->in_room, "!!SOUND(targetlock)" );
space.c:   if( autofly( target ) && !target->target0 )
space.c:      sprintf( buf, "You are being targetted by %s.", target->name );
space.c:      target->target0 = ship;
space.c:   if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c:   if( ch->piloting == NULL || ch->piloting != ship || ship->gunpilotch != ch )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->starsystem == NULL )
space.c:   if( ship->energy < 5 )
space.c:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "lasers" ) )
space.c:      if( ship->statet0 == LASER_DAMAGED )
space.c:      if( ship->statet0 >= ship->lasers )
space.c:      ship->statet0++;
space.c:	for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c:			theta = atan( ((double)(target->ship_class+0.35))/range)*2;
space.c:				sprintf( buf, "Laserfire from %s hits %s.", ship->name, target->name );
space.c:				sprintf( buf, "You are hit by lasers from %s!", ship->name );
space.c:				sprintf( buf, "Your ships lasers hit %s!.", target->name );
space.c:				sprintf( buf, "Laserfire from %s barely misses %s.", ship->name, target->name );
space.c:				sprintf( buf, "Laserfire from %s barely misses you!", ship->name );
space.c:				sprintf( buf, "Your ships very nearly hit %s!.", target->name );
space.c:				sprintf( buf, "Laserfire from %s nearly hits %s.", ship->name, target->name );
space.c:				sprintf( buf, "Laserfire from %s nearly hits you!", ship->name );
space.c:				sprintf( buf, "Your ships very nearly hit %s!.", target->name );
space.c:		sprintf( buf, "%s fires its lasers out into empty space", ship->name );
space.c:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "missile" ) )
space.c:      if( ship->missilestate == MISSILE_DAMAGED )
space.c:      if( ship->missiles <= 0 )
space.c:      if( ship->missilestate != MISSILE_READY )
space.c:	for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c:			theta = atan( ((double)(target->ship_class+0.25*10))/range)*2;
space.c:			        sprintf( buf, "%s fires a missile towards %s.", ship->name, target->name );
space.c:				sprintf( buf, "%s fires a missile at you!", ship->name );
space.c:				sprintf( buf, "You fire a missile at %s!.", target->name );
space.c:				sprintf( buf, "%s fires a missile, it looks like it could hit %s!", ship->name, target->name );
space.c:				sprintf( buf, "%s fires a missile in your direction, it looks like it could hit you!", ship->name );
space.c:				sprintf( buf, "You fire a missile in the direction of %s, it looks like it could hit them!!.", target->name );
space.c:				sprintf( buf, "%s fires a missile in %s's general direction.", ship->name, target->name );
space.c:				sprintf( buf, "%s fires a missile kind of in your direction!", ship->name );
space.c:				sprintf( buf, "You fire a missile at %s, but it's not quite on target!.", target->name );
space.c:		sprintf( buf, "%s fires a missile out into empty space", ship->name );
space.c:      ship->missiles--;
space.c:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c:         ship->missilestate = MISSILE_RELOAD;
space.c:         ship->missilestate = MISSILE_FIRED;
space.c:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "torpedo" ) )
space.c:      if( ship->missilestate == MISSILE_DAMAGED )
space.c:      if( ship->torpedos <= 0 )
space.c:      if( ship->missilestate != MISSILE_READY )
space.c:      if( ship->target0 == NULL )
space.c:      target = ship->target0;
space.c:      if( ship->target0->starsystem != ship->starsystem )
space.c:         ship->target0 = NULL;
space.c:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c:      if( ship->ship_class < 2 && !is_facing( ship, target ) )
space.c:      schance -= target->manuever / 5;
space.c:      schance -= target->currspeed / 20;
space.c:      schance += target->ship_class * target->ship_class * 25;
space.c:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c:         ship->missilestate = MISSILE_RELOAD_2;
space.c:      ship->torpedos--;
space.c:      sprintf( buf, "Incoming torpedo from %s.", ship->name );
space.c:      sprintf( buf, "%s fires a torpedo towards %s.", ship->name, target->name );
space.c:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c:         ship->missilestate = MISSILE_RELOAD;
space.c:         ship->missilestate = MISSILE_FIRED;
space.c:      if( autofly( target ) && target->target0 != ship )
space.c:         target->target0 = ship;
space.c:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "rocket" ) )
space.c:      if( ship->missilestate == MISSILE_DAMAGED )
space.c:      if( ship->rockets <= 0 )
space.c:      if( ship->missilestate != MISSILE_READY )
space.c:      if( ship->target0 == NULL )
space.c:      target = ship->target0;
space.c:      if( ship->target0->starsystem != ship->starsystem )
space.c:         ship->target0 = NULL;
space.c:      if( abs( ( int )( target->vx - ship->vx ) ) > 800
space.c:	  || abs( ( int )( target->vy - ship->vy ) ) > 800)
space.c:      if( ship->ship_class < 2 && !is_facing( ship, target ) )
space.c:      schance -= target->manuever / 5;
space.c:      schance -= target->currspeed / 20;
space.c:      schance += target->ship_class * target->ship_class * 25;
space.c:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c:      schance -= 30;
space.c:         ship->missilestate = MISSILE_RELOAD_2;
space.c:      ship->rockets--;
space.c:      sprintf( buf, "Incoming rocket from %s.", ship->name );
space.c:      sprintf( buf, "%s fires a heavy rocket towards %s.", ship->name, target->name );
space.c:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c:         ship->missilestate = MISSILE_RELOAD;
space.c:         ship->missilestate = MISSILE_FIRED;
space.c:      if( autofly( target ) && target->target0 != ship )
space.c:         target->target0 = ship;
space.c:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c:   if( ch->in_room->vnum == ship->turret1 && !str_prefix( argument, "lasers" ) )
space.c:      if( ship->statet1 == LASER_DAMAGED )
space.c:      if( ship->statet1 > ship->ship_class )
space.c:      if( ship->target1 == NULL )
space.c:      target = ship->target1;
space.c:      if( ship->target1->starsystem != ship->starsystem )
space.c:         ship->target1 = NULL;
space.c:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c:      ship->statet1++;
space.c:      schance -= target->manuever / 10;
space.c:      schance += target->ship_class * 25;
space.c:      schance -= target->currspeed / 20;
space.c:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c:         sprintf( buf, "Turbolasers fire from %s at you but miss.", ship->name );
space.c:         sprintf( buf, "Turbolasers fire from the ships turret at %s but miss.", target->name );
space.c:         sprintf( buf, "%s fires at %s but misses.", ship->name, target->name );
space.c:      sprintf( buf, "Turboasers fire from %s, hitting %s.", ship->name, target->name );
space.c:      sprintf( buf, "You are hit by turbolasers from %s!", ship->name );
space.c:      sprintf( buf, "Turbolasers fire from the turret, hitting %s!.", target->name );
space.c:      if( autofly( target ) && target->target0 != ship )
space.c:         target->target0 = ship;
space.c:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c:   if( ch->in_room->vnum == ship->turret2 && !str_prefix( argument, "lasers" ) )
space.c:      if( ship->statet2 == LASER_DAMAGED )
space.c:      if( ship->statet2 > ship->ship_class )
space.c:      if( ship->target2 == NULL )
space.c:      target = ship->target2;
space.c:      if( ship->target2->starsystem != ship->starsystem )
space.c:         ship->target2 = NULL;
space.c:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c:      ship->statet2++;
space.c:      schance -= target->manuever / 10;
space.c:      schance += target->ship_class * 25;
space.c:      schance -= target->currspeed / 20;
space.c:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c:         sprintf( buf, "Turbolasers fire from %s barely missing %s.", ship->name, target->name );
space.c:         sprintf( buf, "Turbolasers fire from %s at you but miss.", ship->name );
space.c:         sprintf( buf, "Turbolasers fire from the turret missing %s.", target->name );
space.c:      sprintf( buf, "Turbolasers fire from %s, hitting %s.", ship->name, target->name );
space.c:      sprintf( buf, "You are hit by turbolasers from %s!", ship->name );
space.c:      sprintf( buf, "turbolasers fire from the turret hitting %s!.", target->name );
space.c:      if( autofly( target ) && target->target0 != ship )
space.c:         target->target0 = ship;
space.c:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_navseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->hyperspeed == 0 )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->starsystem == NULL )
space.c:      for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c:         ch_printf( ch, "%-30s %d\r\n", starsystem->name,
space.c:                    ( abs( starsystem->xpos - ship->starsystem->xpos ) +
space.c:                      abs( starsystem->ypos - ship->starsystem->ypos ) ) / 2 );
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_navigation] );
space.c:   ship->currjump = starsystem_from_name( arg1 );
space.c:   ship->jx = atoi( arg2 );
space.c:   ship->jy = atoi( argument );
space.c:   if( ship->currjump == NULL )
space.c:      starsystem2 = ship->currjump;
space.c:      if( starsystem2->star1 && strcmp( starsystem2->star1, "" )
space.c:	  && abs( ( int )( ship->jx - starsystem2->s1x ) ) < 300
space.c:	  && abs( ( int )( ship->jy - starsystem2->s1y ) ) < 300)
space.c:         ship->currjump = NULL;
space.c:      else if( starsystem2->star2 && strcmp( starsystem2->star2, "" )
space.c:	       && abs( ( int )( ship->jx - starsystem2->s2x ) ) < 300
space.c:	       && abs( ( int )( ship->jy - starsystem2->s2y ) ) < 300)
space.c:         ship->currjump = NULL;
space.c:      else if( starsystem2->planet1 && strcmp( starsystem2->planet1, "" )
space.c:	       && abs( ( int )( ship->jx - starsystem2->p1x ) ) < 300
space.c:	       && abs( ( int )( ship->jy - starsystem2->p1y ) ) < 300)
space.c:         ship->currjump = NULL;
space.c:      else if( starsystem2->planet2 && strcmp( starsystem2->planet2, "" )
space.c:	       && abs( ( int )( ship->jx - starsystem2->p2x ) ) < 300
space.c:	       && abs( ( int )( ship->jy - starsystem2->p2y ) ) < 300)
space.c:         ship->currjump = NULL;
space.c:      else if( starsystem2->planet3 && strcmp( starsystem2->planet3, "" )
space.c:	       && abs( ( int )( ship->jx - starsystem2->p3x ) ) < 300
space.c:	       && abs( ( int )( ship->jy - starsystem2->p3y ) ) < 300)
space.c:         ship->currjump = NULL;
space.c:         ship->jx += number_range( -250, 250 );
space.c:         ship->jy += number_range( -250, 250 );
space.c:   ship->hyperdistance = abs( ship->starsystem->xpos - ship->currjump->xpos );
space.c:   ship->hyperdistance += abs( ship->starsystem->ypos - ship->currjump->ypos );
space.c:   ship->hyperdistance /= 5;
space.c:   if( ship->hyperdistance < 100 )
space.c:      ship->hyperdistance = 100;
space.c:   ship->hyperdistance += number_range( 0, 200 );
space.c:   sound_to_room( ch->in_room, "!!SOUND(computer)" );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c:      send_to_char( "&RThe controls must be at the co-pilot station.\r\n", ch );
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->energy < 100 )
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c:   recharge = UMIN( ship->maxshield - ship->shield, ship->energy * 5 + 100 );
space.c:   recharge = URANGE( 1, recharge, 25 + ship->ship_class * 25 );
space.c:   ship->shield += recharge;
space.c:   ship->energy -= ( recharge * 2 + recharge * ship->ship_class );
space.c:   switch ( ch->substate )
space.c:         if( ( ship = ship_from_engine( ch->in_room->vnum ) ) == NULL )
space.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipmaintenance] );
space.c:            ch->dest_buf = str_dup( arg );
space.c:         if( !ch->dest_buf )
space.c:         strcpy( arg, ( const char* ) ch->dest_buf );
space.c:         DISPOSE( ch->dest_buf );
space.c:         DISPOSE( ch->dest_buf );
space.c:         ch->substate = SUB_NONE;
space.c:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   ch->substate = SUB_NONE;
space.c:   if( ( ship = ship_from_engine( ch->in_room->vnum ) ) == NULL )
space.c:                       number_range( ( int )( ch->pcdata->learned[gsn_shipmaintenance] / 2 ),
space.c:                                     ( int )( ch->pcdata->learned[gsn_shipmaintenance] ) ), ( ship->maxhull - ship->hull ) );
space.c:      ship->hull += change;
space.c:      if( ship->location == ship->lastdoc )
space.c:         ship->shipstate = SHIP_DOCKED;
space.c:         ship->shipstate = SHIP_READY;
space.c:      ship->missilestate = MISSILE_READY;
space.c:      ship->statet0 = LASER_READY;
space.c:      ship->statet1 = LASER_READY;
space.c:      ship->statet2 = LASER_READY;
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( str_cmp( ship->owner, ch->name ) )
space.c:      if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c:         else if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c:         else if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c:   if( str_cmp( ship->pilot, "" ) )
space.c:      if( str_cmp( ship->copilot, "" ) )
space.c:      STRFREE( ship->copilot );
space.c:      ship->copilot = STRALLOC( argument );
space.c:   STRFREE( ship->pilot );
space.c:   ship->pilot = STRALLOC( argument );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( str_cmp( ship->owner, ch->name ) )
space.c:      if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c:         else if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c:         else if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c:   if( !str_cmp( ship->pilot, argument ) )
space.c:      STRFREE( ship->pilot );
space.c:      ship->pilot = STRALLOC( "" );
space.c:   if( !str_cmp( ship->copilot, argument ) )
space.c:      STRFREE( ship->copilot );
space.c:      ship->copilot = STRALLOC( "" );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->starsystem == NULL )
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_navigation] );
space.c:   ch_printf( ch, "%s\r\n\r\n", ship->starsystem->name );
space.c:   if( ship->starsystem->star1 && str_cmp( ship->starsystem->star1, "" ) )
space.c:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y);
space.c:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y));
space.c:                 ship->starsystem->star1, ship->starsystem->s1x, ship->starsystem->s1y,range,bearing);
space.c:   if( ship->starsystem->star2 && str_cmp( ship->starsystem->star2, "" ) )
space.c:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y);
space.c:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y));
space.c:                 ship->starsystem->star2, ship->starsystem->s2x, ship->starsystem->s2y,range,bearing);
space.c:   if( ship->starsystem->planet1 && str_cmp( ship->starsystem->planet1, "" ) )
space.c:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y);
space.c:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y));
space.c:                 ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y,range,bearing);
space.c:   if( ship->starsystem->planet2 && str_cmp( ship->starsystem->planet2, "" ) )
space.c:                 ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y );
space.c:   if( ship->starsystem->planet3 && str_cmp( ship->starsystem->planet3, "" ) )
space.c:                 ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c:   for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c:	range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c:	bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));
space.c:		 target->name, target->vx, target->vy, range,bearing,
space.c:		 target->currspeed,(ship->target0 == target ? "&R[YOUR TARGET]&z" : ""),(target->target0 == ship ? "&R[TARGETTING YOU]&z" : "")  );
space.c:   for( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
space.c:	range = sqrt(pow(ship->vx-missile->mx,2)+pow(ship->vy-missile->my,2) );
space.c:                 missile->missiletype == CONCUSSION_MISSILE ? "A Concusion missile" :
space.c:                 ( missile->missiletype == PROTON_TORPEDO ? "A Torpedo" :
space.c:                   ( missile->missiletype == HEAVY_ROCKET ? "A Heavy Rocket" : "A Heavy Bomb" ) ),
space.c:                 missile->mx, missile->my, range,radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,missile->mx,missile->my)));
space.c:   ch_printf( ch, "\r\n&WYour Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy );
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ship->ship_class == SHIP_PLATFORM )
space.c:   if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c:   if( ship->autotrack )
space.c:      ship->autotrack = FALSE;
space.c:      ship->autotrack = TRUE;
space.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c:      if( obj->pIndexData->item_type == ITEM_COMLINK )
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class < LAND_SPEEDER )
space.c:   if( ship->shipstate == SHIP_DISABLED )
space.c:   if( ship->energy < 1 )
space.c:   if( ( dir = get_door( argument ) ) == -1 )
space.c:   drive_ship( ch, ship, get_exit( get_room_index( ship->location ), dir ), 0 );
space.c:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
space.c:      pexit = get_exit( get_room_index( ship->location ), door );
space.c:      sprintf( buf, "drive_ship: %s to door %d", ch->name, pexit->vdir );
space.c:   in_room = get_room_index( ship->location );
space.c:   if( !pexit || ( to_room = pexit->to_room ) == NULL )
space.c:   door = pexit->vdir;
space.c:   distance = pexit->distance;
space.c:   if( IS_SET( pexit->exit_info, EX_WINDOW ) && !IS_SET( pexit->exit_info, EX_ISDOOR ) )
space.c:   if( IS_SET( pexit->exit_info, EX_PORTAL ) && IS_NPC( ch ) )
space.c:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) )
space.c:   if( IS_SET( pexit->exit_info, EX_CLOSED ) && ( IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
space.c:      if( !IS_SET( pexit->exit_info, EX_SECRET ) && !IS_SET( pexit->exit_info, EX_DIG ) )
space.c:            act( AT_PLAIN, "$n drives into the $d in $s drunken state.", ch, NULL, pexit->keyword, TO_ROOM );
space.c:            act( AT_PLAIN, "You drive into the $d in your drunken state.", ch, NULL, pexit->keyword, TO_CHAR );
space.c:            act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
space.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
space.c:      if( ch->top_level < to_room->area->low_hard_range )
space.c:         switch ( to_room->area->low_hard_range - ch->top_level )
space.c:      else if( ch->top_level > to_room->area->hi_hard_range )
space.c:      if( IS_SET( to_room->room_flags, ROOM_INDOORS )
space.c:          || IS_SET( to_room->room_flags, ROOM_SPACECRAFT ) || to_room->sector_type == SECT_INSIDE )
space.c:      if( IS_SET( to_room->room_flags, ROOM_NO_DRIVING ) )
space.c:      if( in_room->sector_type == SECT_AIR || to_room->sector_type == SECT_AIR || IS_SET( pexit->exit_info, EX_FLY ) )
space.c:         if( ship->ship_class > CLOUD_CAR )
space.c:      if( in_room->sector_type == SECT_WATER_NOSWIM
space.c:          || to_room->sector_type == SECT_WATER_NOSWIM
space.c:          || to_room->sector_type == SECT_WATER_SWIM
space.c:          || to_room->sector_type == SECT_UNDERWATER || to_room->sector_type == SECT_OCEANFLOOR )
space.c:         if( ship->ship_class != OCEAN_SHIP )
space.c:      if( IS_SET( pexit->exit_info, EX_CLIMB ) )
space.c:         if( ship->ship_class < CLOUD_CAR )
space.c:   if( to_room->tunnel > 0 )
space.c:      for( ctmp = to_room->first_person; ctmp; ctmp = ctmp->next_in_room )
space.c:         if( ++count >= to_room->tunnel )
space.c:      if( ship->ship_class < OCEAN_SHIP )
space.c:      else if( ship->ship_class == OCEAN_SHIP )
space.c:      else if( ship->ship_class > OCEAN_SHIP )
space.c:   sprintf( buf, "%s %ss %s.", ship->name, txt, dir_name[door] );
space.c:   echo_to_room( AT_ACTION, get_room_index( ship->location ), buf );
space.c:   ship_to_room( ship, to_room->vnum );
space.c:   ship->location = to_room->vnum;
space.c:   ship->lastdoc = ship->location;
space.c:   else if( ship->ship_class < OCEAN_SHIP )
space.c:   else if( ship->ship_class == OCEAN_SHIP )
space.c:   else if( ship->ship_class > OCEAN_SHIP )
space.c:         dtxt = "the south-west";
space.c:         dtxt = "the south-east";
space.c:         dtxt = "the north-west";
space.c:         dtxt = "the north-east";
space.c:   sprintf( buf, "%s %s from %s.", ship->name, txt, dtxt );
space.c:   echo_to_room( AT_ACTION, get_room_index( ship->location ), buf );
space.c:   for( rch = ch->in_room->last_person; rch; rch = next_rch )
space.c:      next_rch = rch->prev_in_room;
space.c:      original = rch->in_room;
space.c:	|| ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
space.c:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:	if( ship->ship_class > SHIP_PLATFORM )
space.c:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c:	if( !ship->starsystem )
space.c:	target = get_ship_here( arg, ship->starsystem );
space.c:        ship->hx = target->vx - ship->vx;
space.c:        ship->hy = target->vy - ship->vy;
space.c:        ship->energy -= ( ship->currspeed / 10 );
space.c:	sprintf( buf, "%s turns altering its present course.", ship->name );
space.c:	if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c:		ship->shipstate = SHIP_BUSY_3;
space.c:	else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c:		ship->shipstate = SHIP_BUSY_2;
space.c:		ship->shipstate = SHIP_BUSY;
space.c:	if( ship->ship_class == FIGHTER_SHIP )
space.c:	if( ship->ship_class == MIDSIZE_SHIP )
space.c:	if( ship->ship_class == CAPITAL_SHIP )
space.c:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:	if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c:	if( ship->ship_class > SHIP_PLATFORM )
space.c:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c:	if( !ship->starsystem )
space.c:        if( ship->shipstate != SHIP_READY)
space.c:	if(ship->track0 != NULL)
space.c:      		sprintf( buf, "You are too busy tracking %s.", ship->track0->name );
space.c:        if(  ship->turnarc != 0 )
space.c:    		echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c:	 	sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c:		ship->turnarc = 0;
space.c:	ship->prevheading = ship->heading;
space.c:		ship->turnarc = modifier * PI / 180;
space.c:	else if ( arg[0] == '-' && arg[1] != '\0' )
space.c:		ship->turnarc = -modifier * PI / 180;
space.c:		ship->turnarc = newheading - ship->heading;
space.c:	if (ship->heading < 0)
space.c:		ship->heading += 2*PI;
space.c:        ship->energy -= ( ship->currspeed / 10 );
space.c:	ch_printf( ch, "&GAdjusting course by %0.f degrees.\r\n",radianstodegrees(ship->turnarc));
space.c:	sprintf( buf, "%s turns altering its present course.", ship->name );
space.c:	REMOVE_BIT(ship->flightflags,SHIP_AUTOMANEUVER);
space.c:	if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c:		ship->shipstate = SHIP_BUSY_3;
space.c:	else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c:		ship->shipstate = SHIP_BUSY_2;
space.c:		ship->shipstate = SHIP_BUSY;
space.c:	if( ship->ship_class == FIGHTER_SHIP )
space.c:	if( ship->ship_class == MIDSIZE_SHIP )
space.c:	if( ship->ship_class == CAPITAL_SHIP )
space.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->ship_class > SHIP_PLATFORM )
space.c:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c:   if( ship->shipstate == SHIP_DOCKED )
space.c:   if( ship->chaff <= 0 )
space.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_weaponsystems] );
space.c:   ship->chaff--;
space.c:   ship->chaff_released++;
space.c:   if( ship->type == MOB_SHIP )
space.c:   if( ship->autopilot )
space.c:    switch( ch->substate )
space.c:    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:                if (ship->shipstate == SHIP_HYPERSPACE)
space.c:                if (ship->shipstate == SHIP_DISABLED)
space.c:    	        if (ship->shipstate == SHIP_DOCKED)
space.c:    	        if (ship->shipstate != SHIP_READY)
space.c:                if ( ship->energy <1 )
space.c:                if ( ship->ship_class == FIGHTER_SHIP )
space.c:                    schance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
space.c:                if ( ship->ship_class == MIDSIZE_SHIP )
space.c:                    schance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
space.c:                if ( ship->ship_class == CAPITAL_SHIP )
space.c:                    schance = IS_NPC(ch) ? ch->top_level
space.c:	                 : (int) (ch->pcdata->learned[gsn_capitalships]);
space.c:		   echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c:    		   ch->dest_buf = str_dup(arg);
space.c:	        if ( ship->ship_class == FIGHTER_SHIP )
space.c:                if ( ship->ship_class == MIDSIZE_SHIP )
space.c:                if ( ship->ship_class == CAPITAL_SHIP )
space.c:    		if ( !ch->dest_buf )
space.c:    		strcpy(arg, ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf);
space.c:    		DISPOSE( ch->dest_buf );
space.c:    		ch->substate = SUB_NONE;
space.c:    		if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:    	        echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c:    		if (ship->shipstate != SHIP_DISABLED)
space.c:    		   ship->shipstate = SHIP_READY;
space.c:    ch->substate = SUB_NONE;
space.c:    if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c:    echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c:    if ( ship->ship_class == FIGHTER_SHIP )
space.c:    if ( ship->ship_class == MIDSIZE_SHIP )
space.c:    if ( ship->ship_class == CAPITAL_SHIP )
space.c:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c:                if (ship->shipstate == SHIP_HYPERSPACE)
space.c:                if (ship->shipstate == SHIP_DISABLED)
space.c:    	        if (ship->shipstate == SHIP_DOCKED)
space.c:    	        if (ship->shipstate != SHIP_READY)
space.c:        if ( ship->energy <1 )
space.c:        if ( ship->ship_class == FIGHTER_SHIP )
space.c:             schance = IS_NPC(ch) ? ch->top_level
space.c:             : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
space.c:        if ( ship->ship_class == MIDSIZE_SHIP )
space.c:             schance = IS_NPC(ch) ? ch->top_level
space.c:                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
space.c:        if ( ship->ship_class == CAPITAL_SHIP )
space.c:              schance = IS_NPC(ch) ? ch->top_level
space.c:                 : (int) (ch->pcdata->learned[gsn_capitalships]);
space.c:            if ( ship->ship_class == FIGHTER_SHIP )
space.c:            if ( ship->ship_class == MIDSIZE_SHIP )   
space.c:            if ( ship->ship_class == CAPITAL_SHIP )
space.c:    echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c:    if ( ship->ship_class == FIGHTER_SHIP )
space.c:    if ( ship->ship_class == MIDSIZE_SHIP )
space.c:    if ( ship->ship_class == CAPITAL_SHIP )
space.c~:*--------------------------------------------------------------------------*
space.c~:* -------------------------------------------------------------------------*
space.c~:*--------------------------------------------------------------------------*
space.c~:* ------------------------------------------------------------------------ *
space.c~:* ------------------------------------------------------------------------ *
space.c~:   for( vic = room->first_person; vic; vic = vic->next_in_room )
space.c~:	return sqrt( pow( shipA->vx - shipB->vx , 2 ) + pow( shipA->vy - shipB->vy , 2 ) );
space.c~:	return sqrt ( pow ( x1 - x2 , 2 ) + pow ( y1 - y2 , 2 ) );	
space.c~:	if( ship->ship_class == FIGHTER_SHIP )
space.c~:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] )/100.0);
space.c~:	if( ship->ship_class == MIDSIZE_SHIP )
space.c~:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] )/100.0);
space.c~:	if( ship->ship_class == CAPITAL_SHIP )
space.c~:		pilotmodifier *= 1.75 - (IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] )/100.0);
space.c~:	pilotmodifier *= 1.75 - (ch->perm_dex/25.00);
space.c~:	pilotmodifier *= 1.50 - (ch->perm_lck/18.00); //luck is a 50 50
space.c~:	pilotmodifier *= 1.10 - (ch->perm_frc/18.00);
space.c~:	if( ship->track0 != NULL )
space.c~:		if( ship->track0->pilotpilotch != NULL )
space.c~:			tempdouble *= 1.10 + (ship->track0->pilotpilotch->perm_frc/18.00);
space.c~:		if( ship->track0->copilotch != NULL && ship->track0->copilotch != ship->track0->pilotpilotch )
space.c~:			tempdouble *= 1.10 + (ship->track0->pilotpilotch->perm_frc/18.00);
space.c~:			x1 = 2.0 * ranf() - 1.0;
space.c~:			x2 = 2.0 * ranf() - 1.0;
space.c~:		w = sqrt( (-2.0 * log( w ) ) / w );
space.c~:		*heading -= 2*PI;
space.c~:	xdiff = x2 - x1;
space.c~:	ydiff = y2 - y1;
space.c~:	angle = PI/2 - angle;
space.c~:	bearing = coordpairtoheading(x1,y1,x2,y2) - heading;
space.c~:	//if (abs(bearing - 2 * PI) < PI/180)
space.c~:		bearing -= 2*PI;
space.c~:	if (bearing < -PI )
space.c~:	return getbearing(shipA->heading,shipA->vx,shipA->vy,shipB->vx,shipB->vy);
space.c~:   ship->location = destination;
space.c~:   ship->lastdoc = ship->location;
space.c~:   ship->shipstate = SHIP_DOCKED;
space.c~:   if( ship->starsystem )
space.c~:      ship_from_starsystem( ship, ship->starsystem );
space.c~:   sprintf( buf, "%s lands on the platform.", ship->name );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:   sprintf( buf, "The hatch on %s opens.", ship->name );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch opens." );
space.c~:   ship->hatchopen = TRUE;
space.c~:   sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:   sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:   sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:   sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:   sprintf( buf, "The hatch on %s closes and it begins to launch.", ship->name );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
space.c~:   ship->hatchopen = FALSE;
space.c~:   ship->location = 0;
space.c~:   ship->shipstate = SHIP_READY;
space.c~:      echo_to_room( AT_YELLOW, get_room_index( turbocar->location ), buf );
space.c~:      turbocar->location = 0;
space.c~:      turbocar->location = station_vnum[turbocar_stop];
space.c~:      turbocar->lastdoc = turbocar->location;
space.c~:      turbocar->shipstate = SHIP_DOCKED;
space.c~:      if( turbocar->starsystem )
space.c~:         ship_from_starsystem( turbocar, turbocar->starsystem );
space.c~:      echo_to_room( AT_YELLOW, get_room_index( turbocar->location ), buf );
space.c~:      turbocar->hatchopen = TRUE;
space.c~:         if( target != NULL && !target->starsystem )
space.c~:         if( target != NULL && !target->starsystem )
space.c~:        m_next = missile->next;
space.c~:        ship = missile->fired_from;
space.c~:	if(missile->target != NULL)
space.c~:		  if (missile->target->starsystem == NULL || fabs(getbearing(missile->heading,missile->mx,missile->my,missile->target->vx,missile->target->vy)) > PI / 12)
space.c~:		  	sprintf( buf, "The missile fired from %s veers off to seek a new target!", missile->fired_from->name );
space.c~:		  	echo_to_system( AT_ORANGE, missile->fired_from, buf, NULL );
space.c~:		  	echo_to_cockpit( AT_ORANGE, missile->fired_from, buf );
space.c~:		  	missile->target = NULL;
space.c~:	if(missile->target == NULL )
space.c~:		for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:			range = sqrt(pow(missile->mx-target->vx,2)+pow(missile->my-target->vy,2) );
space.c~:			bearing = fabs(getbearing(missile->heading,missile->mx,missile->my,target->vx,target->vy));		
space.c~:			theta = atan( ((double)(target->ship_class+0.25*20))/range)*2;
space.c~:		target = missile->target;	
space.c~:	if(missile->target == NULL && target != NULL)
space.c~:		missile->target = target;
space.c~:		sprintf( buf, "MISSILE WARNING: A missile fired from %s has locked its tracking radar onto you!", ship->name );
space.c~:		sprintf( buf, "A missile fired from %s locks course on %s", ship->name,target->name );
space.c~:      if( target != NULL && target->starsystem && target->starsystem == missile->starsystem )
space.c~:		trackbearing = getbearing(missile->heading,missile->mx,missile->my,target->vx,target->vy);
space.c~:		missile->turnarc = trackbearing;
space.c~:		turnvelocity = missile->turnvelocity * (4.00/PULSE_PER_SECOND);
space.c~:		if ( fabs(missile->turnarc) > turnvelocity )
space.c~:			if ( missile->turnarc >= 0 )
space.c~:				missile->turnarc -= turnvelocity;
space.c~:				missile->heading += turnvelocity;
space.c~:				fixheading(&missile->heading);
space.c~:				missile->turnarc += turnvelocity;
space.c~:				missile->heading -= turnvelocity;
space.c~:				fixheading(&missile->heading);
space.c~:			missile->heading += missile->turnarc;
space.c~:			fixheading(&missile->heading);
space.c~:			/*sprintf( buf, "Missile adjusts heading %0.2f degrees", radianstodegrees(missile->turnarc));
space.c~:			missile->turnarc = 0;
space.c~:	missile->my += missile->speed/5.00 * (4.00/PULSE_PER_SECOND) *  cos( missile->heading );
space.c~:	missile->mx += missile->speed/5.00 * (4.00/PULSE_PER_SECOND) * sin( missile->heading );	
space.c~:      if( target != NULL && target->starsystem && target->starsystem == missile->starsystem )
space.c~:	  if( pointdistance(target->vx,target->vy,missile->mx,missile->my) < 50 )
space.c~:	      if( target->chaff_released <= 0 )
space.c~:		  echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ), "Your missile hits its target dead on!" );
space.c~:		  sprintf( buf, "You see a small explosion as %s is hit by a missile", target->name );
space.c~:		  for( ch = first_char; ch; ch = ch->next )
space.c~:		    if( !IS_NPC( ch ) && nifty_is_name( missile->fired_by, ch->name ) )
space.c~:			damage_ship_ch( target, 35 + missile->missiletype * missile->missiletype * 20,
space.c~:					45 + missile->missiletype * missile->missiletype * missile->missiletype * 30, ch );
space.c~:		    damage_ship( target, 35 + missile->missiletype * missile->missiletype * 20,
space.c~:				 45 + missile->missiletype * missile->missiletype * ship->missiletype * 30 );
space.c~:		  echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ),
space.c~:	   else if( pointdistance(target->vx,target->vy,missile->mx,missile->my) < 200 )
space.c~:      missile->age++;
space.c~:      if( missile->age >= 50 )
space.c~:	  sprintf( buf, "A missile fired from %s runs out of fuel and self destructs", missile->fired_from->name );
space.c~:	  echo_to_system( AT_ORANGE, missile->fired_from, buf, NULL );
space.c~:  for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( !ship->starsystem )
space.c~:      if( ship->currspeed > 0 )
space.c~:	  //change = sqrt( ship->hx * ship->hx + ship->hy * ship->hy );
space.c~:	     // dx = ship->hx / change;
space.c~:	      //dy = ship->hy / change;
space.c~:	      ///dz = ship->hz / change;
space.c~:	      //ship->vx += ( dx * ship->currspeed / 5 );
space.c~:	      //ship->vy += ( dy * ship->currspeed / 5 );
space.c~:	     // ship->vz += ( dz * ship->currspeed / 5 );
space.c~:	   /*   if (ship->heading > PI / 2 && ship->heading <= 3*PI/2 ) 
space.c~:	      	      ship->vy += ship->currspeed/5 *  sin( ship->heading );
space.c~:		      ship->vx += ship->currspeed/5 *  cos( ship->heading );	
space.c~:		ship->vy += ship->currspeed/5.00 * (4.00/PULSE_PER_SECOND) * cos( ship->heading );
space.c~:		ship->vx += ship->currspeed/5.00 * (4.00/PULSE_PER_SECOND) * sin( ship->heading );	
space.c~:		tempdouble = (double)ship->ship_class * 25;
space.c~:		sigma = 2 * (((double)ship->manuever)/((double)100)) 
space.c~:  			  * MAX(((double)(100.0-tempdouble))/100.00,0.10)
space.c~:		if( ship->pilotpilotch == NULL && ship->copilotch == NULL )
space.c~:			if(ship->pilotpilotch != NULL)
space.c~:				pilotmodifier = getPilotErrorModifier(ship,ship->pilotpilotch);
space.c~:			if(ship->copilotch != NULL && ship->copilotch != ship->pilotpilotch)
space.c~:				pilotmodifier += getPilotErrorModifier(ship,ship->pilotpilotch);
space.c~:	if(!finite(ship->turnarc))
space.c~:		ship->turnarc = 0;
space.c~:		tempdouble = (double)ship->ship_class * 25;
space.c~:				* (((double)ship->manuever)/((double)100)) 
space.c~:				* MAX(((double)(100.0-tempdouble))/100.00,0.10)
space.c~:	if ( ship->turnarc != 0 )
space.c~:		ship->prevheading = ship->heading;		  
space.c~:		if(IS_SET(ship->flightflags,SHIP_AUTOMANEUVER) && ship->track0 != NULL && ship->turnarc > PI/8 )
space.c~:			sprintf( buf, "%s adjusts its course attempting to match that of %s.", ship->name,ship->track0->name );
space.c~:			echo_to_system( AT_ORANGE, ship, buf, ship->track0 );
space.c~:		 	sprintf( buf, "%s attempts to match your maneuver.",ship->name);
space.c~:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c~:		if ( fabs(ship->turnarc) > turnvelocity )
space.c~:			if ( ship->turnarc >= 0 )
space.c~:				ship->turnarc -= turnvelocity;
space.c~:				ship->heading += turnvelocity;
space.c~:				fixheading(&ship->heading);
space.c~:				ship->turnarc += turnvelocity;
space.c~:				ship->heading -= turnvelocity;
space.c~:				fixheading(&ship->heading);
space.c~:			ship->heading += ship->turnarc;
space.c~:			fixheading(&ship->heading);
space.c~:			ship->turnarc = 0;
space.c~:			ship->heading += flighterror;
space.c~:			if(!IS_SET(ship->flightflags,SHIP_AUTOMANEUVER))
space.c~:		        	echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c~:		 		sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c~:				//ch_printf( ch, "&GNew heading %0.4f degrees.\r\n",radianstodegrees(ship->heading));
space.c~:		ship->heading += flighterror;
space.c~:	if(ship->track0 == NULL && IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c~:		for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c~:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c~:			theta = atan( ((double)(target->ship_class+0.25*20))/range)*2;
space.c~:			ship->track0 = besttarget;
space.c~:			sprintf( buf, "Tracking radar auto acquiring new objective %s\n\r",ship->track0->name);
space.c~:			sprintf( buf, "You are being painted by %s's tracking radar!\n\r", ship->name);
space.c~:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c~:	if( ship->track0 != NULL )
space.c~:		trackbearing = s2sbearing(ship,ship->track0);
space.c~:		trackrange = ship2shipdist(ship,ship->track0);
space.c~:		if(ship->track0->starsystem == NULL)
space.c~:			sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c~:			echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c~:			ship->track0 = NULL;
space.c~:			ship->turnarc = 0;
space.c~:			if(trackrange > 500 && dice < (5000-trackrange))
space.c~:					sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c~:					echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c~:					ship->track0 = NULL;
space.c~:					//ship->turnarc = 0;
space.c~:				if(trackbearing > PI/4 || trackbearing < - PI/4 )
space.c~:					if( fabs(trackbearing) > PI/2  && trackrange < 150 && ship->currspeed > 0)
space.c~:						sprintf( buf, "You fly right past %s!\n\r",ship->track0->name);
space.c~:						sprintf( buf, "%s flies right past you!\n\r", ship->name);
space.c~:						echo_to_cockpit( AT_YELLOW, ship->track0, buf );		
space.c~:					sprintf( buf, "You are no longer being painted by %s\n\r", ship->name);
space.c~:					echo_to_cockpit( AT_YELLOW, ship->track0, buf );
space.c~:					ship->track0 = NULL;
space.c~:					//ship->turnarc = 0;
space.c~:					if(ship->turnarc == 0 )
space.c~:						if(ship->pilotpilotch != NULL)
space.c~:							if(IS_SET(ship->flightflags,SHIP_AUTOMANEUVER) 
space.c~:							&& (ship->ship_class == FIGHTER_SHIP || ship->ship_class == MIDSIZE_SHIP) 
space.c~:							&& ship->pilotpilotch->pcdata->learned[gsn_starfighters] == 100 
space.c~:							&& (ship->track0->ship_class == FIGHTER_SHIP || ship->track0->ship_class == MIDSIZE_SHIP))
space.c~:								if(ship->pilotpilotch->pcdata->learned[gsn_spacecombat] != 100 
space.c~:								   && fabs(ship->prevheading - ship->heading) >= MAX(((double)ship->pilotpilotch->pcdata->learned[gsn_spacecombat])/100.00*(2*turnvelocity/6.00) ,PI/45.00)
space.c~:								   && ship->track0->currspeed >= ship->track0->realspeed*0.25)
space.c~:									learn_from_success( ship->pilotpilotch, gsn_spacecombat );
space.c~:								else if(ship->pilotpilotch->pcdata->learned[gsn_spacecombat] == 100
space.c~:								        && fabs(ship->prevheading - ship->heading) >= 3/5.00 * turnvelocity 
space.c~:								        && ship->track0->currspeed >= ship->track0->realspeed*0.5 
space.c~:									&& ship->ship_class != MIDSIZE_SHIP 
space.c~:									&& ship->track0->ship_class != MIDSIZE_SHIP)
space.c~:										learn_from_success( ship->pilotpilotch, gsn_spacecombat2 );								
space.c~:								else if(fabs(ship->prevheading - ship->heading) >= 4/5.00 * turnvelocity 
space.c~:									&& ship->pilotpilotch->pcdata->learned[gsn_spacecombat] == 100
space.c~:									&& ship->pilotpilotch->pcdata->learned[gsn_spacecombat2] == 100
space.c~:									&& ship->track0->currspeed == ship->track0->realspeed 
space.c~:									&& ship->ship_class != MIDSIZE_SHIP 
space.c~:									&& ship->track0->ship_class != MIDSIZE_SHIP)
space.c~:										learn_from_success( ship->pilotpilotch, gsn_spacecombat3 );
space.c~:							ship->turnarc = trackbearing * MAX(0.025,(0.45 * (ship->pilotpilotch->pcdata->learned[gsn_spacecombat]/100.00) + 0.30 *(ship->pilotpilotch->pcdata->learned[gsn_spacecombat2]/100.00) + 0.25 *(ship->pilotpilotch->pcdata->learned[gsn_spacecombat2]/100.00))); //other flight commands override
space.c~:							ship->turnarc = trackbearing * 0.90;  //human can be better
space.c~:						SET_BIT(ship->flightflags,SHIP_AUTOMANEUVER);
space.c~:		if(ship->track0 == NULL && IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c~:          if ( ship->class != SHIP_PLATFORM && !autofly(ship) )
space.c~:            if ( ship->starsystem->star1 && strcmp(ship->starsystem->star1,"") )
space.c~:              if (ship->vx >= ship->starsystem->s1x + 1 || ship->vx <= ship->starsystem->s1x - 1 )
space.c~:                ship->vx -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vx - ship->starsystem->s1x)/2,3);
space.c~:              if (ship->vy >= ship->starsystem->s1y + 1 || ship->vy <= ship->starsystem->s1y - 1 )
space.c~:                ship->vy -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vy - ship->starsystem->s1y)/2,3);
space.c~:              if (ship->vz >= ship->starsystem->s1z + 1 || ship->vz <= ship->starsystem->s1z - 1 )
space.c~:                ship->vz -= URANGE(-3,(ship->starsystem->gravitys1)/(ship->vz - ship->starsystem->s1z)/2,3);
space.c~:            if ( ship->starsystem->star2 && strcmp(ship->starsystem->star2,"") )
space.c~:              if (ship->vx >= ship->starsystem->s2x + 1 || ship->vx <= ship->starsystem->s2x - 1 )
space.c~:                ship->vx -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vx - ship->starsystem->s2x)/2,3);
space.c~:              if (ship->vy >= ship->starsystem->s2y + 1 || ship->vy <= ship->starsystem->s2y - 1 )
space.c~:                ship->vy -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vy - ship->starsystem->s2y)/2,3);
space.c~:              if (ship->vz >= ship->starsystem->s2z + 1 || ship->vz <= ship->starsystem->s2z - 1 )
space.c~:                ship->vz -= URANGE(-3,(ship->starsystem->gravitys2)/(ship->vz - ship->starsystem->s2z)/2,3);
space.c~:            if ( ship->starsystem->planet1 && strcmp(ship->starsystem->planet1,"") )
space.c~:              if (ship->vx >= ship->starsystem->p1x + 1 || ship->vx <= ship->starsystem->p1x - 1 )
space.c~:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vx - ship->starsystem->p1x)/2,3);
space.c~:              if (ship->vy >= ship->starsystem->p1y + 1 || ship->vy <= ship->starsystem->p1y - 1 )
space.c~:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vy - ship->starsystem->p1y)/2,3);
space.c~:              if (ship->vz >= ship->starsystem->p1z + 1 || ship->vz <= ship->starsystem->p1z - 1 )
space.c~:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp1)/(ship->vz - ship->starsystem->p1z)/2,3);
space.c~:            if ( ship->starsystem->planet2 && strcmp(ship->starsystem->planet2,"") )
space.c~:              if (ship->vx >= ship->starsystem->p2x + 1 || ship->vx <= ship->starsystem->p2x - 1 )
space.c~:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vx - ship->starsystem->p2x)/2,3);
space.c~:              if (ship->vy >= ship->starsystem->p2y + 1 || ship->vy <= ship->starsystem->p2y - 1 )
space.c~:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vy - ship->starsystem->p2y)/2,3);
space.c~:              if (ship->vz >= ship->starsystem->p2z + 1 || ship->vz <= ship->starsystem->p2z - 1 )
space.c~:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp2)/(ship->vz - ship->starsystem->p2z)/2,3);
space.c~:            if ( ship->starsystem->planet3 && strcmp(ship->starsystem->planet3,"") )
space.c~:              if (ship->vx >= ship->starsystem->p3x + 1 || ship->vx <= ship->starsystem->p3x - 1 )
space.c~:                ship->vx -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vx - ship->starsystem->p3x)/2,3);
space.c~:              if (ship->vy >= ship->starsystem->p3y + 1 || ship->vy <= ship->starsystem->p3y - 1 )
space.c~:                ship->vy -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vy - ship->starsystem->p3y)/2,3);
space.c~:              if (ship->vz >= ship->starsystem->p3z + 1 || ship->vz <= ship->starsystem->p3z - 1 )
space.c~:                ship->vz -= URANGE(-3,(ship->starsystem->gravityp3)/(ship->vz - ship->starsystem->p3z)/2,3);
space.c~:          for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem)
space.c~:                    abs(ship->vx - target->vx) < 1 &&
space.c~:                    abs(ship->vy - target->vy) < 1 &&
space.c~:                    abs(ship->vz - target->vz) < 1 )
space.c~:                    ship->collision = target->maxhull;
space.c~:                    target->collision = ship->maxhull;
space.c~:      if( ship->starsystem->star1 && strcmp( ship->starsystem->star1, "" )
space.c~:	  && pointdistance(ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y) < 100)
space.c~:	  sprintf( buf, "%s flys directly into %s!", ship->name, ship->starsystem->star1 );
space.c~:      if( ship->starsystem->star2 && strcmp( ship->starsystem->star2, "" )
space.c~:	  && pointdistance(ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y) < 100)
space.c~:	  sprintf( buf, "%s flys directly into %s!", ship->name, ship->starsystem->star2 );
space.c~:      if( ship->currspeed > 0 )
space.c~:	  if( ship->starsystem->planet1 && strcmp( ship->starsystem->planet1, "" )
space.c~:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y) < 10
space.c~:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y) - ship->heading < PI/4 
space.c~:		   || (ship->vx == ship->starsystem->p1x && ship->vy == ship->starsystem->p1y)))
space.c~:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet1 );
space.c~:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet1 );
space.c~:	      ship->vx = ship->starsystem->p1x;
space.c~:	      ship->vy = ship->starsystem->p1y;
space.c~:	      ship->currspeed = 0;
space.c~:	  if( ship->starsystem->planet2 && strcmp( ship->starsystem->planet2, "" )
space.c~:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p2x,ship->starsystem->p2y) < 10
space.c~:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p2x,ship->starsystem->p2y) - ship->heading < PI/4
space.c~:		|| (ship->vx == ship->starsystem->p2x && ship->vy == ship->starsystem->p2y)))
space.c~:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet2 );
space.c~:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet2 );
space.c~:	      ship->vx = ship->starsystem->p2x;
space.c~:	      ship->vy = ship->starsystem->p2y;
space.c~:	      ship->currspeed = 0;
space.c~:	  if( ship->starsystem->planet3 && strcmp( ship->starsystem->planet3, "" )
space.c~:	      && pointdistance(ship->vx,ship->vy,ship->starsystem->p3x,ship->starsystem->p3y) < 10
space.c~:	      && (coordpairtoheading(ship->vx,ship->vy,ship->starsystem->p3x,ship->starsystem->p3y) - ship->heading < PI/4
space.c~:		|| (ship->vx == ship->starsystem->p3x && ship->vy == ship->starsystem->p3y)))
space.c~:	      sprintf( buf, "You begin orbitting %s.", ship->starsystem->planet3 );
space.c~:	      sprintf( buf, "%s begins orbiting %s.", ship->name, ship->starsystem->planet3 );
space.c~:	      ship->vx = ship->starsystem->p3x;
space.c~:	      ship->vy = ship->starsystem->p3y;
space.c~:	      ship->currspeed = 0;
space.c~:  for( ship = first_ship; ship; ship = ship->next )
space.c~:    if( ship->collision )
space.c~:	damage_ship( ship, ship->collision, ship->collision );
space.c~:	ship->collision = 0;
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->statet0 > 0 )
space.c~:         ship->energy -= ship->statet0;
space.c~:         ship->statet0 = 0;
space.c~:      if( ship->statet1 > 0 )
space.c~:         ship->energy -= ship->statet1;
space.c~:         ship->statet1 = 0;
space.c~:      if( ship->statet2 > 0 )
space.c~:         ship->energy -= ship->statet2;
space.c~:         ship->statet2 = 0;
space.c~:      if( ship->missilestate == MISSILE_RELOAD_2 )
space.c~:         ship->missilestate = MISSILE_READY;
space.c~:         if( ship->missiles > 0 )
space.c~:            echo_to_room( AT_YELLOW, get_room_index( ship->gunseat ), "Missile launcher reloaded." );
space.c~:      if( ship->missilestate == MISSILE_RELOAD )
space.c~:         ship->missilestate = MISSILE_RELOAD_2;
space.c~:      if( ship->missilestate == MISSILE_FIRED )
space.c~:         ship->missilestate = MISSILE_RELOAD;
space.c~:         if( ship->starsystem )
space.c~:            if( ship->target0 && ship->statet0 != LASER_DAMAGED )
space.c~:               SHIP_DATA *target = ship->target0;
space.c~:               for( shots = 0; shots <= ship->lasers; shots++ )
space.c~:                  if( ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
space.c~:                      && ship->target0->starsystem == ship->starsystem
space.c~:		      && ship->statet0 < ship->lasers )
space.c~:                     if( ship->ship_class > 1 || is_facing( ship, target ) )
space.c~:                        schance += target->ship_class * 25;
space.c~:                        schance -= target->manuever / 10;
space.c~:                        schance -= target->currspeed / 20;
space.c~:                        schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c~:                        schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c~:                           sprintf( buf, "%s fires at you but misses.", ship->name );
space.c~:                           sprintf( buf, "Laserfire from %s barely misses %s.", ship->name, target->name );
space.c~:                           sprintf( buf, "Laserfire from %s hits %s.", ship->name, target->name );
space.c~:                           sprintf( buf, "You are hit by lasers from %s!", ship->name );
space.c~:                        ship->statet0++;
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->starsystem )
space.c~:         if( ship->energy > 0 && ship->shipstate == SHIP_DISABLED
space.c~:	     && ship->ship_class != SHIP_PLATFORM )
space.c~:            ship->energy -= 100;
space.c~:         else if( ship->energy > 0 )
space.c~:            ship->energy += ( 5 + ship->ship_class * 5 );
space.c~:      if( ship->chaff_released > 0 )
space.c~:         ship->chaff_released--;
space.c~:      if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:         ship->hyperdistance -= ship->hyperspeed * 2;
space.c~:         if( ship->hyperdistance <= 0 )
space.c~:            ship_to_starsystem( ship, ship->currjump );
space.c~:            if( ship->starsystem == NULL )
space.c~:               echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Hyperjump complete." );
space.c~:               sprintf( buf, "%s enters the starsystem at %.0f %.0f", ship->name, ship->vx, ship->vy);
space.c~:               ship->shipstate = SHIP_READY;
space.c~:               STRFREE( ship->home );
space.c~:               ship->home = STRALLOC( ship->starsystem->name );
space.c~:               if( str_cmp( "Public", ship->owner ) )
space.c~:            sprintf( buf, "%d", ship->hyperdistance );
space.c~:            echo_to_room_dnr( AT_YELLOW, get_room_index( ship->pilotseat ), "Remaining jump distance: " );
space.c~:            echo_to_room( AT_WHITE, get_room_index( ship->pilotseat ), buf );
space.c~:      if( ship->shipstate == SHIP_BUSY_3 )
space.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c~:         ship->shipstate = SHIP_READY;
space.c~:      if( ship->shipstate == SHIP_BUSY_2 )
space.c~:         ship->shipstate = SHIP_BUSY_3;
space.c~:      if( ship->shipstate == SHIP_BUSY )
space.c~:         ship->shipstate = SHIP_BUSY_2;
space.c~:      if( ship->shipstate == SHIP_LAND_2 )
space.c~:         landship( ship, ship->dest );
space.c~:      if( ship->shipstate == SHIP_LAND )
space.c~:         ship->shipstate = SHIP_LAND_2;
space.c~:      if( ship->shipstate == SHIP_LAUNCH_2 )
space.c~:      if( ship->shipstate == SHIP_LAUNCH )
space.c~:         ship->shipstate = SHIP_LAUNCH_2;
space.c~:      ship->shield = UMAX( 0, ship->shield - 1 - ship->ship_class );
space.c~:      if( ship->autorecharge && ship->maxshield > ship->shield && ship->energy > 100 )
space.c~:         recharge = UMIN( ship->maxshield - ship->shield, 10 + ship->ship_class * 10 );
space.c~:         recharge = UMIN( recharge, ship->energy / 2 - 100 );
space.c~:         ship->shield += recharge;
space.c~:         ship->energy -= recharge;
space.c~:      if( ship->shield > 0 )
space.c~:         if( ship->energy < 200 )
space.c~:            ship->shield = 0;
space.c~:            ship->autorecharge = FALSE;
space.c~:      if( ship->starsystem && ship->currspeed > 0 )
space.c~:         sprintf( buf, "%d", ship->currspeed );
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->pilotseat ), "Speed: " );
space.c~:         echo_to_room_dnr( AT_LBLUE, get_room_index( ship->pilotseat ), buf );
space.c~:         sprintf( buf, "%.0f %.0f", ship->vx, ship->vy);
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->pilotseat ), "  Coords: " );
space.c~:         echo_to_room( AT_LBLUE, get_room_index( ship->pilotseat ), buf );
space.c~:         if( ship->pilotseat != ship->coseat )
space.c~:            sprintf( buf, "%d", ship->currspeed );
space.c~:            echo_to_room_dnr( AT_BLUE, get_room_index( ship->coseat ), "Speed: " );
space.c~:            echo_to_room_dnr( AT_LBLUE, get_room_index( ship->coseat ), buf );
space.c~:            sprintf( buf, "%.0f %.0f", ship->vx, ship->vy);
space.c~:            echo_to_room_dnr( AT_BLUE, get_room_index( ship->coseat ), "  Coords: " );
space.c~:            echo_to_room( AT_LBLUE, get_room_index( ship->coseat ), buf );
space.c~:      if( ship->starsystem )
space.c~:         too_close = ship->currspeed + 50;
space.c~:         for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:            target_too_close = too_close + target->currspeed;
space.c~:		&& abs( ( int )( ship->vx - target->vx ) ) < target_too_close
space.c~:		&& abs( ( int )( ship->vy - target->vy ) ) < target_too_close)
space.c~:               sprintf( buf, "Proximity alert: %s  %.0f %.0f", target->name, target->vx, target->vy );
space.c~:               echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:         too_close = ship->currspeed + 100;
space.c~:         if( ship->starsystem->star1 && strcmp( ship->starsystem->star1, "" )
space.c~:	     && abs( ( int )( ship->vx - ship->starsystem->s1x ) ) < too_close
space.c~:	     && abs( ( int )( ship->vy - ship->starsystem->s1y ) ) < too_close)
space.c~:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->star1,
space.c~:                     ship->starsystem->s1x, ship->starsystem->s1y);
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:         if( ship->starsystem->star2 && strcmp( ship->starsystem->star2, "" )
space.c~:	     && abs( ( int )( ship->vx - ship->starsystem->s2x ) ) < too_close
space.c~:	     && abs( ( int )( ship->vy - ship->starsystem->s2y ) ) < too_close)
space.c~:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->star2,
space.c~:                     ship->starsystem->s2x, ship->starsystem->s2y );
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:         if( ship->starsystem->planet1
space.c~:	     && strcmp( ship->starsystem->planet1, "" )
space.c~:	     && abs( ( int )( ship->vx - ship->starsystem->p1x ) ) < too_close
space.c~:	     && abs( ( int )( ship->vy - ship->starsystem->p1y ) ) < too_close)
space.c~:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet1,
space.c~:                     ship->starsystem->p1x, ship->starsystem->p1y);
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:         if( ship->starsystem->planet2
space.c~:	     && strcmp( ship->starsystem->planet2, "" )
space.c~:	     && abs( ( int )( ship->vx - ship->starsystem->p2x ) ) < too_close
space.c~:	     && abs( ( int )( ship->vy - ship->starsystem->p2y ) ) < too_close)
space.c~:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet2,
space.c~:                     ship->starsystem->p2x, ship->starsystem->p2y );
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:         if( ship->starsystem->planet3
space.c~:	     && strcmp( ship->starsystem->planet3, "" )
space.c~:	     && abs( ( int )( ship->vx - ship->starsystem->p3x ) ) < too_close
space.c~:	     && abs( ( int )( ship->vy - ship->starsystem->p3y ) ) < too_close)
space.c~:            sprintf( buf, "Proximity alert: %s  %d %d", ship->starsystem->planet3,
space.c~:                     ship->starsystem->p3x, ship->starsystem->p3y );
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), buf );
space.c~:      if( ship->target0 )
space.c~:         sprintf( buf, "%s   %.0f %.0f", ship->target0->name, ship->target0->vx, ship->target0->vy );
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->gunseat ), "Target: " );
space.c~:         echo_to_room( AT_LBLUE, get_room_index( ship->gunseat ), buf );
space.c~:	 range = sqrt(pow(ship->vx-ship->target0->vx,2)+pow(ship->vy-ship->target0->vy,2) );
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->gunseat ), "Range: " );
space.c~:         echo_to_room( AT_LBLUE, get_room_index( ship->gunseat ), buf );
space.c~:         if( ship->starsystem != ship->target0->starsystem )
space.c~:            ship->target0 = NULL;
space.c~:      if( ship->target1 )
space.c~:         sprintf( buf, "%s   %.0f %.0f", ship->target1->name, ship->target1->vx, ship->target1->vy);
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->turret1 ), "Target: " );
space.c~:         echo_to_room( AT_LBLUE, get_room_index( ship->turret1 ), buf );
space.c~:         if( ship->starsystem != ship->target1->starsystem )
space.c~:            ship->target1 = NULL;
space.c~:      if( ship->target2 )
space.c~:         sprintf( buf, "%s   %.0f %.0f", ship->target2->name, ship->target2->vx, ship->target2->vy);
space.c~:         echo_to_room_dnr( AT_BLUE, get_room_index( ship->turret2 ), "Target: " );
space.c~:         echo_to_room( AT_LBLUE, get_room_index( ship->turret2 ), buf );
space.c~:         if( ship->starsystem != ship->target2->starsystem )
space.c~:            ship->target2 = NULL;
space.c~:      if( ship->energy < 100 && ship->starsystem )
space.c~:      ship->energy = URANGE( 0, ship->energy, ship->maxenergy );
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->autotrack && ship->target0 && ship->ship_class < 3 )
space.c~:         target = ship->target0;
space.c~:         too_close = ship->currspeed + 10;
space.c~:         target_too_close = too_close + target->currspeed;
space.c~:         if( target != ship && ship->shipstate == SHIP_READY
space.c~:	     && abs( ( int )( ship->vx - target->vx ) ) < target_too_close
space.c~:	     && abs( ( int )( ship->vy - target->vy ) ) < target_too_close)
space.c~:            ship->hx = 0 - ( ship->target0->vx - ship->vx );
space.c~:            ship->hy = 0 - ( ship->target0->vy - ship->vy );
space.c~:            ship->energy -= ship->currspeed / 10;
space.c~:            echo_to_room( AT_RED, get_room_index( ship->pilotseat ), "Autotrack: Evading to avoid collision!\r\n" );
space.c~:            if( ship->ship_class == FIGHTER_SHIP
space.c~:		|| ( ship->ship_class == MIDSIZE_SHIP
space.c~:		     && ship->manuever > 50 ) )
space.c~:               ship->shipstate = SHIP_BUSY_3;
space.c~:            else if( ship->ship_class == MIDSIZE_SHIP
space.c~:		     || ( ship->ship_class == CAPITAL_SHIP
space.c~:			  && ship->manuever > 50 ) )
space.c~:               ship->shipstate = SHIP_BUSY_2;
space.c~:               ship->shipstate = SHIP_BUSY;
space.c~:         else if( !is_facing( ship, ship->target0 ) )
space.c~:            ship->hx = ship->target0->vx - ship->vx;
space.c~:            ship->hy = ship->target0->vy - ship->vy;
space.c~:            ship->energy -= ship->currspeed / 10;
space.c~:            echo_to_room( AT_BLUE, get_room_index( ship->pilotseat ), "Autotracking target ... setting new course.\r\n" );
space.c~:            if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c~:               ship->shipstate = SHIP_BUSY_3;
space.c~:            else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c~:               ship->shipstate = SHIP_BUSY_2;
space.c~:               ship->shipstate = SHIP_BUSY;
space.c~:         if( ship->starsystem )
space.c~:            if( ship->target0 )
space.c~:               for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:                     if( !str_cmp( target->owner, ship->owner ) && target != ship )
space.c~:                        if( target->target0 == NULL && ship->target0 != target )
space.c~:                           target->target0 = ship->target0;
space.c~:                           sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:                           echo_to_cockpit( AT_BLOOD, target->target0, buf );
space.c~:               target = ship->target0;
space.c~:               ship->autotrack = TRUE;
space.c~:               if( ship->ship_class != SHIP_PLATFORM )
space.c~:                  ship->currspeed = ship->realspeed;
space.c~:               if( ship->energy > 200 )
space.c~:                  ship->autorecharge = TRUE;
space.c~:               if( ship->shipstate != SHIP_HYPERSPACE && ship->energy > 25
space.c~:                   && ship->missilestate == MISSILE_READY && ship->target0->starsystem == ship->starsystem
space.c~:		   && ship->missiles > 0 )
space.c~:                  if( ship->ship_class > 1 || is_facing( ship, target ) )
space.c~:                     schance -= target->manuever / 5;
space.c~:                     schance -= target->currspeed / 20;
space.c~:                     schance += target->ship_class * target->ship_class * 25;
space.c~:                     schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c~:                     schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c~:                        ship->missiles--;
space.c~:                        sprintf( buf, "Incoming missile from %s.", ship->name );
space.c~:                        sprintf( buf, "%s fires a missile towards %s.", ship->name, target->name );
space.c~:                        if( ship->ship_class == CAPITAL_SHIP
space.c~:			    || ship->ship_class == SHIP_PLATFORM )
space.c~:                           ship->missilestate = MISSILE_RELOAD_2;
space.c~:                           ship->missilestate = MISSILE_FIRED;
space.c~:               if( ship->missilestate == MISSILE_DAMAGED )
space.c~:                  ship->missilestate = MISSILE_READY;
space.c~:               if( ship->statet0 == LASER_DAMAGED )
space.c~:                  ship->statet0 = LASER_READY;
space.c~:               if( ship->shipstate == SHIP_DISABLED )
space.c~:                  ship->shipstate = SHIP_READY;
space.c~:               if( !str_cmp( ship->owner, "The Empire" ) )
space.c~:                  for( target = first_ship; target; target = target->next )
space.c~:                     if( ship->starsystem == target->starsystem )
space.c~:                        if( !str_cmp( target->owner, "The New Republic" ) )
space.c~:                           ship->target0 = target;
space.c~:                           sprintf( buf, "You are being targetted by %s.", ship->name );
space.c~:               if( !str_cmp( ship->owner, "The New Republic" ) )
space.c~:                  for( target = first_ship; target; target = target->next )
space.c~:                     if( ship->starsystem == target->starsystem )
space.c~:                        if( !str_cmp( target->owner, "The Empire" ) )
space.c~:                           sprintf( buf, "You are being targetted by %s.", ship->name );
space.c~:                           ship->target0 = target;
space.c~:               if( !str_cmp( ship->owner, "Pirates" ) )
space.c~:                  for( target = first_ship; target; target = target->next )
space.c~:                     if( ship->starsystem == target->starsystem )
space.c~:                        sprintf( buf, "You are being targetted by %s.", ship->name );
space.c~:                        ship->target0 = target;
space.c~:               ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c~:               ship->vx = number_range( -5000, 5000 );
space.c~:               ship->vy = number_range( -5000, 5000 );
space.c~:               ship->hx = 1;
space.c~:               ship->hy = 1;
space.c~:      if( ( ship->ship_class == CAPITAL_SHIP
space.c~:	    || ship->ship_class == SHIP_PLATFORM ) && ship->target0 == NULL )
space.c~:         if( ship->missiles < ship->maxmissiles )
space.c~:            ship->missiles++;
space.c~:         if( ship->torpedos < ship->maxtorpedos )
space.c~:            ship->torpedos++;
space.c~:         if( ship->rockets < ship->maxrockets )
space.c~:            ship->rockets++;
space.c~:   for( tstarsystem = first_starsystem; tstarsystem; tstarsystem = tstarsystem->next )
space.c~:      fprintf( fpout, "%s\n", tstarsystem->filename );
space.c~:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c~:      if( !str_cmp( name, starsystem->name ) )
space.c~:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c~:      if( !str_prefix( name, starsystem->name ) )
space.c~:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c~:      if( vnum == starsystem->doc1a || vnum == starsystem->doc2a || vnum == starsystem->doc3a ||
space.c~:          vnum == starsystem->doc1b || vnum == starsystem->doc2b || vnum == starsystem->doc3b ||
space.c~:          vnum == starsystem->doc1c || vnum == starsystem->doc2c || vnum == starsystem->doc3c )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->hanger )
space.c~:         return ship->starsystem;
space.c~:   if( !starsystem->filename || starsystem->filename[0] == '\0' )
space.c~:      sprintf( buf, "save_starsystem: %s has no filename", starsystem->name );
space.c~:   sprintf( filename, "%s%s", SPACE_DIR, starsystem->filename );
space.c~:      fprintf( fp, "Name         %s~\n", starsystem->name );
space.c~:      fprintf( fp, "Filename     %s~\n", starsystem->filename );
space.c~:      fprintf( fp, "Planet1      %s~\n", starsystem->planet1 );
space.c~:      fprintf( fp, "Planet2      %s~\n", starsystem->planet2 );
space.c~:      fprintf( fp, "Planet3      %s~\n", starsystem->planet3 );
space.c~:      fprintf( fp, "Star1        %s~\n", starsystem->star1 );
space.c~:      fprintf( fp, "Star2        %s~\n", starsystem->star2 );
space.c~:      fprintf( fp, "Location1a      %s~\n", starsystem->location1a );
space.c~:      fprintf( fp, "Location1b      %s~\n", starsystem->location1b );
space.c~:      fprintf( fp, "Location1c      %s~\n", starsystem->location1c );
space.c~:      fprintf( fp, "Location2a       %s~\n", starsystem->location2a );
space.c~:      fprintf( fp, "Location2b      %s~\n", starsystem->location2b );
space.c~:      fprintf( fp, "Location2c      %s~\n", starsystem->location2c );
space.c~:      fprintf( fp, "Location3a      %s~\n", starsystem->location3a );
space.c~:      fprintf( fp, "Location3b      %s~\n", starsystem->location3b );
space.c~:      fprintf( fp, "Location3c      %s~\n", starsystem->location3c );
space.c~:      fprintf( fp, "Doc1a          %d\n", starsystem->doc1a );
space.c~:      fprintf( fp, "Doc2a          %d\n", starsystem->doc2a );
space.c~:      fprintf( fp, "Doc3a          %d\n", starsystem->doc3a );
space.c~:      fprintf( fp, "Doc1b          %d\n", starsystem->doc1b );
space.c~:      fprintf( fp, "Doc2b          %d\n", starsystem->doc2b );
space.c~:      fprintf( fp, "Doc3b          %d\n", starsystem->doc3b );
space.c~:      fprintf( fp, "Doc1c          %d\n", starsystem->doc1c );
space.c~:      fprintf( fp, "Doc2c          %d\n", starsystem->doc2c );
space.c~:      fprintf( fp, "Doc3c          %d\n", starsystem->doc3c );
space.c~:      fprintf( fp, "P1x          %d\n", starsystem->p1x );
space.c~:      fprintf( fp, "P1y          %d\n", starsystem->p1y );
space.c~:      fprintf( fp, "P1z          %d\n", starsystem->p1z );
space.c~:      fprintf( fp, "P2x          %d\n", starsystem->p2x );
space.c~:      fprintf( fp, "P2y          %d\n", starsystem->p2y );
space.c~:      fprintf( fp, "P2z          %d\n", starsystem->p2z );
space.c~:      fprintf( fp, "P3x          %d\n", starsystem->p3x );
space.c~:      fprintf( fp, "P3y          %d\n", starsystem->p3y );
space.c~:      fprintf( fp, "P3z          %d\n", starsystem->p3z );
space.c~:      fprintf( fp, "S1x          %d\n", starsystem->s1x );
space.c~:      fprintf( fp, "S1y          %d\n", starsystem->s1y );
space.c~:      fprintf( fp, "S1z          %d\n", starsystem->s1z );
space.c~:      fprintf( fp, "S2x          %d\n", starsystem->s2x );
space.c~:      fprintf( fp, "S2y          %d\n", starsystem->s2y );
space.c~:      fprintf( fp, "S2z          %d\n", starsystem->s2z );
space.c~:      fprintf( fp, "Gravitys1     %d\n", starsystem->gravitys1 );
space.c~:      fprintf( fp, "Gravitys2     %d\n", starsystem->gravitys2 );
space.c~:      fprintf( fp, "Gravityp1     %d\n", starsystem->gravityp1 );
space.c~:      fprintf( fp, "Gravityp2     %d\n", starsystem->gravityp2 );
space.c~:      fprintf( fp, "Gravityp3     %d\n", starsystem->gravityp3 );
space.c~:      fprintf( fp, "Xpos          %d\n", starsystem->xpos );
space.c~:      fprintf( fp, "Ypos          %d\n", starsystem->ypos );
space.c~:            KEY( "Doc1a", starsystem->doc1a, fread_number( fp ) );
space.c~:            KEY( "Doc2a", starsystem->doc2a, fread_number( fp ) );
space.c~:            KEY( "Doc3a", starsystem->doc3a, fread_number( fp ) );
space.c~:            KEY( "Doc1b", starsystem->doc1b, fread_number( fp ) );
space.c~:            KEY( "Doc2b", starsystem->doc2b, fread_number( fp ) );
space.c~:            KEY( "Doc3b", starsystem->doc3b, fread_number( fp ) );
space.c~:            KEY( "Doc1c", starsystem->doc1c, fread_number( fp ) );
space.c~:            KEY( "Doc2c", starsystem->doc2c, fread_number( fp ) );
space.c~:            KEY( "Doc3c", starsystem->doc3c, fread_number( fp ) );
space.c~:               if( !starsystem->name )
space.c~:                  starsystem->name = STRALLOC( "" );
space.c~:               if( !starsystem->location1a )
space.c~:                  starsystem->location1a = STRALLOC( "" );
space.c~:               if( !starsystem->location2a )
space.c~:                  starsystem->location2a = STRALLOC( "" );
space.c~:               if( !starsystem->location3a )
space.c~:                  starsystem->location3a = STRALLOC( "" );
space.c~:               if( !starsystem->location1b )
space.c~:                  starsystem->location1b = STRALLOC( "" );
space.c~:               if( !starsystem->location2b )
space.c~:                  starsystem->location2b = STRALLOC( "" );
space.c~:               if( !starsystem->location3b )
space.c~:                  starsystem->location3b = STRALLOC( "" );
space.c~:               if( !starsystem->location1c )
space.c~:                  starsystem->location1c = STRALLOC( "" );
space.c~:               if( !starsystem->location2c )
space.c~:                  starsystem->location2c = STRALLOC( "" );
space.c~:               if( !starsystem->location3c )
space.c~:                  starsystem->location3c = STRALLOC( "" );
space.c~:               if( !starsystem->planet1 )
space.c~:                  starsystem->planet1 = STRALLOC( "" );
space.c~:               if( !starsystem->planet2 )
space.c~:                  starsystem->planet2 = STRALLOC( "" );
space.c~:               if( !starsystem->planet3 )
space.c~:                  starsystem->planet3 = STRALLOC( "" );
space.c~:               if( !starsystem->star1 )
space.c~:                  starsystem->star1 = STRALLOC( "" );
space.c~:               if( !starsystem->star2 )
space.c~:                  starsystem->star2 = STRALLOC( "" );
space.c~:            KEY( "Filename", starsystem->filename, fread_string_nohash( fp ) );
space.c~:            KEY( "Gravitys1", starsystem->gravitys1, fread_number( fp ) );
space.c~:            KEY( "Gravitys2", starsystem->gravitys2, fread_number( fp ) );
space.c~:            KEY( "Gravityp1", starsystem->gravityp1, fread_number( fp ) );
space.c~:            KEY( "Gravityp2", starsystem->gravityp2, fread_number( fp ) );
space.c~:            KEY( "Gravityp3", starsystem->gravityp3, fread_number( fp ) );
space.c~:            KEY( "Location1a", starsystem->location1a, fread_string( fp ) );
space.c~:            KEY( "Location2a", starsystem->location2a, fread_string( fp ) );
space.c~:            KEY( "Location3a", starsystem->location3a, fread_string( fp ) );
space.c~:            KEY( "Location1b", starsystem->location1b, fread_string( fp ) );
space.c~:            KEY( "Location2b", starsystem->location2b, fread_string( fp ) );
space.c~:            KEY( "Location3b", starsystem->location3b, fread_string( fp ) );
space.c~:            KEY( "Location1c", starsystem->location1c, fread_string( fp ) );
space.c~:            KEY( "Location2c", starsystem->location2c, fread_string( fp ) );
space.c~:            KEY( "Location3c", starsystem->location3c, fread_string( fp ) );
space.c~:            KEY( "Name", starsystem->name, fread_string( fp ) );
space.c~:            KEY( "Planet1", starsystem->planet1, fread_string( fp ) );
space.c~:            KEY( "Planet2", starsystem->planet2, fread_string( fp ) );
space.c~:            KEY( "Planet3", starsystem->planet3, fread_string( fp ) );
space.c~:            KEY( "P1x", starsystem->p1x, fread_number( fp ) );
space.c~:            KEY( "P1y", starsystem->p1y, fread_number( fp ) );
space.c~:            KEY( "P1z", starsystem->p1z, fread_number( fp ) );
space.c~:            KEY( "P2x", starsystem->p2x, fread_number( fp ) );
space.c~:            KEY( "P2y", starsystem->p2y, fread_number( fp ) );
space.c~:            KEY( "P2z", starsystem->p2z, fread_number( fp ) );
space.c~:            KEY( "P3x", starsystem->p3x, fread_number( fp ) );
space.c~:            KEY( "P3y", starsystem->p3y, fread_number( fp ) );
space.c~:            KEY( "P3z", starsystem->p3z, fread_number( fp ) );
space.c~:            KEY( "Star1", starsystem->star1, fread_string( fp ) );
space.c~:            KEY( "Star2", starsystem->star2, fread_string( fp ) );
space.c~:            KEY( "S1x", starsystem->s1x, fread_number( fp ) );
space.c~:            KEY( "S1y", starsystem->s1y, fread_number( fp ) );
space.c~:            KEY( "S1z", starsystem->s1z, fread_number( fp ) );
space.c~:            KEY( "S2x", starsystem->s2x, fread_number( fp ) );
space.c~:            KEY( "S2y", starsystem->s2y, fread_number( fp ) );
space.c~:            KEY( "S2z", starsystem->s2z, fread_number( fp ) );
space.c~:            KEY( "Xpos", starsystem->xpos, fread_number( fp ) );
space.c~:            KEY( "Ypos", starsystem->ypos, fread_number( fp ) );
space.c~:      starsystem->doc1a = atoi( argument );
space.c~:      starsystem->doc1b = atoi( argument );
space.c~:      starsystem->doc1c = atoi( argument );
space.c~:      starsystem->doc2a = atoi( argument );
space.c~:      starsystem->doc2b = atoi( argument );
space.c~:      starsystem->doc2c = atoi( argument );
space.c~:      starsystem->doc3a = atoi( argument );
space.c~:      starsystem->doc3b = atoi( argument );
space.c~:      starsystem->doc3c = atoi( argument );
space.c~:      starsystem->s1x = atoi( argument );
space.c~:      starsystem->s1y = atoi( argument );
space.c~:      starsystem->s1z = atoi( argument );
space.c~:      starsystem->s2x = atoi( argument );
space.c~:      starsystem->s2y = atoi( argument );
space.c~:      starsystem->s2z = atoi( argument );
space.c~:      starsystem->p1x = atoi( argument );
space.c~:      starsystem->p1y = atoi( argument );
space.c~:      starsystem->p1z = atoi( argument );
space.c~:      starsystem->p2x = atoi( argument );
space.c~:      starsystem->p2y = atoi( argument );
space.c~:      starsystem->p2z = atoi( argument );
space.c~:      starsystem->p3x = atoi( argument );
space.c~:      starsystem->p3y = atoi( argument );
space.c~:      starsystem->p3z = atoi( argument );
space.c~:      starsystem->xpos = atoi( argument );
space.c~:      starsystem->ypos = atoi( argument );
space.c~:      starsystem->gravitys1 = atoi( argument );
space.c~:      starsystem->gravitys2 = atoi( argument );
space.c~:      starsystem->gravityp1 = atoi( argument );
space.c~:      starsystem->gravityp2 = atoi( argument );
space.c~:      starsystem->gravityp3 = atoi( argument );
space.c~:      STRFREE( starsystem->name );
space.c~:      starsystem->name = STRALLOC( argument );
space.c~:      STRFREE( starsystem->star1 );
space.c~:      starsystem->star1 = STRALLOC( argument );
space.c~:      STRFREE( starsystem->star2 );
space.c~:      starsystem->star2 = STRALLOC( argument );
space.c~:      STRFREE( starsystem->planet1 );
space.c~:      starsystem->planet1 = STRALLOC( argument );
space.c~:      STRFREE( starsystem->planet2 );
space.c~:      starsystem->planet2 = STRALLOC( argument );
space.c~:      STRFREE( starsystem->planet3 );
space.c~:      starsystem->planet3 = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location1a );
space.c~:      starsystem->location1a = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location1b );
space.c~:      starsystem->location1b = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location1c );
space.c~:      starsystem->location1c = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location2a );
space.c~:      starsystem->location2a = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location2a );
space.c~:      starsystem->location2b = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location2c );
space.c~:      starsystem->location2c = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location3a );
space.c~:      starsystem->location3a = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location3b );
space.c~:      starsystem->location3b = STRALLOC( argument );
space.c~:      STRFREE( starsystem->location3c );
space.c~:      starsystem->location3c = STRALLOC( argument );
space.c~:              starsystem->name, starsystem->filename, starsystem->xpos, starsystem->ypos );
space.c~:              starsystem->star1, starsystem->gravitys1, starsystem->s1x, starsystem->s1y, starsystem->s1z );
space.c~:              starsystem->star2, starsystem->gravitys2, starsystem->s2x, starsystem->s2y, starsystem->s2z );
space.c~:              starsystem->planet1, starsystem->gravityp1, starsystem->p1x, starsystem->p1y, starsystem->p1z );
space.c~:   ch_printf( ch, "     Doc1a: %5d (%s)\r\n", starsystem->doc1a, starsystem->location1a );
space.c~:   ch_printf( ch, "     Doc1b: %5d (%s)\r\n", starsystem->doc1b, starsystem->location1b );
space.c~:   ch_printf( ch, "     Doc1c: %5d (%s)\r\n", starsystem->doc1c, starsystem->location1c );
space.c~:              starsystem->planet2, starsystem->gravityp2, starsystem->p2x, starsystem->p2y, starsystem->p2z );
space.c~:   ch_printf( ch, "     Doc2a: %5d (%s)\r\n", starsystem->doc2a, starsystem->location2a );
space.c~:   ch_printf( ch, "     Doc2b: %5d (%s)\r\n", starsystem->doc2b, starsystem->location2b );
space.c~:   ch_printf( ch, "     Doc2c: %5d (%s)\r\n", starsystem->doc2c, starsystem->location2c );
space.c~:              starsystem->planet3, starsystem->gravityp3, starsystem->p3x, starsystem->p3y, starsystem->p3z );
space.c~:   ch_printf( ch, "     Doc3a: %5d (%s)\r\n", starsystem->doc3a, starsystem->location3a );
space.c~:   ch_printf( ch, "     Doc3b: %5d (%s)\r\n", starsystem->doc3b, starsystem->location3b );
space.c~:   ch_printf( ch, "     Doc3c: %5d (%s)\r\n", starsystem->doc3c, starsystem->location3c );
space.c~:   starsystem->name = STRALLOC( argument );
space.c~:   starsystem->location1a = STRALLOC( "" );
space.c~:   starsystem->location2a = STRALLOC( "" );
space.c~:   starsystem->location3a = STRALLOC( "" );
space.c~:   starsystem->location1b = STRALLOC( "" );
space.c~:   starsystem->location2b = STRALLOC( "" );
space.c~:   starsystem->location3b = STRALLOC( "" );
space.c~:   starsystem->location1c = STRALLOC( "" );
space.c~:   starsystem->location2c = STRALLOC( "" );
space.c~:   starsystem->location3c = STRALLOC( "" );
space.c~:   starsystem->planet1 = STRALLOC( "" );
space.c~:   starsystem->planet2 = STRALLOC( "" );
space.c~:   starsystem->planet3 = STRALLOC( "" );
space.c~:   starsystem->star1 = STRALLOC( "" );
space.c~:   starsystem->star2 = STRALLOC( "" );
space.c~:   starsystem->filename = str_dup( filename );
space.c~:   for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c~:      ch_printf( ch, "%s\r\n", starsystem->name );
space.c~:   for( room = ship->firstroom; room <= ship->lastroom; room++ )
space.c~:   for( roomnum = ship->firstroom; roomnum <= ship->lastroom; roomnum++ )
space.c~:      for( vic = room->first_person; vic; vic = vic->next_in_room )
space.c~:         if( !IS_NPC( vic ) && IS_SET( vic->act, PLR_SOUND ) )
space.c~:   for( room = ship->firstroom; room <= ship->lastroom; room++ )
space.c~:      if( room == ship->cockpit || room == ship->navseat
space.c~:          || room == ship->pilotseat || room == ship->coseat
space.c~:          || room == ship->gunseat || room == ship->engineroom || room == ship->turret1 || room == ship->turret2 )
space.c~:   if( !ship->starsystem )
space.c~:   for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:     headingtotarget = coordpairtoheading(ship->vx,ship->vy,target->vx,target->vy);
space.c~:     if( abs( headingtotarget - ship->heading ) <  PI / 2) //180 degrees
space.c~:   hx = ship->hx;
space.c~:   hy = ship->hy;
space.c~:   dx = target->vx - ship->vx;
space.c~:   dy = target->vy - ship->vy;
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   else if( ship->ship_class == MIDSIZE_SHIP )
space.c~:   else if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ship->ship_class <= CAPITAL_SHIP )
space.c~:      price += ( ship->manuever * 100 * ( 1 + ship->ship_class ) );
space.c~:   price += ( ship->tractorbeam * 100 );
space.c~:   price += ( ship->realspeed * 10 );
space.c~:   price += ( ship->astro_array * 5 );
space.c~:   price += ( 5 * ship->maxhull );
space.c~:   price += ( 2 * ship->maxenergy );
space.c~:   price += ( 100 * ship->maxchaff );
space.c~:   if( ship->maxenergy > 5000 )
space.c~:      price += ( ( ship->maxenergy - 5000 ) * 20 );
space.c~:   if( ship->maxenergy > 10000 )
space.c~:      price += ( ( ship->maxenergy - 10000 ) * 50 );
space.c~:   if( ship->maxhull > 1000 )
space.c~:      price += ( ( ship->maxhull - 1000 ) * 10 );
space.c~:   if( ship->maxhull > 10000 )
space.c~:      price += ( ( ship->maxhull - 10000 ) * 20 );
space.c~:   if( ship->maxshield > 200 )
space.c~:      price += ( ( ship->maxshield - 200 ) * 50 );
space.c~:   if( ship->maxshield > 1000 )
space.c~:      price += ( ( ship->maxshield - 1000 ) * 100 );
space.c~:   if( ship->realspeed > 100 )
space.c~:      price += ( ( ship->realspeed - 100 ) * 500 );
space.c~:   if( ship->lasers > 5 )
space.c~:      price += ( ( ship->lasers - 5 ) * 500 );
space.c~:   if( ship->maxshield )
space.c~:      price += ( 1000 + 10 * ship->maxshield );
space.c~:   if( ship->lasers )
space.c~:      price += ( 500 + 500 * ship->lasers );
space.c~:   if( ship->maxmissiles )
space.c~:      price += ( 1000 + 100 * ship->maxmissiles );
space.c~:   if( ship->maxrockets )
space.c~:      price += ( 2000 + 200 * ship->maxmissiles );
space.c~:   if( ship->maxtorpedos )
space.c~:      price += ( 1500 + 150 * ship->maxmissiles );
space.c~:   if( ship->missiles )
space.c~:      price += ( 250 * ship->missiles );
space.c~:   else if( ship->torpedos )
space.c~:      price += ( 500 * ship->torpedos );
space.c~:   else if( ship->rockets )
space.c~:      price += ( 1000 * ship->rockets );
space.c~:   if( ship->turret1 )
space.c~:   if( ship->turret2 )
space.c~:   if( ship->hyperspeed )
space.c~:      price += ( 1000 + ship->hyperspeed * 10 );
space.c~:   if( ship->hanger )
space.c~:      price += ( ship->ship_class == MIDSIZE_SHIP ? 50000 : 100000 );
space.c~:   for( tship = first_ship; tship; tship = tship->next )
space.c~:      fprintf( fpout, "%s\n", tship->filename );
space.c~:   for( ship = room->first_ship; ship; ship = ship->next_in_room )
space.c~:      if( !str_cmp( name, ship->name ) )
space.c~:   for( ship = room->first_ship; ship; ship = ship->next_in_room )
space.c~:      if( nifty_is_name_prefix( name, ship->name ) )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( !str_cmp( name, ship->name ) )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( nifty_is_name_prefix( name, ship->name ) )
space.c~:   for( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
space.c~:      if( !str_cmp( name, ship->name ) )
space.c~:   for( ship = starsystem->first_ship; ship; ship = ship->next_in_starsystem )
space.c~:      if( nifty_is_name_prefix( name, ship->name ) )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( !str_cmp( name, ship->pilot ) )
space.c~:   if( !str_cmp( name, ship->copilot ) )
space.c~:   if( !str_cmp( name, ship->owner ) )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->cockpit || vnum == ship->turret1 || vnum == ship->turret2
space.c~:          || vnum == ship->pilotseat || vnum == ship->coseat || vnum == ship->navseat
space.c~:          || vnum == ship->gunseat || vnum == ship->engineroom )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->pilotseat )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->coseat )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->navseat )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->gunseat )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->engineroom )
space.c~:         if( vnum == ship->engineroom )
space.c~:         if( vnum == ship->cockpit )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->gunseat || vnum == ship->turret1 || vnum == ship->turret2 )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->entrance )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( vnum == ship->hanger )
space.c~:   if( !ship->filename || ship->filename[0] == '\0' )
space.c~:      sprintf( buf, "save_ship: %s has no filename", ship->name );
space.c~:   sprintf( filename, "%s%s", SHIP_DIR, ship->filename );
space.c~:      fprintf( fp, "Name         %s~\n", ship->name );
space.c~:      fprintf( fp, "Filename     %s~\n", ship->filename );
space.c~:      fprintf( fp, "Description  %s~\n", ship->description );
space.c~:      fprintf( fp, "Owner        %s~\n", ship->owner );
space.c~:      fprintf( fp, "Pilot        %s~\n", ship->pilot );
space.c~:      fprintf( fp, "Copilot      %s~\n", ship->copilot );
space.c~:      fprintf( fp, "Class        %d\n", ship->ship_class );
space.c~:      fprintf( fp, "Tractorbeam  %d\n", ship->tractorbeam );
space.c~:      fprintf( fp, "Shipyard     %d\n", ship->shipyard );
space.c~:      fprintf( fp, "Hanger       %d\n", ship->hanger );
space.c~:      fprintf( fp, "Turret1      %d\n", ship->turret1 );
space.c~:      fprintf( fp, "Turret2      %d\n", ship->turret2 );
space.c~:      fprintf( fp, "Statet0      %d\n", ship->statet0 );
space.c~:      fprintf( fp, "Statet1      %d\n", ship->statet1 );
space.c~:      fprintf( fp, "Statet2      %d\n", ship->statet2 );
space.c~:      fprintf( fp, "Lasers       %d\n", ship->lasers );
space.c~:      fprintf( fp, "Missiles     %d\n", ship->missiles );
space.c~:      fprintf( fp, "Maxmissiles  %d\n", ship->maxmissiles );
space.c~:      fprintf( fp, "Rockets     %d\n", ship->rockets );
space.c~:      fprintf( fp, "Maxrockets  %d\n", ship->maxrockets );
space.c~:      fprintf( fp, "Torpedos     %d\n", ship->torpedos );
space.c~:      fprintf( fp, "Maxtorpedos  %d\n", ship->maxtorpedos );
space.c~:      fprintf( fp, "Lastdoc      %d\n", ship->lastdoc );
space.c~:      fprintf( fp, "Firstroom    %d\n", ship->firstroom );
space.c~:      fprintf( fp, "Lastroom     %d\n", ship->lastroom );
space.c~:      fprintf( fp, "Shield       %d\n", ship->shield );
space.c~:      fprintf( fp, "Maxshield    %d\n", ship->maxshield );
space.c~:      fprintf( fp, "Hull         %d\n", ship->hull );
space.c~:      fprintf( fp, "Maxhull      %d\n", ship->maxhull );
space.c~:      fprintf( fp, "Maxenergy    %d\n", ship->maxenergy );
space.c~:      fprintf( fp, "Hyperspeed   %d\n", ship->hyperspeed );
space.c~:      fprintf( fp, "Comm         %d\n", ship->comm );
space.c~:      fprintf( fp, "Chaff        %d\n", ship->chaff );
space.c~:      fprintf( fp, "Maxchaff     %d\n", ship->maxchaff );
space.c~:      fprintf( fp, "Sensor       %d\n", ship->sensor );
space.c~:      fprintf( fp, "Astro_array  %d\n", ship->astro_array );
space.c~:      fprintf( fp, "Realspeed    %d\n", ship->realspeed );
space.c~:      fprintf( fp, "Type         %d\n", ship->type );
space.c~:      fprintf( fp, "Cockpit      %d\n", ship->cockpit );
space.c~:      fprintf( fp, "Coseat       %d\n", ship->coseat );
space.c~:      fprintf( fp, "Pilotseat    %d\n", ship->pilotseat );
space.c~:      fprintf( fp, "Gunseat      %d\n", ship->gunseat );
space.c~:      fprintf( fp, "Navseat      %d\n", ship->navseat );
space.c~:      fprintf( fp, "Engineroom   %d\n", ship->engineroom );
space.c~:      fprintf( fp, "Entrance     %d\n", ship->entrance );
space.c~:      fprintf( fp, "Shipstate    %d\n", ship->shipstate );
space.c~:      fprintf( fp, "Missilestate %d\n", ship->missilestate );
space.c~:      fprintf( fp, "Energy       %d\n", ship->energy );
space.c~:      fprintf( fp, "Manuever     %d\n", ship->manuever );
space.c~:      fprintf( fp, "Home         %s~\n", ship->home );
space.c~:            KEY( "Astro_array", ship->astro_array, fread_number( fp ) );
space.c~:            KEY( "Cockpit", ship->cockpit, fread_number( fp ) );
space.c~:            KEY( "Coseat", ship->coseat, fread_number( fp ) );
space.c~:            KEY( "Class", ship->ship_class, fread_number( fp ) );
space.c~:            KEY( "Copilot", ship->copilot, fread_string( fp ) );
space.c~:            KEY( "Comm", ship->comm, fread_number( fp ) );
space.c~:            KEY( "Chaff", ship->chaff, fread_number( fp ) );
space.c~:            KEY( "Description", ship->description, fread_string( fp ) );
space.c~:            KEY( "Engineroom", ship->engineroom, fread_number( fp ) );
space.c~:            KEY( "Entrance", ship->entrance, fread_number( fp ) );
space.c~:            KEY( "Energy", ship->energy, fread_number( fp ) );
space.c~:               if( !ship->home )
space.c~:                  ship->home = STRALLOC( "" );
space.c~:               if( !ship->name )
space.c~:                  ship->name = STRALLOC( "" );
space.c~:               if( !ship->owner )
space.c~:                  ship->owner = STRALLOC( "" );
space.c~:               if( !ship->description )
space.c~:                  ship->description = STRALLOC( "" );
space.c~:               if( !ship->copilot )
space.c~:                  ship->copilot = STRALLOC( "" );
space.c~:               if( !ship->pilot )
space.c~:                  ship->pilot = STRALLOC( "" );
space.c~:               if( ship->shipstate != SHIP_DISABLED )
space.c~:                  ship->shipstate = SHIP_DOCKED;
space.c~:               if( ship->statet0 != LASER_DAMAGED )
space.c~:                  ship->statet0 = LASER_READY;
space.c~:               if( ship->statet1 != LASER_DAMAGED )
space.c~:                  ship->statet1 = LASER_READY;
space.c~:               if( ship->statet2 != LASER_DAMAGED )
space.c~:                  ship->statet2 = LASER_READY;
space.c~:               if( ship->missilestate != MISSILE_DAMAGED )
space.c~:                  ship->missilestate = MISSILE_READY;
space.c~:               if( ship->shipyard <= 0 )
space.c~:                  ship->shipyard = ROOM_LIMBO_SHIPYARD;
space.c~:               if( ship->lastdoc <= 0 )
space.c~:                  ship->lastdoc = ship->shipyard;
space.c~:               ship->bayopen = TRUE;
space.c~:               ship->autopilot = FALSE;
space.c~:               ship->hatchopen = FALSE;
space.c~:               if( ship->navseat <= 0 )
space.c~:                  ship->navseat = ship->cockpit;
space.c~:               if( ship->gunseat <= 0 )
space.c~:                  ship->gunseat = ship->cockpit;
space.c~:               if( ship->coseat <= 0 )
space.c~:                  ship->coseat = ship->cockpit;
space.c~:               if( ship->pilotseat <= 0 )
space.c~:                  ship->pilotseat = ship->cockpit;
space.c~:               if( ship->missiletype == 1 )
space.c~:                  ship->torpedos = ship->missiles; /* for back compatability */
space.c~:                  ship->missiles = 0;
space.c~:               ship->starsystem = NULL;
space.c~:               ship->energy = ship->maxenergy;
space.c~:               ship->hull = ship->maxhull;
space.c~:               ship->in_room = NULL;
space.c~:               ship->next_in_room = NULL;
space.c~:               ship->prev_in_room = NULL;
space.c~:            KEY( "Filename", ship->filename, fread_string_nohash( fp ) );
space.c~:            KEY( "Firstroom", ship->firstroom, fread_number( fp ) );
space.c~:            KEY( "Gunseat", ship->gunseat, fread_number( fp ) );
space.c~:            KEY( "Home", ship->home, fread_string( fp ) );
space.c~:            KEY( "Hyperspeed", ship->hyperspeed, fread_number( fp ) );
space.c~:            KEY( "Hull", ship->hull, fread_number( fp ) );
space.c~:            KEY( "Hanger", ship->hanger, fread_number( fp ) );
space.c~:            KEY( "Laserstr", ship->lasers, ( short )( fread_number( fp ) / 10 ) );
space.c~:            KEY( "Lasers", ship->lasers, fread_number( fp ) );
space.c~:            KEY( "Lastdoc", ship->lastdoc, fread_number( fp ) );
space.c~:            KEY( "Lastroom", ship->lastroom, fread_number( fp ) );
space.c~:            KEY( "Manuever", ship->manuever, fread_number( fp ) );
space.c~:            KEY( "Maxmissiles", ship->maxmissiles, fread_number( fp ) );
space.c~:            KEY( "Maxtorpedos", ship->maxtorpedos, fread_number( fp ) );
space.c~:            KEY( "Maxrockets", ship->maxrockets, fread_number( fp ) );
space.c~:            KEY( "Missiles", ship->missiles, fread_number( fp ) );
space.c~:            KEY( "Missiletype", ship->missiletype, fread_number( fp ) );
space.c~:            KEY( "Maxshield", ship->maxshield, fread_number( fp ) );
space.c~:            KEY( "Maxenergy", ship->maxenergy, fread_number( fp ) );
space.c~:            KEY( "Missilestate", ship->missilestate, fread_number( fp ) );
space.c~:            KEY( "Maxhull", ship->maxhull, fread_number( fp ) );
space.c~:            KEY( "Maxchaff", ship->maxchaff, fread_number( fp ) );
space.c~:            KEY( "Name", ship->name, fread_string( fp ) );
space.c~:            KEY( "Navseat", ship->navseat, fread_number( fp ) );
space.c~:            KEY( "Owner", ship->owner, fread_string( fp ) );
space.c~:            KEY( "Pilot", ship->pilot, fread_string( fp ) );
space.c~:            KEY( "Pilotseat", ship->pilotseat, fread_number( fp ) );
space.c~:            KEY( "Realspeed", ship->realspeed, fread_number( fp ) );
space.c~:            KEY( "Rockets", ship->rockets, fread_number( fp ) );
space.c~:            KEY( "Shipyard", ship->shipyard, fread_number( fp ) );
space.c~:            KEY( "Sensor", ship->sensor, fread_number( fp ) );
space.c~:            KEY( "Shield", ship->shield, fread_number( fp ) );
space.c~:            KEY( "Shipstate", ship->shipstate, fread_number( fp ) );
space.c~:            KEY( "Statet0", ship->statet0, fread_number( fp ) );
space.c~:            KEY( "Statet1", ship->statet1, fread_number( fp ) );
space.c~:            KEY( "Statet2", ship->statet2, fread_number( fp ) );
space.c~:            KEY( "Type", ship->type, fread_number( fp ) );
space.c~:            KEY( "Tractorbeam", ship->tractorbeam, fread_number( fp ) );
space.c~:            KEY( "Turret1", ship->turret1, fread_number( fp ) );
space.c~:            KEY( "Turret2", ship->turret2, fread_number( fp ) );
space.c~:            KEY( "Torpedos", ship->torpedos, fread_number( fp ) );
space.c~:      if( !str_cmp( "Public", ship->owner ) || ship->type == MOB_SHIP )
space.c~:	if( ship->ship_class != SHIP_PLATFORM && ship->type != MOB_SHIP && ship->ship_class != CAPITAL_SHIP )
space.c~:            ship_to_room( ship, ship->shipyard );
space.c~:            ship->location = ship->shipyard;
space.c~:            ship->lastdoc = ship->shipyard;
space.c~:            ship->shipstate = SHIP_DOCKED;
space.c~:         ship->currspeed = 0;
space.c~:         ship->energy = ship->maxenergy;
space.c~:         ship->chaff = ship->maxchaff;
space.c~:         ship->hull = ship->maxhull;
space.c~:         ship->shield = 0;
space.c~:         ship->statet1 = LASER_READY;
space.c~:         ship->statet2 = LASER_READY;
space.c~:         ship->statet0 = LASER_READY;
space.c~:         ship->missilestate = LASER_READY;
space.c~:         ship->currjump = NULL;
space.c~:         ship->target0 = NULL;
space.c~:         ship->target1 = NULL;
space.c~:         ship->target2 = NULL;
space.c~:	 ship->track0  = NULL;
space.c~:         ship->hatchopen = FALSE;
space.c~:         ship->bayopen = TRUE;
space.c~:         ship->missiles = ship->maxmissiles;
space.c~:         ship->torpedos = ship->maxtorpedos;
space.c~:         ship->rockets = ship->maxrockets;
space.c~:         ship->autorecharge = FALSE;
space.c~:         ship->autotrack = FALSE;
space.c~:         ship->autospeed = FALSE;
space.c~:	 ship->flightflags = 0;
space.c~:      else if( ship->cockpit == ROOM_SHUTTLE_BUS ||
space.c~:               ship->cockpit == ROOM_SHUTTLE_BUS_2 ||
space.c~:               ship->cockpit == ROOM_SENATE_SHUTTLE ||
space.c~:               ship->cockpit == ROOM_CORUSCANT_TURBOCAR || ship->cockpit == ROOM_CORUSCANT_SHUTTLE )
space.c~:      else if( ( pRoomIndex = get_room_index( ship->lastdoc ) ) != NULL
space.c~:               && ship->ship_class != CAPITAL_SHIP
space.c~:	       && ship->ship_class != SHIP_PLATFORM )
space.c~:         LINK( ship, pRoomIndex->first_ship, pRoomIndex->last_ship, next_in_room, prev_in_room );
space.c~:         ship->in_room = pRoomIndex;
space.c~:         ship->location = ship->lastdoc;
space.c~:      if( ship->ship_class == SHIP_PLATFORM
space.c~:	  || ship->type == MOB_SHIP || ship->ship_class == CAPITAL_SHIP )
space.c~:         ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c~:         ship->vx = number_range( -5000, 5000 );
space.c~:         ship->vy = number_range( -5000, 5000 );
space.c~:         ship->hx = 1;
space.c~:         ship->hy = 1;
space.c~:	 ship->heading = 0;
space.c~:	 ship->prevheading = 0;
space.c~:	 ship->turnarc = 0;
space.c~:         ship->shipstate = SHIP_READY;
space.c~:         ship->autopilot = TRUE;
space.c~:         ship->autorecharge = TRUE;
space.c~:         ship->shield = ship->maxshield;
space.c~:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c~:	if( ship->ship_class <= SHIP_PLATFORM )
space.c~:            clan->spacecraft++;
space.c~:            clan->vehicles++;
space.c~:   ship->shipstate = SHIP_READY;
space.c~:   if( ship->ship_class != SHIP_PLATFORM && ship->type != MOB_SHIP )
space.c~:      ship_to_room( ship, ship->shipyard );
space.c~:      ship->location = ship->shipyard;
space.c~:      ship->lastdoc = ship->shipyard;
space.c~:      ship->shipstate = SHIP_DOCKED;
space.c~:   if( ship->starsystem )
space.c~:      ship_from_starsystem( ship, ship->starsystem );
space.c~:   ship->currspeed = 0;
space.c~:   ship->energy = ship->maxenergy;
space.c~:   ship->chaff = ship->maxchaff;
space.c~:   ship->hull = ship->maxhull;
space.c~:   ship->shield = 0;
space.c~:   ship->statet1 = LASER_READY;
space.c~:   ship->statet2 = LASER_READY;
space.c~:   ship->statet0 = LASER_READY;
space.c~:   ship->missilestate = LASER_READY;
space.c~:   ship->currjump = NULL;
space.c~:   ship->target0 = NULL;
space.c~:   ship->target1 = NULL;
space.c~:   ship->target2 = NULL;
space.c~:   ship->track0 = NULL;
space.c~:   ship->heading = 0;
space.c~:   ship->prevheading = 0;
space.c~:   ship->turnarc = 0;
space.c~:   ship->hatchopen = FALSE;
space.c~:   ship->bayopen = TRUE;
space.c~:   ship->missiles = ship->maxmissiles;
space.c~:   ship->torpedos = ship->maxtorpedos;
space.c~:   ship->rockets = ship->maxrockets;
space.c~:   ship->autorecharge = FALSE;
space.c~:   ship->autotrack = FALSE;
space.c~:   ship->autospeed = FALSE;
space.c~:   ship->flightflags = 0;
space.c~:   if( str_cmp( "Public", ship->owner ) && ship->type != MOB_SHIP )
space.c~:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c~:	if( ship->ship_class <= SHIP_PLATFORM )
space.c~:	  clan->spacecraft--;
space.c~:	  clan->vehicles--;
space.c~:      STRFREE( ship->owner );
space.c~:      ship->owner = STRALLOC( "" );
space.c~:      STRFREE( ship->pilot );
space.c~:      ship->pilot = STRALLOC( "" );
space.c~:      STRFREE( ship->copilot );
space.c~:      ship->copilot = STRALLOC( "" );
space.c~:   if( ship->type == SHIP_REPUBLIC || ( ship->type == MOB_SHIP && !str_cmp( ship->owner, "the new republic" ) ) )
space.c~:      STRFREE( ship->home );
space.c~:      ship->home = STRALLOC( "coruscant" );
space.c~:   else if( ship->type == SHIP_IMPERIAL || ( ship->type == MOB_SHIP && !str_cmp( ship->owner, "the empire" ) ) )
space.c~:      STRFREE( ship->home );
space.c~:      ship->home = STRALLOC( "byss" );
space.c~:   else if( ship->type == SHIP_CIVILIAN )
space.c~:      STRFREE( ship->home );
space.c~:      ship->home = STRALLOC( "corperate" );
space.c~:   if( ( ship->ship_class == SHIP_PLATFORM || ship->type == MOB_SHIP || ship->ship_class == CAPITAL_SHIP ) && ship->home )
space.c~:      ship_to_starsystem( ship, starsystem_from_name( ship->home ) );
space.c~:      ship->vx = number_range( -5000, 5000 );
space.c~:      ship->vy = number_range( -5000, 5000 );
space.c~:      ship->shipstate = SHIP_READY;
space.c~:      ship->autopilot = TRUE;
space.c~:      ship->autorecharge = TRUE;
space.c~:      ship->shield = ship->maxshield;
space.c~:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c~:	if( ship->ship_class <= SHIP_PLATFORM )
space.c~:	  clan->spacecraft--;
space.c~:	  clan->vehicles--;
space.c~:      STRFREE( ship->owner );
space.c~:      ship->owner = STRALLOC( argument );
space.c~:      if( ship->type != MOB_SHIP && ( clan = get_clan( ship->owner ) ) != NULL )
space.c~:	if( ship->ship_class <= SHIP_PLATFORM )
space.c~:	  clan->spacecraft++;
space.c~:	  clan->vehicles++;
space.c~:      STRFREE( ship->home );
space.c~:      ship->home = STRALLOC( argument );
space.c~:      STRFREE( ship->pilot );
space.c~:      ship->pilot = STRALLOC( argument );
space.c~:      STRFREE( ship->copilot );
space.c~:      ship->copilot = STRALLOC( argument );
space.c~:      ship->firstroom = tempnum;
space.c~:      ship->lastroom = tempnum;
space.c~:      ship->cockpit = tempnum;
space.c~:      ship->coseat = tempnum;
space.c~:      ship->pilotseat = tempnum;
space.c~:      ship->gunseat = tempnum;
space.c~:      ship->navseat = tempnum;
space.c~:      ship->entrance = tempnum;
space.c~:      ship->turret1 = 0;
space.c~:      ship->turret2 = 0;
space.c~:      ship->hanger = 0;
space.c~:      if( tempnum < ship->firstroom )
space.c~:      if( ship->ship_class == FIGHTER_SHIP
space.c~:	  && ( tempnum - ship->firstroom ) > 5 )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP
space.c~:	  && ( tempnum - ship->firstroom ) > 25 )
space.c~:      if( ship->ship_class == CAPITAL_SHIP
space.c~:	  && ( tempnum - ship->firstroom ) > 100 )
space.c~:      ship->lastroom = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->cockpit = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->pilotseat = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->coseat = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->navseat = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->gunseat = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      ship->entrance = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c~:          tempnum == ship->turret2 || tempnum == ship->hanger || tempnum == ship->engineroom )
space.c~:      ship->turret1 = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c~:          tempnum == ship->turret1 || tempnum == ship->hanger || tempnum == ship->engineroom )
space.c~:      ship->turret2 = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c~:          tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->engineroom )
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      ship->hanger = tempnum;
space.c~:      if( tempnum < ship->firstroom || tempnum > ship->lastroom )
space.c~:      if( tempnum == ship->cockpit || tempnum == ship->entrance ||
space.c~:          tempnum == ship->turret1 || tempnum == ship->turret2 || tempnum == ship->hanger )
space.c~:      ship->engineroom = tempnum;
space.c~:      ship->shipyard = tempnum;
space.c~:         ship->type = SHIP_REPUBLIC;
space.c~:         ship->type = SHIP_IMPERIAL;
space.c~:         ship->type = SHIP_CIVILIAN;
space.c~:         ship->type = MOB_SHIP;
space.c~:      STRFREE( ship->name );
space.c~:      ship->name = STRALLOC( argument );
space.c~:      DISPOSE( ship->filename );
space.c~:      ship->filename = str_dup( argument );
space.c~:      STRFREE( ship->description );
space.c~:      ship->description = STRALLOC( argument );
space.c~:      ship->manuever = URANGE( 0, atoi( argument ), 120 );
space.c~:      ship->lasers = URANGE( 0, atoi( argument ), 10 );
space.c~:     ship->ship_class = URANGE( 0, atoi( argument ), 9 );
space.c~:      ship->maxmissiles = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->missiles = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->maxtorpedos = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->torpedos = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->maxrockets = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->rockets = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->realspeed = URANGE( 0, atoi( argument ), 150 );
space.c~:      ship->tractorbeam = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->hyperspeed = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->maxshield = URANGE( 0, atoi( argument ), 1000 );
space.c~:      ship->hull = URANGE( 1, atoi( argument ), 20000 );
space.c~:      ship->maxhull = URANGE( 1, atoi( argument ), 20000 );
space.c~:      ship->energy = URANGE( 1, atoi( argument ), 30000 );
space.c~:      ship->maxenergy = URANGE( 1, atoi( argument ), 30000 );
space.c~:      ship->sensor = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->astro_array = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->comm = URANGE( 0, atoi( argument ), 255 );
space.c~:      ship->chaff = URANGE( 0, atoi( argument ), 25 );
space.c~:      ship->maxchaff = URANGE( 0, atoi( argument ), 25 );
space.c~:              ship->type == SHIP_REPUBLIC ? "New Republic" :
space.c~:              ( ship->type == SHIP_IMPERIAL ? "Imperial" :
space.c~:                ( ship->type == SHIP_CIVILIAN ? "Civilian" : "Mob" ) ),
space.c~:              ship->ship_class == FIGHTER_SHIP ? "Starfighter" :
space.c~:              ( ship->ship_class == MIDSIZE_SHIP ? "Midship" :
space.c~:                ( ship->ship_class == CAPITAL_SHIP ? "Capital Ship" :
space.c~:                  ( ship->ship_class == SHIP_PLATFORM ? "Platform" :
space.c~:                    ( ship->ship_class == CLOUD_CAR ? "Cloudcar" :
space.c~:                      ( ship->ship_class == OCEAN_SHIP ? "Boat" :
space.c~:                        ( ship->ship_class == LAND_SPEEDER ? "Speeder" :
space.c~:                          ( ship->ship_class == WHEELED ? "Wheeled Transport" :
space.c~:                            ( ship->ship_class == LAND_CRAWLER ? "Crawler" :
space.c~:                              ( ship->ship_class == WALKER ? "Walker" : "Unknown" ) ) ) ) ) ) ) ) ), ship->name, ship->filename );
space.c~:              ship->home, ship->description, ship->owner, ship->pilot, ship->copilot );
space.c~:   ch_printf( ch, "Firstroom: %d   Lastroom: %d", ship->firstroom, ship->lastroom );
space.c~:              ship->cockpit, ship->entrance, ship->hanger, ship->engineroom );
space.c~:              ship->pilotseat, ship->coseat, ship->navseat, ship->gunseat );
space.c~:   ch_printf( ch, "Location: %d   Lastdoc: %d   Shipyard: %d\r\n", ship->location, ship->lastdoc, ship->shipyard );
space.c~:              ship->tractorbeam, ship->comm, ship->sensor, ship->astro_array );
space.c~:   ch_printf( ch, "Lasers: %d  Laser Condition: %s\r\n", ship->lasers, ship->statet0 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c~:   ch_printf( ch, "Turret One: %d  Condition: %s\r\n", ship->turret1, ship->statet1 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c~:   ch_printf( ch, "Turret Two: %d  Condition: %s\r\n", ship->turret2, ship->statet2 == LASER_DAMAGED ? "Damaged" : "Good" );
space.c~:              ship->missiles,
space.c~:              ship->maxmissiles,
space.c~:              ship->torpedos,
space.c~:              ship->maxtorpedos,
space.c~:              ship->rockets, ship->maxrockets, ship->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good" );
space.c~:              ship->hull, ship->maxhull, ship->shipstate == SHIP_DISABLED ? "Disabled" : "Running" );
space.c~:              ship->shield, ship->maxshield, ship->energy, ship->maxenergy, ship->chaff, ship->maxchaff );
space.c~:   ch_printf( ch, "Current Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy );
space.c~:   ch_printf( ch, "Current Heading: %.0f %.0f\r\n", ship->hx, ship->hy );
space.c~:              ship->currspeed, ship->realspeed, ship->hyperspeed, ship->manuever );
space.c~:   ship->name = STRALLOC( argument );
space.c~:   ship->description = STRALLOC( "" );
space.c~:   ship->owner = STRALLOC( "" );
space.c~:   ship->copilot = STRALLOC( "" );
space.c~:   ship->pilot = STRALLOC( "" );
space.c~:   ship->home = STRALLOC( "" );
space.c~:   ship->type = SHIP_CIVILIAN;
space.c~:   ship->starsystem = NULL;
space.c~:   ship->energy = ship->maxenergy;
space.c~:   ship->hull = ship->maxhull;
space.c~:   ship->in_room = NULL;
space.c~:   ship->next_in_room = NULL;
space.c~:   ship->prev_in_room = NULL;
space.c~:   ship->currjump = NULL;
space.c~:   ship->target0 = NULL;
space.c~:   ship->target1 = NULL;
space.c~:   ship->target2 = NULL;
space.c~:   ship->filename = str_dup( arg );
space.c~:   ship->name = STRALLOC( argument );
space.c~:   ship->description = STRALLOC( "" );
space.c~:   ship->owner = STRALLOC( "" );
space.c~:   ship->copilot = STRALLOC( "" );
space.c~:   ship->pilot = STRALLOC( "" );
space.c~:   ship->home = STRALLOC( "" );
space.c~:   ship->type = old->type;
space.c~:   ship->ship_class = old->ship_class;
space.c~:   ship->lasers = old->lasers;
space.c~:   ship->maxmissiles = old->maxmissiles;
space.c~:   ship->maxrockets = old->maxrockets;
space.c~:   ship->maxtorpedos = old->maxtorpedos;
space.c~:   ship->maxshield = old->maxshield;
space.c~:   ship->maxhull = old->maxhull;
space.c~:   ship->maxenergy = old->maxenergy;
space.c~:   ship->hyperspeed = old->hyperspeed;
space.c~:   ship->maxchaff = old->maxchaff;
space.c~:   ship->realspeed = old->realspeed;
space.c~:   ship->manuever = old->manuever;
space.c~:   ship->in_room = NULL;
space.c~:   ship->next_in_room = NULL;
space.c~:   ship->prev_in_room = NULL;
space.c~:   ship->currjump = NULL;
space.c~:   ship->target0 = NULL;
space.c~:   ship->target1 = NULL;
space.c~:   ship->target2 = NULL;
space.c~:   ship->filename = str_dup( arg2 );
space.c~:      for( ship = first_ship; ship; ship = ship->next )
space.c~:         if( str_cmp( ship->owner, ch->name ) )
space.c~:            if( !ch->pcdata || !ch->pcdata->clan || str_cmp( ship->owner, ch->pcdata->clan->name )
space.c~:                || ship->ship_class > SHIP_PLATFORM )
space.c~:         if( ship->type == MOB_SHIP )
space.c~:         else if( ship->type == SHIP_REPUBLIC )
space.c~:         else if( ship->type == SHIP_IMPERIAL )
space.c~:         if( ship->in_room )
space.c~:            ch_printf( ch, "%s (%s) - %s\r\n", ship->name, ship->in_room->name );
space.c~:            ch_printf( ch, "%s (%s)\r\n", ship->name );
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->location != ch->in_room->vnum
space.c~:	  || ship->ship_class > SHIP_PLATFORM )
space.c~:      if( ship->type == MOB_SHIP )
space.c~:      else if( ship->type == SHIP_REPUBLIC )
space.c~:      else if( ship->type == SHIP_IMPERIAL )
space.c~:      ch_printf( ch, "%-35s %-15s", ship->name, ship->owner );
space.c~:      if( ship->type == MOB_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c~:      if( !str_cmp( ship->owner, "Public" ) )
space.c~:      else if( str_cmp( ship->owner, "" ) )
space.c~:      for( ship = first_ship; ship; ship = ship->next )
space.c~:         if( str_cmp( ship->owner, ch->name ) )
space.c~:            if( !ch->pcdata || !ch->pcdata->clan || str_cmp( ship->owner, ch->pcdata->clan->name )
space.c~:                || ship->ship_class <= SHIP_PLATFORM )
space.c~:         if( ship->location != ch->in_room->vnum
space.c~:	     || ship->ship_class <= SHIP_PLATFORM )
space.c~:         if( ship->type == MOB_SHIP )
space.c~:         else if( ship->type == SHIP_REPUBLIC )
space.c~:         else if( ship->type == SHIP_IMPERIAL )
space.c~:         ch_printf( ch, "%-35s %-15s\r\n", ship->name, ship->owner );
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->location != ch->in_room->vnum
space.c~:	  || ship->ship_class <= SHIP_PLATFORM )
space.c~:      if( ship->type == MOB_SHIP )
space.c~:      else if( ship->type == SHIP_REPUBLIC )
space.c~:      else if( ship->type == SHIP_IMPERIAL )
space.c~:      ch_printf( ch, "%-35s %-15s", ship->name, ship->owner );
space.c~:      if( !str_cmp( ship->owner, "Public" ) )
space.c~:      else if( str_cmp( ship->owner, "" ) )
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:      if( ship->ship_class <= SHIP_PLATFORM )
space.c~:      if( ship->type == MOB_SHIP )
space.c~:      else if( ship->type == SHIP_REPUBLIC )
space.c~:      else if( ship->type == SHIP_IMPERIAL )
space.c~:      ch_printf( ch, "%-35s %-15s ", ship->name, ship->owner );
space.c~:      if( !str_cmp( ship->owner, "Public" ) )
space.c~:      else if( str_cmp( ship->owner, "" ) )
space.c~:      for( ship = first_ship; ship; ship = ship->next )
space.c~:         if( ship->type == MOB_SHIP )
space.c~:            ch_printf( ch, "&w%-35s %-15s\r\n", ship->name, ship->owner );
space.c~:   for( ship = first_ship; ship; ship = ship->next )
space.c~:     if( ship->ship_class > SHIP_PLATFORM )
space.c~:      if( ship->type == MOB_SHIP )
space.c~:      else if( ship->type == SHIP_REPUBLIC )
space.c~:      else if( ship->type == SHIP_IMPERIAL )
space.c~:      ch_printf( ch, "%-35s %-15s ", ship->name, ship->owner );
space.c~:      if( ship->type == MOB_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c~:      if( !str_cmp( ship->owner, "Public" ) )
space.c~:      else if( str_cmp( ship->owner, "" ) )
space.c~:   if( starsystem->first_ship == NULL )
space.c~:      starsystem->first_ship = ship;
space.c~:   if( starsystem->last_ship )
space.c~:      starsystem->last_ship->next_in_starsystem = ship;
space.c~:      ship->prev_in_starsystem = starsystem->last_ship;
space.c~:   starsystem->last_ship = ship;
space.c~:   ship->starsystem = starsystem;
space.c~:   if( ( starsystem = ship->starsystem ) == NULL )
space.c~:   missile->target = target;
space.c~:   missile->fired_from = ship;
space.c~:      missile->fired_by = STRALLOC( ch->name );
space.c~:      missile->fired_by = STRALLOC( "" );
space.c~:   missile->missiletype = missiletype;
space.c~:   missile->age = 0;
space.c~:   if( missile->missiletype == HEAVY_BOMB )
space.c~:      missile->speed = 20;
space.c~:   }else if( missile->missiletype == PROTON_TORPEDO )
space.c~:      missile->speed = 200;
space.c~:   }else if( missile->missiletype == CONCUSSION_MISSILE )
space.c~:      missile->speed = 500;
space.c~:      missile->turnvelocity = PI/(double)120;
space.c~:      missile->speed = 50;
space.c~:      missile->turnvelocity = PI/(double)24;
space.c~:   missile->mx = ( int ) ship->vx;
space.c~:   missile->my = ( int ) ship->vy;
space.c~:   missile->heading = ship->heading;
space.c~:   if( starsystem->first_missile == NULL )
space.c~:      starsystem->first_missile = missile;
space.c~:   if( starsystem->last_missile )
space.c~:      starsystem->last_missile->next_in_starsystem = missile;
space.c~:      missile->prev_in_starsystem = starsystem->last_missile;
space.c~:   starsystem->last_missile = missile;
space.c~:   missile->starsystem = starsystem;
space.c~:   if( starsystem->last_ship == ship )
space.c~:      starsystem->last_ship = ship->prev_in_starsystem;
space.c~:   if( starsystem->first_ship == ship )
space.c~:      starsystem->first_ship = ship->next_in_starsystem;
space.c~:   if( ship->prev_in_starsystem )
space.c~:      ship->prev_in_starsystem->next_in_starsystem = ship->next_in_starsystem;
space.c~:   if( ship->next_in_starsystem )
space.c~:      ship->next_in_starsystem->prev_in_starsystem = ship->prev_in_starsystem;
space.c~:   ship->starsystem = NULL;
space.c~:   ship->next_in_starsystem = NULL;
space.c~:   ship->prev_in_starsystem = NULL;
space.c~:   if( ( starsystem = missile->starsystem ) != NULL )
space.c~:      if( starsystem->last_missile == missile )
space.c~:         starsystem->last_missile = missile->prev_in_starsystem;
space.c~:      if( starsystem->first_missile == missile )
space.c~:         starsystem->first_missile = missile->next_in_starsystem;
space.c~:      if( missile->prev_in_starsystem )
space.c~:         missile->prev_in_starsystem->next_in_starsystem = missile->next_in_starsystem;
space.c~:      if( missile->next_in_starsystem )
space.c~:         missile->next_in_starsystem->prev_in_starsystem = missile->prev_in_starsystem;
space.c~:      missile->starsystem = NULL;
space.c~:      missile->next_in_starsystem = NULL;
space.c~:      missile->prev_in_starsystem = NULL;
space.c~:   missile->target = NULL;
space.c~:   missile->fired_from = NULL;
space.c~:   if( missile->fired_by )
space.c~:      STRFREE( missile->fired_by );
space.c~:   if( !str_cmp( "Public", ship->owner ) )
space.c~:   if( !str_cmp( ch->name, ship->owner ) || !str_cmp( ch->name, ship->pilot )
space.c~:       || !str_cmp( ch->name, ship->copilot ) || !str_cmp( "Public", ship->owner ) )
space.c~:   if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan )
space.c~:      if( !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c~:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c~:         if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c~:         if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c~:         if( ch->pcdata->bestowments && is_name( "pilot", ch->pcdata->bestowments ) )
space.c~:   if( ( room = ship->in_room ) != NULL )
space.c~:      UNLINK( ship, room->first_ship, room->last_ship, next_in_room, prev_in_room );
space.c~:      ship->in_room = NULL;
space.c~:   xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) ) / 25;
space.c~:   if( ship->shield > 0 )
space.c~:      shield_dmg = UMIN( ship->shield, sdamage );
space.c~:      sdamage -= shield_dmg;
space.c~:      ship->shield -= shield_dmg;
space.c~:      if( ship->shield == 0 )
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->shipstate != SHIP_DISABLED )
space.c~:         ship->shipstate = SHIP_DISABLED;
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Ships Missile Launcher DAMAGED!" );
space.c~:         ship->missilestate = MISSILE_DAMAGED;
space.c~:      if( number_range( 1, 100 ) <= 2 && ship->statet0 != LASER_DAMAGED )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Lasers DAMAGED!" );
space.c~:         ship->statet1 = LASER_DAMAGED;
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret1 ), "Turret DAMAGED!" );
space.c~:         ship->statet1 = LASER_DAMAGED;
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret2 ), "Turret DAMAGED!" );
space.c~:         ship->statet2 = LASER_DAMAGED;
space.c~:   ship->hull -= sdamage * 5;
space.c~:   if( ship->hull <= 0 )
space.c~:      xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) );
space.c~:   if( ship->hull <= ship->maxhull / 20 )
space.c~:   if( ship->shield > 0 )
space.c~:      shield_dmg = UMIN( ship->shield, sdamage );
space.c~:      sdamage -= shield_dmg;
space.c~:      ship->shield -= shield_dmg;
space.c~:      if( ship->shield == 0 )
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->shipstate != SHIP_DISABLED )
space.c~:         ship->shipstate = SHIP_DISABLED;
space.c~:      if( number_range( 1, 100 ) <= 5 && ship->missilestate != MISSILE_DAMAGED && ship->maxmissiles > 0 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->gunseat ), "Ships Missile Launcher DAMAGED!" );
space.c~:         ship->missilestate = MISSILE_DAMAGED;
space.c~:      if( number_range( 1, 100 ) <= 2 && ship->statet1 != LASER_DAMAGED && ship->turret1 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret1 ), "Turret DAMAGED!" );
space.c~:         ship->statet1 = LASER_DAMAGED;
space.c~:      if( number_range( 1, 100 ) <= 2 && ship->statet2 != LASER_DAMAGED && ship->turret2 )
space.c~:         echo_to_room( AT_BLOOD + AT_BLINK, get_room_index( ship->turret2 ), "Turret DAMAGED!" );
space.c~:         ship->statet2 = LASER_DAMAGED;
space.c~:   ship->hull -= sdamage * 5;
space.c~:   if( ship->hull <= 0 )
space.c~:   if( ship->hull <= ship->maxhull / 20 )
space.c~:   sprintf( buf, "%s explodes in a blinding flash of light!", ship->name );
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   for( roomnum = ship->firstroom; roomnum <= ship->lastroom; roomnum++ )
space.c~:         rch = room->first_person;
space.c~:            rch = room->first_person;
space.c~:         for( robj = room->first_content; robj; robj = robj->next_content )
space.c~:   LINK( ship, shipto->first_ship, shipto->last_ship, next_in_room, prev_in_room );
space.c~:   ship->in_room = shipto;
space.c~:   if( ( ship = ship_in_room( ch->in_room, argument ) ) == NULL )
space.c~:   if( IS_SET( ch->act, ACT_MOUNTED ) )
space.c~:   fromroom = ch->in_room;
space.c~:   if( ( toroom = get_room_index( ship->entrance ) ) != NULL )
space.c~:      if( !ship->hatchopen )
space.c~:      if( toroom->tunnel > 0 )
space.c~:         for( ctmp = toroom->first_person; ctmp; ctmp = ctmp->next_in_room )
space.c~:            if( ++count >= toroom->tunnel )
space.c~:      if( ship->shipstate == SHIP_LAUNCH || ship->shipstate == SHIP_LAUNCH_2 )
space.c~:      act( AT_PLAIN, "$n enters $T.", ch, NULL, ship->name, TO_ROOM );
space.c~:      act( AT_PLAIN, "You enter $T.", ch, NULL, ship->name, TO_CHAR );
space.c~:   if( ch->gold < price )
space.c~:   ch->gold -= price;
space.c~:   fromroom = ch->in_room;
space.c~:   if( ( ship = ship_from_entrance( fromroom->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->lastdoc != ship->location )
space.c~:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c~:   if( !ship->hatchopen )
space.c~:   if( ( toroom = get_room_index( ship->location ) ) != NULL )
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->lastdoc != ship->location )
space.c~:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c~:         if( ship->ship_class == FIGHTER_SHIP )
space.c~:         if( ship->ship_class == MIDSIZE_SHIP )
space.c~:         if( ship->ship_class == CAPITAL_SHIP )
space.c~:         price += ( ship->maxhull - ship->hull );
space.c~:         if( ship->missiles )
space.c~:            price += ( 50 * ( ship->maxmissiles - ship->missiles ) );
space.c~:         else if( ship->torpedos )
space.c~:            price += ( 75 * ( ship->maxtorpedos - ship->torpedos ) );
space.c~:         else if( ship->rockets )
space.c~:            price += ( 150 * ( ship->maxrockets - ship->rockets ) );
space.c~:         if( ship->shipstate == SHIP_DISABLED )
space.c~:         if( ship->missilestate == MISSILE_DAMAGED )
space.c~:         if( ship->statet0 == LASER_DAMAGED )
space.c~:         if( ship->statet1 == LASER_DAMAGED )
space.c~:         if( ship->statet2 == LASER_DAMAGED )
space.c~:      if( ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c~:         if( ch->pcdata->clan->funds < price )
space.c~:            ch_printf( ch, "&R%s doesn't have enough funds to prepare this ship for launch.\r\n", ch->pcdata->clan->name );
space.c~:         ch->pcdata->clan->funds -= price;
space.c~:         ch_printf( ch, "&GIt costs %s %ld credits to ready this ship for launch.\r\n", ch->pcdata->clan->name, price );
space.c~:      else if( str_cmp( ship->owner, "Public" ) )
space.c~:         if( ch->gold < price )
space.c~:         ch->gold -= price;
space.c~:      ship->energy = ship->maxenergy;
space.c~:      ship->chaff = ship->maxchaff;
space.c~:      ship->missiles = ship->maxmissiles;
space.c~:      ship->torpedos = ship->maxtorpedos;
space.c~:      ship->rockets = ship->maxrockets;
space.c~:      ship->shield = 0;
space.c~:      ship->autorecharge = FALSE;
space.c~:      ship->autotrack = FALSE;
space.c~:      ship->autospeed = FALSE;
space.c~:      ship->hull = ship->maxhull;
space.c~:      ship->missilestate = MISSILE_READY;
space.c~:      ship->statet0 = LASER_READY;
space.c~:      ship->statet1 = LASER_READY;
space.c~:      ship->statet2 = LASER_READY;
space.c~:      ship->shipstate = SHIP_DOCKED;
space.c~:      if( ship->hatchopen )
space.c~:         ship->hatchopen = FALSE;
space.c~:         sprintf( buf, "The hatch on %s closes.", ship->name );
space.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
space.c~:         sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:         sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:      sprintf( buf, "%s begins to launch.", ship->name );
space.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:      ship->shipstate = SHIP_LAUNCH;
space.c~:      ship->currspeed = ship->realspeed;
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:   ship_to_starsystem( ship, starsystem_from_vnum( ship->location ) );
space.c~:   if( ship->starsystem == NULL )
space.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Launch path blocked .. Launch aborted." );
space.c~:      sprintf( buf, "%s slowly sets back down.", ship->name );
space.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:      ship->shipstate = SHIP_DOCKED;
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      sound_to_room( get_room_index( ship->location ), "!!SOUND(falcon)" );
space.c~:   else if( ship->type == SHIP_IMPERIAL )
space.c~:      sound_to_room( get_room_index( ship->location ), "!!SOUND(tie)" );
space.c~:      sound_to_room( get_room_index( ship->location ), "!!SOUND(xwing)" );
space.c~:   ship->location = 0;
space.c~:   if( ship->shipstate != SHIP_DISABLED )
space.c~:      ship->shipstate = SHIP_READY;
space.c~:   plusminus = number_range( -1, 2 );
space.c~:      ship->hx = 1;
space.c~:      ship->hx = -1;
space.c~:   plusminus = number_range( -1, 2 );
space.c~:      ship->hy = 1;
space.c~:      ship->hy = -1;
space.c~:   if( ship->lastdoc == ship->starsystem->doc1a ||
space.c~:       ship->lastdoc == ship->starsystem->doc1b || ship->lastdoc == ship->starsystem->doc1c )
space.c~:      ship->vx = ship->starsystem->p1x;
space.c~:      ship->vy = ship->starsystem->p1y;
space.c~:   else if( ship->lastdoc == ship->starsystem->doc2a ||
space.c~:            ship->lastdoc == ship->starsystem->doc2b || ship->lastdoc == ship->starsystem->doc2c )
space.c~:      ship->vx = ship->starsystem->p2x;
space.c~:      ship->vy = ship->starsystem->p2y;
space.c~:   else if( ship->lastdoc == ship->starsystem->doc3a ||
space.c~:            ship->lastdoc == ship->starsystem->doc3b || ship->lastdoc == ship->starsystem->doc3c )
space.c~:      ship->vx = ship->starsystem->p3x;
space.c~:      ship->vy = ship->starsystem->p3y;
space.c~:      for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:         if( ship->lastdoc == target->hanger )
space.c~:            ship->vx = target->vx;
space.c~:            ship->vy = target->vy;
space.c~:   ship->energy -= ( 100 + 100 * ship->ship_class );
space.c~:   ship->vx += ( ship->hx * ship->currspeed * 2 );
space.c~:   ship->vy += ( ship->hy * ship->currspeed * 2 );
space.c~:   echo_to_room( AT_GREEN, get_room_index( ship->pilotseat ), "Launch complete.\r\n" );
space.c~:   sprintf( buf, "%s enters the starsystem at %.0f %.0f", ship->name, ship->vx, ship->vy);
space.c~:   sprintf( buf, "%s lifts off into space.", ship->name );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->lastdoc ), buf );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->shipstate != SHIP_READY )
space.c~:   if( ship->starsystem == NULL )
space.c~:   if( ship->energy < ( 25 + 25 * ship->ship_class ) )
space.c~:      if( ship->starsystem->doc1a )
space.c~:                    ship->starsystem->location1a,
space.c~:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y);
space.c~:      if( ship->starsystem->doc1b )
space.c~:                    ship->starsystem->location1b,
space.c~:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y );
space.c~:      if( ship->starsystem->doc1c )
space.c~:                    ship->starsystem->location1c,
space.c~:                    ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y);
space.c~:      if( ship->starsystem->doc2a )
space.c~:                    ship->starsystem->location2a,
space.c~:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y );
space.c~:      if( ship->starsystem->doc2b )
space.c~:                    ship->starsystem->location2b,
space.c~:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y);
space.c~:      if( ship->starsystem->doc2c )
space.c~:                    ship->starsystem->location2c,
space.c~:                    ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y);
space.c~:      if( ship->starsystem->doc3a )
space.c~:                    ship->starsystem->location3a,
space.c~:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c~:      if( ship->starsystem->doc3b )
space.c~:                    ship->starsystem->location3b,
space.c~:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c~:      if( ship->starsystem->doc3c )
space.c~:                    ship->starsystem->location3c,
space.c~:                    ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c~:      for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:         if( target->hanger > 0 && target != ship )
space.c~:            ch_printf( ch, "%s    %.0f %.0f\r\n         ", target->name, target->vx, target->vy);
space.c~:      ch_printf( ch, "\r\nYour Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy);
space.c~:   if( str_prefix( argument, ship->starsystem->location1a ) &&
space.c~:       str_prefix( argument, ship->starsystem->location2a ) &&
space.c~:       str_prefix( argument, ship->starsystem->location3a ) &&
space.c~:       str_prefix( argument, ship->starsystem->location1b ) &&
space.c~:       str_prefix( argument, ship->starsystem->location2b ) &&
space.c~:       str_prefix( argument, ship->starsystem->location3b ) &&
space.c~:       str_prefix( argument, ship->starsystem->location1c ) &&
space.c~:       str_prefix( argument, ship->starsystem->location2c ) && str_prefix( argument, ship->starsystem->location3c ) )
space.c~:      target = get_ship_here( argument, ship->starsystem );
space.c~:      if( !target->hanger )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP && target->ship_class == MIDSIZE_SHIP )
space.c~:      if( !target->bayopen )
space.c~:      if( ( target->vx > ship->vx + 200 ) || ( target->vx < ship->vx - 200 ) ||
space.c~:          ( target->vy > ship->vy + 200 ) || ( target->vy < ship->vy - 200 ) )
space.c~:      if( !str_prefix( argument, ship->starsystem->location3a ) ||
space.c~:          !str_prefix( argument, ship->starsystem->location3b ) || !str_prefix( argument, ship->starsystem->location3c ) )
space.c~:         vx = ship->starsystem->p3x;
space.c~:         vy = ship->starsystem->p3y;
space.c~:      if( !str_prefix( argument, ship->starsystem->location2a ) ||
space.c~:          !str_prefix( argument, ship->starsystem->location2b ) || !str_prefix( argument, ship->starsystem->location2c ) )
space.c~:         vx = ship->starsystem->p2x;
space.c~:         vy = ship->starsystem->p2y;
space.c~:      if( !str_prefix( argument, ship->starsystem->location1a ) ||
space.c~:          !str_prefix( argument, ship->starsystem->location1b ) || !str_prefix( argument, ship->starsystem->location1c ) )
space.c~:         vx = ship->starsystem->p1x;
space.c~:         vy = ship->starsystem->p1y;
space.c~:      if( ( vx > ship->vx + 200 ) || ( vx < ship->vx - 200 ) ||
space.c~:          ( vy > ship->vy + 200 ) || ( vy < ship->vy - 200 ) )
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c~:      if(ship->track0 != NULL)
space.c~:	    ship->track0 = NULL;
space.c~:      ship->dest = STRALLOC( arg );
space.c~:      ship->shipstate = SHIP_LAND;
space.c~:      ship->currspeed = 0;
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      if( starsystem_from_vnum( ship->lastdoc ) != ship->starsystem )
space.c~:         int xp = ( exp_level( ch->skill_level[PILOTING_ABILITY] + 1 ) - exp_level( ch->skill_level[PILOTING_ABILITY] ) );
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   if( !str_prefix( arg, ship->starsystem->location3a ) )
space.c~:      destination = ship->starsystem->doc3a;
space.c~:   if( !str_prefix( arg, ship->starsystem->location3b ) )
space.c~:      destination = ship->starsystem->doc3b;
space.c~:   if( !str_prefix( arg, ship->starsystem->location3c ) )
space.c~:      destination = ship->starsystem->doc3c;
space.c~:   if( !str_prefix( arg, ship->starsystem->location2a ) )
space.c~:      destination = ship->starsystem->doc2a;
space.c~:   if( !str_prefix( arg, ship->starsystem->location2b ) )
space.c~:      destination = ship->starsystem->doc2b;
space.c~:   if( !str_prefix( arg, ship->starsystem->location2c ) )
space.c~:      destination = ship->starsystem->doc2c;
space.c~:   if( !str_prefix( arg, ship->starsystem->location1a ) )
space.c~:      destination = ship->starsystem->doc1a;
space.c~:   if( !str_prefix( arg, ship->starsystem->location1b ) )
space.c~:      destination = ship->starsystem->doc1b;
space.c~:   if( !str_prefix( arg, ship->starsystem->location1c ) )
space.c~:      destination = ship->starsystem->doc1c;
space.c~:   target = get_ship_here( arg, ship->starsystem );
space.c~:   if( target != ship && target != NULL && target->bayopen
space.c~:       && ( ship->ship_class != MIDSIZE_SHIP || target->ship_class != MIDSIZE_SHIP ) )
space.c~:      destination = target->hanger;
space.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Could not complete aproach. Landing aborted." );
space.c~:      if( ship->shipstate != SHIP_DISABLED )
space.c~:         ship->shipstate = SHIP_READY;
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Landing sequence complete." );
space.c~:   sprintf( buf, "%s disapears from your scanner.", ship->name );
space.c~:   ship->location = destination;
space.c~:   ship->lastdoc = ship->location;
space.c~:   if( ship->shipstate != SHIP_DISABLED )
space.c~:      ship->shipstate = SHIP_DOCKED;
space.c~:   ship_from_starsystem( ship, ship->starsystem );
space.c~:   sprintf( buf, "%s lands on the platform.", ship->name );
space.c~:   echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:   ship->energy = ship->energy - 25 - 25 * ship->ship_class;
space.c~:   if( !str_cmp( "Public", ship->owner ) )
space.c~:      ship->energy = ship->maxenergy;
space.c~:      ship->chaff = ship->maxchaff;
space.c~:      ship->missiles = ship->maxmissiles;
space.c~:      ship->torpedos = ship->maxtorpedos;
space.c~:      ship->rockets = ship->maxrockets;
space.c~:      ship->shield = 0;
space.c~:      ship->autorecharge = FALSE;
space.c~:      ship->autotrack = FALSE;
space.c~:      ship->autospeed = FALSE;
space.c~:      ship->track0 = NULL;
space.c~:      ship->heading = 0;
space.c~:      ship->prevheading = 0;
space.c~:      ship->turnarc = 0;
space.c~:      ship->hull = ship->maxhull;
space.c~:      ship->flightflags = 0;
space.c~:      ship->missilestate = MISSILE_READY;
space.c~:      ship->statet0 = LASER_READY;
space.c~:      ship->statet1 = LASER_READY;
space.c~:      ship->statet2 = LASER_READY;
space.c~:      ship->shipstate = SHIP_DOCKED;
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->energy < abs( ( atoi( argument ) - abs( ship->currspeed ) ) / 10 ) )
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( change > ship->currspeed )
space.c~:      sprintf( buf, "%s begins to speed up.", ship->name );
space.c~:   if( change < ship->currspeed )
space.c~:      sprintf( buf, "%s begins to slow down.", ship->name );
space.c~:   ship->energy -= abs( ( change - abs( ship->currspeed ) ) / 10 );
space.c~:   ship->currspeed = URANGE( 0, change, ship->realspeed );
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->shipstate != SHIP_READY )
space.c~:   if( ship->energy < ( ship->currspeed / 10 ) )
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( vx == ship->vx && vy == ship->vy )
space.c~:   ship->hx = vx - ship->vx;
space.c~:   ship->hy = vy - ship->vy;
space.c~:   ship->heading = coordpairtoheading(ship->vx,ship->vy,vx,vy);
space.c~:   ship->energy -= ( ship->currspeed / 10 );
space.c~:   ch_printf( ch, "&GNew course set aproaching %.0f %.0f, heading %0.f degrees.\r\n", vx, vy,radianstodegrees(ship->heading));
space.c~:   sprintf( buf, "%s turns altering its present course.", ship->name );
space.c~:   if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c~:      ship->shipstate = SHIP_BUSY_3;
space.c~:   else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c~:      ship->shipstate = SHIP_BUSY_2;
space.c~:      ship->shipstate = SHIP_BUSY;
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( IS_NPC( ch ) || !ch->pcdata )
space.c~:   ship = ship_in_room( ch->in_room, argument );
space.c~:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c~:   if( str_cmp( ship->owner, "" ) || ship->type == MOB_SHIP )
space.c~:   if( ship->type == SHIP_IMPERIAL )
space.c~:      if( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name, "the empire" ) )
space.c~:         if( !ch->pcdata->clan || !ch->pcdata->clan->mainclan || str_cmp( ch->pcdata->clan->mainclan->name, "The Empire" ) )
space.c~:   else if( ship->type == SHIP_REPUBLIC )
space.c~:      if( !ch->pcdata->clan || str_cmp( ch->pcdata->clan->name, "the new republic" ) )
space.c~:         if( !ch->pcdata->clan || !ch->pcdata->clan->mainclan
space.c~:             || str_cmp( ch->pcdata->clan->mainclan->name, "The New Republic" ) )
space.c~:      if( ch->pcdata->clan &&
space.c~:          ( !str_cmp( ch->pcdata->clan->name, "the new republic" ) ||
space.c~:            ( ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, "the new republic" ) ) ) )
space.c~:      if( ch->pcdata->clan &&
space.c~:          ( !str_cmp( ch->pcdata->clan->name, "the empire" ) ||
space.c~:            ( ch->pcdata->clan->mainclan && !str_cmp( ch->pcdata->clan->mainclan->name, "the empire" ) ) ) )
space.c~:   if( ch->gold < price )
space.c~:   ch->gold -= price;
space.c~:   STRFREE( ship->owner );
space.c~:   ship->owner = STRALLOC( ch->name );
space.c~:   if( IS_NPC( ch ) || !ch->pcdata )
space.c~:   if( !ch->pcdata->clan )
space.c~:   clan = ch->pcdata->clan;
space.c~:   mainclan = ch->pcdata->clan->mainclan ? ch->pcdata->clan->mainclan : clan;
space.c~:   if( ( ch->pcdata->bestowments
space.c~:         && is_name( "clanbuyship", ch->pcdata->bestowments ) ) || !str_cmp( ch->name, clan->leader ) )
space.c~:   ship = ship_in_room( ch->in_room, argument );
space.c~:      ship = ship_from_cockpit( ch->in_room->vnum );
space.c~:   if( str_cmp( ship->owner, "" ) || ship->type == MOB_SHIP )
space.c~:   if( str_cmp( mainclan->name, "The Empire" ) && ship->type == SHIP_IMPERIAL )
space.c~:   if( str_cmp( mainclan->name, "The New Republic" ) && ship->type == SHIP_REPUBLIC )
space.c~:   if( !str_cmp( mainclan->name, "The Empire" ) && ship->type != SHIP_IMPERIAL )
space.c~:   if( !str_cmp( mainclan->name, "The New Republic" ) && ship->type != SHIP_REPUBLIC )
space.c~:   if( ch->pcdata->clan->funds < price )
space.c~:   clan->funds -= price;
space.c~:   ch_printf( ch, "&G%s pays %ld credits to purchace the ship.\r\n", clan->name, price );
space.c~:   STRFREE( ship->owner );
space.c~:   ship->owner = STRALLOC( clan->name );
space.c~:   if( ship->ship_class <= SHIP_PLATFORM )
space.c~:      clan->spacecraft++;
space.c~:      clan->vehicles++;
space.c~:   ship = ship_in_room( ch->in_room, argument );
space.c~:   if( str_cmp( ship->owner, ch->name ) )
space.c~:   ch->gold += ( price - price / 10 );
space.c~:   ch_printf( ch, "&GYou receive %ld credits from selling your ship.\r\n", price - price / 10 );
space.c~:   STRFREE( ship->owner );
space.c~:   ship->owner = STRALLOC( "" );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:      ship = ship_in_room( ch->in_room, argument );
space.c~:      target = get_ship_here( argument, ship->starsystem );
space.c~:   if( abs( ( int )( target->vx - ship->vx ) ) > 500 + ship->sensor * 2
space.c~:       || abs( ( int )( target->vy - ship->vy ) ) > 500 + ship->sensor * 2)
space.c~:              target->type == SHIP_REPUBLIC ? "New Republic" :
space.c~:              ( target->type == SHIP_IMPERIAL ? "Imperial" : "Civilian" ),
space.c~:              target->ship_class == FIGHTER_SHIP ? "Starfighter" :
space.c~:              ( target->ship_class == MIDSIZE_SHIP ? "Midtarget" :
space.c~:                ( target->ship_class == CAPITAL_SHIP ? "Capital Ship" :
space.c~:                  ( ship->ship_class == SHIP_PLATFORM ? "Platform" :
space.c~:                    ( ship->ship_class == CLOUD_CAR ? "Cloudcar" :
space.c~:                      ( ship->ship_class == OCEAN_SHIP ? "Boat" :
space.c~:                        ( ship->ship_class == LAND_SPEEDER ? "Speeder" :
space.c~:                          ( ship->ship_class == WHEELED ? "Wheeled Transport" :
space.c~:                            ( ship->ship_class == LAND_CRAWLER ? "Crawler" :
space.c~:                              ( ship->ship_class == WALKER ? "Walker" : "Unknown" ) ) ) ) ) ) ) ) ),
space.c~:              target->name, target->filename );
space.c~:              target->description, target->owner, target->pilot, target->copilot );
space.c~:   ch_printf( ch, "Laser cannons: %d  ", target->lasers );
space.c~:   ch_printf( ch, "Maximum Missiles: %d  ", target->maxmissiles );
space.c~:   ch_printf( ch, "Max Chaff: %d\r\n", target->maxchaff );
space.c~:   ch_printf( ch, "Max Hull: %d  ", target->maxhull );
space.c~:   ch_printf( ch, "Max Shields: %d   Max Energy(fuel): %d\r\n", target->maxshield, target->maxenergy );
space.c~:   ch_printf( ch, "Maximum Speed: %d   Hyperspeed: %d\r\n", target->realspeed, target->hyperspeed );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c~:      send_to_char( "&RYou must be in the co-pilots seat!\r\n", ch );
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c~:      ship->autorecharge = TRUE;
space.c~:      ship->autorecharge = FALSE;
space.c~:      ship->shield = 0;
space.c~:      ship->autorecharge = FALSE;
space.c~:      if( ship->autorecharge == TRUE )
space.c~:         ship->autorecharge = FALSE;
space.c~:         ship->autorecharge = TRUE;
space.c~:   if( ship->autorecharge )
space.c~:      recharge = URANGE( 1, ship->maxshield - ship->shield, 25 + ship->ship_class * 25 );
space.c~:      recharge = UMIN( recharge, ship->energy * 5 + 100 );
space.c~:      ship->shield += recharge;
space.c~:      ship->energy -= ( recharge * 2 + recharge * ship->ship_class );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->target0 || ship->target1 || ship->target2 )
space.c~:   if( ship->autopilot == TRUE )
space.c~:      ship->autopilot = FALSE;
space.c~:      ship->autopilot = TRUE;
space.c~:      ship->autorecharge = TRUE;
space.c~:      ship = ship_from_entrance( ch->in_room->vnum );
space.c~:         if( !ship->hatchopen )
space.c~:            if( ship->ship_class == SHIP_PLATFORM )
space.c~:            if( ship->location != ship->lastdoc || ( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED ) )
space.c~:            ship->hatchopen = TRUE;
space.c~:            sprintf( buf, "The hatch on %s opens.", ship->name );
space.c~:            echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:            sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:            sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:   ship = ship_in_room( ch->in_room, argument );
space.c~:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c~:   if( !ship->hatchopen )
space.c~:      ship->hatchopen = TRUE;
space.c~:      act( AT_PLAIN, "You open the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
space.c~:      act( AT_PLAIN, "$n opens the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
space.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch opens from the outside." );
space.c~:      sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:      sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:      ship = ship_from_entrance( ch->in_room->vnum );
space.c~:         if( ship->ship_class == SHIP_PLATFORM )
space.c~:         if( ship->hatchopen )
space.c~:            ship->hatchopen = FALSE;
space.c~:            sprintf( buf, "The hatch on %s closes.", ship->name );
space.c~:            echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
space.c~:            sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:            sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:   ship = ship_in_room( ch->in_room, argument );
space.c~:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
space.c~:      if( ship->hatchopen )
space.c~:         ship->hatchopen = FALSE;
space.c~:         act( AT_PLAIN, "You close the hatch on $T.", ch, NULL, ship->name, TO_CHAR );
space.c~:         act( AT_PLAIN, "$n closes the hatch on $T.", ch, NULL, ship->name, TO_ROOM );
space.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch is closed from outside." );
space.c~:         sound_to_room( get_room_index( ship->entrance ), "!!SOUND(door)" );
space.c~:         sound_to_room( get_room_index( ship->location ), "!!SOUND(door)" );
space.c~:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL || ch->in_room->vnum == ship->engineroom )
space.c~:	if( ch->piloting != NULL && ch->piloting == ship)
space.c~:		ch->piloting = NULL;
space.c~:   	if( ch->in_room->vnum == ship->gunseat )
space.c~:		if( ship->gunpilotch != ch && ship->gunpilotch != NULL)
space.c~:			ship->gunpilotch = newpilot;
space.c~:   	if( ch->in_room->vnum == ship->navseat )
space.c~:		if( ship->navpilotch != ch && ship->navpilotch != NULL)
space.c~:			ship->navpilotch = newpilot;
space.c~:   	if( ch->in_room->vnum == ship->coseat )
space.c~:		if( ship->copilotch != ch && ship->copilotch != NULL)
space.c~:			ship->copilotch = newpilot;
space.c~:   	if( ch->in_room->vnum == ship->pilotseat )
space.c~:		if( ship->pilotpilotch != ch && ship->pilotpilotch != NULL)
space.c~:			ship->pilotpilotch = newpilot;
space.c~:		ch->piloting = ship;
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:      target = get_ship_here( argument, ship->starsystem );
space.c~:   if( abs( ( int )( target->vx - ship->vx ) ) > 500 + ship->sensor * 2
space.c~:       || abs( ( int )( target->vy - ship->vy ) ) > 500 + ship->sensor * 2)
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c~:   ch_printf( ch, "&W%s:\r\n", target->name );
space.c~:   ch_printf( ch, "&OCurrent Coordinates:&Y %.0f %.0f\r\n", target->vx, target->vy);
space.c~:   ch_printf( ch, "&OCurrent Heading:&Y %.0f %.0f\r\n", target->hx, target->hy);
space.c~:   ch_printf( ch, "&OCurrent Heading in Radians: &Y %0.f\r\n", ship->heading);
space.c~:   ch_printf( ch, "&OCurrent Heading in Degrees: &Y %0.2f\r\n", radianstodegrees(ship->heading));
space.c~:   ch_printf( ch, "&OCurrent Speed:&Y %d&O/%d\r\n", target->currspeed, target->realspeed );
space.c~:              target->hull, target->maxhull, target->shipstate == SHIP_DISABLED ? "Disabled" : "Running" );
space.c~:              target->shield, target->maxshield, target->energy, target->maxenergy );
space.c~:              target->statet0 == LASER_DAMAGED ? "Damaged" : "Good", target->target0 ? target->target0->name : "none" );
space.c~:   if( target->turret1 )
space.c~:                 target->statet1 == LASER_DAMAGED ? "Damaged" : "Good", target->target1 ? target->target1->name : "none" );
space.c~:   if( target->turret2 )
space.c~:                 target->statet2 == LASER_DAMAGED ? "Damaged" : "Good", target->target2 ? target->target2->name : "none" );
space.c~:              ship->missiles,
space.c~:              ship->maxmissiles,
space.c~:              ship->torpedos,
space.c~:              ship->maxtorpedos,
space.c~:              ship->rockets, ship->maxrockets, ship->missilestate == MISSILE_DAMAGED ? "Damaged" : "Good" );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->hyperspeed == 0 )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->shipstate != SHIP_READY )
space.c~:   if( !ship->currjump )
space.c~:   if( ship->energy < ( 200 + ship->hyperdistance * ( 1 + ship->ship_class ) / 3 ) )
space.c~:   if( ship->currspeed <= 0 )
space.c~:   for( eShip = ship->starsystem->first_ship; eShip; eShip = eShip->next_in_starsystem )
space.c~:         ch_printf( ch, "&RYou are too close to %s to make the jump to lightspeed.\r\n", eShip->name );
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
space.c~:      if( ship->ship_class == FIGHTER_SHIP )
space.c~:      if( ship->ship_class == MIDSIZE_SHIP )
space.c~:      if( ship->ship_class == CAPITAL_SHIP )
space.c~:   sprintf( buf, "%s disapears from your scanner.", ship->name );
space.c~:   ship_from_starsystem( ship, ship->starsystem );
space.c~:   ship->shipstate = SHIP_HYPERSPACE;
space.c~:   ship->energy -= ( 100 + ship->hyperdistance * ( 1 + ship->ship_class ) / 3 );
space.c~:   ship->vx = ship->jx;
space.c~:   ship->vy = ship->jy;
space.c~:   if( ship->ship_class == FIGHTER_SHIP )
space.c~:   if( ship->ship_class == MIDSIZE_SHIP )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:	if( ship->ship_class > SHIP_PLATFORM )
space.c~:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:	if( !ship->starsystem )
space.c~:         if( ship->ship_class > SHIP_PLATFORM )
space.c~:        if( ship->shipstate != SHIP_READY)
space.c~:	    REMOVE_BIT(ship->flightflags,SHIP_TRACKINGRADAR);
space.c~:	    ship->track0 = NULL;
space.c~:	if(!IS_SET(ship->flightflags,SHIP_TRACKINGRADAR))
space.c~:	SET_BIT(ship->flightflags,SHIP_TRACKINGRADAR);
space.c~:		 target = get_ship_here( arg, ship->starsystem );
space.c~:		if(targetbearing > PI/4 || targetbearing < -PI/4)
space.c~:		    send_to_char( "&RThat ship needs to be infront of you! (within -45 to 45 bearing)\r\n", ch );
space.c~:		if(ship->turnarc != 0 && ship->track0 == NULL)
space.c~:	    		echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c~:		 	sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c~:			ship->turnarc = 0;
space.c~:		ship->track0 = target;
space.c~:   switch ( ch->substate )
space.c~:         if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c~:         if( ship->ship_class > SHIP_PLATFORM )
space.c~:         if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:         if( !ship->starsystem )
space.c~:            if( ch->in_room->vnum == ship->gunseat )
space.c~:               ship->target0 = NULL;
space.c~:            if( ch->in_room->vnum == ship->turret1 )
space.c~:               ship->target1 = NULL;
space.c~:            if( ch->in_room->vnum == ship->turret2 )
space.c~:               ship->target2 = NULL;
space.c~:         target = get_ship_here( arg, ship->starsystem );
space.c~:         if( !str_cmp( target->owner, ship->owner ) && str_cmp( target->owner, "" ) )
space.c~:         if( abs( ( int )( ship->vx - target->vx ) ) > 5000
space.c~:	     || abs( ( int )( ship->vy - target->vy ) ) > 5000)
space.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_weaponsystems] );
space.c~:            ch->dest_buf = str_dup( arg );
space.c~:         if( !ch->dest_buf )
space.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
space.c~:         DISPOSE( ch->dest_buf );
space.c~:         DISPOSE( ch->dest_buf );
space.c~:         ch->substate = SUB_NONE;
space.c~:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   ch->substate = SUB_NONE;
space.c~:   if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c~:   target = get_ship_here( arg, ship->starsystem );
space.c~:   if( ch->in_room->vnum == ship->gunseat )
space.c~:      ship->target0 = target;
space.c~:   if( ch->in_room->vnum == ship->turret1 )
space.c~:      ship->target1 = target;
space.c~:   if( ch->in_room->vnum == ship->turret2 )
space.c~:      ship->target2 = target;
space.c~:   sprintf( buf, "You are being targetted by %s.", ship->name );
space.c~:   sound_to_room( ch->in_room, "!!SOUND(targetlock)" );
space.c~:   if( autofly( target ) && !target->target0 )
space.c~:      sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:      target->target0 = ship;
space.c~:   if( ( ship = ship_from_turret( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ch->piloting == NULL || ch->piloting != ship || ship->gunpilotch != ch )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->starsystem == NULL )
space.c~:   if( ship->energy < 5 )
space.c~:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "lasers" ) )
space.c~:      if( ship->statet0 == LASER_DAMAGED )
space.c~:      if( ship->statet0 >= ship->lasers )
space.c~:      ship->statet0++;
space.c~:	for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c~:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c~:			theta = atan( ((double)(target->ship_class+0.35))/range)*2;
space.c~:				sprintf( buf, "Laserfire from %s hits %s.", ship->name, target->name );
space.c~:				sprintf( buf, "You are hit by lasers from %s!", ship->name );
space.c~:				sprintf( buf, "Your ships lasers hit %s!.", target->name );
space.c~:				sprintf( buf, "Laserfire from %s barely misses %s.", ship->name, target->name );
space.c~:				sprintf( buf, "Laserfire from %s barely misses you!", ship->name );
space.c~:				sprintf( buf, "Your ships very nearly hit %s!.", target->name );
space.c~:				sprintf( buf, "Laserfire from %s nearly hits %s.", ship->name, target->name );
space.c~:				sprintf( buf, "Laserfire from %s nearly hits you!", ship->name );
space.c~:				sprintf( buf, "Your ships very nearly hit %s!.", target->name );
space.c~:		sprintf( buf, "%s fires its lasers out into empty space", ship->name );
space.c~:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "missile" ) )
space.c~:      if( ship->missilestate == MISSILE_DAMAGED )
space.c~:      if( ship->missiles <= 0 )
space.c~:      if( ship->missilestate != MISSILE_READY )
space.c~:	for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:			range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c~:			bearing = fabs(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));		
space.c~:			theta = atan( ((double)(target->ship_class+0.25*10))/range)*2;
space.c~:			        sprintf( buf, "%s fires a missile towards %s.", ship->name, target->name );
space.c~:				sprintf( buf, "%s fires a missile at you!", ship->name );
space.c~:				sprintf( buf, "You fire a missile at %s!.", target->name );
space.c~:				sprintf( buf, "%s fires a missile, it looks like it could hit %s!", ship->name, target->name );
space.c~:				sprintf( buf, "%s fires a missile in your direction, it looks like it could hit you!", ship->name );
space.c~:				sprintf( buf, "You fire a missile in the direction of %s, it looks like it could hit them!!.", target->name );
space.c~:				sprintf( buf, "%s fires a missile in %s's general direction.", ship->name, target->name );
space.c~:				sprintf( buf, "%s fires a missile kind of in your direction!", ship->name );
space.c~:				sprintf( buf, "You fire a missile at %s, but it's not quite on target!.", target->name );
space.c~:		sprintf( buf, "%s fires a missile out into empty space", ship->name );
space.c~:      ship->missiles--;
space.c~:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c~:         ship->missilestate = MISSILE_RELOAD;
space.c~:         ship->missilestate = MISSILE_FIRED;
space.c~:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "torpedo" ) )
space.c~:      if( ship->missilestate == MISSILE_DAMAGED )
space.c~:      if( ship->torpedos <= 0 )
space.c~:      if( ship->missilestate != MISSILE_READY )
space.c~:      if( ship->target0 == NULL )
space.c~:      target = ship->target0;
space.c~:      if( ship->target0->starsystem != ship->starsystem )
space.c~:         ship->target0 = NULL;
space.c~:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c~:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c~:      if( ship->ship_class < 2 && !is_facing( ship, target ) )
space.c~:      schance -= target->manuever / 5;
space.c~:      schance -= target->currspeed / 20;
space.c~:      schance += target->ship_class * target->ship_class * 25;
space.c~:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c~:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c~:         ship->missilestate = MISSILE_RELOAD_2;
space.c~:      ship->torpedos--;
space.c~:      sprintf( buf, "Incoming torpedo from %s.", ship->name );
space.c~:      sprintf( buf, "%s fires a torpedo towards %s.", ship->name, target->name );
space.c~:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c~:         ship->missilestate = MISSILE_RELOAD;
space.c~:         ship->missilestate = MISSILE_FIRED;
space.c~:      if( autofly( target ) && target->target0 != ship )
space.c~:         target->target0 = ship;
space.c~:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:   if( ch->in_room->vnum == ship->gunseat && !str_prefix( argument, "rocket" ) )
space.c~:      if( ship->missilestate == MISSILE_DAMAGED )
space.c~:      if( ship->rockets <= 0 )
space.c~:      if( ship->missilestate != MISSILE_READY )
space.c~:      if( ship->target0 == NULL )
space.c~:      target = ship->target0;
space.c~:      if( ship->target0->starsystem != ship->starsystem )
space.c~:         ship->target0 = NULL;
space.c~:      if( abs( ( int )( target->vx - ship->vx ) ) > 800
space.c~:	  || abs( ( int )( target->vy - ship->vy ) ) > 800)
space.c~:      if( ship->ship_class < 2 && !is_facing( ship, target ) )
space.c~:      schance -= target->manuever / 5;
space.c~:      schance -= target->currspeed / 20;
space.c~:      schance += target->ship_class * target->ship_class * 25;
space.c~:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 100 );
space.c~:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 100 );
space.c~:      schance -= 30;
space.c~:         ship->missilestate = MISSILE_RELOAD_2;
space.c~:      ship->rockets--;
space.c~:      sprintf( buf, "Incoming rocket from %s.", ship->name );
space.c~:      sprintf( buf, "%s fires a heavy rocket towards %s.", ship->name, target->name );
space.c~:      if( ship->ship_class == CAPITAL_SHIP || ship->ship_class == SHIP_PLATFORM )
space.c~:         ship->missilestate = MISSILE_RELOAD;
space.c~:         ship->missilestate = MISSILE_FIRED;
space.c~:      if( autofly( target ) && target->target0 != ship )
space.c~:         target->target0 = ship;
space.c~:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:   if( ch->in_room->vnum == ship->turret1 && !str_prefix( argument, "lasers" ) )
space.c~:      if( ship->statet1 == LASER_DAMAGED )
space.c~:      if( ship->statet1 > ship->ship_class )
space.c~:      if( ship->target1 == NULL )
space.c~:      target = ship->target1;
space.c~:      if( ship->target1->starsystem != ship->starsystem )
space.c~:         ship->target1 = NULL;
space.c~:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c~:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c~:      ship->statet1++;
space.c~:      schance -= target->manuever / 10;
space.c~:      schance += target->ship_class * 25;
space.c~:      schance -= target->currspeed / 20;
space.c~:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c~:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c~:         sprintf( buf, "Turbolasers fire from %s at you but miss.", ship->name );
space.c~:         sprintf( buf, "Turbolasers fire from the ships turret at %s but miss.", target->name );
space.c~:         sprintf( buf, "%s fires at %s but misses.", ship->name, target->name );
space.c~:      sprintf( buf, "Turboasers fire from %s, hitting %s.", ship->name, target->name );
space.c~:      sprintf( buf, "You are hit by turbolasers from %s!", ship->name );
space.c~:      sprintf( buf, "Turbolasers fire from the turret, hitting %s!.", target->name );
space.c~:      if( autofly( target ) && target->target0 != ship )
space.c~:         target->target0 = ship;
space.c~:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:   if( ch->in_room->vnum == ship->turret2 && !str_prefix( argument, "lasers" ) )
space.c~:      if( ship->statet2 == LASER_DAMAGED )
space.c~:      if( ship->statet2 > ship->ship_class )
space.c~:      if( ship->target2 == NULL )
space.c~:      target = ship->target2;
space.c~:      if( ship->target2->starsystem != ship->starsystem )
space.c~:         ship->target2 = NULL;
space.c~:      if( abs( ( int )( target->vx - ship->vx ) ) > 1000
space.c~:	  || abs( ( int )( target->vy - ship->vy ) ) > 1000)
space.c~:      ship->statet2++;
space.c~:      schance -= target->manuever / 10;
space.c~:      schance += target->ship_class * 25;
space.c~:      schance -= target->currspeed / 20;
space.c~:      schance -= ( abs( ( int )( target->vx - ship->vx ) ) / 70 );
space.c~:      schance -= ( abs( ( int )( target->vy - ship->vy ) ) / 70 );
space.c~:         sprintf( buf, "Turbolasers fire from %s barely missing %s.", ship->name, target->name );
space.c~:         sprintf( buf, "Turbolasers fire from %s at you but miss.", ship->name );
space.c~:         sprintf( buf, "Turbolasers fire from the turret missing %s.", target->name );
space.c~:      sprintf( buf, "Turbolasers fire from %s, hitting %s.", ship->name, target->name );
space.c~:      sprintf( buf, "You are hit by turbolasers from %s!", ship->name );
space.c~:      sprintf( buf, "turbolasers fire from the turret hitting %s!.", target->name );
space.c~:      if( autofly( target ) && target->target0 != ship )
space.c~:         target->target0 = ship;
space.c~:         sprintf( buf, "You are being targetted by %s.", target->name );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_navseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->hyperspeed == 0 )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->starsystem == NULL )
space.c~:      for( starsystem = first_starsystem; starsystem; starsystem = starsystem->next )
space.c~:         ch_printf( ch, "%-30s %d\r\n", starsystem->name,
space.c~:                    ( abs( starsystem->xpos - ship->starsystem->xpos ) +
space.c~:                      abs( starsystem->ypos - ship->starsystem->ypos ) ) / 2 );
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_navigation] );
space.c~:   ship->currjump = starsystem_from_name( arg1 );
space.c~:   ship->jx = atoi( arg2 );
space.c~:   ship->jy = atoi( argument );
space.c~:   if( ship->currjump == NULL )
space.c~:      starsystem2 = ship->currjump;
space.c~:      if( starsystem2->star1 && strcmp( starsystem2->star1, "" )
space.c~:	  && abs( ( int )( ship->jx - starsystem2->s1x ) ) < 300
space.c~:	  && abs( ( int )( ship->jy - starsystem2->s1y ) ) < 300)
space.c~:         ship->currjump = NULL;
space.c~:      else if( starsystem2->star2 && strcmp( starsystem2->star2, "" )
space.c~:	       && abs( ( int )( ship->jx - starsystem2->s2x ) ) < 300
space.c~:	       && abs( ( int )( ship->jy - starsystem2->s2y ) ) < 300)
space.c~:         ship->currjump = NULL;
space.c~:      else if( starsystem2->planet1 && strcmp( starsystem2->planet1, "" )
space.c~:	       && abs( ( int )( ship->jx - starsystem2->p1x ) ) < 300
space.c~:	       && abs( ( int )( ship->jy - starsystem2->p1y ) ) < 300)
space.c~:         ship->currjump = NULL;
space.c~:      else if( starsystem2->planet2 && strcmp( starsystem2->planet2, "" )
space.c~:	       && abs( ( int )( ship->jx - starsystem2->p2x ) ) < 300
space.c~:	       && abs( ( int )( ship->jy - starsystem2->p2y ) ) < 300)
space.c~:         ship->currjump = NULL;
space.c~:      else if( starsystem2->planet3 && strcmp( starsystem2->planet3, "" )
space.c~:	       && abs( ( int )( ship->jx - starsystem2->p3x ) ) < 300
space.c~:	       && abs( ( int )( ship->jy - starsystem2->p3y ) ) < 300)
space.c~:         ship->currjump = NULL;
space.c~:         ship->jx += number_range( -250, 250 );
space.c~:         ship->jy += number_range( -250, 250 );
space.c~:   ship->hyperdistance = abs( ship->starsystem->xpos - ship->currjump->xpos );
space.c~:   ship->hyperdistance += abs( ship->starsystem->ypos - ship->currjump->ypos );
space.c~:   ship->hyperdistance /= 5;
space.c~:   if( ship->hyperdistance < 100 )
space.c~:      ship->hyperdistance = 100;
space.c~:   ship->hyperdistance += number_range( 0, 200 );
space.c~:   sound_to_room( ch->in_room, "!!SOUND(computer)" );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c~:      send_to_char( "&RThe controls must be at the co-pilot station.\r\n", ch );
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->energy < 100 )
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c~:   recharge = UMIN( ship->maxshield - ship->shield, ship->energy * 5 + 100 );
space.c~:   recharge = URANGE( 1, recharge, 25 + ship->ship_class * 25 );
space.c~:   ship->shield += recharge;
space.c~:   ship->energy -= ( recharge * 2 + recharge * ship->ship_class );
space.c~:   switch ( ch->substate )
space.c~:         if( ( ship = ship_from_engine( ch->in_room->vnum ) ) == NULL )
space.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipmaintenance] );
space.c~:            ch->dest_buf = str_dup( arg );
space.c~:         if( !ch->dest_buf )
space.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
space.c~:         DISPOSE( ch->dest_buf );
space.c~:         DISPOSE( ch->dest_buf );
space.c~:         ch->substate = SUB_NONE;
space.c~:         if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   ch->substate = SUB_NONE;
space.c~:   if( ( ship = ship_from_engine( ch->in_room->vnum ) ) == NULL )
space.c~:                       number_range( ( int )( ch->pcdata->learned[gsn_shipmaintenance] / 2 ),
space.c~:                                     ( int )( ch->pcdata->learned[gsn_shipmaintenance] ) ), ( ship->maxhull - ship->hull ) );
space.c~:      ship->hull += change;
space.c~:      if( ship->location == ship->lastdoc )
space.c~:         ship->shipstate = SHIP_DOCKED;
space.c~:         ship->shipstate = SHIP_READY;
space.c~:      ship->missilestate = MISSILE_READY;
space.c~:      ship->statet0 = LASER_READY;
space.c~:      ship->statet1 = LASER_READY;
space.c~:      ship->statet2 = LASER_READY;
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( str_cmp( ship->owner, ch->name ) )
space.c~:      if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c~:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c~:         else if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c~:         else if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c~:   if( str_cmp( ship->pilot, "" ) )
space.c~:      if( str_cmp( ship->copilot, "" ) )
space.c~:      STRFREE( ship->copilot );
space.c~:      ship->copilot = STRALLOC( argument );
space.c~:   STRFREE( ship->pilot );
space.c~:   ship->pilot = STRALLOC( argument );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( str_cmp( ship->owner, ch->name ) )
space.c~:      if( !IS_NPC( ch ) && ch->pcdata && ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, ship->owner ) )
space.c~:         if( !str_cmp( ch->pcdata->clan->leader, ch->name ) )
space.c~:         else if( !str_cmp( ch->pcdata->clan->number1, ch->name ) )
space.c~:         else if( !str_cmp( ch->pcdata->clan->number2, ch->name ) )
space.c~:   if( !str_cmp( ship->pilot, argument ) )
space.c~:      STRFREE( ship->pilot );
space.c~:      ship->pilot = STRALLOC( "" );
space.c~:   if( !str_cmp( ship->copilot, argument ) )
space.c~:      STRFREE( ship->copilot );
space.c~:      ship->copilot = STRALLOC( "" );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->starsystem == NULL )
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_navigation] );
space.c~:   ch_printf( ch, "%s\r\n\r\n", ship->starsystem->name );
space.c~:   if( ship->starsystem->star1 && str_cmp( ship->starsystem->star1, "" ) )
space.c~:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y);
space.c~:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->s1x,ship->starsystem->s1y));
space.c~:                 ship->starsystem->star1, ship->starsystem->s1x, ship->starsystem->s1y,range,bearing);
space.c~:   if( ship->starsystem->star2 && str_cmp( ship->starsystem->star2, "" ) )
space.c~:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y);
space.c~:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->s2x,ship->starsystem->s2y));
space.c~:                 ship->starsystem->star2, ship->starsystem->s2x, ship->starsystem->s2y,range,bearing);
space.c~:   if( ship->starsystem->planet1 && str_cmp( ship->starsystem->planet1, "" ) )
space.c~:      range = pointdistance(ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y);
space.c~:      bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,ship->starsystem->p1x,ship->starsystem->p1y));
space.c~:                 ship->starsystem->planet1, ship->starsystem->p1x, ship->starsystem->p1y,range,bearing);
space.c~:   if( ship->starsystem->planet2 && str_cmp( ship->starsystem->planet2, "" ) )
space.c~:                 ship->starsystem->planet2, ship->starsystem->p2x, ship->starsystem->p2y );
space.c~:   if( ship->starsystem->planet3 && str_cmp( ship->starsystem->planet3, "" ) )
space.c~:                 ship->starsystem->planet3, ship->starsystem->p3x, ship->starsystem->p3y);
space.c~:   for( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
space.c~:	range = sqrt(pow(ship->vx-target->vx,2)+pow(ship->vy-target->vy,2) );
space.c~:	bearing = radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,target->vx,target->vy));
space.c~:		 target->name, target->vx, target->vy, range,bearing,
space.c~:		 target->currspeed,(ship->target0 == target ? "&R[YOUR TARGET]&z" : ""),(target->target0 == ship ? "&R[TARGETTING YOU]&z" : "")  );
space.c~:   for( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
space.c~:	range = sqrt(pow(ship->vx-missile->mx,2)+pow(ship->vy-missile->my,2) );
space.c~:                 missile->missiletype == CONCUSSION_MISSILE ? "A Concusion missile" :
space.c~:                 ( missile->missiletype == PROTON_TORPEDO ? "A Torpedo" :
space.c~:                   ( missile->missiletype == HEAVY_ROCKET ? "A Heavy Rocket" : "A Heavy Bomb" ) ),
space.c~:                 missile->mx, missile->my, range,radianstodegrees(getbearing(ship->heading,ship->vx,ship->vy,missile->mx,missile->my)));
space.c~:   ch_printf( ch, "\r\n&WYour Coordinates: %.0f %.0f\r\n", ship->vx, ship->vy );
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ship->ship_class == SHIP_PLATFORM )
space.c~:   if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_shipsystems] );
space.c~:   if( ship->autotrack )
space.c~:      ship->autotrack = FALSE;
space.c~:      ship->autotrack = TRUE;
space.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
space.c~:      if( obj->pIndexData->item_type == ITEM_COMLINK )
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class < LAND_SPEEDER )
space.c~:   if( ship->shipstate == SHIP_DISABLED )
space.c~:   if( ship->energy < 1 )
space.c~:   if( ( dir = get_door( argument ) ) == -1 )
space.c~:   drive_ship( ch, ship, get_exit( get_room_index( ship->location ), dir ), 0 );
space.c~:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
space.c~:      pexit = get_exit( get_room_index( ship->location ), door );
space.c~:      sprintf( buf, "drive_ship: %s to door %d", ch->name, pexit->vdir );
space.c~:   in_room = get_room_index( ship->location );
space.c~:   if( !pexit || ( to_room = pexit->to_room ) == NULL )
space.c~:   door = pexit->vdir;
space.c~:   distance = pexit->distance;
space.c~:   if( IS_SET( pexit->exit_info, EX_WINDOW ) && !IS_SET( pexit->exit_info, EX_ISDOOR ) )
space.c~:   if( IS_SET( pexit->exit_info, EX_PORTAL ) && IS_NPC( ch ) )
space.c~:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) )
space.c~:   if( IS_SET( pexit->exit_info, EX_CLOSED ) && ( IS_SET( pexit->exit_info, EX_NOPASSDOOR ) ) )
space.c~:      if( !IS_SET( pexit->exit_info, EX_SECRET ) && !IS_SET( pexit->exit_info, EX_DIG ) )
space.c~:            act( AT_PLAIN, "$n drives into the $d in $s drunken state.", ch, NULL, pexit->keyword, TO_ROOM );
space.c~:            act( AT_PLAIN, "You drive into the $d in your drunken state.", ch, NULL, pexit->keyword, TO_CHAR );
space.c~:            act( AT_PLAIN, "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
space.c~:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
space.c~:      if( ch->top_level < to_room->area->low_hard_range )
space.c~:         switch ( to_room->area->low_hard_range - ch->top_level )
space.c~:      else if( ch->top_level > to_room->area->hi_hard_range )
space.c~:      if( IS_SET( to_room->room_flags, ROOM_INDOORS )
space.c~:          || IS_SET( to_room->room_flags, ROOM_SPACECRAFT ) || to_room->sector_type == SECT_INSIDE )
space.c~:      if( IS_SET( to_room->room_flags, ROOM_NO_DRIVING ) )
space.c~:      if( in_room->sector_type == SECT_AIR || to_room->sector_type == SECT_AIR || IS_SET( pexit->exit_info, EX_FLY ) )
space.c~:         if( ship->ship_class > CLOUD_CAR )
space.c~:      if( in_room->sector_type == SECT_WATER_NOSWIM
space.c~:          || to_room->sector_type == SECT_WATER_NOSWIM
space.c~:          || to_room->sector_type == SECT_WATER_SWIM
space.c~:          || to_room->sector_type == SECT_UNDERWATER || to_room->sector_type == SECT_OCEANFLOOR )
space.c~:         if( ship->ship_class != OCEAN_SHIP )
space.c~:      if( IS_SET( pexit->exit_info, EX_CLIMB ) )
space.c~:         if( ship->ship_class < CLOUD_CAR )
space.c~:   if( to_room->tunnel > 0 )
space.c~:      for( ctmp = to_room->first_person; ctmp; ctmp = ctmp->next_in_room )
space.c~:         if( ++count >= to_room->tunnel )
space.c~:      if( ship->ship_class < OCEAN_SHIP )
space.c~:      else if( ship->ship_class == OCEAN_SHIP )
space.c~:      else if( ship->ship_class > OCEAN_SHIP )
space.c~:   sprintf( buf, "%s %ss %s.", ship->name, txt, dir_name[door] );
space.c~:   echo_to_room( AT_ACTION, get_room_index( ship->location ), buf );
space.c~:   ship_to_room( ship, to_room->vnum );
space.c~:   ship->location = to_room->vnum;
space.c~:   ship->lastdoc = ship->location;
space.c~:   else if( ship->ship_class < OCEAN_SHIP )
space.c~:   else if( ship->ship_class == OCEAN_SHIP )
space.c~:   else if( ship->ship_class > OCEAN_SHIP )
space.c~:         dtxt = "the south-west";
space.c~:         dtxt = "the south-east";
space.c~:         dtxt = "the north-west";
space.c~:         dtxt = "the north-east";
space.c~:   sprintf( buf, "%s %s from %s.", ship->name, txt, dtxt );
space.c~:   echo_to_room( AT_ACTION, get_room_index( ship->location ), buf );
space.c~:   for( rch = ch->in_room->last_person; rch; rch = next_rch )
space.c~:      next_rch = rch->prev_in_room;
space.c~:      original = rch->in_room;
space.c~:	|| ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
space.c~:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:	if( ship->ship_class > SHIP_PLATFORM )
space.c~:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:	if( !ship->starsystem )
space.c~:	target = get_ship_here( arg, ship->starsystem );
space.c~:        ship->hx = target->vx - ship->vx;
space.c~:        ship->hy = target->vy - ship->vy;
space.c~:        ship->energy -= ( ship->currspeed / 10 );
space.c~:	sprintf( buf, "%s turns altering its present course.", ship->name );
space.c~:	if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c~:		ship->shipstate = SHIP_BUSY_3;
space.c~:	else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c~:		ship->shipstate = SHIP_BUSY_2;
space.c~:		ship->shipstate = SHIP_BUSY;
space.c~:	if( ship->ship_class == FIGHTER_SHIP )
space.c~:	if( ship->ship_class == MIDSIZE_SHIP )
space.c~:	if( ship->ship_class == CAPITAL_SHIP )
space.c~:	if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:	if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
space.c~:	if( ship->ship_class > SHIP_PLATFORM )
space.c~:	if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:	if( !ship->starsystem )
space.c~:        if( ship->shipstate != SHIP_READY)
space.c~:	if(ship->track0 != NULL)
space.c~:      		sprintf( buf, "You are too busy tracking %s.", ship->track0->name );
space.c~:        if(  ship->turnarc != 0 )
space.c~:    		echo_to_room( AT_YELLOW, get_room_index( ship->pilotseat ), "Manuever complete." );
space.c~:	 	sprintf( buf, "Turn complete.  New heading: %0.2f degrees.",radianstodegrees(ship->heading));
space.c~:		ship->turnarc = 0;
space.c~:	ship->prevheading = ship->heading;
space.c~:		ship->turnarc = modifier * PI / 180;
space.c~:	else if ( arg[0] == '-' && arg[1] != '\0' )
space.c~:		ship->turnarc = -modifier * PI / 180;
space.c~:		ship->turnarc = newheading - ship->heading;
space.c~:	if (ship->heading < 0)
space.c~:		ship->heading += 2*PI;
space.c~:        ship->energy -= ( ship->currspeed / 10 );
space.c~:	ch_printf( ch, "&GAdjusting course by %0.f degrees.\r\n",radianstodegrees(ship->turnarc));
space.c~:	sprintf( buf, "%s turns altering its present course.", ship->name );
space.c~:	REMOVE_BIT(ship->flightflags,SHIP_AUTOMANEUVER);
space.c~:	if( ship->ship_class == FIGHTER_SHIP || ( ship->ship_class == MIDSIZE_SHIP && ship->manuever > 50 ) )
space.c~:		ship->shipstate = SHIP_BUSY_3;
space.c~:	else if( ship->ship_class == MIDSIZE_SHIP || ( ship->ship_class == CAPITAL_SHIP && ship->manuever > 50 ) )
space.c~:		ship->shipstate = SHIP_BUSY_2;
space.c~:		ship->shipstate = SHIP_BUSY;
space.c~:	if( ship->ship_class == FIGHTER_SHIP )
space.c~:	if( ship->ship_class == MIDSIZE_SHIP )
space.c~:	if( ship->ship_class == CAPITAL_SHIP )
space.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->ship_class > SHIP_PLATFORM )
space.c~:   if( ( ship = ship_from_coseat( ch->in_room->vnum ) ) == NULL )
space.c~:   if( ship->shipstate == SHIP_HYPERSPACE )
space.c~:   if( ship->shipstate == SHIP_DOCKED )
space.c~:   if( ship->chaff <= 0 )
space.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_weaponsystems] );
space.c~:   ship->chaff--;
space.c~:   ship->chaff_released++;
space.c~:   if( ship->type == MOB_SHIP )
space.c~:   if( ship->autopilot )
space.c~:    switch( ch->substate )
space.c~:    	        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c~:                if (ship->shipstate == SHIP_HYPERSPACE)
space.c~:                if (ship->shipstate == SHIP_DISABLED)
space.c~:    	        if (ship->shipstate == SHIP_DOCKED)
space.c~:    	        if (ship->shipstate != SHIP_READY)
space.c~:                if ( ship->energy <1 )
space.c~:                if ( ship->ship_class == FIGHTER_SHIP )
space.c~:                    schance = IS_NPC(ch) ? ch->top_level
space.c~:	                 : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
space.c~:                if ( ship->ship_class == MIDSIZE_SHIP )
space.c~:                    schance = IS_NPC(ch) ? ch->top_level
space.c~:	                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
space.c~:                if ( ship->ship_class == CAPITAL_SHIP )
space.c~:                    schance = IS_NPC(ch) ? ch->top_level
space.c~:	                 : (int) (ch->pcdata->learned[gsn_capitalships]);
space.c~:		   echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c~:    		   ch->dest_buf = str_dup(arg);
space.c~:	        if ( ship->ship_class == FIGHTER_SHIP )
space.c~:                if ( ship->ship_class == MIDSIZE_SHIP )
space.c~:                if ( ship->ship_class == CAPITAL_SHIP )
space.c~:    		if ( !ch->dest_buf )
space.c~:    		strcpy(arg, ch->dest_buf);
space.c~:    		DISPOSE( ch->dest_buf);
space.c~:    		DISPOSE( ch->dest_buf );
space.c~:    		ch->substate = SUB_NONE;
space.c~:    		if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c~:    	        echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c~:    		if (ship->shipstate != SHIP_DISABLED)
space.c~:    		   ship->shipstate = SHIP_READY;
space.c~:    ch->substate = SUB_NONE;
space.c~:    if ( (ship = ship_from_cockpit(ch->in_room->vnum)) == NULL )
space.c~:    echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c~:    if ( ship->ship_class == FIGHTER_SHIP )
space.c~:    if ( ship->ship_class == MIDSIZE_SHIP )
space.c~:    if ( ship->ship_class == CAPITAL_SHIP )
space.c~:        if (  (ship = ship_from_cockpit(ch->in_room->vnum))  == NULL )
space.c~:                if (ship->shipstate == SHIP_HYPERSPACE)
space.c~:                if (ship->shipstate == SHIP_DISABLED)
space.c~:    	        if (ship->shipstate == SHIP_DOCKED)
space.c~:    	        if (ship->shipstate != SHIP_READY)
space.c~:        if ( ship->energy <1 )
space.c~:        if ( ship->ship_class == FIGHTER_SHIP )
space.c~:             schance = IS_NPC(ch) ? ch->top_level
space.c~:             : (int)  (ch->pcdata->learned[gsn_starfighters]) ;
space.c~:        if ( ship->ship_class == MIDSIZE_SHIP )
space.c~:             schance = IS_NPC(ch) ? ch->top_level
space.c~:                 : (int)  (ch->pcdata->learned[gsn_midships]) ;
space.c~:        if ( ship->ship_class == CAPITAL_SHIP )
space.c~:              schance = IS_NPC(ch) ? ch->top_level
space.c~:                 : (int) (ch->pcdata->learned[gsn_capitalships]);
space.c~:            if ( ship->ship_class == FIGHTER_SHIP )
space.c~:            if ( ship->ship_class == MIDSIZE_SHIP )   
space.c~:            if ( ship->ship_class == CAPITAL_SHIP )
space.c~:    echo_to_room( AT_YELLOW , get_room_index(ship->cockpit) , "");
space.c~:    if ( ship->ship_class == FIGHTER_SHIP )
space.c~:    if ( ship->ship_class == MIDSIZE_SHIP )
space.c~:    if ( ship->ship_class == CAPITAL_SHIP )
special.c:*--------------------------------------------------------------------------*
special.c:* -------------------------------------------------------------------------*
special.c:*--------------------------------------------------------------------------*
special.c:* ------------------------------------------------------------------------ *
special.c:* ------------------------------------------------------------------------ *
special.c:/* Simple load function - no OLC support for now.
special.c:      bug( "%s", "load_specfuns: FATAL - cannot load specfuns.dat, exiting." );
special.c:         specfun->name = str_dup( word );
special.c:   for( specfun = first_specfun; specfun; specfun = specfun->next )
special.c:      if( !str_cmp( specfun->name, name ) )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_NPC( victim ) || victim->position == POS_FIGHTING )
special.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:         if( obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_DIPLOMA )
special.c:      switch ( victim->race )
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:            sprintf( buf, "Hmm, a %s.", race_table[victim->race].race_name );
special.c:            do_look( ch, victim->name );
special.c:            echo_to_room( AT_ACTION, ch->in_room,
special.c:      sprintf( buf, "%s steps out and the shuttle quickly returns to the academy.\r\n", victim->name );
special.c:      echo_to_room( AT_ACTION, ch->in_room, buf );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( !IS_NPC( victim ) && victim->pcdata && victim->pcdata->clan && IS_AWAKE( victim )
special.c:          && str_cmp( ch->name, victim->pcdata->clan->name ) )
special.c:   if( !IS_AWAKE( ch ) || ch->position == POS_FIGHTING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_NPC( victim ) || victim->position == POS_FIGHTING )
special.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:         if( obj->pIndexData->item_type == ITEM_SMUT )
special.c:               sprintf( buf, "%s is illegal contraband. I'm going to have to confiscate that.", obj->short_descr );
special.c:               if( obj->wear_loc != WEAR_NONE )
special.c:                  remove_obj( victim, obj->wear_loc, TRUE );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               gain_exp( victim, 0 - ch_exp, SMUGGLING_ABILITY );
special.c:            else if( can_see( ch, victim ) && !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:            else if( !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:         else if( obj->item_type == ITEM_CONTAINER )
special.c:            for( content = obj->first_content; content; content = content->next_content )
special.c:               if( content->pIndexData->item_type == ITEM_SMUT && !IS_SET( content->extra_flags, ITEM_CONTRABAND ) )
special.c:                     UMIN( content->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, content->short_descr );
special.c:                  SET_BIT( content->extra_flags, ITEM_CONTRABAND );
special.c:   if( !IS_AWAKE( ch ) || ch->position == POS_FIGHTING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_NPC( victim ) || victim->position == POS_FIGHTING )
special.c:      if( victim->pcdata && victim->pcdata->clan && !str_cmp( victim->pcdata->clan->name, ch->mob_clan ) )
special.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:         if( obj->pIndexData->item_type == ITEM_WEAPON )
special.c:               sprintf( buf, "Weapons are banned from non-military usage. I'm going to have to confiscate %s.",
special.c:                        obj->short_descr );
special.c:               if( obj->wear_loc != WEAR_NONE )
special.c:                  remove_obj( victim, obj->wear_loc, TRUE );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               gain_exp( victim, 0 - ch_exp, SMUGGLING_ABILITY );
special.c:            else if( can_see( ch, victim ) && !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %d.\r\n ", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:            else if( !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:         else if( obj->item_type == ITEM_CONTAINER )
special.c:            for( content = obj->first_content; content; content = content->next_content )
special.c:               if( content->pIndexData->item_type == ITEM_WEAPON && !IS_SET( content->extra_flags, ITEM_CONTRABAND ) )
special.c:                     UMIN( content->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, content->short_descr );
special.c:                  SET_BIT( content->extra_flags, ITEM_CONTRABAND );
special.c:   if( !IS_AWAKE( ch ) || ch->position == POS_FIGHTING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_NPC( victim ) || victim->position == POS_FIGHTING )
special.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:         if( obj->pIndexData->item_type == ITEM_DRINK_CON )
special.c:            if( ( liquid = obj->value[2] ) >= LIQ_MAX )
special.c:               liquid = obj->value[2] = 0;
special.c:                  sprintf( buf, "%s is illegal contraband. I'm going to have to confiscate that.", obj->short_descr );
special.c:                  if( obj->wear_loc != WEAR_NONE )
special.c:                     remove_obj( victim, obj->wear_loc, TRUE );
special.c:                  SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:                     UMIN( obj->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  gain_exp( victim, 0 - ch_exp, SMUGGLING_ABILITY );
special.c:               else if( can_see( ch, victim ) && !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                     UMIN( obj->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %d. \r\n", ch_exp, obj->short_descr );
special.c:                  SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:               else if( !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                     UMIN( obj->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %d. \r\n", ch_exp, obj->short_descr );
special.c:                  SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:         else if( obj->item_type == ITEM_CONTAINER )
special.c:            for( content = obj->first_content; content; content = content->next_content )
special.c:               if( content->pIndexData->item_type == ITEM_DRINK_CON && !IS_SET( content->extra_flags, ITEM_CONTRABAND ) )
special.c:                  if( ( liquid = obj->value[2] ) >= LIQ_MAX )
special.c:                     liquid = obj->value[2] = 0;
special.c:                     UMIN( content->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %d.\r\n ", ch_exp, content->short_descr );
special.c:                  SET_BIT( content->extra_flags, ITEM_CONTRABAND );
special.c:   if( !IS_AWAKE( ch ) || ch->position == POS_FIGHTING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_NPC( victim ) || victim->position == POS_FIGHTING )
special.c:      for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:         if( obj->pIndexData->item_type == ITEM_SPICE || obj->pIndexData->item_type == ITEM_RAWSPICE )
special.c:               sprintf( buf, "%s is illegal contraband. I'm going to have to confiscate that.", obj->short_descr );
special.c:               if( obj->wear_loc != WEAR_NONE )
special.c:                  remove_obj( victim, obj->wear_loc, TRUE );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               gain_exp( victim, 0 - ch_exp, SMUGGLING_ABILITY );
special.c:            else if( can_see( ch, victim ) && !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %s. \r\n", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:            else if( !IS_SET( obj->extra_flags, ITEM_CONTRABAND ) )
special.c:                  UMIN( obj->cost * 10,
special.c:                        ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                          exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:               ch_printf( victim, "You receive %ld experience for smuggling %s. \r\n", ch_exp, obj->short_descr );
special.c:               SET_BIT( obj->extra_flags, ITEM_CONTRABAND );
special.c:         else if( obj->item_type == ITEM_CONTAINER )
special.c:            for( content = obj->first_content; content; content = content->next_content )
special.c:               if( content->pIndexData->item_type == ITEM_SPICE && !IS_SET( content->extra_flags, ITEM_CONTRABAND ) )
special.c:                     UMIN( content->cost * 10,
special.c:                           ( exp_level( victim->skill_level[SMUGGLING_ABILITY] + 1 ) -
special.c:                             exp_level( victim->skill_level[SMUGGLING_ABILITY] ) ) );
special.c:                  ch_printf( victim, "You receive %ld experience for smuggling %s.\r\n ", ch_exp, content->short_descr );
special.c:                  SET_BIT( content->extra_flags, ITEM_CONTRABAND );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         if( IS_SET( ch->vip_flags, 1 << vip ) && IS_SET( victim->pcdata->wanted_flags, 1 << vip ) )
special.c:            REMOVE_BIT( victim->pcdata->wanted_flags, 1 << vip );
special.c:            if( ch->top_level >= victim->top_level )
special.c:               victim->gold /= 2;
special.c:               REMOVE_BIT( victim->pcdata->wanted_flags, 1 << vip );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         if( IS_SET( ch->vip_flags, 1 << vip ) && IS_SET( victim->pcdata->wanted_flags, 1 << vip ) )
special.c:            REMOVE_BIT( victim->pcdata->wanted_flags, 1 << vip );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         if( IS_SET( ch->vip_flags, 1 << vip ) && IS_SET( victim->pcdata->wanted_flags, 1 << vip ) )
special.c:            victim->gold /= 2;
special.c:            REMOVE_BIT( victim->pcdata->wanted_flags, 1 << vip );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         if( IS_SET( ch->vip_flags, 1 << vip ) && IS_SET( victim->pcdata->wanted_flags, 1 << vip ) )
special.c:               REMOVE_BIT( victim->pcdata->wanted_flags, 1 << vip );
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         spell_smaug( skill_lookup( "armor" ), ch->top_level, ch, victim );
special.c:         spell_smaug( skill_lookup( "good fortune" ), ch->top_level, ch, victim );
special.c:         spell_cure_blindness( skill_lookup( "cure blindness" ), ch->top_level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure light" ), ch->top_level, ch, victim );
special.c:         spell_cure_poison( skill_lookup( "cure poison" ), ch->top_level, ch, victim );
special.c:         spell_smaug( skill_lookup( "refresh" ), ch->top_level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( ch->top_level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->top_level, ch, victim );
special.c:   for( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:      c_next = corpse->next_content;
special.c:      if( corpse->item_type != ITEM_CORPSE_NPC )
special.c:      for( obj = corpse->first_content; obj; obj = obj_next )
special.c:         obj_next = obj->next_content;
special.c:         obj_to_room( obj, ch->in_room );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( ( IS_NPC( victim ) && nifty_is_name( "republic", victim->name )
special.c:            && victim->fighting && who_fighting( victim ) != ch ) ||
special.c:          ( !IS_NPC( victim ) && victim->pcdata && victim->pcdata->clan && IS_AWAKE( victim )
special.c:            && nifty_is_name( "republic", victim->pcdata->clan->name ) ) )
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( ( IS_NPC( victim ) && nifty_is_name( "imperial", victim->name )
special.c:            && victim->fighting && who_fighting( victim ) != ch ) ||
special.c:          ( !IS_NPC( victim ) && victim->pcdata && victim->pcdata->clan && IS_AWAKE( victim )
special.c:            && nifty_is_name( "empire", victim->pcdata->clan->name ) ) )
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( victim->fighting && who_fighting( victim ) != ch && victim->alignment < max_evil )
special.c:         max_evil = victim->alignment;
special.c:   if( victim && IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:      sprintf( buf, "%s is a %s!  As well as a COWARD!", victim->name, crime );
special.c:      sprintf( buf, "%s is a %s!  PROTECT THE INNOCENT!!", victim->name, crime );
special.c:   for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:      trash_next = trash->next_content;
special.c:      if( !IS_SET( trash->wear_flags, ITEM_TAKE ) || IS_OBJ_STAT( trash, ITEM_BURRIED ) )
special.c:      if( IS_OBJ_STAT( trash, ITEM_PROTOTYPE ) && !IS_SET( ch->act, ACT_PROTOTYPE ) )
special.c:      if( trash->item_type == ITEM_DRINK_CON
special.c:          || trash->item_type == ITEM_TRASH
special.c:          || trash->cost < 10 || ( trash->pIndexData->vnum == OBJ_VNUM_SHOPPING_BAG && !trash->first_content ) )
special.c:   if( ch->position != POS_FIGHTING || ( victim = who_fighting( ch ) ) == NULL || number_percent(  ) > 2 * ch->top_level )
special.c:   spell_poison( gsn_poison, ch->top_level, ch, victim );
special.c:   if( ch->position != POS_STANDING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:      if( IS_AWAKE( victim ) && number_range( 0, ch->top_level ) == 0 )
special.c:         maxgold = ch->top_level * ch->top_level * 1000;
special.c:         gold = victim->gold * number_range( 1, URANGE( 2, ch->top_level / 4, 10 ) ) / 100;
special.c:         ch->gold += 9 * gold / 10;
special.c:         victim->gold -= gold;
special.c:         if( ch->gold > maxgold )
special.c:            boost_economy( ch->in_room->area, ch->gold - maxgold / 2 );
special.c:            ch->gold = maxgold / 2;
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      v_next = victim->next_in_room;
special.c:         for( obj = victim->last_carrying; obj; obj = obj->prev_content )
special.c:            if( obj->pIndexData == get_obj_index( OBJ_VNUM_SCHOOL_DIPLOMA ) )
special.c:      if( IS_NPC( victim ) || !IS_SET( victim->pcdata->flags, PCFLAG_UNAUTHED ) )
special.c:      victim->pcdata->auth_state = 3;
special.c:      REMOVE_BIT( victim->pcdata->flags, PCFLAG_UNAUTHED );
special.c:      if( victim->pcdata->authed_by )
special.c:         STRFREE( victim->pcdata->authed_by );
special.c:      victim->pcdata->authed_by = QUICKLINK( ch->name );
special.c:      sprintf( buf, "%s authorized %s", ch->name, victim->name );
special.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", ch->top_level );
startup:#! /bin/csh -f
startup:if ( -e shutdown.txt ) rm -f shutdown.txt
startup:	if ( ! -e $logfile ) break
startup:    set matches = `netstat -an | grep ":$port " | grep -c LISTEN`
startup:    if ( -e shutdown.txt ) then
startup:	rm -f shutdown.txt
swskills.c:*--------------------------------------------------------------------------*
swskills.c:* -------------------------------------------------------------------------*
swskills.c:*--------------------------------------------------------------------------*
swskills.c:* ------------------------------------------------------------------------ *
swskills.c:* ------------------------------------------------------------------------ *
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_DURASTEEL )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_OVEN )
swskills.c:            send_to_char( "&RYou need toolkit to make a vibro-blade.\r\n", ch );
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_OVEN )
swskills.c:      if( obj->item_type == ITEM_DURASTEEL && checkdura == FALSE )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:         charge = UMAX( 5, obj->value[0] );
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c:   obj->item_type = ITEM_WEAPON;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = 3;
swskills.c:   STRFREE( obj->name );
swskills.c:   strcat( buf, " vibro-blade blade" );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   paf->type = -1;
swskills.c:   paf->duration = -1;
swskills.c:   paf->location = get_atype( "backstab" );
swskills.c:   paf->modifier = level / 3;
swskills.c:   paf->bitvector = 0;
swskills.c:   paf->next = NULL;
swskills.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   paf2->type = -1;
swskills.c:   paf2->duration = -1;
swskills.c:   paf2->location = get_atype( "hitroll" );
swskills.c:   paf2->modifier = -2;
swskills.c:   paf2->bitvector = 0;
swskills.c:   paf2->next = NULL;
swskills.c:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   obj->value[0] = INIT_WEAPON_CONDITION;
swskills.c:   obj->value[1] = ( int )( level / 20 + 10 );  /* min dmg  */
swskills.c:   obj->value[2] = ( int )( level / 10 + 20 );  /* max dmg */
swskills.c:   obj->value[3] = WEAPON_VIBRO_BLADE;
swskills.c:   obj->value[4] = charge;
swskills.c:   obj->value[5] = charge;
swskills.c:   obj->cost = obj->value[2] * 10;
swskills.c:   act( AT_PLAIN, "$n finishes crafting a vibro-blade.", ch, NULL, argument, TO_ROOM );
swskills.c:         UMIN( obj->cost * 200,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_DURAPLAST )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_OVEN )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_OVEN )
swskills.c:      if( obj->item_type == ITEM_DURAPLAST && checkdura == FALSE )
swskills.c:      if( obj->item_type == ITEM_AMMO && checkammo == FALSE )
swskills.c:         ammo = obj->value[0];
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:      if( obj->item_type == ITEM_LENS && scope == 0 )
swskills.c:      if( obj->item_type == ITEM_SUPERCONDUCTOR && power < 2 )
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c:   obj->item_type = ITEM_WEAPON;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = 2 + level / 10;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   paf->type = -1;
swskills.c:   paf->duration = -1;
swskills.c:   paf->location = get_atype( "hitroll" );
swskills.c:   paf->modifier = URANGE( 0, 1 + scope, level / 30 );
swskills.c:   paf->bitvector = 0;
swskills.c:   paf->next = NULL;
swskills.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   paf2->type = -1;
swskills.c:   paf2->duration = -1;
swskills.c:   paf2->location = get_atype( "damroll" );
swskills.c:   paf2->modifier = URANGE( 0, power, level / 30 );
swskills.c:   paf2->bitvector = 0;
swskills.c:   paf2->next = NULL;
swskills.c:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   obj->value[0] = INIT_WEAPON_CONDITION; /* condition  */
swskills.c:   obj->value[1] = ( int )( level / 10 + 15 );  /* min dmg  */
swskills.c:   obj->value[2] = ( int )( level / 5 + 25 );   /* max dmg  */
swskills.c:   obj->value[3] = WEAPON_BLASTER;
swskills.c:   obj->value[4] = ammo;
swskills.c:   obj->value[5] = 2000;
swskills.c:   obj->cost = obj->value[2] * 50;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_LENS )
swskills.c:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c:            if( obj->item_type == ITEM_MIRROR )
swskills.c:            if( obj->item_type == ITEM_DURAPLAST || obj->item_type == ITEM_DURASTEEL )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_OVEN )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_OVEN )
swskills.c:      if( ( obj->item_type == ITEM_DURAPLAST || obj->item_type == ITEM_DURASTEEL ) && checkdura == FALSE )
swskills.c:      if( obj->item_type == ITEM_DURASTEEL && checkdura == FALSE )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:         charge = UMIN( obj->value[1], 10 );
swskills.c:      if( obj->item_type == ITEM_SUPERCONDUCTOR && checkcond == FALSE )
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:      if( obj->item_type == ITEM_LENS && checklens == FALSE )
swskills.c:      if( obj->item_type == ITEM_MIRROR && checkmirr == FALSE )
swskills.c:      if( obj->item_type == ITEM_CRYSTAL && gems < 3 )
swskills.c:         if( gemtype < obj->value[0] )
swskills.c:            gemtype = obj->value[0];
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c:   obj->item_type = ITEM_WEAPON;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   SET_BIT( obj->extra_flags, ITEM_ANTI_SOLDIER );
swskills.c:   SET_BIT( obj->extra_flags, ITEM_ANTI_THIEF );
swskills.c:   SET_BIT( obj->extra_flags, ITEM_ANTI_HUNTER );
swskills.c:   SET_BIT( obj->extra_flags, ITEM_ANTI_PILOT );
swskills.c:   SET_BIT( obj->extra_flags, ITEM_ANTI_CITIZEN );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = 5;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( "lightsaber saber" );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   STRFREE( obj->action_desc );
swskills.c:   obj->action_desc = STRALLOC( buf );
swskills.c:   paf->type = -1;
swskills.c:   paf->duration = -1;
swskills.c:   paf->location = get_atype( "hitroll" );
swskills.c:   paf->modifier = URANGE( 0, gems, level / 30 );
swskills.c:   paf->bitvector = 0;
swskills.c:   paf->next = NULL;
swskills.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   paf2->type = -1;
swskills.c:   paf2->duration = -1;
swskills.c:   paf2->location = get_atype( "parry" );
swskills.c:   paf2->modifier = ( level / 3 );
swskills.c:   paf2->bitvector = 0;
swskills.c:   paf2->next = NULL;
swskills.c:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c:   obj->value[0] = INIT_WEAPON_CONDITION; /* condition  */
swskills.c:   obj->value[1] = ( int )( level / 10 + gemtype * 2 );  /* min dmg  */
swskills.c:   obj->value[2] = ( int )( level / 5 + gemtype * 6 );   /* max dmg */
swskills.c:   obj->value[3] = WEAPON_LIGHTSABER;
swskills.c:   obj->value[4] = charge;
swskills.c:   obj->value[5] = charge;
swskills.c:   obj->cost = obj->value[2] * 75;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[FORCE_ABILITY] + 1 ) - exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_REFINERY ) )
swskills.c:         if( obj->item_type != ITEM_RAWSPICE )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_spice_refining] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   if( obj->item_type != ITEM_RAWSPICE )
swskills.c:   obj->value[1] = URANGE( 10, obj->value[1], ( IS_NPC( ch ) ? ch->top_level
swskills.c:                                                : ( int )( ch->pcdata->learned[gsn_spice_refining] ) ) + 10 );
swskills.c:   strcpy( buf, obj->name );
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   strcat( buf, obj->short_descr );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->item_type = ITEM_SPICE;
swskills.c:   obj->cost += obj->value[1] * 10;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_DRINK_CON && obj->value[1] == 0 )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_DRINK_CON && checkdrink == FALSE && obj->value[1] == 0 )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c:         strength = URANGE( 10, obj->value[0], level * 5 );
swskills.c:         weight = obj->weight;
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c:   obj->item_type = ITEM_GRENADE;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = weight;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = strength / 2;
swskills.c:   obj->value[1] = strength;
swskills.c:   obj->cost = obj->value[1] * 5;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_DRINK_CON && obj->value[1] == 0 )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_DRINK_CON && checkdrink == FALSE && obj->value[1] == 0 )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c:         strength = URANGE( 10, obj->value[0], level * 5 );
swskills.c:         weight = obj->weight;
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c:   obj->item_type = ITEM_LANDMINE;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = weight;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = strength / 2;
swskills.c:   obj->value[1] = strength;
swskills.c:   obj->cost = obj->value[1] * 5;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c:            if( obj->item_type == ITEM_LENS )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:         strength = obj->value[0];
swskills.c:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:      if( obj->item_type == ITEM_LENS && checklens == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c:   obj->item_type = ITEM_LIGHT;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = 3;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[2] = strength;
swskills.c:   obj->cost = obj->value[2];
swskills.c:         UMIN( obj->cost * 100,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_OVEN )
swskills.c:            if( obj->item_type == ITEM_RARE_METAL )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c:         if( !ch->dest_buf )
swskills.c:         if( !ch->dest_buf_2 )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_OVEN )
swskills.c:      if( obj->item_type == ITEM_RARE_METAL && checkmetal == FALSE )
swskills.c:      if( obj->item_type == ITEM_CRYSTAL )
swskills.c:         cost += obj->cost;
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c:   obj->item_type = ITEM_ARMOR;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:      SET_BIT( obj->wear_flags, ITEM_WEAR_NECK );
swskills.c:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c:   obj->level = level;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = obj->value[1];
swskills.c:   obj->cost *= 10;
swskills.c:   obj->cost += cost;
swskills.c:         UMIN( obj->cost * 100,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_FABRIC )
swskills.c:            if( obj->item_type == ITEM_THREAD )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c:         if( !ch->dest_buf )
swskills.c:         if( !ch->dest_buf_2 )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_THREAD )
swskills.c:      if( obj->item_type == ITEM_FABRIC && checkfab == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c:   obj->item_type = ITEM_ARMOR;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:      SET_BIT( obj->wear_flags, ITEM_WEAR_BODY );
swskills.c:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c:   obj->level = level;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = obj->value[1];
swskills.c:   obj->cost *= 10;
swskills.c:         UMIN( obj->cost * 100,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecomlink] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_CRYSTAL && checkgem == FALSE )
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecomlink] );
swskills.c:   obj = create_object( pObjIndex, ch->top_level );
swskills.c:   obj->item_type = ITEM_COMLINK;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:   obj->weight = 3;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->cost = 50;
swskills.c:         UMIN( obj->cost * 100,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c:            if( obj->item_type == ITEM_BATTERY )
swskills.c:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c:         charge = UMIN( obj->value[1], 10 );
swskills.c:      if( obj->item_type == ITEM_SUPERCONDUCTOR && checkcond == FALSE )
swskills.c:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c:      if( obj->item_type == ITEM_CRYSTAL && checkgems == FALSE )
swskills.c:         gemtype = obj->value[0];
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c:   obj->item_type = ITEM_ARMOR;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c:   SET_BIT( obj->wear_flags, ITEM_WEAR_SHIELD );
swskills.c:   obj->level = level;
swskills.c:   obj->weight = 2;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( "energy shield" );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = ( int )( level / 10 + gemtype * 2 );  /* condition */
swskills.c:   obj->value[1] = ( int )( level / 10 + gemtype * 2 );  /* armor */
swskills.c:   obj->value[4] = charge;
swskills.c:   obj->value[5] = charge;
swskills.c:   obj->cost = obj->value[2] * 100;
swskills.c:         UMIN( obj->cost * 50,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   switch ( ch->substate )
swskills.c:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:            if( obj->item_type == ITEM_FABRIC )
swskills.c:            if( obj->item_type == ITEM_THREAD )
swskills.c:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c:         if( !ch->dest_buf )
swskills.c:         if( !ch->dest_buf_2 )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf_2 );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c:      if( obj->item_type == ITEM_THREAD )
swskills.c:      if( obj->item_type == ITEM_FABRIC && checkfab == FALSE )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c:   obj->item_type = ITEM_CONTAINER;
swskills.c:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c:      SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c:   obj->level = level;
swskills.c:   STRFREE( obj->name );
swskills.c:   obj->name = STRALLOC( buf );
swskills.c:   STRFREE( obj->short_descr );
swskills.c:   obj->short_descr = STRALLOC( buf );
swskills.c:   STRFREE( obj->description );
swskills.c:   obj->description = STRALLOC( buf );
swskills.c:   obj->value[0] = level;
swskills.c:   obj->value[1] = 0;
swskills.c:   obj->value[2] = 0;
swskills.c:   obj->value[3] = 10;
swskills.c:   obj->cost *= 2;
swskills.c:         UMIN( obj->cost * 100,
swskills.c:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c:   switch ( ch->substate )
swskills.c:         if( ch->backup_wait )
swskills.c:         if( !ch->pcdata->clan )
swskills.c:         if( ch->gold < ch->skill_level[LEADERSHIP_ABILITY] * 50 )
swskills.c:         schance = ( int )( ch->pcdata->learned[gsn_reinforcements] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   credits = ch->skill_level[LEADERSHIP_ABILITY] * 50;
swskills.c:   ch->gold -= UMIN( credits, ch->gold );
swskills.c:   if( nifty_is_name( "empire", ch->pcdata->clan->name ) )
swskills.c:      ch->backup_mob = MOB_VNUM_STORMTROOPER;
swskills.c:   else if( nifty_is_name( "republic", ch->pcdata->clan->name ) )
swskills.c:      ch->backup_mob = MOB_VNUM_NR_TROOPER;
swskills.c:      ch->backup_mob = MOB_VNUM_MERCINARY;
swskills.c:   ch->backup_wait = number_range( 1, 2 );
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c:   switch ( ch->substate )
swskills.c:         if( ch->backup_wait )
swskills.c:         if( !ch->pcdata->clan )
swskills.c:         if( ch->gold < ch->skill_level[LEADERSHIP_ABILITY] * 30 )
swskills.c:         schance = ( int )( ch->pcdata->learned[gsn_postguard] );
swskills.c:            ch->dest_buf = str_dup( arg );
swskills.c:         if( !ch->dest_buf )
swskills.c:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         DISPOSE( ch->dest_buf );
swskills.c:         ch->substate = SUB_NONE;
swskills.c:   ch->substate = SUB_NONE;
swskills.c:   credits = ch->skill_level[LEADERSHIP_ABILITY] * 30;
swskills.c:   ch->gold -= UMIN( credits, ch->gold );
swskills.c:   if( nifty_is_name( "empire", ch->pcdata->clan->name ) )
swskills.c:      ch->backup_mob = MOB_VNUM_IMP_GUARD;
swskills.c:   else if( nifty_is_name( "republic", ch->pcdata->clan->name ) )
swskills.c:      ch->backup_mob = MOB_VNUM_NR_GUARD;
swskills.c:      ch->backup_mob = MOB_VNUM_BOUNCER;
swskills.c:   ch->backup_wait = 1;
swskills.c:   if( ( pMobIndex = get_mob_index( ch->backup_mob ) ) == NULL )
swskills.c:   if( ch->backup_mob == MOB_VNUM_STORMTROOPER ||
swskills.c:       ch->backup_mob == MOB_VNUM_NR_TROOPER || ch->backup_mob == MOB_VNUM_MERCINARY )
swskills.c:         char_to_room( mob[mob_cnt], ch->in_room );
swskills.c:         mob[mob_cnt]->top_level = ch->skill_level[LEADERSHIP_ABILITY] / 3;
swskills.c:            mob[mob_cnt]->skill_level[ability] = mob[mob_cnt]->top_level;
swskills.c:         mob[mob_cnt]->hit = mob[mob_cnt]->top_level * 15;
swskills.c:         mob[mob_cnt]->max_hit = mob[mob_cnt]->hit;
swskills.c:         mob[mob_cnt]->armor = ( short )( LEVEL_HERO - mob[mob_cnt]->top_level * 2.5 );
swskills.c:         mob[mob_cnt]->damroll = mob[mob_cnt]->top_level / 5;
swskills.c:         mob[mob_cnt]->hitroll = mob[mob_cnt]->top_level / 5;
swskills.c:            blaster = create_object( pObjIndex, mob[mob_cnt]->top_level );
swskills.c:         if( mob[mob_cnt]->master )
swskills.c:         SET_BIT( mob[mob_cnt]->affected_by, AFF_CHARM );
swskills.c:      char_to_room( mob, ch->in_room );
swskills.c:      if( ch->pcdata && ch->pcdata->clan )
swskills.c:         STRFREE( mob->name );
swskills.c:         mob->name = STRALLOC( ch->pcdata->clan->name );
swskills.c:         sprintf( tmpbuf, "(%s) %s", ch->pcdata->clan->name, mob->long_descr );
swskills.c:         STRFREE( mob->long_descr );
swskills.c:         mob->long_descr = STRALLOC( tmpbuf );
swskills.c:      mob->top_level = ch->skill_level[LEADERSHIP_ABILITY];
swskills.c:         mob->skill_level[ability] = mob->top_level;
swskills.c:      mob->hit = mob->top_level * 15;
swskills.c:      mob->max_hit = mob->hit;
swskills.c:      mob->armor = ( short )( LEVEL_HERO - mob->top_level * 2.5 );
swskills.c:      mob->damroll = mob->top_level / 5;
swskills.c:      mob->hitroll = mob->top_level / 5;
swskills.c:         blaster = create_object( pObjIndex, mob->top_level );
swskills.c:      if( mob->mob_clan )
swskills.c:         STRFREE( mob->mob_clan );
swskills.c:      if( ch->pcdata && ch->pcdata->clan )
swskills.c:         mob->mob_clan = STRALLOC( ch->pcdata->clan->name );
swskills.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_torture] <= 0 )
swskills.c:   if( ch->mount )
swskills.c:   if( victim->fighting )
swskills.c:   ch->alignment = ch->alignment -= 100;
swskills.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
swskills.c:   WAIT_STATE( ch, skill_table[gsn_torture]->beats );
swskills.c:   schance = ris_save( victim, ch->skill_level[HUNTING_ABILITY], RIS_PARALYSIS );
swskills.c:   if( !fail && ( IS_NPC( ch ) || ( number_percent(  ) + schance ) < ch->pcdata->learned[gsn_torture] ) )
swskills.c:      dam = dice( ch->skill_level[HUNTING_ABILITY] / 10, 4 );
swskills.c:      dam = URANGE( 0, victim->max_hit - 10, dam );
swskills.c:      victim->hit -= dam;
swskills.c:      victim->max_hit -= dam;
swskills.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
swskills.c:   schance = ( int )( ch->pcdata->learned[gsn_disguise] );
swskills.c:   if( ch->pcdata->learned[gsn_mine] <= 0 )
swskills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
swskills.c:      if( obj->item_type == ITEM_SHOVEL )
swskills.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
swskills.c:   if( obj->item_type != ITEM_LANDMINE )
swskills.c:   switch ( ch->in_room->sector_type )
swskills.c:   if( obj->weight > ( UMAX( 5, ( can_carry_w( ch ) / 10 ) ) ) && !shovel )
swskills.c:   move = ( obj->weight * 50 * ( shovel ? 1 : 5 ) ) / UMAX( 1, can_carry_w( ch ) );
swskills.c:   if( move > ch->move )
swskills.c:   ch->move -= move;
swskills.c:   SET_BIT( obj->extra_flags, ITEM_BURRIED );
swskills.c:   STRFREE( obj->armed_by );
swskills.c:   obj->armed_by = STRALLOC( ch->name );
swskills.c:   ch_printf( ch, "You arm and bury %s.\r\n", obj->short_descr );
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( !medpac || medpac->item_type != ITEM_MEDPAC )
swskills.c:   if( medpac->value[0] <= 0 )
swskills.c:   if( heal > ch->pcdata->learned[gsn_first_aid] * 2 )
swskills.c:      sprintf( buf, "$n uses %s to help heal $s wounds.", medpac->short_descr );
swskills.c:      sprintf( buf, "$n uses %s to help heal $N's wounds.", medpac->short_descr );
swskills.c:      sprintf( buf, "$n uses %s to help heal your wounds.", medpac->short_descr );
swskills.c:   --medpac->value[0];
swskills.c:   victim->hit += URANGE( 0, heal, victim->max_hit - victim->hit );
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( !wield || wield->item_type != ITEM_WEAPON || wield->value[3] != WEAPON_BLASTER )
swskills.c:   if( ( dir = get_door( arg ) ) == -1 || arg2[0] == '\0' )
swskills.c:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:   if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c:   was_in_room = ch->in_room;
swskills.c:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c:      if( !pexit->to_room )
swskills.c:      if( pexit->distance > 1 )
swskills.c:         to_room = generate_exit( ch->in_room, &pexit );
swskills.c:         to_room = pexit->to_room;
swskills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:   if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:   schance = IS_NPC( ch ) ? 100 : ( int )( ch->pcdata->learned[gsn_snipe] );
swskills.c:         dir -= 2;
swskills.c:         dir -= 1;
swskills.c:         dir -= 3;
swskills.c:      char_to_room( ch, victim->in_room );
swskills.c:      char_to_room( ch, victim->in_room );
swskills.c:      if( number_percent(  ) < ch->pcdata->learned[gsn_third_attack] )
swskills.c:      else if( number_percent(  ) < ch->pcdata->learned[gsn_second_attack] )
swskills.c:      if( IS_SET( victim->act, ACT_SENTINEL ) )
swskills.c:         victim->was_sentinel = victim->in_room;
swskills.c:         REMOVE_BIT( victim->act, ACT_SENTINEL );
swskills.c:   was_in_room = ch->in_room;
swskills.c:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c:      if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:      sprintf( buf, "$n throws %s at the floor.", obj->short_descr );
swskills.c:      ch_printf( ch, "You throw %s at the floor.\r\n", obj->short_descr );
swskills.c:   else if( ( dir = get_door( arg2 ) ) != -1 )
swskills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c:            dir -= 2;
swskills.c:            dir -= 1;
swskills.c:            dir -= 3;
swskills.c:      if( pexit->distance > 1 )
swskills.c:         to_room = generate_exit( ch->in_room, &pexit );
swskills.c:         to_room = pexit->to_room;
swskills.c:         if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c:         if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:         if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:         if( pexit->distance > 1 )
swskills.c:            to_room = generate_exit( ch->in_room, &pexit );
swskills.c:            to_room = pexit->to_room;
swskills.c:         sprintf( buf, "Someone throws %s at you from the %s.", obj->short_descr, dir_name[dir] );
swskills.c:         sprintf( buf, "$n throws %s to the %s.", obj->short_descr, dir_name[get_dir(arg2)] );
swskills.c:         sprintf( buf, "%s is thrown at $N from the %s.", obj->short_descr, dir_name[dir] );
swskills.c:         ch_printf( ch, "You throw %s %s.\r\n", obj->short_descr, dir_name[get_dir( arg2 )] );
swskills.c:         sprintf( buf, "$n throws %s to the %s.", obj->short_descr, dir_name[get_dir(arg2)] );
swskills.c:         sprintf( buf, "%s is thrown from the %s.", obj->short_descr, dir_name[dir] );
swskills.c:      if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c:      if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c:      tmpobj->wear_loc = WEAR_WIELD;
swskills.c:   obj = obj_to_room( obj, ch->in_room );
swskills.c:   if( obj->item_type != ITEM_GRENADE )
swskills.c:   if( ch->in_room != was_in_room )
swskills.c:      WAIT_STATE( ch, skill_table[gsn_throw]->beats );
swskills.c:      if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_throw] )
swskills.c:            damage( ch, victim, number_range( obj->weight * 2, ( obj->weight * 2 + ch->perm_str ) ), TYPE_HIT );
swskills.c:         if( IS_SET( victim->act, ACT_SENTINEL ) )
swskills.c:            victim->was_sentinel = victim->in_room;
swskills.c:            REMOVE_BIT( victim->act, ACT_SENTINEL );
swskills.c:   if( ch->mount )
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( victim->position == POS_FIGHTING )
swskills.c:   if( ch->position <= POS_SLEEPING )
swskills.c:   if( victim->position <= POS_SLEEPING )
swskills.c:   WAIT_STATE( ch, skill_table[gsn_beg]->beats );
swskills.c:   percent = number_percent(  ) + ch->skill_level[SMUGGLING_ABILITY] + victim->top_level;
swskills.c:   if( percent > ch->pcdata->learned[gsn_beg] )
swskills.c:      if( victim->alignment < 0 && victim->top_level >= ch->top_level + 5 )
swskills.c:         sprintf( buf, "%s is an annoying beggar and needs to be taught a lesson!", ch->name );
swskills.c:   amount = UMIN( victim->gold, number_range( 1, 10 ) );
swskills.c:      do_look( victim, ch->name );
swskills.c:   ch->gold += amount;
swskills.c:   victim->gold -= amount;
swskills.c:   ch_printf( ch, "%s gives you %d credits.\r\n", victim->short_descr, amount );
swskills.c:            ( exp_level( ch->skill_level[SMUGGLING_ABILITY] + 1 ) - exp_level( ch->skill_level[SMUGGLING_ABILITY] ) ) );
swskills.c:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
swskills.c:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
swskills.c:   if( ship->ship_class > SHIP_PLATFORM )
swskills.c:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
swskills.c:   if( ship->type == MOB_SHIP && get_trust( ch ) < 102 )
swskills.c:   if( ship->ship_class == SHIP_PLATFORM )
swskills.c:   if( ship->lastdoc != ship->location )
swskills.c:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
swskills.c:   if( ship->shipstate == SHIP_DISABLED )
swskills.c:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_hijack] );
swskills.c:   if( ship->ship_class == FIGHTER_SHIP )
swskills.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
swskills.c:   if( ship->ship_class == MIDSIZE_SHIP )
swskills.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
swskills.c:   if( ship->ship_class == CAPITAL_SHIP )
swskills.c:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
swskills.c:      if( ship->hatchopen )
swskills.c:         ship->hatchopen = FALSE;
swskills.c:         sprintf( buf, "The hatch on %s closes.", ship->name );
swskills.c:         echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
swskills.c:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
swskills.c:      sprintf( buf, "%s begins to launch.", ship->name );
swskills.c:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
swskills.c:      ship->shipstate = SHIP_LAUNCH;
swskills.c:      ship->currspeed = ship->realspeed;
swskills.c:      if( ship->ship_class == FIGHTER_SHIP )
swskills.c:      if( ship->ship_class == MIDSIZE_SHIP )
swskills.c:      if( ship->ship_class == CAPITAL_SHIP )
swskills.c:      sprintf( buf, "%s has been hijacked!", ship->name );
swskills.c:   if( ship->ship_class == FIGHTER_SHIP )
swskills.c:   if( ship->ship_class == MIDSIZE_SHIP )
swskills.c:   if( ship->ship_class == CAPITAL_SHIP )
swskills.c:   if( !ch->pcdata || ( clan = ch->pcdata->clan ) == NULL )
swskills.c:   jail = get_room_index( clan->jail );
swskills.c:   if( !jail && clan->mainclan )
swskills.c:      jail = get_room_index( clan->mainclan->jail );
swskills.c:   if( jail->area && ch->in_room->area
swskills.c:       && jail->area != ch->in_room->area && ( !jail->area->planet || jail->area->planet != ch->in_room->area->planet ) )
swskills.c:   if( ch->mount )
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( ch->position <= POS_SLEEPING )
swskills.c:   if( victim->position >= POS_SLEEPING )
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c:   if( ch->mount )
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( victim->position == POS_FIGHTING )
swskills.c:   if( !IS_NPC( victim ) || victim->vip_flags == 0 )
swskills.c:   if( ch->position <= POS_SLEEPING )
swskills.c:   if( victim->position <= POS_SLEEPING )
swskills.c:   WAIT_STATE( ch, skill_table[gsn_smalltalk]->beats );
swskills.c:   if( percent - ch->skill_level[DIPLOMACY_ABILITY] + victim->top_level > ch->pcdata->learned[gsn_smalltalk] )
swskills.c:      if( victim->alignment < -500 && victim->top_level >= ch->top_level + 5 )
swskills.c:         sprintf( buf, "SHUT UP %s!", ch->name );
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:      clan = ch->pcdata->clan;
swskills.c:   planet = ch->in_room->area->planet;
swskills.c:   if( clan != planet->governed_by )
swskills.c:   planet->pop_support += 0.2;
swskills.c:   gain_exp( ch, victim->top_level * 10, DIPLOMACY_ABILITY );
swskills.c:   ch_printf( ch, "You gain %d diplomacy experience.\r\n", victim->top_level * 10 );
swskills.c:   if( planet->pop_support > 100 )
swskills.c:      planet->pop_support = 100;
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:   if( ch->mount )
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( victim->position == POS_FIGHTING )
swskills.c:   if( victim->vip_flags == 0 )
swskills.c:   if( ch->position <= POS_SLEEPING )
swskills.c:   if( victim->position <= POS_SLEEPING )
swskills.c:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:      clan = ch->pcdata->clan;
swskills.c:   planet = ch->in_room->area->planet;
swskills.c:   sprintf( buf, ", and the evils of %s", planet->governed_by ? planet->governed_by->name : "their current leaders" );
swskills.c:   ch_printf( ch, "You speak to them about the benifits of the %s%s.\r\n", ch->pcdata->clan->name,
swskills.c:              planet->governed_by == clan ? "" : buf );
swskills.c:   WAIT_STATE( ch, skill_table[gsn_propeganda]->beats );
swskills.c:   if( percent - get_curr_cha( ch ) + victim->top_level > ch->pcdata->learned[gsn_propeganda] )
swskills.c:      if( planet->governed_by != clan )
swskills.c:         sprintf( buf, "%s is a traitor!", ch->name );
swskills.c:   if( planet->governed_by == clan )
swskills.c:      planet->pop_support += .5 + ch->top_level / 50;
swskills.c:      planet->pop_support += ch->top_level / 50;
swskills.c:   gain_exp( ch, victim->top_level * 100, DIPLOMACY_ABILITY );
swskills.c:   ch_printf( ch, "You gain %d diplomacy experience.\r\n", victim->top_level * 100 );
swskills.c:   if( planet->pop_support > 100 )
swskills.c:      planet->pop_support = 100;
swskills.c:   if( planet->pop_support < -100 )
swskills.c:      planet->pop_support = -100;
swskills.c:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c:   if( ch->mount )
swskills.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c:   if( ch->position == POS_FIGHTING )
swskills.c:   if( victim->position == POS_FIGHTING )
swskills.c:   if( ch->position <= POS_SLEEPING )
swskills.c:   if( victim->position <= POS_SLEEPING )
swskills.c:   if( victim->vip_flags == 0 )
swskills.c:   if( ch->gold < amount )
swskills.c:   ch->gold -= amount;
swskills.c:   victim->gold += amount;
swskills.c:   ch_printf( ch, "You give them a small gift on behalf of %s.\r\n", ch->pcdata->clan->name );
swskills.c:   WAIT_STATE( ch, skill_table[gsn_bribe]->beats );
swskills.c:   if( percent - amount + victim->top_level > ch->pcdata->learned[gsn_bribe] )
swskills.c:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c:      clan = ch->pcdata->clan;
swskills.c:   planet = ch->in_room->area->planet;
swskills.c:   if( clan == planet->governed_by )
swskills.c:     planet->pop_support += URANGE( ( int ) 0.1, amount / 1000, 2 );
swskills.c:	     ( exp_level( ch->skill_level[DIPLOMACY_ABILITY] + 1 ) - exp_level( ch->skill_level[DIPLOMACY_ABILITY] ) ) );
swskills.c:   if( planet->pop_support > 100 )
swskills.c:      planet->pop_support = 100;
swskills.c~:*--------------------------------------------------------------------------*
swskills.c~:* -------------------------------------------------------------------------*
swskills.c~:*--------------------------------------------------------------------------*
swskills.c~:* ------------------------------------------------------------------------ *
swskills.c~:* ------------------------------------------------------------------------ *
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_DURASTEEL )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_OVEN )
swskills.c~:            send_to_char( "&RYou need toolkit to make a vibro-blade.\r\n", ch );
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_OVEN )
swskills.c~:      if( obj->item_type == ITEM_DURASTEEL && checkdura == FALSE )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:         charge = UMAX( 5, obj->value[0] );
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblade] );
swskills.c~:   obj->item_type = ITEM_WEAPON;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = 3;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   strcat( buf, " vibro-blade blade" );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   paf->type = -1;
swskills.c~:   paf->duration = -1;
swskills.c~:   paf->location = get_atype( "backstab" );
swskills.c~:   paf->modifier = level / 3;
swskills.c~:   paf->bitvector = 0;
swskills.c~:   paf->next = NULL;
swskills.c~:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   paf2->type = -1;
swskills.c~:   paf2->duration = -1;
swskills.c~:   paf2->location = get_atype( "hitroll" );
swskills.c~:   paf2->modifier = -2;
swskills.c~:   paf2->bitvector = 0;
swskills.c~:   paf2->next = NULL;
swskills.c~:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   obj->value[0] = INIT_WEAPON_CONDITION;
swskills.c~:   obj->value[1] = ( int )( level / 20 + 10 );  /* min dmg  */
swskills.c~:   obj->value[2] = ( int )( level / 10 + 20 );  /* max dmg */
swskills.c~:   obj->value[3] = WEAPON_VIBRO_BLADE;
swskills.c~:   obj->value[4] = charge;
swskills.c~:   obj->value[5] = charge;
swskills.c~:   obj->cost = obj->value[2] * 10;
swskills.c~:   act( AT_PLAIN, "$n finishes crafting a vibro-blade.", ch, NULL, argument, TO_ROOM );
swskills.c~:         UMIN( obj->cost * 200,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_DURAPLAST )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_OVEN )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_OVEN )
swskills.c~:      if( obj->item_type == ITEM_DURAPLAST && checkdura == FALSE )
swskills.c~:      if( obj->item_type == ITEM_AMMO && checkammo == FALSE )
swskills.c~:         ammo = obj->value[0];
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:      if( obj->item_type == ITEM_LENS && scope == 0 )
swskills.c~:      if( obj->item_type == ITEM_SUPERCONDUCTOR && power < 2 )
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeblaster] );
swskills.c~:   obj->item_type = ITEM_WEAPON;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = 2 + level / 10;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   paf->type = -1;
swskills.c~:   paf->duration = -1;
swskills.c~:   paf->location = get_atype( "hitroll" );
swskills.c~:   paf->modifier = URANGE( 0, 1 + scope, level / 30 );
swskills.c~:   paf->bitvector = 0;
swskills.c~:   paf->next = NULL;
swskills.c~:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   paf2->type = -1;
swskills.c~:   paf2->duration = -1;
swskills.c~:   paf2->location = get_atype( "damroll" );
swskills.c~:   paf2->modifier = URANGE( 0, power, level / 30 );
swskills.c~:   paf2->bitvector = 0;
swskills.c~:   paf2->next = NULL;
swskills.c~:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   obj->value[0] = INIT_WEAPON_CONDITION; /* condition  */
swskills.c~:   obj->value[1] = ( int )( level / 10 + 15 );  /* min dmg  */
swskills.c~:   obj->value[2] = ( int )( level / 5 + 25 );   /* max dmg  */
swskills.c~:   obj->value[3] = WEAPON_BLASTER;
swskills.c~:   obj->value[4] = ammo;
swskills.c~:   obj->value[5] = 2000;
swskills.c~:   obj->cost = obj->value[2] * 50;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) || !IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_LENS )
swskills.c~:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c~:            if( obj->item_type == ITEM_MIRROR )
swskills.c~:            if( obj->item_type == ITEM_DURAPLAST || obj->item_type == ITEM_DURASTEEL )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_OVEN )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_OVEN )
swskills.c~:      if( ( obj->item_type == ITEM_DURAPLAST || obj->item_type == ITEM_DURASTEEL ) && checkdura == FALSE )
swskills.c~:      if( obj->item_type == ITEM_DURASTEEL && checkdura == FALSE )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:         charge = UMIN( obj->value[1], 10 );
swskills.c~:      if( obj->item_type == ITEM_SUPERCONDUCTOR && checkcond == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:      if( obj->item_type == ITEM_LENS && checklens == FALSE )
swskills.c~:      if( obj->item_type == ITEM_MIRROR && checkmirr == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CRYSTAL && gems < 3 )
swskills.c~:         if( gemtype < obj->value[0] )
swskills.c~:            gemtype = obj->value[0];
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_lightsaber_crafting] );
swskills.c~:   obj->item_type = ITEM_WEAPON;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_ANTI_SOLDIER );
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_ANTI_THIEF );
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_ANTI_HUNTER );
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_ANTI_PILOT );
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_ANTI_CITIZEN );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = 5;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( "lightsaber saber" );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   STRFREE( obj->action_desc );
swskills.c~:   obj->action_desc = STRALLOC( buf );
swskills.c~:   paf->type = -1;
swskills.c~:   paf->duration = -1;
swskills.c~:   paf->location = get_atype( "hitroll" );
swskills.c~:   paf->modifier = URANGE( 0, gems, level / 30 );
swskills.c~:   paf->bitvector = 0;
swskills.c~:   paf->next = NULL;
swskills.c~:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   paf2->type = -1;
swskills.c~:   paf2->duration = -1;
swskills.c~:   paf2->location = get_atype( "parry" );
swskills.c~:   paf2->modifier = ( level / 3 );
swskills.c~:   paf2->bitvector = 0;
swskills.c~:   paf2->next = NULL;
swskills.c~:   LINK( paf2, obj->first_affect, obj->last_affect, next, prev );
swskills.c~:   obj->value[0] = INIT_WEAPON_CONDITION; /* condition  */
swskills.c~:   obj->value[1] = ( int )( level / 10 + gemtype * 2 );  /* min dmg  */
swskills.c~:   obj->value[2] = ( int )( level / 5 + gemtype * 6 );   /* max dmg */
swskills.c~:   obj->value[3] = WEAPON_LIGHTSABER;
swskills.c~:   obj->value[4] = charge;
swskills.c~:   obj->value[5] = charge;
swskills.c~:   obj->cost = obj->value[2] * 75;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[FORCE_ABILITY] + 1 ) - exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_REFINERY ) )
swskills.c~:         if( obj->item_type != ITEM_RAWSPICE )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_spice_refining] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   if( obj->item_type != ITEM_RAWSPICE )
swskills.c~:   obj->value[1] = URANGE( 10, obj->value[1], ( IS_NPC( ch ) ? ch->top_level
swskills.c~:                                                : ( int )( ch->pcdata->learned[gsn_spice_refining] ) ) + 10 );
swskills.c~:   strcpy( buf, obj->name );
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   strcat( buf, obj->short_descr );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->item_type = ITEM_SPICE;
swskills.c~:   obj->cost += obj->value[1] * 10;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_DRINK_CON && obj->value[1] == 0 )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_DRINK_CON && checkdrink == FALSE && obj->value[1] == 0 )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:         strength = URANGE( 10, obj->value[0], level * 5 );
swskills.c~:         weight = obj->weight;
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makegrenade] );
swskills.c~:   obj->item_type = ITEM_GRENADE;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = weight;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = strength / 2;
swskills.c~:   obj->value[1] = strength;
swskills.c~:   obj->cost = obj->value[1] * 5;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_DRINK_CON && obj->value[1] == 0 )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_DRINK_CON && checkdrink == FALSE && obj->value[1] == 0 )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:         strength = URANGE( 10, obj->value[0], level * 5 );
swskills.c~:         weight = obj->weight;
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelandmine] );
swskills.c~:   obj->item_type = ITEM_LANDMINE;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = weight;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = strength / 2;
swskills.c~:   obj->value[1] = strength;
swskills.c~:   obj->cost = obj->value[1] * 5;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:            if( obj->item_type == ITEM_LENS )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:         strength = obj->value[0];
swskills.c~:      if( obj->item_type == ITEM_CHEMICAL )
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:      if( obj->item_type == ITEM_LENS && checklens == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makelight] );
swskills.c~:   obj->item_type = ITEM_LIGHT;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = 3;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[2] = strength;
swskills.c~:   obj->cost = obj->value[2];
swskills.c~:         UMIN( obj->cost * 100,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_OVEN )
swskills.c~:            if( obj->item_type == ITEM_RARE_METAL )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         if( !ch->dest_buf_2 )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_OVEN )
swskills.c~:      if( obj->item_type == ITEM_RARE_METAL && checkmetal == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CRYSTAL )
swskills.c~:         cost += obj->cost;
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makejewelry] );
swskills.c~:   obj->item_type = ITEM_ARMOR;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:      SET_BIT( obj->wear_flags, ITEM_WEAR_NECK );
swskills.c~:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c~:   obj->level = level;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = obj->value[1];
swskills.c~:   obj->cost *= 10;
swskills.c~:   obj->cost += cost;
swskills.c~:         UMIN( obj->cost * 100,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_FABRIC )
swskills.c~:            if( obj->item_type == ITEM_THREAD )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         if( !ch->dest_buf_2 )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_THREAD )
swskills.c~:      if( obj->item_type == ITEM_FABRIC && checkfab == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makearmor] );
swskills.c~:   obj->item_type = ITEM_ARMOR;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:      SET_BIT( obj->wear_flags, ITEM_WEAR_BODY );
swskills.c~:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c~:   obj->level = level;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = obj->value[1];
swskills.c~:   obj->cost *= 10;
swskills.c~:         UMIN( obj->cost * 100,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecomlink] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_CRYSTAL && checkgem == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecomlink] );
swskills.c~:   obj = create_object( pObjIndex, ch->top_level );
swskills.c~:   obj->item_type = ITEM_COMLINK;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:   obj->weight = 3;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->cost = 50;
swskills.c~:         UMIN( obj->cost * 100,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:            if( obj->item_type == ITEM_CRYSTAL )
swskills.c~:            if( obj->item_type == ITEM_BATTERY )
swskills.c~:            if( obj->item_type == ITEM_CIRCUIT )
swskills.c~:            if( obj->item_type == ITEM_SUPERCONDUCTOR )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_TOOLKIT )
swskills.c~:      if( obj->item_type == ITEM_BATTERY && checkbatt == FALSE )
swskills.c~:         charge = UMIN( obj->value[1], 10 );
swskills.c~:      if( obj->item_type == ITEM_SUPERCONDUCTOR && checkcond == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CIRCUIT && checkcirc == FALSE )
swskills.c~:      if( obj->item_type == ITEM_CRYSTAL && checkgems == FALSE )
swskills.c~:         gemtype = obj->value[0];
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makeshield] );
swskills.c~:   obj->item_type = ITEM_ARMOR;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_WIELD );
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_WEAR_SHIELD );
swskills.c~:   obj->level = level;
swskills.c~:   obj->weight = 2;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( "energy shield" );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = ( int )( level / 10 + gemtype * 2 );  /* condition */
swskills.c~:   obj->value[1] = ( int )( level / 10 + gemtype * 2 );  /* armor */
swskills.c~:   obj->value[4] = charge;
swskills.c~:   obj->value[5] = charge;
swskills.c~:   obj->cost = obj->value[2] * 100;
swskills.c~:         UMIN( obj->cost * 50,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( !IS_SET( ch->in_room->room_flags, ROOM_FACTORY ) )
swskills.c~:         for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:            if( obj->item_type == ITEM_FABRIC )
swskills.c~:            if( obj->item_type == ITEM_THREAD )
swskills.c~:         schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:            ch->dest_buf_2 = str_dup( arg2 );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         if( !ch->dest_buf_2 )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         strcpy( arg2, ( const char* ) ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf_2 );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   level = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c~:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
swskills.c~:      if( obj->item_type == ITEM_THREAD )
swskills.c~:      if( obj->item_type == ITEM_FABRIC && checkfab == FALSE )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_makecontainer] );
swskills.c~:   obj->item_type = ITEM_CONTAINER;
swskills.c~:   SET_BIT( obj->wear_flags, ITEM_TAKE );
swskills.c~:      SET_BIT( obj->wear_flags, ITEM_HOLD );
swskills.c~:      SET_BIT( obj->wear_flags, 1 << value );
swskills.c~:   obj->level = level;
swskills.c~:   STRFREE( obj->name );
swskills.c~:   obj->name = STRALLOC( buf );
swskills.c~:   STRFREE( obj->short_descr );
swskills.c~:   obj->short_descr = STRALLOC( buf );
swskills.c~:   STRFREE( obj->description );
swskills.c~:   obj->description = STRALLOC( buf );
swskills.c~:   obj->value[0] = level;
swskills.c~:   obj->value[1] = 0;
swskills.c~:   obj->value[2] = 0;
swskills.c~:   obj->value[3] = 10;
swskills.c~:   obj->cost *= 2;
swskills.c~:         UMIN( obj->cost * 100,
swskills.c~:               ( exp_level( ch->skill_level[ENGINEERING_ABILITY] + 1 ) -
swskills.c~:                 exp_level( ch->skill_level[ENGINEERING_ABILITY] ) ) );
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( ch->backup_wait )
swskills.c~:         if( !ch->pcdata->clan )
swskills.c~:         if( ch->gold < ch->skill_level[LEADERSHIP_ABILITY] * 50 )
swskills.c~:         schance = ( int )( ch->pcdata->learned[gsn_reinforcements] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   credits = ch->skill_level[LEADERSHIP_ABILITY] * 50;
swskills.c~:   ch->gold -= UMIN( credits, ch->gold );
swskills.c~:   if( nifty_is_name( "empire", ch->pcdata->clan->name ) )
swskills.c~:      ch->backup_mob = MOB_VNUM_STORMTROOPER;
swskills.c~:   else if( nifty_is_name( "republic", ch->pcdata->clan->name ) )
swskills.c~:      ch->backup_mob = MOB_VNUM_NR_TROOPER;
swskills.c~:      ch->backup_mob = MOB_VNUM_MERCINARY;
swskills.c~:   ch->backup_wait = number_range( 1, 2 );
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c~:   switch ( ch->substate )
swskills.c~:         if( ch->backup_wait )
swskills.c~:         if( !ch->pcdata->clan )
swskills.c~:         if( ch->gold < ch->skill_level[LEADERSHIP_ABILITY] * 30 )
swskills.c~:         schance = ( int )( ch->pcdata->learned[gsn_postguard] );
swskills.c~:            ch->dest_buf = str_dup( arg );
swskills.c~:         if( !ch->dest_buf )
swskills.c~:         strcpy( arg, ( const char* ) ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         DISPOSE( ch->dest_buf );
swskills.c~:         ch->substate = SUB_NONE;
swskills.c~:   ch->substate = SUB_NONE;
swskills.c~:   credits = ch->skill_level[LEADERSHIP_ABILITY] * 30;
swskills.c~:   ch->gold -= UMIN( credits, ch->gold );
swskills.c~:   if( nifty_is_name( "empire", ch->pcdata->clan->name ) )
swskills.c~:      ch->backup_mob = MOB_VNUM_IMP_GUARD;
swskills.c~:   else if( nifty_is_name( "republic", ch->pcdata->clan->name ) )
swskills.c~:      ch->backup_mob = MOB_VNUM_NR_GUARD;
swskills.c~:      ch->backup_mob = MOB_VNUM_BOUNCER;
swskills.c~:   ch->backup_wait = 1;
swskills.c~:   if( ( pMobIndex = get_mob_index( ch->backup_mob ) ) == NULL )
swskills.c~:   if( ch->backup_mob == MOB_VNUM_STORMTROOPER ||
swskills.c~:       ch->backup_mob == MOB_VNUM_NR_TROOPER || ch->backup_mob == MOB_VNUM_MERCINARY )
swskills.c~:         char_to_room( mob[mob_cnt], ch->in_room );
swskills.c~:         mob[mob_cnt]->top_level = ch->skill_level[LEADERSHIP_ABILITY] / 3;
swskills.c~:            mob[mob_cnt]->skill_level[ability] = mob[mob_cnt]->top_level;
swskills.c~:         mob[mob_cnt]->hit = mob[mob_cnt]->top_level * 15;
swskills.c~:         mob[mob_cnt]->max_hit = mob[mob_cnt]->hit;
swskills.c~:         mob[mob_cnt]->armor = ( short )( LEVEL_HERO - mob[mob_cnt]->top_level * 2.5 );
swskills.c~:         mob[mob_cnt]->damroll = mob[mob_cnt]->top_level / 5;
swskills.c~:         mob[mob_cnt]->hitroll = mob[mob_cnt]->top_level / 5;
swskills.c~:            blaster = create_object( pObjIndex, mob[mob_cnt]->top_level );
swskills.c~:         if( mob[mob_cnt]->master )
swskills.c~:         SET_BIT( mob[mob_cnt]->affected_by, AFF_CHARM );
swskills.c~:      char_to_room( mob, ch->in_room );
swskills.c~:      if( ch->pcdata && ch->pcdata->clan )
swskills.c~:         STRFREE( mob->name );
swskills.c~:         mob->name = STRALLOC( ch->pcdata->clan->name );
swskills.c~:         sprintf( tmpbuf, "(%s) %s", ch->pcdata->clan->name, mob->long_descr );
swskills.c~:         STRFREE( mob->long_descr );
swskills.c~:         mob->long_descr = STRALLOC( tmpbuf );
swskills.c~:      mob->top_level = ch->skill_level[LEADERSHIP_ABILITY];
swskills.c~:         mob->skill_level[ability] = mob->top_level;
swskills.c~:      mob->hit = mob->top_level * 15;
swskills.c~:      mob->max_hit = mob->hit;
swskills.c~:      mob->armor = ( short )( LEVEL_HERO - mob->top_level * 2.5 );
swskills.c~:      mob->damroll = mob->top_level / 5;
swskills.c~:      mob->hitroll = mob->top_level / 5;
swskills.c~:         blaster = create_object( pObjIndex, mob->top_level );
swskills.c~:      if( mob->mob_clan )
swskills.c~:         STRFREE( mob->mob_clan );
swskills.c~:      if( ch->pcdata && ch->pcdata->clan )
swskills.c~:         mob->mob_clan = STRALLOC( ch->pcdata->clan->name );
swskills.c~:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_torture] <= 0 )
swskills.c~:   if( ch->mount )
swskills.c~:   if( victim->fighting )
swskills.c~:   ch->alignment = ch->alignment -= 100;
swskills.c~:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
swskills.c~:   WAIT_STATE( ch, skill_table[gsn_torture]->beats );
swskills.c~:   schance = ris_save( victim, ch->skill_level[HUNTING_ABILITY], RIS_PARALYSIS );
swskills.c~:   if( !fail && ( IS_NPC( ch ) || ( number_percent(  ) + schance ) < ch->pcdata->learned[gsn_torture] ) )
swskills.c~:      dam = dice( ch->skill_level[HUNTING_ABILITY] / 10, 4 );
swskills.c~:      dam = URANGE( 0, victim->max_hit - 10, dam );
swskills.c~:      victim->hit -= dam;
swskills.c~:      victim->max_hit -= dam;
swskills.c~:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
swskills.c~:   schance = ( int )( ch->pcdata->learned[gsn_disguise] );
swskills.c~:   if( ch->pcdata->learned[gsn_mine] <= 0 )
swskills.c~:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
swskills.c~:      if( obj->item_type == ITEM_SHOVEL )
swskills.c~:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
swskills.c~:   if( obj->item_type != ITEM_LANDMINE )
swskills.c~:   switch ( ch->in_room->sector_type )
swskills.c~:   if( obj->weight > ( UMAX( 5, ( can_carry_w( ch ) / 10 ) ) ) && !shovel )
swskills.c~:   move = ( obj->weight * 50 * ( shovel ? 1 : 5 ) ) / UMAX( 1, can_carry_w( ch ) );
swskills.c~:   if( move > ch->move )
swskills.c~:   ch->move -= move;
swskills.c~:   SET_BIT( obj->extra_flags, ITEM_BURRIED );
swskills.c~:   STRFREE( obj->armed_by );
swskills.c~:   obj->armed_by = STRALLOC( ch->name );
swskills.c~:   ch_printf( ch, "You arm and bury %s.\r\n", obj->short_descr );
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( !medpac || medpac->item_type != ITEM_MEDPAC )
swskills.c~:   if( medpac->value[0] <= 0 )
swskills.c~:   if( heal > ch->pcdata->learned[gsn_first_aid] * 2 )
swskills.c~:      sprintf( buf, "$n uses %s to help heal $s wounds.", medpac->short_descr );
swskills.c~:      sprintf( buf, "$n uses %s to help heal $N's wounds.", medpac->short_descr );
swskills.c~:      sprintf( buf, "$n uses %s to help heal your wounds.", medpac->short_descr );
swskills.c~:   --medpac->value[0];
swskills.c~:   victim->hit += URANGE( 0, heal, victim->max_hit - victim->hit );
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( !wield || wield->item_type != ITEM_WEAPON || wield->value[3] != WEAPON_BLASTER )
swskills.c~:   if( ( dir = get_door( arg ) ) == -1 || arg2[0] == '\0' )
swskills.c~:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c~:   if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c~:   was_in_room = ch->in_room;
swskills.c~:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c~:      if( !pexit->to_room )
swskills.c~:      if( pexit->distance > 1 )
swskills.c~:         to_room = generate_exit( ch->in_room, &pexit );
swskills.c~:         to_room = pexit->to_room;
swskills.c~:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c~:   if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c~:   schance = IS_NPC( ch ) ? 100 : ( int )( ch->pcdata->learned[gsn_snipe] );
swskills.c~:         dir -= 2;
swskills.c~:         dir -= 1;
swskills.c~:         dir -= 3;
swskills.c~:      char_to_room( ch, victim->in_room );
swskills.c~:      char_to_room( ch, victim->in_room );
swskills.c~:      if( number_percent(  ) < ch->pcdata->learned[gsn_third_attack] )
swskills.c~:      else if( number_percent(  ) < ch->pcdata->learned[gsn_second_attack] )
swskills.c~:      if( IS_SET( victim->act, ACT_SENTINEL ) )
swskills.c~:         victim->was_sentinel = victim->in_room;
swskills.c~:         REMOVE_BIT( victim->act, ACT_SENTINEL );
swskills.c~:   was_in_room = ch->in_room;
swskills.c~:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name( arg, obj->name ) )
swskills.c~:      if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c~:   if( !obj || !nifty_is_name_prefix( arg, obj->name ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:      sprintf( buf, "$n throws %s at the floor.", obj->short_descr );
swskills.c~:      ch_printf( ch, "You throw %s at the floor.\r\n", obj->short_descr );
swskills.c~:   else if( ( dir = get_door( arg2 ) ) != -1 )
swskills.c~:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
swskills.c~:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
swskills.c~:            dir -= 2;
swskills.c~:            dir -= 1;
swskills.c~:            dir -= 3;
swskills.c~:      if( pexit->distance > 1 )
swskills.c~:         to_room = generate_exit( ch->in_room, &pexit );
swskills.c~:         to_room = pexit->to_room;
swskills.c~:         if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c~:         if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c~:         if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:         if( pexit->distance > 1 )
swskills.c~:            to_room = generate_exit( ch->in_room, &pexit );
swskills.c~:            to_room = pexit->to_room;
swskills.c~:         sprintf( buf, "Someone throws %s at you from the %s.", obj->short_descr, dir_name[dir] );
swskills.c~:         sprintf( buf, "$n throws %s to the %s.", obj->short_descr, dir_name[get_dir(arg2)] );
swskills.c~:         sprintf( buf, "%s is thrown at $N from the %s.", obj->short_descr, dir_name[dir] );
swskills.c~:         ch_printf( ch, "You throw %s %s.\r\n", obj->short_descr, dir_name[get_dir( arg2 )] );
swskills.c~:         sprintf( buf, "$n throws %s to the %s.", obj->short_descr, dir_name[get_dir(arg2)] );
swskills.c~:         sprintf( buf, "%s is thrown from the %s.", obj->short_descr, dir_name[dir] );
swskills.c~:      if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
swskills.c~:      if( !IS_NPC( victim ) && IS_SET( ch->act, PLR_NICE ) )
swskills.c~:      tmpobj->wear_loc = WEAR_WIELD;
swskills.c~:   obj = obj_to_room( obj, ch->in_room );
swskills.c~:   if( obj->item_type != ITEM_GRENADE )
swskills.c~:   if( ch->in_room != was_in_room )
swskills.c~:      WAIT_STATE( ch, skill_table[gsn_throw]->beats );
swskills.c~:      if( IS_NPC( ch ) || number_percent(  ) < ch->pcdata->learned[gsn_throw] )
swskills.c~:            damage( ch, victim, number_range( obj->weight * 2, ( obj->weight * 2 + ch->perm_str ) ), TYPE_HIT );
swskills.c~:         if( IS_SET( victim->act, ACT_SENTINEL ) )
swskills.c~:            victim->was_sentinel = victim->in_room;
swskills.c~:            REMOVE_BIT( victim->act, ACT_SENTINEL );
swskills.c~:   if( ch->mount )
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( victim->position == POS_FIGHTING )
swskills.c~:   if( ch->position <= POS_SLEEPING )
swskills.c~:   if( victim->position <= POS_SLEEPING )
swskills.c~:   WAIT_STATE( ch, skill_table[gsn_beg]->beats );
swskills.c~:   percent = number_percent(  ) + ch->skill_level[SMUGGLING_ABILITY] + victim->top_level;
swskills.c~:   if( percent > ch->pcdata->learned[gsn_beg] )
swskills.c~:      if( victim->alignment < 0 && victim->top_level >= ch->top_level + 5 )
swskills.c~:         sprintf( buf, "%s is an annoying beggar and needs to be taught a lesson!", ch->name );
swskills.c~:   amount = UMIN( victim->gold, number_range( 1, 10 ) );
swskills.c~:      do_look( victim, ch->name );
swskills.c~:   ch->gold += amount;
swskills.c~:   victim->gold -= amount;
swskills.c~:   ch_printf( ch, "%s gives you %d credits.\r\n", victim->short_descr, amount );
swskills.c~:            ( exp_level( ch->skill_level[SMUGGLING_ABILITY] + 1 ) - exp_level( ch->skill_level[SMUGGLING_ABILITY] ) ) );
swskills.c~:   if( ( ship = ship_from_cockpit( ch->in_room->vnum ) ) == NULL )
swskills.c~:   if( ch->piloting == NULL || ch->piloting != ship || (ship->pilotpilotch != ch && ship->copilotch != ch) )
swskills.c~:   if( ship->ship_class > SHIP_PLATFORM )
swskills.c~:   if( ( ship = ship_from_pilotseat( ch->in_room->vnum ) ) == NULL )
swskills.c~:   if( ship->type == MOB_SHIP && get_trust( ch ) < 102 )
swskills.c~:   if( ship->ship_class == SHIP_PLATFORM )
swskills.c~:   if( ship->lastdoc != ship->location )
swskills.c~:   if( ship->shipstate != SHIP_DOCKED && ship->shipstate != SHIP_DISABLED )
swskills.c~:   if( ship->shipstate == SHIP_DISABLED )
swskills.c~:   schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_hijack] );
swskills.c~:   if( ship->ship_class == FIGHTER_SHIP )
swskills.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_starfighters] );
swskills.c~:   if( ship->ship_class == MIDSIZE_SHIP )
swskills.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_midships] );
swskills.c~:   if( ship->ship_class == CAPITAL_SHIP )
swskills.c~:      schance = IS_NPC( ch ) ? ch->top_level : ( int )( ch->pcdata->learned[gsn_capitalships] );
swskills.c~:      if( ship->hatchopen )
swskills.c~:         ship->hatchopen = FALSE;
swskills.c~:         sprintf( buf, "The hatch on %s closes.", ship->name );
swskills.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
swskills.c~:         echo_to_room( AT_YELLOW, get_room_index( ship->entrance ), "The hatch slides shut." );
swskills.c~:      sprintf( buf, "%s begins to launch.", ship->name );
swskills.c~:      echo_to_room( AT_YELLOW, get_room_index( ship->location ), buf );
swskills.c~:      ship->shipstate = SHIP_LAUNCH;
swskills.c~:      ship->currspeed = ship->realspeed;
swskills.c~:      if( ship->ship_class == FIGHTER_SHIP )
swskills.c~:      if( ship->ship_class == MIDSIZE_SHIP )
swskills.c~:      if( ship->ship_class == CAPITAL_SHIP )
swskills.c~:      sprintf( buf, "%s has been hijacked!", ship->name );
swskills.c~:   if( ship->ship_class == FIGHTER_SHIP )
swskills.c~:   if( ship->ship_class == MIDSIZE_SHIP )
swskills.c~:   if( ship->ship_class == CAPITAL_SHIP )
swskills.c~:   if( !ch->pcdata || ( clan = ch->pcdata->clan ) == NULL )
swskills.c~:   jail = get_room_index( clan->jail );
swskills.c~:   if( !jail && clan->mainclan )
swskills.c~:      jail = get_room_index( clan->mainclan->jail );
swskills.c~:   if( jail->area && ch->in_room->area
swskills.c~:       && jail->area != ch->in_room->area && ( !jail->area->planet || jail->area->planet != ch->in_room->area->planet ) )
swskills.c~:   if( ch->mount )
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( ch->position <= POS_SLEEPING )
swskills.c~:   if( victim->position >= POS_SLEEPING )
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata )
swskills.c~:   if( ch->mount )
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( victim->position == POS_FIGHTING )
swskills.c~:   if( !IS_NPC( victim ) || victim->vip_flags == 0 )
swskills.c~:   if( ch->position <= POS_SLEEPING )
swskills.c~:   if( victim->position <= POS_SLEEPING )
swskills.c~:   WAIT_STATE( ch, skill_table[gsn_smalltalk]->beats );
swskills.c~:   if( percent - ch->skill_level[DIPLOMACY_ABILITY] + victim->top_level > ch->pcdata->learned[gsn_smalltalk] )
swskills.c~:      if( victim->alignment < -500 && victim->top_level >= ch->top_level + 5 )
swskills.c~:         sprintf( buf, "SHUT UP %s!", ch->name );
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c~:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c~:      clan = ch->pcdata->clan;
swskills.c~:   planet = ch->in_room->area->planet;
swskills.c~:   if( clan != planet->governed_by )
swskills.c~:   planet->pop_support += 0.2;
swskills.c~:   gain_exp( ch, victim->top_level * 10, DIPLOMACY_ABILITY );
swskills.c~:   ch_printf( ch, "You gain %d diplomacy experience.\r\n", victim->top_level * 10 );
swskills.c~:   if( planet->pop_support > 100 )
swskills.c~:      planet->pop_support = 100;
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c~:   if( ch->mount )
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( victim->position == POS_FIGHTING )
swskills.c~:   if( victim->vip_flags == 0 )
swskills.c~:   if( ch->position <= POS_SLEEPING )
swskills.c~:   if( victim->position <= POS_SLEEPING )
swskills.c~:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c~:      clan = ch->pcdata->clan;
swskills.c~:   planet = ch->in_room->area->planet;
swskills.c~:   sprintf( buf, ", and the evils of %s", planet->governed_by ? planet->governed_by->name : "their current leaders" );
swskills.c~:   ch_printf( ch, "You speak to them about the benifits of the %s%s.\r\n", ch->pcdata->clan->name,
swskills.c~:              planet->governed_by == clan ? "" : buf );
swskills.c~:   WAIT_STATE( ch, skill_table[gsn_propeganda]->beats );
swskills.c~:   if( percent - get_curr_cha( ch ) + victim->top_level > ch->pcdata->learned[gsn_propeganda] )
swskills.c~:      if( planet->governed_by != clan )
swskills.c~:         sprintf( buf, "%s is a traitor!", ch->name );
swskills.c~:   if( planet->governed_by == clan )
swskills.c~:      planet->pop_support += .5 + ch->top_level / 50;
swskills.c~:      planet->pop_support += ch->top_level / 50;
swskills.c~:   gain_exp( ch, victim->top_level * 100, DIPLOMACY_ABILITY );
swskills.c~:   ch_printf( ch, "You gain %d diplomacy experience.\r\n", victim->top_level * 100 );
swskills.c~:   if( planet->pop_support > 100 )
swskills.c~:      planet->pop_support = 100;
swskills.c~:   if( planet->pop_support < -100 )
swskills.c~:      planet->pop_support = -100;
swskills.c~:   if( IS_NPC( ch ) || !ch->pcdata || !ch->pcdata->clan || !ch->in_room->area || !ch->in_room->area->planet )
swskills.c~:   if( ch->mount )
swskills.c~:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
swskills.c~:   if( ch->position == POS_FIGHTING )
swskills.c~:   if( victim->position == POS_FIGHTING )
swskills.c~:   if( ch->position <= POS_SLEEPING )
swskills.c~:   if( victim->position <= POS_SLEEPING )
swskills.c~:   if( victim->vip_flags == 0 )
swskills.c~:   if( ch->gold < amount )
swskills.c~:   ch->gold -= amount;
swskills.c~:   victim->gold += amount;
swskills.c~:   ch_printf( ch, "You give them a small gift on behalf of %s.\r\n", ch->pcdata->clan->name );
swskills.c~:   WAIT_STATE( ch, skill_table[gsn_bribe]->beats );
swskills.c~:   if( percent - amount + victim->top_level > ch->pcdata->learned[gsn_bribe] )
swskills.c~:   if( ( clan = ch->pcdata->clan->mainclan ) == NULL )
swskills.c~:      clan = ch->pcdata->clan;
swskills.c~:   planet = ch->in_room->area->planet;
swskills.c~:   if( clan == planet->governed_by )
swskills.c~:     planet->pop_support += URANGE( ( int ) 0.1, amount / 1000, 2 );
swskills.c~:	     ( exp_level( ch->skill_level[DIPLOMACY_ABILITY] + 1 ) - exp_level( ch->skill_level[DIPLOMACY_ABILITY] ) ) );
swskills.c~:   if( planet->pop_support > 100 )
swskills.c~:      planet->pop_support = 100;
tables.c:*--------------------------------------------------------------------------*
tables.c:* -------------------------------------------------------------------------*
tables.c:*--------------------------------------------------------------------------*
tables.c:* ------------------------------------------------------------------------ *
tables.c:* ------------------------------------------------------------------------ *
tables.c:      return -1;
tables.c:   if( skill1->type < skill2->type )
tables.c:      return -1;
tables.c:   if( skill1->type > skill2->type )
tables.c:   return strcasecmp( skill1->name, skill2->name );
tables.c:   qsort( &skill_table[1], top_sn - 1, sizeof( SKILLTYPE * ), ( int ( * )( const void *, const void * ) )skill_comp );
tables.c:   fprintf( fpout, "Name         %s~\n", skill->name );
tables.c:   fprintf( fpout, "Type         %s\n", skill_tname[skill->type] );
tables.c:   fprintf( fpout, "Flags        %d\n", skill->flags );
tables.c:   if( skill->target )
tables.c:      fprintf( fpout, "Target       %d\n", skill->target );
tables.c:   if( skill->minimum_position )
tables.c:      fprintf( fpout, "Minpos       %d\n", skill->minimum_position );
tables.c:   if( skill->saves )
tables.c:      fprintf( fpout, "Saves        %d\n", skill->saves );
tables.c:   if( skill->slot )
tables.c:      fprintf( fpout, "Slot         %d\n", skill->slot );
tables.c:   if( skill->min_mana )
tables.c:      fprintf( fpout, "Mana         %d\n", skill->min_mana );
tables.c:   if( skill->beats )
tables.c:      fprintf( fpout, "Rounds       %d\n", skill->beats );
tables.c:   if( skill->guild != -1 )
tables.c:      fprintf( fpout, "Guild        %d\n", skill->guild );
tables.c:   if( skill->skill_fun )
tables.c:      fprintf( fpout, "Code         %s\n", skill->skill_fun_name );
tables.c:   else if( skill->spell_fun )
tables.c:      fprintf( fpout, "Code         %s\n", skill->spell_fun_name );
tables.c:   fprintf( fpout, "Dammsg       %s~\n", skill->noun_damage );
tables.c:   if( skill->msg_off && skill->msg_off[0] != '\0' )
tables.c:      fprintf( fpout, "Wearoff      %s~\n", skill->msg_off );
tables.c:   if( skill->hit_char && skill->hit_char[0] != '\0' )
tables.c:      fprintf( fpout, "Hitchar      %s~\n", skill->hit_char );
tables.c:   if( skill->hit_vict && skill->hit_vict[0] != '\0' )
tables.c:      fprintf( fpout, "Hitvict      %s~\n", skill->hit_vict );
tables.c:   if( skill->hit_room && skill->hit_room[0] != '\0' )
tables.c:      fprintf( fpout, "Hitroom      %s~\n", skill->hit_room );
tables.c:   if( skill->miss_char && skill->miss_char[0] != '\0' )
tables.c:      fprintf( fpout, "Misschar     %s~\n", skill->miss_char );
tables.c:   if( skill->miss_vict && skill->miss_vict[0] != '\0' )
tables.c:      fprintf( fpout, "Missvict     %s~\n", skill->miss_vict );
tables.c:   if( skill->miss_room && skill->miss_room[0] != '\0' )
tables.c:      fprintf( fpout, "Missroom     %s~\n", skill->miss_room );
tables.c:   if( skill->die_char && skill->die_char[0] != '\0' )
tables.c:      fprintf( fpout, "Diechar      %s~\n", skill->die_char );
tables.c:   if( skill->die_vict && skill->die_vict[0] != '\0' )
tables.c:      fprintf( fpout, "Dievict      %s~\n", skill->die_vict );
tables.c:   if( skill->die_room && skill->die_room[0] != '\0' )
tables.c:      fprintf( fpout, "Dieroom      %s~\n", skill->die_room );
tables.c:   if( skill->imm_char && skill->imm_char[0] != '\0' )
tables.c:      fprintf( fpout, "Immchar      %s~\n", skill->imm_char );
tables.c:   if( skill->imm_vict && skill->imm_vict[0] != '\0' )
tables.c:      fprintf( fpout, "Immvict      %s~\n", skill->imm_vict );
tables.c:   if( skill->imm_room && skill->imm_room[0] != '\0' )
tables.c:      fprintf( fpout, "Immroom      %s~\n", skill->imm_room );
tables.c:   if( skill->dice && skill->dice[0] != '\0' )
tables.c:      fprintf( fpout, "Dice         %s~\n", skill->dice );
tables.c:   if( skill->value )
tables.c:      fprintf( fpout, "Value        %d\n", skill->value );
tables.c:   if( skill->difficulty )
tables.c:      fprintf( fpout, "Difficulty   %d\n", skill->difficulty );
tables.c:   if( skill->participants )
tables.c:      fprintf( fpout, "Participants %d\n", skill->participants );
tables.c:   if( skill->components && skill->components[0] != '\0' )
tables.c:      fprintf( fpout, "Components   %s~\n", skill->components );
tables.c:   if( skill->teachers && skill->teachers[0] != '\0' )
tables.c:      fprintf( fpout, "Teachers     %s~\n", skill->teachers );
tables.c:   for( aff = skill->first_affect; aff; aff = aff->next )
tables.c:      fprintf( fpout, "Affect       '%s' %d '%s' %d\n", aff->duration, aff->location, aff->modifier, aff->bitvector );
tables.c:   if( skill->alignment )
tables.c:      fprintf( fpout, "Alignment   %d\n", skill->alignment );
tables.c:   if( skill->type != SKILL_HERB )
tables.c:      fprintf( fpout, "Minlevel     %d\n", skill->min_level );
tables.c:      if( !skill_table[x]->name || skill_table[x]->name[0] == '\0' )
tables.c:      if( !herb_table[x]->name || herb_table[x]->name[0] == '\0' )
tables.c:      for( social = social_index[x]; social; social = social->next )
tables.c:         if( !social->name || social->name[0] == '\0' )
tables.c:         fprintf( fpout, "Name        %s~\n", social->name );
tables.c:         if( social->char_no_arg )
tables.c:            fprintf( fpout, "CharNoArg   %s~\n", social->char_no_arg );
tables.c:         if( social->others_no_arg )
tables.c:            fprintf( fpout, "OthersNoArg %s~\n", social->others_no_arg );
tables.c:         if( social->char_found )
tables.c:            fprintf( fpout, "CharFound   %s~\n", social->char_found );
tables.c:         if( social->others_found )
tables.c:            fprintf( fpout, "OthersFound %s~\n", social->others_found );
tables.c:         if( social->vict_found )
tables.c:            fprintf( fpout, "VictFound   %s~\n", social->vict_found );
tables.c:         if( social->char_auto )
tables.c:            fprintf( fpout, "CharAuto    %s~\n", social->char_auto );
tables.c:         if( social->others_auto )
tables.c:            fprintf( fpout, "OthersAuto  %s~\n", social->others_auto );
tables.c:      for( command = command_hash[x]; command; command = command->next )
tables.c:         if( !command->name || command->name[0] == '\0' )
tables.c:         fprintf( fpout, "Name        %s~\n", command->name );
tables.c:         fprintf( fpout, "Code        %s\n", command->fun_name?command->fun_name:"" ); // Modded to use new field - Trax
tables.c:         fprintf( fpout, "Position    %d\n", command->position );
tables.c:         fprintf( fpout, "Level       %d\n", command->level );
tables.c:         fprintf( fpout, "Log         %d\n", command->log );
tables.c:   skill->guild = -1;
tables.c:            KEY( "Alignment", skill->alignment, fread_number( fp ) );
tables.c:               aff->duration = str_dup( fread_word( fp ) );
tables.c:               aff->location = fread_number( fp );
tables.c:               aff->modifier = str_dup( fread_word( fp ) );
tables.c:               aff->bitvector = fread_number( fp );
tables.c:               LINK( aff, skill->first_affect, skill->last_affect, next, prev );
tables.c:                  skill->skill_fun = dofun;
tables.c:                  skill->spell_fun = NULL;
tables.c:                  skill->skill_fun_name = str_dup(w);
tables.c:                  skill->spell_fun = spellfun;
tables.c:                  skill->skill_fun = NULL;
tables.c:                  skill->spell_fun_name = str_dup(w);
tables.c:                  skill->spell_fun = spell_null;
tables.c:            KEY( "Components", skill->components, fread_string_nohash( fp ) );
tables.c:            KEY( "Dammsg", skill->noun_damage, fread_string_nohash( fp ) );
tables.c:            KEY( "Dice", skill->dice, fread_string_nohash( fp ) );
tables.c:            KEY( "Diechar", skill->die_char, fread_string_nohash( fp ) );
tables.c:            KEY( "Dieroom", skill->die_room, fread_string_nohash( fp ) );
tables.c:            KEY( "Dievict", skill->die_vict, fread_string_nohash( fp ) );
tables.c:            KEY( "Difficulty", skill->difficulty, fread_number( fp ) );
tables.c:            KEY( "Flags", skill->flags, fread_number( fp ) );
tables.c:            KEY( "Guild", skill->guild, fread_number( fp ) );
tables.c:            KEY( "Hitchar", skill->hit_char, fread_string_nohash( fp ) );
tables.c:            KEY( "Hitroom", skill->hit_room, fread_string_nohash( fp ) );
tables.c:            KEY( "Hitvict", skill->hit_vict, fread_string_nohash( fp ) );
tables.c:            KEY( "Immchar", skill->imm_char, fread_string_nohash( fp ) );
tables.c:            KEY( "Immroom", skill->imm_room, fread_string_nohash( fp ) );
tables.c:            KEY( "Immvict", skill->imm_vict, fread_string_nohash( fp ) );
tables.c:            KEY( "Mana", skill->min_mana, fread_number( fp ) );
tables.c:            KEY( "Minlevel", skill->min_level, fread_number( fp ) );
tables.c:            KEY( "Minpos", skill->minimum_position, fread_number( fp ) );
tables.c:            KEY( "Misschar", skill->miss_char, fread_string_nohash( fp ) );
tables.c:            KEY( "Missroom", skill->miss_room, fread_string_nohash( fp ) );
tables.c:            KEY( "Missvict", skill->miss_vict, fread_string_nohash( fp ) );
tables.c:            KEY( "Name", skill->name, fread_string_nohash( fp ) );
tables.c:            KEY( "Participants", skill->participants, fread_number( fp ) );
tables.c:            KEY( "Rounds", skill->beats, fread_number( fp ) );
tables.c:            KEY( "Slot", skill->slot, fread_number( fp ) );
tables.c:            KEY( "Saves", skill->saves, fread_number( fp ) );
tables.c:            KEY( "Target", skill->target, fread_number( fp ) );
tables.c:            KEY( "Teachers", skill->teachers, fread_string_nohash( fp ) );
tables.c:            KEY( "Type", skill->type, get_skill( fread_word( fp ) ) );
tables.c:            KEY( "Value", skill->value, fread_number( fp ) );
tables.c:            KEY( "Wearoff", skill->msg_off, fread_string_nohash( fp ) );
tables.c:            if( herb_table[top_herb - 1]->slot == 0 )
tables.c:               herb_table[top_herb - 1]->slot = top_herb - 1;
tables.c:            KEY( "CharNoArg", social->char_no_arg, fread_string_nohash( fp ) );
tables.c:            KEY( "CharFound", social->char_found, fread_string_nohash( fp ) );
tables.c:            KEY( "CharAuto", social->char_auto, fread_string_nohash( fp ) );
tables.c:               if( !social->name )
tables.c:               if( !social->char_no_arg )
tables.c:            KEY( "Name", social->name, fread_string_nohash( fp ) );
tables.c:            KEY( "OthersNoArg", social->others_no_arg, fread_string_nohash( fp ) );
tables.c:            KEY( "OthersFound", social->others_found, fread_string_nohash( fp ) );
tables.c:            KEY( "OthersAuto", social->others_auto, fread_string_nohash( fp ) );
tables.c:            KEY( "VictFound", social->vict_found, fread_string_nohash( fp ) );
tables.c:	    KEY( "Code",	command->fun_name, str_dup( fread_word( fp ) ) );
tables.c:		if( !command->name )
tables.c:		if( !command->fun_name )
tables.c:		   bug( "fread_command: No function name supplied for %s", command->name );
tables.c:	      command->do_fun = skill_function( command->fun_name );
tables.c:		if( command->do_fun == skill_notfound )
tables.c:		   bug( "Fread_command: Function %s not found for %s", command->fun_name, command->name );
tables.c:            KEY( "Level", command->level, fread_number( fp ) );
tables.c:            KEY( "Log", command->log, fread_number( fp ) );
tables.c:            KEY( "Name", command->name, fread_string_nohash( fp ) );
tables.c:            KEY( "Position", command->position, fread_number( fp ) );
track.c:*--------------------------------------------------------------------------*
track.c:* -------------------------------------------------------------------------*
track.c:*--------------------------------------------------------------------------*
track.c:* ------------------------------------------------------------------------ *
track.c:* ------------------------------------------------------------------------ *
track.c:#define BFS_ERROR	   -1
track.c:#define BFS_ALREADY_THERE  -2
track.c:#define BFS_NO_PATH	   -3
track.c:#define MARK(room)	(SET_BIT(	(room)->room_flags, BFS_MARK) )
track.c:#define UNMARK(room)	(REMOVE_BIT(	(room)->room_flags, BFS_MARK) )
track.c:#define IS_MARKED(room)	(IS_SET(	(room)->room_flags, BFS_MARK) )
track.c:   return ( get_exit( room, door )->to_room );
track.c:   if( pexit && ( to_room = pexit->to_room ) != NULL
track.c:       && !IS_SET( pexit->exit_info, EX_CLOSED )
track.c:   curr->room = room;
track.c:   curr->dir = dir;
track.c:   curr->next = NULL;
track.c:      queue_tail->next = curr;
track.c:   if( !( queue_head = queue_head->next ) )
track.c:   curr->room = room;
track.c:   curr->next = room_queue;
track.c:      UNMARK( curr->room );
track.c:      curr_next = curr->next;
track.c:   if( src->area != target->area )
track.c:      if( queue_head->room == target )
track.c:         curr_dir = queue_head->dir;
track.c:            if( valid_edge( queue_head->room, curr_dir ) )
track.c:               MARK( toroom( queue_head->room, curr_dir ) );
track.c:               room_enqueue( toroom( queue_head->room, curr_dir ) );
track.c:               bfs_enqueue( toroom( queue_head->room, curr_dir ), queue_head->dir );
track.c:   if( !IS_NPC( ch ) && !ch->pcdata->learned[gsn_track] )
track.c:   WAIT_STATE( ch, skill_table[gsn_track]->beats );
track.c:   maxdist = 100 + ch->top_level * 30;
track.c:      maxdist = ( maxdist * ch->pcdata->learned[gsn_track] ) / 100;
track.c:   dir = find_first_step( ch->in_room, vict->in_room, maxdist );
track.c:   if( victim->in_room == NULL )
track.c:      bug( "Found_prey: null victim->in_room", 0 );
track.c:   strcpy( victname, IS_NPC( victim ) ? victim->short_descr : victim->name );
track.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:            sprintf( buf, "%s is a yellow-bellied wimp!", victname );
track.c:   if( !ch || !ch->hunting || !ch->hunting->who )
track.c:   for( found = FALSE, tmp = first_char; tmp && !found; tmp = tmp->next )
track.c:      if( ch->hunting->who == tmp )
track.c:   if( ch->in_room == ch->hunting->who->in_room )
track.c:      if( ch->fighting )
track.c:      found_prey( ch, ch->hunting->who );
track.c:      if( wield != NULL && wield->value[3] == WEAPON_BLASTER )
track.c:         if( mob_snipe( ch, ch->hunting->who ) == TRUE )
track.c:      else if( !IS_SET( ch->act, ACT_DROID ) )
track.c:   ret = find_first_step( ch->in_room, ch->hunting->who->in_room, 5000 );
track.c:         if( ( pexit = get_exit( ch->in_room, ret ) ) == NULL
track.c:             || !pexit->to_room
track.c:             || IS_SET( pexit->exit_info, EX_CLOSED ) || IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB ) )
track.c:      move_char( ch, get_exit( ch->in_room, ret ), FALSE );
track.c:      if( !ch->hunting )
track.c:         if( !ch->in_room )
track.c:            sprintf( buf, "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.",
track.c:                     ch->pIndexData->vnum, ch->name );
track.c:      if( ch->in_room == ch->hunting->who->in_room )
track.c:         found_prey( ch, ch->hunting->who );
track.c:   if( !ch->in_room || !victim->in_room )
track.c:   if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
track.c:      if( IS_SET( pexit->exit_info, EX_CLOSED ) )
track.c:      was_in_room = ch->in_room;
track.c:         if( IS_SET( pexit->exit_info, EX_CLOSED ) )
track.c:         if( !pexit->to_room )
track.c:         if( pexit->distance > 1 )
track.c:            to_room = generate_exit( ch->in_room, &pexit );
track.c:            to_room = pexit->to_room;
track.c:         if( ch->in_room == victim->in_room )
track.c:         if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
track.c:      if( IS_SET( victim->in_room->room_flags, ROOM_SAFE ) )
track.c:      if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
track.c:      if( ch->position == POS_FIGHTING )
track.c:            dir -= 2;
track.c:            dir -= 1;
track.c:            dir -= 3;
track.c:      char_to_room( ch, victim->in_room );
track.c:      if( victim && !char_died( victim ) && victim->hit < 0 )
update.c:*--------------------------------------------------------------------------*
update.c:* -------------------------------------------------------------------------*
update.c:*--------------------------------------------------------------------------*
update.c:* ------------------------------------------------------------------------ *
update.c:* ------------------------------------------------------------------------ *
update.c:      if( ch->main_ability == COMBAT_ABILITY )
update.c:      if( ch->main_ability == FORCE_ABILITY )
update.c:      if( ch->main_ability == HUNTING_ABILITY )
update.c:      if( ch->race == RACE_WOOKIEE )
update.c:      if( ch->race == RACE_NOGHRI )
update.c:      if( ch->race == RACE_GAMORREAN )
update.c:      if( ch->race == RACE_DEFEL )
update.c:      if( ch->race == RACE_TRANDOSHAN )
update.c:      if( ch->race == RACE_DUINUOGWUIN )
update.c:      level += ch->perm_con + ch->perm_dex + ch->perm_str;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->main_ability == ENGINEERING_ABILITY )
update.c:      if( ch->main_ability == HUNTING_ABILITY )
update.c:      if( ch->main_ability == SMUGGLING_ABILITY )
update.c:      if( ch->main_ability == FORCE_ABILITY )
update.c:      if( ch->race == RACE_HUTT )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_GAMORREAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_QUARREN )
update.c:      if( ch->race == RACE_DUINUOGWUIN )
update.c:         level -= 30;
update.c:      level += ch->perm_dex * 2;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->main_ability == PILOTING_ABILITY )
update.c:      if( ch->race == RACE_WOOKIEE )
update.c:      if( ch->race == RACE_RODIAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_HUTT )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_MON_CALAMARI )
update.c:      if( ch->race == RACE_GAMORREAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_VERPINE )
update.c:      if( ch->race == RACE_TRANDOSHAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_CHADRA_FAN )
update.c:      level += ch->perm_int * 2;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->race == RACE_WOOKIEE )
update.c:      if( ch->race == RACE_RODIAN )
update.c:      if( ch->race == RACE_TWI_LEK )
update.c:      if( ch->race == RACE_HUTT )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_MON_CALAMARI )
update.c:      if( ch->race == RACE_JAWA )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_ADARIAN )
update.c:         level -= 30;
update.c:      if( ch->race == RACE_TRANDOSHAN )
update.c:      if( ch->race == RACE_CHADRA_FAN )
update.c:         level -= 25;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->main_ability == PILOTING_ABILITY )
update.c:      if( ch->main_ability == ENGINEERING_ABILITY )
update.c:      if( ch->race == RACE_TWI_LEK )
update.c:      if( ch->race == RACE_MON_CALAMARI )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_JAWA )
update.c:      if( ch->race == RACE_ADARIAN )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_VERPINE )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_DEFEL )
update.c:      if( ch->race == RACE_QUARREN )
update.c:      if( ch->race == RACE_CHADRA_FAN )
update.c:      if( ch->race == RACE_DUINUOGWUIN )
update.c:         level -= 10;
update.c:      level += ch->perm_lck * 2;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->main_ability == COMBAT_ABILITY )
update.c:      if( ch->main_ability == DIPLOMACY_ABILITY )
update.c:      if( ch->race == RACE_TWI_LEK )
update.c:         level -= 25;
update.c:      if( ch->race == RACE_RODIAN )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_HUTT )
update.c:      if( ch->race == RACE_MON_CALAMARI )
update.c:      if( ch->race == RACE_JAWA )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_ADARIAN )
update.c:      if( ch->race == RACE_TRANDOSHAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_QUARREN )
update.c:         level -= 10;
update.c:      level += ch->perm_wis + ch->perm_cha + ch->perm_int;
update.c:      if( ch->main_ability == ability )
update.c:      if( ch->main_ability == PILOTING_ABILITY )
update.c:      if( ch->main_ability == LEADERSHIP_ABILITY )
update.c:      if( ch->race == RACE_WOOKIEE )
update.c:         level -= 50;
update.c:      if( ch->race == RACE_TWI_LEK )
update.c:         level -= 25;
update.c:      if( ch->race == RACE_RODIAN )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_HUTT )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_MON_CALAMARI )
update.c:      if( ch->race == RACE_NOGHRI )
update.c:         level -= 50;
update.c:      if( ch->race == RACE_GAMORREAN )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_JAWA )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_ADARIAN )
update.c:      if( ch->race == RACE_VERPINE )
update.c:         level -= 10;
update.c:      if( ch->race == RACE_DEFEL )
update.c:         level -= 30;
update.c:      if( ch->race == RACE_TRANDOSHAN )
update.c:         level -= 30;
update.c:      if( ch->race == RACE_QUARREN )
update.c:         level -= 20;
update.c:      if( ch->race == RACE_DUINUOGWUIN )
update.c:      level += ch->perm_cha * 3;
update.c:      if( ch->main_ability == ability )
update.c:      level += ch->perm_frc * 5;
update.c:   if( ch->top_level < ch->skill_level[ability] && ch->top_level < LEVEL_HERO )
update.c:      ch->top_level = URANGE( 1, ch->skill_level[ability], LEVEL_HERO );
update.c:      REMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:   ch->experience[ability] = UMAX( 0, ch->experience[ability] + gain );
update.c:   if( NOT_AUTHED( ch ) && ch->experience[ability] >= exp_level( ch->skill_level[ability] + 1 ) )
update.c:      ch->experience[ability] = ( exp_level( ch->skill_level[ability] + 1 ) - 1 );
update.c:   while( ch->experience[ability] >= exp_level( ch->skill_level[ability] + 1 ) )
update.c:      if( ch->skill_level[ability] >= max_level( ch, ability ) )
update.c:         ch->experience[ability] = ( exp_level( ch->skill_level[ability] + 1 ) - 1 );
update.c:      ch_printf( ch, "You have now obtained %s level %d!\r\n", ability_name[ability], ++ch->skill_level[ability] );
update.c:      gain = ch->top_level;
update.c:      gain = UMIN( 5, ch->top_level );
update.c:      switch ( ch->position )
update.c:            return -25;
update.c:            return -20;
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:      return -10;
update.c:   if( ch->race == RACE_TRANDOSHAN )
update.c:   return UMIN( gain, ch->max_hit - ch->hit );
update.c:      gain = ch->top_level;
update.c:      if( ch->skill_level[FORCE_ABILITY] <= 1 )
update.c:         return ( 0 - ch->mana );
update.c:      gain = UMIN( 5, ch->skill_level[FORCE_ABILITY] / 2 );
update.c:      if( ch->position < POS_SLEEPING )
update.c:      switch ( ch->position )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_mana - ch->mana );
update.c:      gain = ch->top_level;
update.c:      gain = UMAX( 15, 2 * ch->top_level );
update.c:      switch ( ch->position )
update.c:            return -1;
update.c:            return -1;
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_move - ch->move );
update.c:      if( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug] )
update.c:         ch->pcdata->addiction[drug]++;
update.c:      if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 150 )
update.c:         switch ( ch->pcdata->addiction[drug] )
update.c:                  af.duration = ch->pcdata->addiction[drug];
update.c:                  af.type = -1;
update.c:                  af.modifier = -10;
update.c:                  af.duration = ch->pcdata->addiction[drug];
update.c:                  af.type = -1;
update.c:                  af.modifier = -5;
update.c:                  af.duration = ch->pcdata->addiction[drug];
update.c:                  af.type = -1;
update.c:                  af.modifier = -5;
update.c:                  af.duration = ch->pcdata->addiction[drug];
update.c:      if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 200 )
update.c:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 100 )
update.c:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 50 )
update.c:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 25 )
update.c:      else if( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug] - 50 )
update.c:         ch->pcdata->drug_level[drug] -= 10;
update.c:      if( ch->pcdata->drug_level[drug] > 1 )
update.c:         ch->pcdata->drug_level[drug] -= 2;
update.c:      else if( ch->pcdata->drug_level[drug] > 0 )
update.c:         ch->pcdata->drug_level[drug] -= 1;
update.c:      else if( ch->pcdata->addiction[drug] > 0 && ch->pcdata->drug_level[drug] <= 0 )
update.c:         ch->pcdata->addiction[drug]--;
update.c:   condition = ch->pcdata->condition[iCond];
update.c:   ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 48 );
update.c:   if( ch->pcdata->condition[iCond] == 0 )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 1 )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 2 )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 3 )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:            if( ch->top_level <= LEVEL_AVATAR )
update.c:      if( ch == first_char && ch->prev )
update.c:         bug( "%s: first_char->prev != NULL... fixed", __FUNCTION__ );
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:      if( gch_prev && gch_prev->next != ch )
update.c:         bug( "FATAL: %s: %s->prev->next doesn't point to ch.", __FUNCTION__, ch->name );
update.c:         ch->prev = NULL;
update.c:      if( !ch->in_room || IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_PARALYSIS ) )
update.c:/* Clean up 'animated corpses' that are not charmed' - Scryn */
update.c:      if( ch->pIndexData->vnum == 5 && !IS_AFFECTED( ch, AFF_CHARM ) )
update.c:         if( ch->in_room->first_person )
update.c:      if( !IS_SET( ch->act, ACT_RUNNING ) && !IS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:         if( ch->top_level < ( LEVEL_HERO * 0.2 ) )
update.c:         else if( ch->top_level < ( LEVEL_HERO * 0.4 ) )
update.c:         else if( ch->top_level < ( LEVEL_HERO * 0.6 ) )
update.c:         else if( ch->top_level < ( LEVEL_HERO * 0.8 ) )
update.c:         else if( ch->top_level < LEVEL_HERO )
update.c:      else if( !ch->fighting && !ch->hunting
update.c:               && !IS_SET( ch->act, ACT_RUNNING ) && ch->was_sentinel && ch->position >= POS_STANDING )
update.c:         char_to_room( ch, ch->was_sentinel );
update.c:         SET_BIT( ch->act, ACT_SENTINEL );
update.c:         ch->was_sentinel = NULL;
update.c:      if( !IS_SET( ch->act, ACT_RUNNING ) && ch->spec_fun )
update.c:         if( ( *ch->spec_fun ) ( ch ) )
update.c:      if( !IS_SET( ch->act, ACT_RUNNING ) && ch->spec_2 )
update.c:         if( ( *ch->spec_2 ) ( ch ) )
update.c:      if( IS_SET( ch->pIndexData->progtypes, SCRIPT_PROG ) )
update.c:      if( ch->position != POS_STANDING )
update.c:      if( IS_SET( ch->act, ACT_MOUNTED ) )
update.c:         if( IS_SET( ch->act, ACT_AGGRESSIVE ) )
update.c:      if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && IS_SET( ch->act, ACT_AGGRESSIVE ) )
update.c:      if( ch->in_room->area->nplayer > 0 )
update.c:         if( ch->position < POS_STANDING )
update.c:      if( ch->position < POS_STANDING )
update.c:      if( IS_SET( ch->act, ACT_SCAVENGER ) && ch->in_room->first_content && number_bits( 2 ) == 0 )
update.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:            if ( IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) && !IS_SET( ch->act, ACT_PROTOTYPE ) )
update.c:            if( CAN_WEAR( obj, ITEM_TAKE ) && obj->cost > max && !IS_OBJ_STAT( obj, ITEM_BURRIED ) )
update.c:               max = obj->cost;
update.c:      if( !IS_SET( ch->act, ACT_RUNNING )
update.c:          && !IS_SET( ch->act, ACT_SENTINEL )
update.c:          && !IS_SET( ch->act, ACT_PROTOTYPE )
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && pexit->to_room
update.c:          && !IS_SET( pexit->exit_info, EX_WINDOW )
update.c:          && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c:          && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
update.c:          && ( !IS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:          * continue - Kahn 
update.c:         if( retcode != rNONE || IS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:      if( ch->hit < ch->max_hit / 2
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && pexit->to_room
update.c:          && !IS_SET( pexit->exit_info, EX_WINDOW )
update.c:          && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c:          && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB ) )
update.c:         for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
update.c:                     sprintf( buf, "Get away from me, %s!", rch->name );
update.c:                     sprintf( buf, "Leave me be, %s!", rch->name );
update.c:                     sprintf( buf, "%s is trying to kill me!  Help!", rch->name );
update.c:                     sprintf( buf, "Someone save me from %s!", rch->name );
update.c:   for( planet = first_planet; planet; planet = planet->next )
update.c:      clan = planet->governed_by;
update.c:         if( clan->first_subclan )
update.c:            for( subclan = clan->first_subclan; subclan; subclan = subclan->next_subclan )
update.c:            for( subclan = clan->first_subclan; subclan; subclan = subclan->next_subclan )
update.c:               subclan->funds += get_taxes( planet ) / 1440 / sCount;
update.c:            clan->funds += get_taxes( planet ) / 1440;
update.c:            clan->funds += get_taxes( planet ) / 720;
update.c:      for( d = first_descriptor; d; d = d->next )
update.c:         if( d->connected == CON_PLAYING
update.c:             && IS_OUTSIDE( d->character )
update.c:             && IS_AWAKE( d->character )
update.c:             && d->character->in_room
update.c:             && d->character->in_room->sector_type != SECT_UNDERWATER
update.c:             && d->character->in_room->sector_type != SECT_OCEANFLOOR
update.c:             && d->character->in_room->sector_type != SECT_UNDERGROUND )
update.c:            act( AT_TEMP, buf, d->character, 0, 0, TO_CHAR );
update.c:      diff = weather_info.mmhg > 985 ? -2 : 2;
update.c:      diff = weather_info.mmhg > 1015 ? -2 : 2;
update.c:   weather_info.change += diff * dice( 1, 4 ) + dice( 2, 6 ) - dice( 2, 6 );
update.c:   weather_info.change = UMAX( weather_info.change, -12 );
update.c:      for( d = first_descriptor; d; d = d->next )
update.c:         if( d->connected == CON_PLAYING && IS_OUTSIDE( d->character ) && IS_AWAKE( d->character ) )
update.c:            act( AT_TEMP, buf, d->character, 0, 0, TO_CHAR );
update.c:      if( ch == first_char && ch->prev )
update.c:         bug( "char_update: first_char->prev != NULL... fixed", 0 );
update.c:         ch->prev = NULL;
update.c:      gch_prev = ch->prev;
update.c:      if( gch_prev && gch_prev->next != ch )
update.c:         bug( "char_update: ch->prev->next != ch", 0 );
update.c:       * See if player should be auto-saved.
update.c:      if( !IS_NPC( ch ) && !NOT_AUTHED( ch ) && current_time - ch->save_time > ( sysdata.save_frequency * 60 ) )
update.c:      if( ch->position >= POS_STUNNED )
update.c:         if( ch->hit < ch->max_hit )
update.c:            ch->hit += hit_gain( ch );
update.c:         if( ch->mana < ch->max_mana || ch->skill_level[FORCE_ABILITY] == 1 )
update.c:            ch->mana += mana_gain( ch );
update.c:         if( ch->move < ch->max_move )
update.c:            ch->move += move_gain( ch );
update.c:      if( ch->position == POS_STUNNED )
update.c:      if( ch->pcdata )
update.c:      if( !IS_NPC( ch ) && ch->top_level < LEVEL_IMMORTAL )
update.c:         if( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL && obj->item_type == ITEM_LIGHT && obj->value[2] > 0 )
update.c:            if( --obj->value[2] == 0 && ch->in_room )
update.c:               ch->in_room->light -= obj->count;
update.c:               if( obj->serial == cur_obj )
update.c:         if( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:            worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK] / 8 );
update.c:         if( ch->pcdata->condition[COND_FULL] > 1 )
update.c:            switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:            switch ( ch->position )
update.c:         gain_condition( ch, COND_DRUNK, -1 );
update.c:         gain_condition( ch, COND_FULL, -1 );
update.c:         if( ch->in_room )
update.c:            switch ( ch->in_room->sector_type )
update.c:                  gain_condition( ch, COND_THIRST, -1 );
update.c:                  gain_condition( ch, COND_THIRST, -2 );
update.c:                     gain_condition( ch, COND_THIRST, -1 );
update.c:            ch->mental_state = URANGE( 20, ch->mental_state + 4, 100 );
update.c:         else if( ch->position == POS_INCAP )
update.c:         else if( ch->position == POS_MORTAL )
update.c:         if( ch->mental_state >= 30 )
update.c:            switch ( ( ch->mental_state + 5 ) / 10 )
update.c:                  act( AT_ACTION, "$n is ranting on about 'the answer', 'ONE' and other mumbo-jumbo...", ch, NULL, NULL,
update.c:         if( ch->mental_state <= -30 )
update.c:            switch ( ( abs( ch->mental_state ) + 5 ) / 10 )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && number_percent(  ) + 10 < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && ( number_percent(  ) + 20 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ch->position < POS_SITTING && ( number_percent(  ) + 30 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:         if( ch->backup_wait > 0 )
update.c:            --ch->backup_wait;
update.c:            if( ch->backup_wait == 0 )
update.c:            if( ++ch->timer > 15 && !ch->desc )
update.c:               if( ch->in_room )
update.c:               ch->position = POS_RESTING;
update.c:               ch->hit = UMAX( 1, ch->hit );
update.c:      if( obj == first_object && obj->prev )
update.c:         bug( "obj_update: first_object->prev != NULL... fixed", 0 );
update.c:         obj->prev = NULL;
update.c:      gobj_prev = obj->prev;
update.c:      if( gobj_prev && gobj_prev->next != obj )
update.c:         bug( "obj_update: obj->prev->next != obj", 0 );
update.c:      if( obj->carried_by )
update.c:      else if( obj->in_room && obj->in_room->area->nplayer > 0 )
update.c:      if( obj->item_type == ITEM_WEAPON && obj->carried_by &&
update.c:          ( obj->wear_loc == WEAR_WIELD || obj->wear_loc == WEAR_DUAL_WIELD ) &&
update.c:          obj->value[3] != WEAPON_BLASTER && obj->value[4] > 0 &&
update.c:          obj->value[3] != WEAPON_BOWCASTER && obj->value[3] != WEAPON_FORCE_PIKE )
update.c:         obj->value[4]--;
update.c:         if( obj->value[4] <= 0 )
update.c:            if( obj->value[3] == WEAPON_LIGHTSABER )
update.c:               act( AT_PLAIN, "$p fizzles and dies.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:               act( AT_PLAIN, "$n's lightsaber fizzles and dies.", obj->carried_by, NULL, NULL, TO_ROOM );
update.c:            else if( obj->value[3] == WEAPON_VIBRO_BLADE )
update.c:               act( AT_PLAIN, "$p stops vibrating.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:      if( obj->item_type == ITEM_PIPE )
update.c:         if( IS_SET( obj->value[3], PIPE_LIT ) )
update.c:            if( --obj->value[1] <= 0 )
update.c:               obj->value[1] = 0;
update.c:               REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c:            else if( IS_SET( obj->value[3], PIPE_HOT ) )
update.c:               REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c:               if( IS_SET( obj->value[3], PIPE_GOINGOUT ) )
update.c:                  REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c:                  REMOVE_BIT( obj->value[3], PIPE_GOINGOUT );
update.c:                  SET_BIT( obj->value[3], PIPE_GOINGOUT );
update.c:            if( !IS_SET( obj->value[3], PIPE_LIT ) )
update.c:               SET_BIT( obj->value[3], PIPE_FULLOFASH );
update.c:            REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c:/* Corpse decay (npc corpses decay at 8 times the rate of pc corpses) - Narn */
update.c:      if( obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_DROID_CORPSE )
update.c:         short timerfrac = UMAX( 1, obj->timer - 1 );
update.c:         if( obj->item_type == ITEM_CORPSE_PC )
update.c:            timerfrac = ( int )( obj->timer / 8 + 1 );
update.c:         if( obj->timer > 0 && obj->value[2] > timerfrac )
update.c:            bufptr = one_argument( obj->short_descr, name );
update.c:            obj->value[2] = timerfrac;
update.c:            if( obj->item_type == ITEM_DROID_CORPSE )
update.c:               sprintf( buf, d_corpse_descs[UMIN( timerfrac - 1, 4 )], bufptr );
update.c:               sprintf( buf, corpse_descs[UMIN( timerfrac - 1, 4 )], capitalize( bufptr ) );
update.c:            STRFREE( obj->description );
update.c:            obj->description = STRALLOC( buf );
update.c:      if( obj->timer > 0 && obj->timer < 5 && obj->item_type == ITEM_ARMOR )
update.c:         if( obj->carried_by )
update.c:            act( AT_TEMP, "$p is almost dead.", obj->carried_by, obj, NULL, TO_CHAR );
update.c:      if( ( obj->timer <= 0 || --obj->timer > 0 ) )
update.c:      switch ( obj->item_type )
update.c:            obj->item_type = ITEM_TRASH;  /* so extract_obj  */
update.c:            if( obj->in_room )
update.c:               --obj->in_room->light;
update.c:      if( obj->carried_by )
update.c:         act( AT_TEMP, message, obj->carried_by, obj, NULL, TO_CHAR );
update.c:      else if( obj->in_room && ( rch = obj->in_room->first_person ) != NULL && !IS_OBJ_STAT( obj, ITEM_BURRIED ) )
update.c:      if( obj->serial == cur_obj )
update.c:      ch_next = ch->next;
update.c:          * running mobs  -Thoric 
update.c:         if( IS_SET( ch->act, ACT_RUNNING ) )
update.c:            if( !IS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:            if( ch->spec_fun )
update.c:               if( ( *ch->spec_fun ) ( ch ) )
update.c:            if( ch->spec_2 )
update.c:               if( ( *ch->spec_2 ) ( ch ) )
update.c:            if( !IS_SET( ch->act, ACT_SENTINEL )
update.c:                && !IS_SET( ch->act, ACT_PROTOTYPE )
update.c:                && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:                && pexit->to_room
update.c:                && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c:                && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
update.c:                && ( !IS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:               if( retcode != rNONE || IS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:         if( ch->mount && ch->in_room != ch->mount->in_room )
update.c:            REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:            ch->mount = NULL;
update.c:            ch->position = POS_STANDING;
update.c:         if( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:             || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:                  dam = number_range( ch->max_hit / 50, ch->max_hit / 30 );
update.c:                  if( ch->hit <= 0 )
update.c:         if( ch->in_room
update.c:             && ( ( ch->in_room->sector_type == SECT_WATER_NOSWIM ) || ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:                && !IS_AFFECTED( ch, AFF_FLOATING ) && !IS_AFFECTED( ch, AFF_AQUA_BREATH ) && !ch->mount )
update.c:                  if( ch->move > 0 )
update.c:                     ch->move--;
update.c:                     dam = number_range( ch->max_hit / 50, ch->max_hit / 30 );
update.c:                     if( ch->hit <= 0 )
update.c:   if( IS_NPC( wch ) && wch->mpactnum > 0 && wch->in_room->area->nplayer > 0 )
update.c:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp_act->next )
update.c:         oprog_wordlist_check( tmp_act->buf, wch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG );
update.c:         DISPOSE( tmp_act->buf );
update.c:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp2_act )
update.c:         tmp2_act = tmp_act->next;
update.c:      wch->mpactnum = 0;
update.c:      wch->mpact = NULL;
update.c:     wch = ( CHAR_DATA* ) mob_act_list->vo;
update.c:      if( !char_died( wch ) && wch->mpactnum > 0 )
update.c:         while( ( tmp_act = wch->mpact ) != NULL )
update.c:            if( tmp_act->obj && obj_extracted( tmp_act->obj ) )
update.c:               tmp_act->obj = NULL;
update.c:            if( tmp_act->ch && !char_died( tmp_act->ch ) )
update.c:               mprog_wordlist_check( tmp_act->buf, wch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG );
update.c:            wch->mpact = tmp_act->next;
update.c:            DISPOSE( tmp_act->buf );
update.c:         wch->mpactnum = 0;
update.c:         wch->mpact = NULL;
update.c:      mob_act_list = apdtmp->next;
update.c:    * We can check for linkdead victims to mobile_update   -Thoric
update.c:      dnext = d->next;
update.c:      if( ( d->connected != CON_PLAYING && d->connected != CON_EDITING ) || ( wch = d->character ) == NULL )
update.c:      if( char_died( wch ) || IS_NPC( wch ) || wch->top_level >= LEVEL_IMMORTAL || !wch->in_room )
update.c:      for( ch = wch->in_room->first_person; ch; ch = ch_next )
update.c:         ch_next = ch->next_in_room;
update.c:             || ch->fighting
update.c:             || IS_AFFECTED( ch, AFF_CHARM ) || !IS_AWAKE( ch ) || ( IS_SET( ch->act, ACT_WIMPY ) ) || !can_see( ch, wch ) )
update.c:         if( !IS_SET( ch->act, ACT_AGGRESSIVE )
update.c:             || IS_SET( ch->act, ACT_MOUNTED ) || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
update.c:         if( IS_NPC( ch ) && IS_SET( ch->attacks, ATCK_BACKSTAB ) )
update.c:            if( !ch->mount
update.c:                && obj->value[3] == 11 && !victim->fighting && victim->hit >= victim->max_hit )
update.c:               WAIT_STATE( ch, skill_table[gsn_backstab]->beats );
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->top_level )
update.c: * drunk randoms	- Tricops
update.c: * (Made part of mobile_update	-Thoric)
update.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:   drunk = ch->pcdata->condition[COND_DRUNK];
update.c:   position = ch->position;
update.c:   ch->position = POS_STANDING;
update.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:      check_social( ch, "puke", ( rvch ? rvch->name : "" ) );
update.c:   ch->position = position;
update.c:   if( ch->mental_state >= 30 && number_bits( 5 - ( ch->mental_state >= 50 ) - ( ch->mental_state >= 75 ) ) == 0 )
update.c:      switch ( number_range( 1, UMIN( 20, ( ch->mental_state + 5 ) / 5 ) ) )
update.c:      tele_next = tele->next;
update.c:      if( --tele->timer <= 0 )
update.c:         if( tele->room->first_person )
update.c:            teleport( tele->room->first_person, tele->room->tele_vnum, TELE_TRANSALL );
update.c: * Write all outstanding authorization requests to Log channel - Gorog
update.c:   for( d = first_descriptor; d; d = d->next )
update.c:      victim = d->character;
update.c:         sprintf( log_buf, " %s@%s new %s", victim->name, victim->desc->host, race_table[victim->race].race_name );
update.c:   for( d = first_descriptor; d; d = d->next )
update.c:      if( ( victim = d->character ) && IS_WAITING_FOR_AUTH( victim ) )
update.c:         sprintf( buf, " %s@%s new %s\r\n", victim->name, victim->desc->host, race_table[victim->race].race_name );
update.c: * Random times to defeat tick-timing clients and players.
update.c:   if( --pulse_area <= 0 )
update.c:   if( --pulse_taxes <= 0 )
update.c:   if( --pulse_mobile <= 0 )
update.c:   if( --pulse_space <= 0 )
update.c:   if( --pulse_recharge <= 0 )
update.c:   if( --pulse_ship <= 0 )
update.c:   if( --pulse_violence <= 0 )
update.c:   if( --pulse_point <= 0 )
update.c:   if( --pulse_second <= 0 )
update.c:       * reboot_check( "" ); Disabled to check if its lagging a lot - Scryn
update.c:   if( auction->item && --auction->pulse <= 0 )
update.c:      auction->pulse = PULSE_AUCTION;
update.c:   fromRoom = portal->in_room;
update.c:      bug( "remove_portal: portal->in_room is NULL", 0 );
update.c:   for( pexit = fromRoom->first_exit; pexit; pexit = pexit->next )
update.c:      if( IS_SET( pexit->exit_info, EX_PORTAL ) )
update.c:      bug( "remove_portal: portal not found in room %d!", fromRoom->vnum );
update.c:   if( pexit->vdir != DIR_PORTAL )
update.c:      bug( "remove_portal: exit in dir %d != DIR_PORTAL", pexit->vdir );
update.c:   if( ( toRoom = pexit->to_room ) == NULL )
update.c:    * ch = fromRoom->first_person; 
update.c:   if( toRoom && ( ch = toRoom->first_person ) != NULL )
update.c:      for( trun = timesize - 1; trun >= 0; trun-- )
update.c:   if( new_boot_time_t - boot_time < 60 * 60 * 18 && !set_boot_time->manual )
update.c:      if( auction->item )
update.c:         sprintf( buf, "Sale of %s has been stopped by mud.", auction->item->short_descr );
update.c:         obj_to_char( auction->item, auction->seller );
update.c:         auction->item = NULL;
update.c:         if( auction->buyer && auction->buyer != auction->seller )
update.c:            auction->buyer->gold += auction->bet;
update.c:            send_to_char( "Your money has been returned.\r\n", auction->buyer );
update.c:      for( vch = first_char; vch; vch = vch->next )
update.c:   if( trun != -1 && new_boot_time_t - current_time <= times[trun] )
update.c:      --trun;
update.c:    * Bools to show which pre-boot echoes we've done. 
update.c:/* Change by Scryn - if mud has not been up 18 hours at boot time - still 
update.c:   if( new_boot_time_t - boot_time < 60 * 60 * 18 && set_boot_time->manual == 0 )
update.c:    if ( timestruct->tm_hour == set_boot_time->hour        
update.c:         && timestruct->tm_min  == set_boot_time->min )*/
update.c:      if( auction->item != NULL )
update.c:         sprintf( buf, "Sale of %s has been stopped by mud.", auction->item->short_descr );
update.c:         obj_to_char( auction->item, auction->seller );
update.c:         auction->item = NULL;
update.c:         if( auction->buyer != NULL && auction->seller != auction->buyer ) /* return money to the buyer */
update.c:            auction->buyer->gold += auction->bet;
update.c:            send_to_char( "Your money has been returned.\r\n", auction->buyer );
update.c:      for( vch = first_char; vch; vch = vch->next )
update.c:/*  timecheck = ( set_boot_time->hour * 60 + set_boot_time->min )
update.c:              - ( timestruct->tm_hour * 60 + timestruct->tm_min );
update.c:   if( new_boot_time_t - current_time <= 60 )
update.c:   if( new_boot_time_t - current_time <= 120 )
update.c:   if( new_boot_time_t - current_time <= 180 )
update.c:   if( new_boot_time_t - current_time <= 240 )
update.c:   if( new_boot_time_t - current_time <= 300 )
update.c:   if( new_boot_time_t - current_time <= 600 )
update.c:   if( new_boot_time_t - current_time <= 900 )
update.c:   if( new_boot_time_t - current_time <= 1800 )
update.c:   switch ( ++auction->going )   /* increase the going state */
update.c:         if( auction->bet > auction->starting )
update.c:            sprintf( buf, "%s: going %s for %d.", auction->item->short_descr,
update.c:                     ( ( auction->going == 1 ) ? "once" : "twice" ), auction->bet );
update.c:            sprintf( buf, "%s: going %s (bid not received yet).", auction->item->short_descr,
update.c:                     ( ( auction->going == 1 ) ? "once" : "twice" ) );
update.c:         if( !auction->buyer && auction->bet )
update.c:            bug( "Auction code reached SOLD, with NULL buyer, but %d gold bid", auction->bet );
update.c:            auction->bet = 0;
update.c:         if( auction->bet > 0 && auction->buyer != auction->seller )
update.c:                     auction->item->short_descr,
update.c:                     IS_NPC( auction->buyer ) ? auction->buyer->short_descr : auction->buyer->name, auction->bet );
update.c:                 auction->buyer, auction->item, NULL, TO_CHAR );
update.c:                 auction->buyer, auction->item, NULL, TO_ROOM );
update.c:            if( ( auction->buyer->carry_weight + get_obj_weight( auction->item ) ) > can_carry_w( auction->buyer ) )
update.c:               act( AT_PLAIN, "$p is too heavy for you to carry with your current inventory.", auction->buyer, auction->item,
update.c:               act( AT_PLAIN, "$n is carrying too much to also carry $p, and $e drops it.", auction->buyer, auction->item,
update.c:               obj_to_room( auction->item, auction->buyer->in_room );
update.c:               obj_to_char( auction->item, auction->buyer );
update.c:            pay = ( int )( auction->bet * 0.9 );
update.c:            tax = ( int )( auction->bet * 0.1 );
update.c:            boost_economy( auction->seller->in_room->area, tax );
update.c:            auction->seller->gold += pay; /* give him the money, tax 10 % */
update.c:            send_to_char( buf, auction->seller );
update.c:            auction->item = NULL;   /* reset item */
update.c:               save_char_obj( auction->buyer );
update.c:               save_char_obj( auction->seller );
update.c:            sprintf( buf, "No bids received for %s - object has been removed from auction\r\n.",
update.c:                     auction->item->short_descr );
update.c:                 auction->seller, auction->item, NULL, TO_CHAR );
update.c:                 auction->seller, auction->item, NULL, TO_ROOM );
update.c:            if( ( auction->seller->carry_weight + get_obj_weight( auction->item ) ) > can_carry_w( auction->seller ) )
update.c:                    " with everything else you're carrying.", auction->seller, auction->item, NULL, TO_CHAR );
update.c:                    " for $m with everything else.", auction->seller, auction->item, NULL, TO_ROOM );
update.c:               obj_to_room( auction->item, auction->seller->in_room );
update.c:               obj_to_char( auction->item, auction->seller );
update.c:            tax = ( int )( auction->item->cost * 0.05 );
update.c:            boost_economy( auction->seller->in_room->area, tax );
update.c:            send_to_char( buf, auction->seller );
update.c:            if( ( auction->seller->gold - tax ) < 0 )
update.c:               auction->seller->gold = 0;
update.c:               auction->seller->gold -= tax;
update.c:               save_char_obj( auction->seller );
update.c:         auction->item = NULL;   /* clear auction */
update.c:   etime->tv_sec -= sttime->tv_sec;
update.c:   etime->tv_usec -= sttime->tv_usec;
update.c:   while( etime->tv_usec < 0 )
update.c:      etime->tv_usec += 1000000;
update.c:      etime->tv_sec--;
update.c~:*--------------------------------------------------------------------------*
update.c~:* -------------------------------------------------------------------------*
update.c~:*--------------------------------------------------------------------------*
update.c~:* ------------------------------------------------------------------------ *
update.c~:* ------------------------------------------------------------------------ *
update.c~:      if( ch->main_ability == COMBAT_ABILITY )
update.c~:      if( ch->main_ability == FORCE_ABILITY )
update.c~:      if( ch->main_ability == HUNTING_ABILITY )
update.c~:      if( ch->race == RACE_WOOKIEE )
update.c~:      if( ch->race == RACE_NOGHRI )
update.c~:      if( ch->race == RACE_GAMORREAN )
update.c~:      if( ch->race == RACE_DEFEL )
update.c~:      if( ch->race == RACE_TRANDOSHAN )
update.c~:      if( ch->race == RACE_DUINUOGWUIN )
update.c~:      level += ch->perm_con + ch->perm_dex + ch->perm_str;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->main_ability == ENGINEERING_ABILITY )
update.c~:      if( ch->main_ability == HUNTING_ABILITY )
update.c~:      if( ch->main_ability == SMUGGLING_ABILITY )
update.c~:      if( ch->main_ability == FORCE_ABILITY )
update.c~:      if( ch->race == RACE_HUTT )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_GAMORREAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_QUARREN )
update.c~:      if( ch->race == RACE_DUINUOGWUIN )
update.c~:         level -= 30;
update.c~:      level += ch->perm_dex * 2;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->main_ability == PILOTING_ABILITY )
update.c~:      if( ch->race == RACE_WOOKIEE )
update.c~:      if( ch->race == RACE_RODIAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_HUTT )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_MON_CALAMARI )
update.c~:      if( ch->race == RACE_GAMORREAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_VERPINE )
update.c~:      if( ch->race == RACE_TRANDOSHAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_CHADRA_FAN )
update.c~:      level += ch->perm_int * 2;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->race == RACE_WOOKIEE )
update.c~:      if( ch->race == RACE_RODIAN )
update.c~:      if( ch->race == RACE_TWI_LEK )
update.c~:      if( ch->race == RACE_HUTT )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_MON_CALAMARI )
update.c~:      if( ch->race == RACE_JAWA )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_ADARIAN )
update.c~:         level -= 30;
update.c~:      if( ch->race == RACE_TRANDOSHAN )
update.c~:      if( ch->race == RACE_CHADRA_FAN )
update.c~:         level -= 25;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->main_ability == PILOTING_ABILITY )
update.c~:      if( ch->main_ability == ENGINEERING_ABILITY )
update.c~:      if( ch->race == RACE_TWI_LEK )
update.c~:      if( ch->race == RACE_MON_CALAMARI )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_JAWA )
update.c~:      if( ch->race == RACE_ADARIAN )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_VERPINE )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_DEFEL )
update.c~:      if( ch->race == RACE_QUARREN )
update.c~:      if( ch->race == RACE_CHADRA_FAN )
update.c~:      if( ch->race == RACE_DUINUOGWUIN )
update.c~:         level -= 10;
update.c~:      level += ch->perm_lck * 2;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->main_ability == COMBAT_ABILITY )
update.c~:      if( ch->main_ability == DIPLOMACY_ABILITY )
update.c~:      if( ch->race == RACE_TWI_LEK )
update.c~:         level -= 25;
update.c~:      if( ch->race == RACE_RODIAN )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_HUTT )
update.c~:      if( ch->race == RACE_MON_CALAMARI )
update.c~:      if( ch->race == RACE_JAWA )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_ADARIAN )
update.c~:      if( ch->race == RACE_TRANDOSHAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_QUARREN )
update.c~:         level -= 10;
update.c~:      level += ch->perm_wis + ch->perm_cha + ch->perm_int;
update.c~:      if( ch->main_ability == ability )
update.c~:      if( ch->main_ability == PILOTING_ABILITY )
update.c~:      if( ch->main_ability == LEADERSHIP_ABILITY )
update.c~:      if( ch->race == RACE_WOOKIEE )
update.c~:         level -= 50;
update.c~:      if( ch->race == RACE_TWI_LEK )
update.c~:         level -= 25;
update.c~:      if( ch->race == RACE_RODIAN )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_HUTT )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_MON_CALAMARI )
update.c~:      if( ch->race == RACE_NOGHRI )
update.c~:         level -= 50;
update.c~:      if( ch->race == RACE_GAMORREAN )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_JAWA )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_ADARIAN )
update.c~:      if( ch->race == RACE_VERPINE )
update.c~:         level -= 10;
update.c~:      if( ch->race == RACE_DEFEL )
update.c~:         level -= 30;
update.c~:      if( ch->race == RACE_TRANDOSHAN )
update.c~:         level -= 30;
update.c~:      if( ch->race == RACE_QUARREN )
update.c~:         level -= 20;
update.c~:      if( ch->race == RACE_DUINUOGWUIN )
update.c~:      level += ch->perm_cha * 3;
update.c~:      if( ch->main_ability == ability )
update.c~:      level += ch->perm_frc * 5;
update.c~:   if( ch->top_level < ch->skill_level[ability] && ch->top_level < LEVEL_HERO )
update.c~:      ch->top_level = URANGE( 1, ch->skill_level[ability], LEVEL_HERO );
update.c~:      REMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c~:   ch->experience[ability] = UMAX( 0, ch->experience[ability] + gain );
update.c~:   if( NOT_AUTHED( ch ) && ch->experience[ability] >= exp_level( ch->skill_level[ability] + 1 ) )
update.c~:      ch->experience[ability] = ( exp_level( ch->skill_level[ability] + 1 ) - 1 );
update.c~:   while( ch->experience[ability] >= exp_level( ch->skill_level[ability] + 1 ) )
update.c~:      if( ch->skill_level[ability] >= max_level( ch, ability ) )
update.c~:         ch->experience[ability] = ( exp_level( ch->skill_level[ability] + 1 ) - 1 );
update.c~:      ch_printf( ch, "You have now obtained %s level %d!\r\n", ability_name[ability], ++ch->skill_level[ability] );
update.c~:      gain = ch->top_level;
update.c~:      gain = UMIN( 5, ch->top_level );
update.c~:      switch ( ch->position )
update.c~:            return -25;
update.c~:            return -20;
update.c~:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c~:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c~:      return -10;
update.c~:   if( ch->race == RACE_TRANDOSHAN )
update.c~:   return UMIN( gain, ch->max_hit - ch->hit );
update.c~:      gain = ch->top_level;
update.c~:      if( ch->skill_level[FORCE_ABILITY] <= 1 )
update.c~:         return ( 0 - ch->mana );
update.c~:      gain = UMIN( 5, ch->skill_level[FORCE_ABILITY] / 2 );
update.c~:      if( ch->position < POS_SLEEPING )
update.c~:      switch ( ch->position )
update.c~:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c~:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c~:   return UMIN( gain, ch->max_mana - ch->mana );
update.c~:      gain = ch->top_level;
update.c~:      gain = UMAX( 15, 2 * ch->top_level );
update.c~:      switch ( ch->position )
update.c~:            return -1;
update.c~:            return -1;
update.c~:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c~:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c~:   return UMIN( gain, ch->max_move - ch->move );
update.c~:      if( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug] )
update.c~:         ch->pcdata->addiction[drug]++;
update.c~:      if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 150 )
update.c~:         switch ( ch->pcdata->addiction[drug] )
update.c~:                  af.duration = ch->pcdata->addiction[drug];
update.c~:                  af.type = -1;
update.c~:                  af.modifier = -10;
update.c~:                  af.duration = ch->pcdata->addiction[drug];
update.c~:                  af.type = -1;
update.c~:                  af.modifier = -5;
update.c~:                  af.duration = ch->pcdata->addiction[drug];
update.c~:                  af.type = -1;
update.c~:                  af.modifier = -5;
update.c~:                  af.duration = ch->pcdata->addiction[drug];
update.c~:      if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 200 )
update.c~:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 100 )
update.c~:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 50 )
update.c~:      else if( ch->pcdata->addiction[drug] > ch->pcdata->drug_level[drug] + 25 )
update.c~:      else if( ch->pcdata->addiction[drug] < ch->pcdata->drug_level[drug] - 50 )
update.c~:         ch->pcdata->drug_level[drug] -= 10;
update.c~:      if( ch->pcdata->drug_level[drug] > 1 )
update.c~:         ch->pcdata->drug_level[drug] -= 2;
update.c~:      else if( ch->pcdata->drug_level[drug] > 0 )
update.c~:         ch->pcdata->drug_level[drug] -= 1;
update.c~:      else if( ch->pcdata->addiction[drug] > 0 && ch->pcdata->drug_level[drug] <= 0 )
update.c~:         ch->pcdata->addiction[drug]--;
update.c~:   condition = ch->pcdata->condition[iCond];
update.c~:   ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 48 );
update.c~:   if( ch->pcdata->condition[iCond] == 0 )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:   if( ch->pcdata->condition[iCond] == 1 )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:   if( ch->pcdata->condition[iCond] == 2 )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:   if( ch->pcdata->condition[iCond] == 3 )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:            if( ch->top_level <= LEVEL_AVATAR )
update.c~:      if( ch == first_char && ch->prev )
update.c~:         bug( "%s: first_char->prev != NULL... fixed", __FUNCTION__ );
update.c~:         ch->prev = NULL;
update.c~:      gch_prev = ch->prev;
update.c~:      if( gch_prev && gch_prev->next != ch )
update.c~:         bug( "FATAL: %s: %s->prev->next doesn't point to ch.", __FUNCTION__, ch->name );
update.c~:         ch->prev = NULL;
update.c~:      if( !ch->in_room || IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_PARALYSIS ) )
update.c~:/* Clean up 'animated corpses' that are not charmed' - Scryn */
update.c~:      if( ch->pIndexData->vnum == 5 && !IS_AFFECTED( ch, AFF_CHARM ) )
update.c~:         if( ch->in_room->first_person )
update.c~:      if( !IS_SET( ch->act, ACT_RUNNING ) && !IS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c~:         if( ch->top_level < ( LEVEL_HERO * 0.2 ) )
update.c~:         else if( ch->top_level < ( LEVEL_HERO * 0.4 ) )
update.c~:         else if( ch->top_level < ( LEVEL_HERO * 0.6 ) )
update.c~:         else if( ch->top_level < ( LEVEL_HERO * 0.8 ) )
update.c~:         else if( ch->top_level < LEVEL_HERO )
update.c~:      else if( !ch->fighting && !ch->hunting
update.c~:               && !IS_SET( ch->act, ACT_RUNNING ) && ch->was_sentinel && ch->position >= POS_STANDING )
update.c~:         char_to_room( ch, ch->was_sentinel );
update.c~:         SET_BIT( ch->act, ACT_SENTINEL );
update.c~:         ch->was_sentinel = NULL;
update.c~:      if( !IS_SET( ch->act, ACT_RUNNING ) && ch->spec_fun )
update.c~:         if( ( *ch->spec_fun ) ( ch ) )
update.c~:      if( !IS_SET( ch->act, ACT_RUNNING ) && ch->spec_2 )
update.c~:         if( ( *ch->spec_2 ) ( ch ) )
update.c~:      if( IS_SET( ch->pIndexData->progtypes, SCRIPT_PROG ) )
update.c~:      if( ch->position != POS_STANDING )
update.c~:      if( IS_SET( ch->act, ACT_MOUNTED ) )
update.c~:         if( IS_SET( ch->act, ACT_AGGRESSIVE ) )
update.c~:      if( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && IS_SET( ch->act, ACT_AGGRESSIVE ) )
update.c~:      if( ch->in_room->area->nplayer > 0 )
update.c~:         if( ch->position < POS_STANDING )
update.c~:      if( ch->position < POS_STANDING )
update.c~:      if( IS_SET( ch->act, ACT_SCAVENGER ) && ch->in_room->first_content && number_bits( 2 ) == 0 )
update.c~:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c~:            if ( IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) && !IS_SET( ch->act, ACT_PROTOTYPE ) )
update.c~:            if( CAN_WEAR( obj, ITEM_TAKE ) && obj->cost > max && !IS_OBJ_STAT( obj, ITEM_BURRIED ) )
update.c~:               max = obj->cost;
update.c~:      if( !IS_SET( ch->act, ACT_RUNNING )
update.c~:          && !IS_SET( ch->act, ACT_SENTINEL )
update.c~:          && !IS_SET( ch->act, ACT_PROTOTYPE )
update.c~:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c~:          && pexit->to_room
update.c~:          && !IS_SET( pexit->exit_info, EX_WINDOW )
update.c~:          && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c~:          && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
update.c~:          && ( !IS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c~:          * continue - Kahn 
update.c~:         if( retcode != rNONE || IS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c~:      if( ch->hit < ch->max_hit / 2
update.c~:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c~:          && pexit->to_room
update.c~:          && !IS_SET( pexit->exit_info, EX_WINDOW )
update.c~:          && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c~:          && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB ) )
update.c~:         for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
update.c~:                     sprintf( buf, "Get away from me, %s!", rch->name );
update.c~:                     sprintf( buf, "Leave me be, %s!", rch->name );
update.c~:                     sprintf( buf, "%s is trying to kill me!  Help!", rch->name );
update.c~:                     sprintf( buf, "Someone save me from %s!", rch->name );
update.c~:   for( planet = first_planet; planet; planet = planet->next )
update.c~:      clan = planet->governed_by;
update.c~:         if( clan->first_subclan )
update.c~:            for( subclan = clan->first_subclan; subclan; subclan = subclan->next_subclan )
update.c~:            for( subclan = clan->first_subclan; subclan; subclan = subclan->next_subclan )
update.c~:               subclan->funds += get_taxes( planet ) / 1440 / sCount;
update.c~:            clan->funds += get_taxes( planet ) / 1440;
update.c~:            clan->funds += get_taxes( planet ) / 720;
update.c~:      for( d = first_descriptor; d; d = d->next )
update.c~:         if( d->connected == CON_PLAYING
update.c~:             && IS_OUTSIDE( d->character )
update.c~:             && IS_AWAKE( d->character )
update.c~:             && d->character->in_room
update.c~:             && d->character->in_room->sector_type != SECT_UNDERWATER
update.c~:             && d->character->in_room->sector_type != SECT_OCEANFLOOR
update.c~:             && d->character->in_room->sector_type != SECT_UNDERGROUND )
update.c~:            act( AT_TEMP, buf, d->character, 0, 0, TO_CHAR );
update.c~:      diff = weather_info.mmhg > 985 ? -2 : 2;
update.c~:      diff = weather_info.mmhg > 1015 ? -2 : 2;
update.c~:   weather_info.change += diff * dice( 1, 4 ) + dice( 2, 6 ) - dice( 2, 6 );
update.c~:   weather_info.change = UMAX( weather_info.change, -12 );
update.c~:      for( d = first_descriptor; d; d = d->next )
update.c~:         if( d->connected == CON_PLAYING && IS_OUTSIDE( d->character ) && IS_AWAKE( d->character ) )
update.c~:            act( AT_TEMP, buf, d->character, 0, 0, TO_CHAR );
update.c~:      if( ch == first_char && ch->prev )
update.c~:         bug( "char_update: first_char->prev != NULL... fixed", 0 );
update.c~:         ch->prev = NULL;
update.c~:      gch_prev = ch->prev;
update.c~:      if( gch_prev && gch_prev->next != ch )
update.c~:         bug( "char_update: ch->prev->next != ch", 0 );
update.c~:       * See if player should be auto-saved.
update.c~:      if( !IS_NPC( ch ) && !NOT_AUTHED( ch ) && current_time - ch->save_time > ( sysdata.save_frequency * 60 ) )
update.c~:      if( ch->position >= POS_STUNNED )
update.c~:         if( ch->hit < ch->max_hit )
update.c~:            ch->hit += hit_gain( ch );
update.c~:         if( ch->mana < ch->max_mana || ch->skill_level[FORCE_ABILITY] == 1 )
update.c~:            ch->mana += mana_gain( ch );
update.c~:         if( ch->move < ch->max_move )
update.c~:            ch->move += move_gain( ch );
update.c~:      if( ch->position == POS_STUNNED )
update.c~:      if( ch->pcdata )
update.c~:      if( !IS_NPC( ch ) && ch->top_level < LEVEL_IMMORTAL )
update.c~:         if( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL && obj->item_type == ITEM_LIGHT && obj->value[2] > 0 )
update.c~:            if( --obj->value[2] == 0 && ch->in_room )
update.c~:               ch->in_room->light -= obj->count;
update.c~:               if( obj->serial == cur_obj )
update.c~:         if( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c~:            worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK] / 8 );
update.c~:         if( ch->pcdata->condition[COND_FULL] > 1 )
update.c~:            switch ( ch->position )
update.c~:         if( ch->pcdata->condition[COND_THIRST] > 1 )
update.c~:            switch ( ch->position )
update.c~:         gain_condition( ch, COND_DRUNK, -1 );
update.c~:         gain_condition( ch, COND_FULL, -1 );
update.c~:         if( ch->in_room )
update.c~:            switch ( ch->in_room->sector_type )
update.c~:                  gain_condition( ch, COND_THIRST, -1 );
update.c~:                  gain_condition( ch, COND_THIRST, -2 );
update.c~:                     gain_condition( ch, COND_THIRST, -1 );
update.c~:            ch->mental_state = URANGE( 20, ch->mental_state + 4, 100 );
update.c~:         else if( ch->position == POS_INCAP )
update.c~:         else if( ch->position == POS_MORTAL )
update.c~:         if( ch->mental_state >= 30 )
update.c~:            switch ( ( ch->mental_state + 5 ) / 10 )
update.c~:                  act( AT_ACTION, "$n is ranting on about 'the answer', 'ONE' and other mumbo-jumbo...", ch, NULL, NULL,
update.c~:         if( ch->mental_state <= -30 )
update.c~:            switch ( ( abs( ch->mental_state ) + 5 ) / 10 )
update.c~:                  if( ch->position > POS_SLEEPING )
update.c~:                     if( ( ch->position == POS_STANDING
update.c~:                           || ch->position < POS_FIGHTING ) && number_percent(  ) + 10 < abs( ch->mental_state ) )
update.c~:                  if( ch->position > POS_SLEEPING )
update.c~:                     if( ( ch->position == POS_STANDING
update.c~:                           || ch->position < POS_FIGHTING ) && ( number_percent(  ) + 20 ) < abs( ch->mental_state ) )
update.c~:                  if( ch->position > POS_SLEEPING )
update.c~:                     if( ch->position < POS_SITTING && ( number_percent(  ) + 30 ) < abs( ch->mental_state ) )
update.c~:                  if( ch->position > POS_RESTING )
update.c~:                  if( ch->position > POS_RESTING )
update.c~:                  if( ch->position > POS_RESTING )
update.c~:                  if( ch->position > POS_RESTING )
update.c~:                  if( ch->position > POS_RESTING )
update.c~:         if( ch->backup_wait > 0 )
update.c~:            --ch->backup_wait;
update.c~:            if( ch->backup_wait == 0 )
update.c~:            if( ++ch->timer > 15 && !ch->desc )
update.c~:               if( ch->in_room )
update.c~:               ch->position = POS_RESTING;
update.c~:               ch->hit = UMAX( 1, ch->hit );
update.c~:      if( obj == first_object && obj->prev )
update.c~:         bug( "obj_update: first_object->prev != NULL... fixed", 0 );
update.c~:         obj->prev = NULL;
update.c~:      gobj_prev = obj->prev;
update.c~:      if( gobj_prev && gobj_prev->next != obj )
update.c~:         bug( "obj_update: obj->prev->next != obj", 0 );
update.c~:      if( obj->carried_by )
update.c~:      else if( obj->in_room && obj->in_room->area->nplayer > 0 )
update.c~:      if( obj->item_type == ITEM_WEAPON && obj->carried_by &&
update.c~:          ( obj->wear_loc == WEAR_WIELD || obj->wear_loc == WEAR_DUAL_WIELD ) &&
update.c~:          obj->value[3] != WEAPON_BLASTER && obj->value[4] > 0 &&
update.c~:          obj->value[3] != WEAPON_BOWCASTER && obj->value[3] != WEAPON_FORCE_PIKE )
update.c~:         obj->value[4]--;
update.c~:         if( obj->value[4] <= 0 )
update.c~:            if( obj->value[3] == WEAPON_LIGHTSABER )
update.c~:               act( AT_PLAIN, "$p fizzles and dies.", obj->carried_by, obj, NULL, TO_CHAR );
update.c~:               act( AT_PLAIN, "$n's lightsaber fizzles and dies.", obj->carried_by, NULL, NULL, TO_ROOM );
update.c~:            else if( obj->value[3] == WEAPON_VIBRO_BLADE )
update.c~:               act( AT_PLAIN, "$p stops vibrating.", obj->carried_by, obj, NULL, TO_CHAR );
update.c~:      if( obj->item_type == ITEM_PIPE )
update.c~:         if( IS_SET( obj->value[3], PIPE_LIT ) )
update.c~:            if( --obj->value[1] <= 0 )
update.c~:               obj->value[1] = 0;
update.c~:               REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c~:            else if( IS_SET( obj->value[3], PIPE_HOT ) )
update.c~:               REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c~:               if( IS_SET( obj->value[3], PIPE_GOINGOUT ) )
update.c~:                  REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c~:                  REMOVE_BIT( obj->value[3], PIPE_GOINGOUT );
update.c~:                  SET_BIT( obj->value[3], PIPE_GOINGOUT );
update.c~:            if( !IS_SET( obj->value[3], PIPE_LIT ) )
update.c~:               SET_BIT( obj->value[3], PIPE_FULLOFASH );
update.c~:            REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c~:/* Corpse decay (npc corpses decay at 8 times the rate of pc corpses) - Narn */
update.c~:      if( obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_DROID_CORPSE )
update.c~:         short timerfrac = UMAX( 1, obj->timer - 1 );
update.c~:         if( obj->item_type == ITEM_CORPSE_PC )
update.c~:            timerfrac = ( int )( obj->timer / 8 + 1 );
update.c~:         if( obj->timer > 0 && obj->value[2] > timerfrac )
update.c~:            bufptr = one_argument( obj->short_descr, name );
update.c~:            obj->value[2] = timerfrac;
update.c~:            if( obj->item_type == ITEM_DROID_CORPSE )
update.c~:               sprintf( buf, d_corpse_descs[UMIN( timerfrac - 1, 4 )], bufptr );
update.c~:               sprintf( buf, corpse_descs[UMIN( timerfrac - 1, 4 )], capitalize( bufptr ) );
update.c~:            STRFREE( obj->description );
update.c~:            obj->description = STRALLOC( buf );
update.c~:      if( obj->timer > 0 && obj->timer < 5 && obj->item_type == ITEM_ARMOR )
update.c~:         if( obj->carried_by )
update.c~:            act( AT_TEMP, "$p is almost dead.", obj->carried_by, obj, NULL, TO_CHAR );
update.c~:      if( ( obj->timer <= 0 || --obj->timer > 0 ) )
update.c~:      switch ( obj->item_type )
update.c~:            obj->item_type = ITEM_TRASH;  /* so extract_obj  */
update.c~:            if( obj->in_room )
update.c~:               --obj->in_room->light;
update.c~:      if( obj->carried_by )
update.c~:         act( AT_TEMP, message, obj->carried_by, obj, NULL, TO_CHAR );
update.c~:      else if( obj->in_room && ( rch = obj->in_room->first_person ) != NULL && !IS_OBJ_STAT( obj, ITEM_BURRIED ) )
update.c~:      if( obj->serial == cur_obj )
update.c~:      ch_next = ch->next;
update.c~:          * running mobs  -Thoric 
update.c~:         if( IS_SET( ch->act, ACT_RUNNING ) )
update.c~:            if( !IS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c~:            if( ch->spec_fun )
update.c~:               if( ( *ch->spec_fun ) ( ch ) )
update.c~:            if( ch->spec_2 )
update.c~:               if( ( *ch->spec_2 ) ( ch ) )
update.c~:            if( !IS_SET( ch->act, ACT_SENTINEL )
update.c~:                && !IS_SET( ch->act, ACT_PROTOTYPE )
update.c~:                && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c~:                && pexit->to_room
update.c~:                && !IS_SET( pexit->exit_info, EX_CLOSED )
update.c~:                && !IS_SET( pexit->to_room->room_flags, ROOM_NO_MOB )
update.c~:                && ( !IS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c~:               if( retcode != rNONE || IS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c~:         if( ch->mount && ch->in_room != ch->mount->in_room )
update.c~:            REMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c~:            ch->mount = NULL;
update.c~:            ch->position = POS_STANDING;
update.c~:         if( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c~:             || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c~:                  dam = number_range( ch->max_hit / 50, ch->max_hit / 30 );
update.c~:                  if( ch->hit <= 0 )
update.c~:         if( ch->in_room
update.c~:             && ( ( ch->in_room->sector_type == SECT_WATER_NOSWIM ) || ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c~:                && !IS_AFFECTED( ch, AFF_FLOATING ) && !IS_AFFECTED( ch, AFF_AQUA_BREATH ) && !ch->mount )
update.c~:                  if( ch->move > 0 )
update.c~:                     ch->move--;
update.c~:                     dam = number_range( ch->max_hit / 50, ch->max_hit / 30 );
update.c~:                     if( ch->hit <= 0 )
update.c~:   if( IS_NPC( wch ) && wch->mpactnum > 0 && wch->in_room->area->nplayer > 0 )
update.c~:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp_act->next )
update.c~:         oprog_wordlist_check( tmp_act->buf, wch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG );
update.c~:         DISPOSE( tmp_act->buf );
update.c~:      for( tmp_act = wch->mpact; tmp_act; tmp_act = tmp2_act )
update.c~:         tmp2_act = tmp_act->next;
update.c~:      wch->mpactnum = 0;
update.c~:      wch->mpact = NULL;
update.c~:     wch = ( CHAR_DATA* ) mob_act_list->vo;
update.c~:      if( !char_died( wch ) && wch->mpactnum > 0 )
update.c~:         while( ( tmp_act = wch->mpact ) != NULL )
update.c~:            if( tmp_act->obj && obj_extracted( tmp_act->obj ) )
update.c~:               tmp_act->obj = NULL;
update.c~:            if( tmp_act->ch && !char_died( tmp_act->ch ) )
update.c~:               mprog_wordlist_check( tmp_act->buf, wch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG );
update.c~:            wch->mpact = tmp_act->next;
update.c~:            DISPOSE( tmp_act->buf );
update.c~:         wch->mpactnum = 0;
update.c~:         wch->mpact = NULL;
update.c~:      mob_act_list = apdtmp->next;
update.c~:    * We can check for linkdead victims to mobile_update   -Thoric
update.c~:      dnext = d->next;
update.c~:      if( ( d->connected != CON_PLAYING && d->connected != CON_EDITING ) || ( wch = d->character ) == NULL )
update.c~:      if( char_died( wch ) || IS_NPC( wch ) || wch->top_level >= LEVEL_IMMORTAL || !wch->in_room )
update.c~:      for( ch = wch->in_room->first_person; ch; ch = ch_next )
update.c~:         ch_next = ch->next_in_room;
update.c~:             || ch->fighting
update.c~:             || IS_AFFECTED( ch, AFF_CHARM ) || !IS_AWAKE( ch ) || ( IS_SET( ch->act, ACT_WIMPY ) ) || !can_see( ch, wch ) )
update.c~:         if( !IS_SET( ch->act, ACT_AGGRESSIVE )
update.c~:             || IS_SET( ch->act, ACT_MOUNTED ) || IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
update.c~:         if( IS_NPC( ch ) && IS_SET( ch->attacks, ATCK_BACKSTAB ) )
update.c~:            if( !ch->mount
update.c~:                && obj->value[3] == 11 && !victim->fighting && victim->hit >= victim->max_hit )
update.c~:               WAIT_STATE( ch, skill_table[gsn_backstab]->beats );
update.c~:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->top_level )
update.c~: * drunk randoms	- Tricops
update.c~: * (Made part of mobile_update	-Thoric)
update.c~:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c~:   drunk = ch->pcdata->condition[COND_DRUNK];
update.c~:   position = ch->position;
update.c~:   ch->position = POS_STANDING;
update.c~:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c~:      check_social( ch, "puke", ( rvch ? rvch->name : "" ) );
update.c~:   ch->position = position;
update.c~:   if( ch->mental_state >= 30 && number_bits( 5 - ( ch->mental_state >= 50 ) - ( ch->mental_state >= 75 ) ) == 0 )
update.c~:      switch ( number_range( 1, UMIN( 20, ( ch->mental_state + 5 ) / 5 ) ) )
update.c~:      tele_next = tele->next;
update.c~:      if( --tele->timer <= 0 )
update.c~:         if( tele->room->first_person )
update.c~:            teleport( tele->room->first_person, tele->room->tele_vnum, TELE_TRANSALL );
update.c~: * Write all outstanding authorization requests to Log channel - Gorog
update.c~:   for( d = first_descriptor; d; d = d->next )
update.c~:      victim = d->character;
update.c~:         sprintf( log_buf, " %s@%s new %s", victim->name, victim->desc->host, race_table[victim->race].race_name );
update.c~:   for( d = first_descriptor; d; d = d->next )
update.c~:      if( ( victim = d->character ) && IS_WAITING_FOR_AUTH( victim ) )
update.c~:         sprintf( buf, " %s@%s new %s\r\n", victim->name, victim->desc->host, race_table[victim->race].race_name );
update.c~: * Random times to defeat tick-timing clients and players.
update.c~:   if( --pulse_area <= 0 )
update.c~:   if( --pulse_taxes <= 0 )
update.c~:   if( --pulse_mobile <= 0 )
update.c~:   if( --pulse_space <= 0 )
update.c~:   if( --pulse_recharge <= 0 )
update.c~:   if( --pulse_ship <= 0 )
update.c~:   if( --pulse_violence <= 0 )
update.c~:   if( --pulse_point <= 0 )
update.c~:   if( --pulse_second <= 0 )
update.c~:       * reboot_check( "" ); Disabled to check if its lagging a lot - Scryn
update.c~:   if( auction->item && --auction->pulse <= 0 )
update.c~:      auction->pulse = PULSE_AUCTION;
update.c~:   fromRoom = portal->in_room;
update.c~:      bug( "remove_portal: portal->in_room is NULL", 0 );
update.c~:   for( pexit = fromRoom->first_exit; pexit; pexit = pexit->next )
update.c~:      if( IS_SET( pexit->exit_info, EX_PORTAL ) )
update.c~:      bug( "remove_portal: portal not found in room %d!", fromRoom->vnum );
update.c~:   if( pexit->vdir != DIR_PORTAL )
update.c~:      bug( "remove_portal: exit in dir %d != DIR_PORTAL", pexit->vdir );
update.c~:   if( ( toRoom = pexit->to_room ) == NULL )
update.c~:    * ch = fromRoom->first_person; 
update.c~:   if( toRoom && ( ch = toRoom->first_person ) != NULL )
update.c~:      for( trun = timesize - 1; trun >= 0; trun-- )
update.c~:   if( new_boot_time_t - boot_time < 60 * 60 * 18 && !set_boot_time->manual )
update.c~:      if( auction->item )
update.c~:         sprintf( buf, "Sale of %s has been stopped by mud.", auction->item->short_descr );
update.c~:         obj_to_char( auction->item, auction->seller );
update.c~:         auction->item = NULL;
update.c~:         if( auction->buyer && auction->buyer != auction->seller )
update.c~:            auction->buyer->gold += auction->bet;
update.c~:            send_to_char( "Your money has been returned.\r\n", auction->buyer );
update.c~:      for( vch = first_char; vch; vch = vch->next )
update.c~:   if( trun != -1 && new_boot_time_t - current_time <= times[trun] )
update.c~:      --trun;
update.c~:    * Bools to show which pre-boot echoes we've done. 
update.c~:/* Change by Scryn - if mud has not been up 18 hours at boot time - still 
update.c~:   if( new_boot_time_t - boot_time < 60 * 60 * 18 && set_boot_time->manual == 0 )
update.c~:    if ( timestruct->tm_hour == set_boot_time->hour        
update.c~:         && timestruct->tm_min  == set_boot_time->min )*/
update.c~:      if( auction->item != NULL )
update.c~:         sprintf( buf, "Sale of %s has been stopped by mud.", auction->item->short_descr );
update.c~:         obj_to_char( auction->item, auction->seller );
update.c~:         auction->item = NULL;
update.c~:         if( auction->buyer != NULL && auction->seller != auction->buyer ) /* return money to the buyer */
update.c~:            auction->buyer->gold += auction->bet;
update.c~:            send_to_char( "Your money has been returned.\r\n", auction->buyer );
update.c~:      for( vch = first_char; vch; vch = vch->next )
update.c~:/*  timecheck = ( set_boot_time->hour * 60 + set_boot_time->min )
update.c~:              - ( timestruct->tm_hour * 60 + timestruct->tm_min );
update.c~:   if( new_boot_time_t - current_time <= 60 )
update.c~:   if( new_boot_time_t - current_time <= 120 )
update.c~:   if( new_boot_time_t - current_time <= 180 )
update.c~:   if( new_boot_time_t - current_time <= 240 )
update.c~:   if( new_boot_time_t - current_time <= 300 )
update.c~:   if( new_boot_time_t - current_time <= 600 )
update.c~:   if( new_boot_time_t - current_time <= 900 )
update.c~:   if( new_boot_time_t - current_time <= 1800 )
update.c~:   switch ( ++auction->going )   /* increase the going state */
update.c~:         if( auction->bet > auction->starting )
update.c~:            sprintf( buf, "%s: going %s for %d.", auction->item->short_descr,
update.c~:                     ( ( auction->going == 1 ) ? "once" : "twice" ), auction->bet );
update.c~:            sprintf( buf, "%s: going %s (bid not received yet).", auction->item->short_descr,
update.c~:                     ( ( auction->going == 1 ) ? "once" : "twice" ) );
update.c~:         if( !auction->buyer && auction->bet )
update.c~:            bug( "Auction code reached SOLD, with NULL buyer, but %d gold bid", auction->bet );
update.c~:            auction->bet = 0;
update.c~:         if( auction->bet > 0 && auction->buyer != auction->seller )
update.c~:                     auction->item->short_descr,
update.c~:                     IS_NPC( auction->buyer ) ? auction->buyer->short_descr : auction->buyer->name, auction->bet );
update.c~:                 auction->buyer, auction->item, NULL, TO_CHAR );
update.c~:                 auction->buyer, auction->item, NULL, TO_ROOM );
update.c~:            if( ( auction->buyer->carry_weight + get_obj_weight( auction->item ) ) > can_carry_w( auction->buyer ) )
update.c~:               act( AT_PLAIN, "$p is too heavy for you to carry with your current inventory.", auction->buyer, auction->item,
update.c~:               act( AT_PLAIN, "$n is carrying too much to also carry $p, and $e drops it.", auction->buyer, auction->item,
update.c~:               obj_to_room( auction->item, auction->buyer->in_room );
update.c~:               obj_to_char( auction->item, auction->buyer );
update.c~:            pay = ( int )( auction->bet * 0.9 );
update.c~:            tax = ( int )( auction->bet * 0.1 );
update.c~:            boost_economy( auction->seller->in_room->area, tax );
update.c~:            auction->seller->gold += pay; /* give him the money, tax 10 % */
update.c~:            send_to_char( buf, auction->seller );
update.c~:            auction->item = NULL;   /* reset item */
update.c~:               save_char_obj( auction->buyer );
update.c~:               save_char_obj( auction->seller );
update.c~:            sprintf( buf, "No bids received for %s - object has been removed from auction\r\n.",
update.c~:                     auction->item->short_descr );
update.c~:                 auction->seller, auction->item, NULL, TO_CHAR );
update.c~:                 auction->seller, auction->item, NULL, TO_ROOM );
update.c~:            if( ( auction->seller->carry_weight + get_obj_weight( auction->item ) ) > can_carry_w( auction->seller ) )
update.c~:                    " with everything else you're carrying.", auction->seller, auction->item, NULL, TO_CHAR );
update.c~:                    " for $m with everything else.", auction->seller, auction->item, NULL, TO_ROOM );
update.c~:               obj_to_room( auction->item, auction->seller->in_room );
update.c~:               obj_to_char( auction->item, auction->seller );
update.c~:            tax = ( int )( auction->item->cost * 0.05 );
update.c~:            boost_economy( auction->seller->in_room->area, tax );
update.c~:            send_to_char( buf, auction->seller );
update.c~:            if( ( auction->seller->gold - tax ) < 0 )
update.c~:               auction->seller->gold = 0;
update.c~:               auction->seller->gold -= tax;
update.c~:               save_char_obj( auction->seller );
update.c~:         auction->item = NULL;   /* clear auction */
update.c~:   etime->tv_sec -= sttime->tv_sec;
update.c~:   etime->tv_usec -= sttime->tv_usec;
update.c~:   while( etime->tv_usec < 0 )
update.c~:      etime->tv_usec += 1000000;
update.c~:      etime->tv_sec--;
